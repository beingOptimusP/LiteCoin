parcelRequire = function(e, r, t, n) {
  var i, o = "function" == typeof parcelRequire && parcelRequire,
    u = "function" == typeof require && require;

  function f(t, n) {
    if (!r[t]) {
      if (!e[t]) {
        var i = "function" == typeof parcelRequire && parcelRequire;
        if (!n && i) return i(t, !0);
        if (o) return o(t, !0);
        if (u && "string" == typeof t) return u(t);
        var c = new Error("Cannot find module '" + t + "'");
        throw c.code = "MODULE_NOT_FOUND", c
      }
      p.resolve = function(r) {
        return e[t][1][r] || r
      }, p.cache = {};
      var l = r[t] = new f.Module(t);
      e[t][0].call(l.exports, p, l, l.exports, this)
    }
    return r[t].exports;

    function p(e) {
      return f(p.resolve(e))
    }
  }
  f.isParcelRequire = !0, f.Module = function(e) {
    this.id = e, this.bundle = f, this.exports = {}
  }, f.modules = e, f.cache = r, f.parent = o, f.register = function(r, t) {
    e[r] = [function(e, r) {
      r.exports = t
    }, {}]
  };
  for (var c = 0; c < t.length; c++) try {
    f(t[c])
  } catch (e) {
    i || (i = e)
  }
  if (t.length) {
    var l = f(t[t.length - 1]);
    "object" == typeof exports && "undefined" != typeof module ? module.exports = l : "function" == typeof define && define.amd ? define(function() {
      return l
    }) : n && (this[n] = l)
  }
  if (parcelRequire = f, i) throw i;
  return f
}({
  "QVnC": [function(require, module, exports) {
    var define;
    var t, r = function(t) {
      "use strict";
      var r, e = Object.prototype,
        n = e.hasOwnProperty,
        o = "function" == typeof Symbol ? Symbol : {},
        i = o.iterator || "@@iterator",
        a = o.asyncIterator || "@@asyncIterator",
        c = o.toStringTag || "@@toStringTag";

      function u(t, r, e) {
        return Object.defineProperty(t, r, {
          value: e,
          enumerable: !0,
          configurable: !0,
          writable: !0
        }), t[r]
      }
      try {
        u({}, "")
      } catch (P) {
        u = function(t, r, e) {
          return t[r] = e
        }
      }

      function h(t, r, e, n) {
        var o = r && r.prototype instanceof d ? r : d,
          i = Object.create(o.prototype),
          a = new G(n || []);
        return i._invoke = function(t, r, e) {
          var n = l;
          return function(o, i) {
            if (n === p) throw new Error("Generator is already running");
            if (n === y) {
              if ("throw" === o) throw i;
              return F()
            }
            for (e.method = o, e.arg = i;;) {
              var a = e.delegate;
              if (a) {
                var c = j(a, e);
                if (c) {
                  if (c === v) continue;
                  return c
                }
              }
              if ("next" === e.method) e.sent = e._sent = e.arg;
              else if ("throw" === e.method) {
                if (n === l) throw n = y, e.arg;
                e.dispatchException(e.arg)
              } else "return" === e.method && e.abrupt("return", e.arg);
              n = p;
              var u = f(t, r, e);
              if ("normal" === u.type) {
                if (n = e.done ? y : s, u.arg === v) continue;
                return {
                  value: u.arg,
                  done: e.done
                }
              }
              "throw" === u.type && (n = y, e.method = "throw", e.arg = u.arg)
            }
          }
        }(t, e, a), i
      }

      function f(t, r, e) {
        try {
          return {
            type: "normal",
            arg: t.call(r, e)
          }
        } catch (P) {
          return {
            type: "throw",
            arg: P
          }
        }
      }
      t.wrap = h;
      var l = "suspendedStart",
        s = "suspendedYield",
        p = "executing",
        y = "completed",
        v = {};

      function d() {}

      function g() {}

      function m() {}
      var w = {};
      w[i] = function() {
        return this
      };
      var L = Object.getPrototypeOf,
        x = L && L(L(N([])));
      x && x !== e && n.call(x, i) && (w = x);
      var b = m.prototype = d.prototype = Object.create(w);

      function E(t) {
        ["next", "throw", "return"].forEach(function(r) {
          u(t, r, function(t) {
            return this._invoke(r, t)
          })
        })
      }

      function _(t, r) {
        var e;
        this._invoke = function(o, i) {
          function a() {
            return new r(function(e, a) {
              ! function e(o, i, a, c) {
                var u = f(t[o], t, i);
                if ("throw" !== u.type) {
                  var h = u.arg,
                    l = h.value;
                  return l && "object" == typeof l && n.call(l, "__await") ? r.resolve(l.__await).then(function(t) {
                    e("next", t, a, c)
                  }, function(t) {
                    e("throw", t, a, c)
                  }) : r.resolve(l).then(function(t) {
                    h.value = t, a(h)
                  }, function(t) {
                    return e("throw", t, a, c)
                  })
                }
                c(u.arg)
              }(o, i, e, a)
            })
          }
          return e = e ? e.then(a, a) : a()
        }
      }

      function j(t, e) {
        var n = t.iterator[e.method];
        if (n === r) {
          if (e.delegate = null, "throw" === e.method) {
            if (t.iterator.return && (e.method = "return", e.arg = r, j(t, e), "throw" === e.method)) return v;
            e.method = "throw", e.arg = new TypeError("The iterator does not provide a 'throw' method")
          }
          return v
        }
        var o = f(n, t.iterator, e.arg);
        if ("throw" === o.type) return e.method = "throw", e.arg = o.arg, e.delegate = null, v;
        var i = o.arg;
        return i ? i.done ? (e[t.resultName] = i.value, e.next = t.nextLoc, "return" !== e.method && (e.method = "next", e.arg = r), e.delegate = null, v) : i : (e.method = "throw", e.arg = new TypeError("iterator result is not an object"), e.delegate = null, v)
      }

      function O(t) {
        var r = {
          tryLoc: t[0]
        };
        1 in t && (r.catchLoc = t[1]), 2 in t && (r.finallyLoc = t[2], r.afterLoc = t[3]), this.tryEntries.push(r)
      }

      function k(t) {
        var r = t.completion || {};
        r.type = "normal", delete r.arg, t.completion = r
      }

      function G(t) {
        this.tryEntries = [{
          tryLoc: "root"
        }], t.forEach(O, this), this.reset(!0)
      }

      function N(t) {
        if (t) {
          var e = t[i];
          if (e) return e.call(t);
          if ("function" == typeof t.next) return t;
          if (!isNaN(t.length)) {
            var o = -1,
              a = function e() {
                for (; ++o < t.length;)
                  if (n.call(t, o)) return e.value = t[o], e.done = !1, e;
                return e.value = r, e.done = !0, e
              };
            return a.next = a
          }
        }
        return {
          next: F
        }
      }

      function F() {
        return {
          value: r,
          done: !0
        }
      }
      return g.prototype = b.constructor = m, m.constructor = g, g.displayName = u(m, c, "GeneratorFunction"), t.isGeneratorFunction = function(t) {
        var r = "function" == typeof t && t.constructor;
        return !!r && (r === g || "GeneratorFunction" === (r.displayName || r.name))
      }, t.mark = function(t) {
        return Object.setPrototypeOf ? Object.setPrototypeOf(t, m) : (t.__proto__ = m, u(t, c, "GeneratorFunction")), t.prototype = Object.create(b), t
      }, t.awrap = function(t) {
        return {
          __await: t
        }
      }, E(_.prototype), _.prototype[a] = function() {
        return this
      }, t.AsyncIterator = _, t.async = function(r, e, n, o, i) {
        void 0 === i && (i = Promise);
        var a = new _(h(r, e, n, o), i);
        return t.isGeneratorFunction(e) ? a : a.next().then(function(t) {
          return t.done ? t.value : a.next()
        })
      }, E(b), u(b, c, "Generator"), b[i] = function() {
        return this
      }, b.toString = function() {
        return "[object Generator]"
      }, t.keys = function(t) {
        var r = [];
        for (var e in t) r.push(e);
        return r.reverse(),
          function e() {
            for (; r.length;) {
              var n = r.pop();
              if (n in t) return e.value = n, e.done = !1, e
            }
            return e.done = !0, e
          }
      }, t.values = N, G.prototype = {
        constructor: G,
        reset: function(t) {
          if (this.prev = 0, this.next = 0, this.sent = this._sent = r, this.done = !1, this.delegate = null, this.method = "next", this.arg = r, this.tryEntries.forEach(k), !t)
            for (var e in this) "t" === e.charAt(0) && n.call(this, e) && !isNaN(+e.slice(1)) && (this[e] = r)
        },
        stop: function() {
          this.done = !0;
          var t = this.tryEntries[0].completion;
          if ("throw" === t.type) throw t.arg;
          return this.rval
        },
        dispatchException: function(t) {
          if (this.done) throw t;
          var e = this;

          function o(n, o) {
            return c.type = "throw", c.arg = t, e.next = n, o && (e.method = "next", e.arg = r), !!o
          }
          for (var i = this.tryEntries.length - 1; i >= 0; --i) {
            var a = this.tryEntries[i],
              c = a.completion;
            if ("root" === a.tryLoc) return o("end");
            if (a.tryLoc <= this.prev) {
              var u = n.call(a, "catchLoc"),
                h = n.call(a, "finallyLoc");
              if (u && h) {
                if (this.prev < a.catchLoc) return o(a.catchLoc, !0);
                if (this.prev < a.finallyLoc) return o(a.finallyLoc)
              } else if (u) {
                if (this.prev < a.catchLoc) return o(a.catchLoc, !0)
              } else {
                if (!h) throw new Error("try statement without catch or finally");
                if (this.prev < a.finallyLoc) return o(a.finallyLoc)
              }
            }
          }
        },
        abrupt: function(t, r) {
          for (var e = this.tryEntries.length - 1; e >= 0; --e) {
            var o = this.tryEntries[e];
            if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) {
              var i = o;
              break
            }
          }
          i && ("break" === t || "continue" === t) && i.tryLoc <= r && r <= i.finallyLoc && (i = null);
          var a = i ? i.completion : {};
          return a.type = t, a.arg = r, i ? (this.method = "next", this.next = i.finallyLoc, v) : this.complete(a)
        },
        complete: function(t, r) {
          if ("throw" === t.type) throw t.arg;
          return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && r && (this.next = r), v
        },
        finish: function(t) {
          for (var r = this.tryEntries.length - 1; r >= 0; --r) {
            var e = this.tryEntries[r];
            if (e.finallyLoc === t) return this.complete(e.completion, e.afterLoc), k(e), v
          }
        },
        catch: function(t) {
          for (var r = this.tryEntries.length - 1; r >= 0; --r) {
            var e = this.tryEntries[r];
            if (e.tryLoc === t) {
              var n = e.completion;
              if ("throw" === n.type) {
                var o = n.arg;
                k(e)
              }
              return o
            }
          }
          throw new Error("illegal catch attempt")
        },
        delegateYield: function(t, e, n) {
          return this.delegate = {
            iterator: N(t),
            resultName: e,
            nextLoc: n
          }, "next" === this.method && (this.arg = r), v
        }
      }, t
    }("object" == typeof module ? module.exports : {});
    try {
      regeneratorRuntime = r
    } catch (e) {
      Function("r", "regeneratorRuntime = r")(r)
    }
  }, {}],
  "dKqR": [function(require, module, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    }), exports.AxisHelper = Ux, exports.BinaryTextureLoader = qx, exports.BoundingBoxHelper = kx, exports.CanvasRenderer = Yx, exports.DynamicBufferAttribute = Px, exports.EdgesHelper = Vx, exports.Float32Attribute = Ox, exports.Float64Attribute = Hx, exports.Int16Attribute = Nx, exports.Int32Attribute = zx, exports.Int8Attribute = Dx, exports.JSONLoader = Zx, exports.LensFlare = Qx, exports.Material = Ni, exports.MeshFaceMaterial = wx, exports.MultiMaterial = Mx, exports.Particle = Tx, exports.ParticleBasicMaterial = Lx, exports.ParticleSystem = Ex, exports.ParticleSystemMaterial = Rx, exports.PointCloud = Sx, exports.PointCloudMaterial = Ax, exports.Uint16Attribute = Fx, exports.Uint32Attribute = Gx, exports.Uint8Attribute = Ix, exports.Uint8ClampedAttribute = Bx, exports.Vertex = Cx, exports.WebGLRenderTargetCube = Xx, exports.WebGLRenderer = Yh, exports.WebGLUtils = Hh, exports.WireframeHelper = Wx, exports.XHRLoader = jx, exports.EllipseCurve = exports.EdgesGeometry = exports.DynamicReadUsage = exports.DynamicDrawUsage = exports.DynamicCopyUsage = exports.DstColorFactor = exports.DstAlphaFactor = exports.DoubleSide = exports.DodecahedronGeometry = exports.DodecahedronBufferGeometry = exports.DiscreteInterpolant = exports.DirectionalLightHelper = exports.DirectionalLight = exports.DepthTexture = exports.DepthStencilFormat = exports.DepthFormat = exports.DefaultLoadingManager = exports.DecrementWrapStencilOp = exports.DecrementStencilOp = exports.DataUtils = exports.DataTextureLoader = exports.DataTexture3D = exports.DataTexture2DArray = exports.DataTexture = exports.Cylindrical = exports.CylinderGeometry = exports.CylinderBufferGeometry = exports.CustomToneMapping = exports.CustomBlending = exports.CurvePath = exports.Curve = exports.CullFaceNone = exports.CullFaceFrontBack = exports.CullFaceFront = exports.CullFaceBack = exports.CubicInterpolant = exports.CubicBezierCurve3 = exports.CubicBezierCurve = exports.CubeUVRefractionMapping = exports.CubeUVReflectionMapping = exports.CubeTextureLoader = exports.CubeTexture = exports.CubeRefractionMapping = exports.CubeReflectionMapping = exports.CubeCamera = exports.ConeGeometry = exports.ConeBufferGeometry = exports.CompressedTextureLoader = exports.CompressedTexture = exports.ColorKeyframeTrack = exports.Color = exports.Clock = exports.ClampToEdgeWrapping = exports.CircleGeometry = exports.CircleBufferGeometry = exports.CineonToneMapping = exports.CatmullRomCurve3 = exports.CanvasTexture = exports.CameraHelper = exports.Camera = exports.Cache = exports.ByteType = exports.BufferGeometryLoader = exports.BufferGeometry = exports.BufferAttribute = exports.BoxHelper = exports.BoxGeometry = exports.BoxBufferGeometry = exports.Box3Helper = exports.Box3 = exports.Box2 = exports.BooleanKeyframeTrack = exports.Bone = exports.BasicShadowMap = exports.BasicDepthPacking = exports.BackSide = exports.AxesHelper = exports.AudioLoader = exports.AudioListener = exports.AudioContext = exports.AudioAnalyser = exports.Audio = exports.ArrowHelper = exports.ArrayCamera = exports.ArcCurve = exports.AnimationUtils = exports.AnimationObjectGroup = exports.AnimationMixer = exports.AnimationLoader = exports.AnimationClip = exports.AmbientLightProbe = exports.AmbientLight = exports.AlwaysStencilFunc = exports.AlwaysDepth = exports.AlphaFormat = exports.AdditiveBlending = exports.AdditiveAnimationBlendMode = exports.AddOperation = exports.AddEquation = exports.ACESFilmicToneMapping = void 0, exports.Math = exports.MaterialLoader = exports.MOUSE = exports.LuminanceFormat = exports.LuminanceAlphaFormat = exports.LoopRepeat = exports.LoopPingPong = exports.LoopOnce = exports.LogLuvEncoding = exports.LoadingManager = exports.LoaderUtils = exports.Loader = exports.LinearToneMapping = exports.LinearMipmapNearestFilter = exports.LinearMipmapLinearFilter = exports.LinearMipMapNearestFilter = exports.LinearMipMapLinearFilter = exports.LinearInterpolant = exports.LinearFilter = exports.LinearEncoding = exports.LineStrip = exports.LineSegments = exports.LinePieces = exports.LineLoop = exports.LineDashedMaterial = exports.LineCurve3 = exports.LineCurve = exports.LineBasicMaterial = exports.Line3 = exports.Line = exports.LightProbe = exports.Light = exports.LessStencilFunc = exports.LessEqualStencilFunc = exports.LessEqualDepth = exports.LessDepth = exports.Layers = exports.LatheGeometry = exports.LatheBufferGeometry = exports.LOD = exports.KeyframeTrack = exports.KeepStencilOp = exports.InvertStencilOp = exports.InterpolateSmooth = exports.InterpolateLinear = exports.InterpolateDiscrete = exports.Interpolant = exports.InterleavedBufferAttribute = exports.InterleavedBuffer = exports.IntType = exports.Int8BufferAttribute = exports.Int32BufferAttribute = exports.Int16BufferAttribute = exports.InstancedMesh = exports.InstancedInterleavedBuffer = exports.InstancedBufferGeometry = exports.InstancedBufferAttribute = exports.IncrementWrapStencilOp = exports.IncrementStencilOp = exports.ImmediateRenderObject = exports.ImageUtils = exports.ImageLoader = exports.ImageBitmapLoader = exports.IcosahedronGeometry = exports.IcosahedronBufferGeometry = exports.HemisphereLightProbe = exports.HemisphereLightHelper = exports.HemisphereLight = exports.HalfFloatType = exports.Group = exports.GridHelper = exports.GreaterStencilFunc = exports.GreaterEqualStencilFunc = exports.GreaterEqualDepth = exports.GreaterDepth = exports.GammaEncoding = exports.GLSL3 = exports.GLSL1 = exports.GLBufferAttribute = exports.Frustum = exports.FrontSide = exports.FontLoader = exports.Font = exports.FogExp2 = exports.Fog = exports.FloatType = exports.Float64BufferAttribute = exports.Float32BufferAttribute = exports.Float16BufferAttribute = exports.FlatShading = exports.FileLoader = exports.FaceColors = exports.ExtrudeGeometry = exports.ExtrudeBufferGeometry = exports.EventDispatcher = exports.Euler = exports.EquirectangularRefractionMapping = exports.EquirectangularReflectionMapping = exports.EqualStencilFunc = exports.EqualDepth = void 0, exports.RGBEFormat = exports.RGBEEncoding = exports.RGBDEncoding = exports.RGBA_S3TC_DXT5_Format = exports.RGBA_S3TC_DXT3_Format = exports.RGBA_S3TC_DXT1_Format = exports.RGBA_PVRTC_4BPPV1_Format = exports.RGBA_PVRTC_2BPPV1_Format = exports.RGBA_ETC2_EAC_Format = exports.RGBA_BPTC_Format = exports.RGBA_ASTC_8x8_Format = exports.RGBA_ASTC_8x6_Format = exports.RGBA_ASTC_8x5_Format = exports.RGBA_ASTC_6x6_Format = exports.RGBA_ASTC_6x5_Format = exports.RGBA_ASTC_5x5_Format = exports.RGBA_ASTC_5x4_Format = exports.RGBA_ASTC_4x4_Format = exports.RGBA_ASTC_12x12_Format = exports.RGBA_ASTC_12x10_Format = exports.RGBA_ASTC_10x8_Format = exports.RGBA_ASTC_10x6_Format = exports.RGBA_ASTC_10x5_Format = exports.RGBA_ASTC_10x10_Format = exports.RGBAIntegerFormat = exports.RGBAFormat = exports.RGBADepthPacking = exports.REVISION = exports.QuaternionLinearInterpolant = exports.QuaternionKeyframeTrack = exports.Quaternion = exports.QuadraticBezierCurve3 = exports.QuadraticBezierCurve = exports.PropertyMixer = exports.PropertyBinding = exports.PositionalAudio = exports.PolyhedronGeometry = exports.PolyhedronBufferGeometry = exports.PolarGridHelper = exports.PointsMaterial = exports.Points = exports.PointLightHelper = exports.PointLight = exports.PlaneHelper = exports.PlaneGeometry = exports.PlaneBufferGeometry = exports.Plane = exports.PerspectiveCamera = exports.Path = exports.ParametricGeometry = exports.ParametricBufferGeometry = exports.PMREMGenerator = exports.PCFSoftShadowMap = exports.PCFShadowMap = exports.OrthographicCamera = exports.OneMinusSrcColorFactor = exports.OneMinusSrcAlphaFactor = exports.OneMinusDstColorFactor = exports.OneMinusDstAlphaFactor = exports.OneFactor = exports.OctahedronGeometry = exports.OctahedronBufferGeometry = exports.ObjectSpaceNormalMap = exports.ObjectLoader = exports.Object3D = exports.NumberKeyframeTrack = exports.NotEqualStencilFunc = exports.NotEqualDepth = exports.NormalBlending = exports.NormalAnimationBlendMode = exports.NoToneMapping = exports.NoColors = exports.NoBlending = exports.NeverStencilFunc = exports.NeverDepth = exports.NearestMipmapNearestFilter = exports.NearestMipmapLinearFilter = exports.NearestMipMapNearestFilter = exports.NearestMipMapLinearFilter = exports.NearestFilter = exports.MultiplyOperation = exports.MultiplyBlending = exports.MixOperation = exports.MirroredRepeatWrapping = exports.MinEquation = exports.MeshToonMaterial = exports.MeshStandardMaterial = exports.MeshPhysicalMaterial = exports.MeshPhongMaterial = exports.MeshNormalMaterial = exports.MeshMatcapMaterial = exports.MeshLambertMaterial = exports.MeshDistanceMaterial = exports.MeshDepthMaterial = exports.MeshBasicMaterial = exports.Mesh = exports.MaxEquation = exports.Matrix4 = exports.Matrix3 = exports.MathUtils = void 0, exports.Uniform = exports.Uint8ClampedBufferAttribute = exports.Uint8BufferAttribute = exports.Uint32BufferAttribute = exports.Uint16BufferAttribute = exports.UVMapping = exports.TubeGeometry = exports.TubeBufferGeometry = exports.TrianglesDrawMode = exports.TriangleStripDrawMode = exports.TriangleFanDrawMode = exports.Triangle = exports.TorusKnotGeometry = exports.TorusKnotBufferGeometry = exports.TorusGeometry = exports.TorusBufferGeometry = exports.TextureLoader = exports.Texture = exports.TextGeometry = exports.TextBufferGeometry = exports.TetrahedronGeometry = exports.TetrahedronBufferGeometry = exports.TangentSpaceNormalMap = exports.TOUCH = exports.SubtractiveBlending = exports.SubtractEquation = exports.StringKeyframeTrack = exports.StreamReadUsage = exports.StreamDrawUsage = exports.StreamCopyUsage = exports.StereoCamera = exports.StaticReadUsage = exports.StaticDrawUsage = exports.StaticCopyUsage = exports.SrcColorFactor = exports.SrcAlphaSaturateFactor = exports.SrcAlphaFactor = exports.SpriteMaterial = exports.Sprite = exports.SpotLightHelper = exports.SpotLight = exports.SplineCurve = exports.SphericalHarmonics3 = exports.Spherical = exports.SphereGeometry = exports.SphereBufferGeometry = exports.Sphere = exports.SmoothShading = exports.SkinnedMesh = exports.SkeletonHelper = exports.Skeleton = exports.ShortType = exports.ShapeUtils = exports.ShapePath = exports.ShapeGeometry = exports.ShapeBufferGeometry = exports.Shape = exports.ShadowMaterial = exports.ShaderMaterial = exports.ShaderLib = exports.ShaderChunk = exports.SceneUtils = exports.Scene = exports.SRGB8_ALPHA8_ASTC_8x8_Format = exports.SRGB8_ALPHA8_ASTC_8x6_Format = exports.SRGB8_ALPHA8_ASTC_8x5_Format = exports.SRGB8_ALPHA8_ASTC_6x6_Format = exports.SRGB8_ALPHA8_ASTC_6x5_Format = exports.SRGB8_ALPHA8_ASTC_5x5_Format = exports.SRGB8_ALPHA8_ASTC_5x4_Format = exports.SRGB8_ALPHA8_ASTC_4x4_Format = exports.SRGB8_ALPHA8_ASTC_12x12_Format = exports.SRGB8_ALPHA8_ASTC_12x10_Format = exports.SRGB8_ALPHA8_ASTC_10x8_Format = exports.SRGB8_ALPHA8_ASTC_10x6_Format = exports.SRGB8_ALPHA8_ASTC_10x5_Format = exports.SRGB8_ALPHA8_ASTC_10x10_Format = exports.RingGeometry = exports.RingBufferGeometry = exports.ReverseSubtractEquation = exports.ReplaceStencilOp = exports.RepeatWrapping = exports.ReinhardToneMapping = exports.RedIntegerFormat = exports.RedFormat = exports.RectAreaLight = exports.Raycaster = exports.Ray = exports.RawShaderMaterial = exports.RGIntegerFormat = exports.RGFormat = exports.RGB_S3TC_DXT1_Format = exports.RGB_PVRTC_4BPPV1_Format = exports.RGB_PVRTC_2BPPV1_Format = exports.RGB_ETC2_Format = exports.RGB_ETC1_Format = exports.RGBM7Encoding = exports.RGBM16Encoding = exports.RGBIntegerFormat = exports.RGBFormat = void 0, exports.sRGBEncoding = exports.ZeroStencilOp = exports.ZeroSlopeEnding = exports.ZeroFactor = exports.ZeroCurvatureEnding = exports.WrapAroundEnding = exports.WireframeGeometry = exports.WebGLRenderTarget = exports.WebGLMultisampleRenderTarget = exports.WebGLCubeRenderTarget = exports.WebGL1Renderer = exports.VideoTexture = exports.VertexColors = exports.VectorKeyframeTrack = exports.Vector4 = exports.Vector3 = exports.Vector2 = exports.VSMShadowMap = exports.UnsignedShortType = exports.UnsignedShort565Type = exports.UnsignedShort5551Type = exports.UnsignedShort4444Type = exports.UnsignedIntType = exports.UnsignedInt248Type = exports.UnsignedByteType = exports.UniformsUtils = exports.UniformsLib = void 0;
    const t = "128";
    exports.REVISION = "128";
    const e = {
      LEFT: 0,
      MIDDLE: 1,
      RIGHT: 2,
      ROTATE: 0,
      DOLLY: 1,
      PAN: 2
    };
    exports.MOUSE = e;
    const n = {
      ROTATE: 0,
      PAN: 1,
      DOLLY_PAN: 2,
      DOLLY_ROTATE: 3
    };
    exports.TOUCH = n;
    const r = 0;
    exports.CullFaceNone = r;
    const i = 1;
    exports.CullFaceBack = i;
    const s = 2;
    exports.CullFaceFront = s;
    const o = 3;
    exports.CullFaceFrontBack = 3;
    const a = 0;
    exports.BasicShadowMap = 0;
    const l = 1;
    exports.PCFShadowMap = l;
    const c = 2;
    exports.PCFSoftShadowMap = c;
    const h = 3;
    exports.VSMShadowMap = h;
    const u = 0;
    exports.FrontSide = u;
    const p = 1;
    exports.BackSide = p;
    const d = 2;
    exports.DoubleSide = d;
    const m = 1;
    exports.FlatShading = 1;
    const f = 2;
    exports.SmoothShading = 2;
    const g = 0;
    exports.NoBlending = g;
    const x = 1;
    exports.NormalBlending = x;
    const v = 2;
    exports.AdditiveBlending = v;
    const y = 3;
    exports.SubtractiveBlending = y;
    const _ = 4;
    exports.MultiplyBlending = _;
    const b = 5;
    exports.CustomBlending = b;
    const w = 100;
    exports.AddEquation = w;
    const M = 101;
    exports.SubtractEquation = M;
    const S = 102;
    exports.ReverseSubtractEquation = S;
    const T = 103;
    exports.MinEquation = T;
    const E = 104;
    exports.MaxEquation = E;
    const A = 200;
    exports.ZeroFactor = A;
    const L = 201;
    exports.OneFactor = L;
    const R = 202;
    exports.SrcColorFactor = R;
    const C = 203;
    exports.OneMinusSrcColorFactor = C;
    const P = 204;
    exports.SrcAlphaFactor = P;
    const D = 205;
    exports.OneMinusSrcAlphaFactor = D;
    const I = 206;
    exports.DstAlphaFactor = I;
    const B = 207;
    exports.OneMinusDstAlphaFactor = B;
    const N = 208;
    exports.DstColorFactor = N;
    const F = 209;
    exports.OneMinusDstColorFactor = F;
    const z = 210;
    exports.SrcAlphaSaturateFactor = z;
    const G = 0;
    exports.NeverDepth = G;
    const O = 1;
    exports.AlwaysDepth = O;
    const H = 2;
    exports.LessDepth = H;
    const U = 3;
    exports.LessEqualDepth = U;
    const k = 4;
    exports.EqualDepth = k;
    const V = 5;
    exports.GreaterEqualDepth = V;
    const W = 6;
    exports.GreaterDepth = W;
    const j = 7;
    exports.NotEqualDepth = j;
    const q = 0;
    exports.MultiplyOperation = q;
    const X = 1;
    exports.MixOperation = X;
    const Y = 2;
    exports.AddOperation = Y;
    const Z = 0;
    exports.NoToneMapping = Z;
    const J = 1;
    exports.LinearToneMapping = J;
    const Q = 2;
    exports.ReinhardToneMapping = Q;
    const K = 3;
    exports.CineonToneMapping = K;
    const $ = 4;
    exports.ACESFilmicToneMapping = $;
    const tt = 5;
    exports.CustomToneMapping = tt;
    const et = 300;
    exports.UVMapping = et;
    const nt = 301;
    exports.CubeReflectionMapping = nt;
    const rt = 302;
    exports.CubeRefractionMapping = rt;
    const it = 303;
    exports.EquirectangularReflectionMapping = it;
    const st = 304;
    exports.EquirectangularRefractionMapping = st;
    const ot = 306;
    exports.CubeUVReflectionMapping = ot;
    const at = 307;
    exports.CubeUVRefractionMapping = at;
    const lt = 1e3;
    exports.RepeatWrapping = lt;
    const ct = 1001;
    exports.ClampToEdgeWrapping = ct;
    const ht = 1002;
    exports.MirroredRepeatWrapping = ht;
    const ut = 1003;
    exports.NearestFilter = ut;
    const pt = 1004;
    exports.NearestMipmapNearestFilter = pt;
    const dt = 1004;
    exports.NearestMipMapNearestFilter = 1004;
    const mt = 1005;
    exports.NearestMipmapLinearFilter = mt;
    const ft = 1005;
    exports.NearestMipMapLinearFilter = 1005;
    const gt = 1006;
    exports.LinearFilter = gt;
    const xt = 1007;
    exports.LinearMipmapNearestFilter = xt;
    const vt = 1007;
    exports.LinearMipMapNearestFilter = 1007;
    const yt = 1008;
    exports.LinearMipmapLinearFilter = yt;
    const _t = 1008;
    exports.LinearMipMapLinearFilter = 1008;
    const bt = 1009;
    exports.UnsignedByteType = bt;
    const wt = 1010;
    exports.ByteType = wt;
    const Mt = 1011;
    exports.ShortType = Mt;
    const St = 1012;
    exports.UnsignedShortType = St;
    const Tt = 1013;
    exports.IntType = Tt;
    const Et = 1014;
    exports.UnsignedIntType = Et;
    const At = 1015;
    exports.FloatType = At;
    const Lt = 1016;
    exports.HalfFloatType = Lt;
    const Rt = 1017;
    exports.UnsignedShort4444Type = Rt;
    const Ct = 1018;
    exports.UnsignedShort5551Type = Ct;
    const Pt = 1019;
    exports.UnsignedShort565Type = Pt;
    const Dt = 1020;
    exports.UnsignedInt248Type = Dt;
    const It = 1021;
    exports.AlphaFormat = It;
    const Bt = 1022;
    exports.RGBFormat = Bt;
    const Nt = 1023;
    exports.RGBAFormat = Nt;
    const Ft = 1024;
    exports.LuminanceFormat = Ft;
    const zt = 1025;
    exports.LuminanceAlphaFormat = zt;
    const Gt = Nt;
    exports.RGBEFormat = Gt;
    const Ot = 1026;
    exports.DepthFormat = Ot;
    const Ht = 1027;
    exports.DepthStencilFormat = Ht;
    const Ut = 1028;
    exports.RedFormat = Ut;
    const kt = 1029;
    exports.RedIntegerFormat = kt;
    const Vt = 1030;
    exports.RGFormat = Vt;
    const Wt = 1031;
    exports.RGIntegerFormat = Wt;
    const jt = 1032;
    exports.RGBIntegerFormat = jt;
    const qt = 1033;
    exports.RGBAIntegerFormat = qt;
    const Xt = 33776;
    exports.RGB_S3TC_DXT1_Format = Xt;
    const Yt = 33777;
    exports.RGBA_S3TC_DXT1_Format = Yt;
    const Zt = 33778;
    exports.RGBA_S3TC_DXT3_Format = Zt;
    const Jt = 33779;
    exports.RGBA_S3TC_DXT5_Format = Jt;
    const Qt = 35840;
    exports.RGB_PVRTC_4BPPV1_Format = Qt;
    const Kt = 35841;
    exports.RGB_PVRTC_2BPPV1_Format = Kt;
    const $t = 35842;
    exports.RGBA_PVRTC_4BPPV1_Format = $t;
    const te = 35843;
    exports.RGBA_PVRTC_2BPPV1_Format = te;
    const ee = 36196;
    exports.RGB_ETC1_Format = ee;
    const ne = 37492;
    exports.RGB_ETC2_Format = ne;
    const re = 37496;
    exports.RGBA_ETC2_EAC_Format = re;
    const ie = 37808;
    exports.RGBA_ASTC_4x4_Format = ie;
    const se = 37809;
    exports.RGBA_ASTC_5x4_Format = se;
    const oe = 37810;
    exports.RGBA_ASTC_5x5_Format = oe;
    const ae = 37811;
    exports.RGBA_ASTC_6x5_Format = ae;
    const le = 37812;
    exports.RGBA_ASTC_6x6_Format = le;
    const ce = 37813;
    exports.RGBA_ASTC_8x5_Format = ce;
    const he = 37814;
    exports.RGBA_ASTC_8x6_Format = he;
    const ue = 37815;
    exports.RGBA_ASTC_8x8_Format = ue;
    const pe = 37816;
    exports.RGBA_ASTC_10x5_Format = pe;
    const de = 37817;
    exports.RGBA_ASTC_10x6_Format = de;
    const me = 37818;
    exports.RGBA_ASTC_10x8_Format = me;
    const fe = 37819;
    exports.RGBA_ASTC_10x10_Format = fe;
    const ge = 37820;
    exports.RGBA_ASTC_12x10_Format = ge;
    const xe = 37821;
    exports.RGBA_ASTC_12x12_Format = xe;
    const ve = 36492;
    exports.RGBA_BPTC_Format = ve;
    const ye = 37840;
    exports.SRGB8_ALPHA8_ASTC_4x4_Format = ye;
    const _e = 37841;
    exports.SRGB8_ALPHA8_ASTC_5x4_Format = _e;
    const be = 37842;
    exports.SRGB8_ALPHA8_ASTC_5x5_Format = be;
    const we = 37843;
    exports.SRGB8_ALPHA8_ASTC_6x5_Format = we;
    const Me = 37844;
    exports.SRGB8_ALPHA8_ASTC_6x6_Format = Me;
    const Se = 37845;
    exports.SRGB8_ALPHA8_ASTC_8x5_Format = Se;
    const Te = 37846;
    exports.SRGB8_ALPHA8_ASTC_8x6_Format = Te;
    const Ee = 37847;
    exports.SRGB8_ALPHA8_ASTC_8x8_Format = Ee;
    const Ae = 37848;
    exports.SRGB8_ALPHA8_ASTC_10x5_Format = Ae;
    const Le = 37849;
    exports.SRGB8_ALPHA8_ASTC_10x6_Format = Le;
    const Re = 37850;
    exports.SRGB8_ALPHA8_ASTC_10x8_Format = Re;
    const Ce = 37851;
    exports.SRGB8_ALPHA8_ASTC_10x10_Format = Ce;
    const Pe = 37852;
    exports.SRGB8_ALPHA8_ASTC_12x10_Format = Pe;
    const De = 37853;
    exports.SRGB8_ALPHA8_ASTC_12x12_Format = De;
    const Ie = 2200;
    exports.LoopOnce = Ie;
    const Be = 2201;
    exports.LoopRepeat = Be;
    const Ne = 2202;
    exports.LoopPingPong = Ne;
    const Fe = 2300;
    exports.InterpolateDiscrete = Fe;
    const ze = 2301;
    exports.InterpolateLinear = ze;
    const Ge = 2302;
    exports.InterpolateSmooth = Ge;
    const Oe = 2400;
    exports.ZeroCurvatureEnding = Oe;
    const He = 2401;
    exports.ZeroSlopeEnding = He;
    const Ue = 2402;
    exports.WrapAroundEnding = Ue;
    const ke = 2500;
    exports.NormalAnimationBlendMode = ke;
    const Ve = 2501;
    exports.AdditiveAnimationBlendMode = Ve;
    const We = 0;
    exports.TrianglesDrawMode = 0;
    const je = 1;
    exports.TriangleStripDrawMode = 1;
    const qe = 2;
    exports.TriangleFanDrawMode = 2;
    const Xe = 3e3;
    exports.LinearEncoding = Xe;
    const Ye = 3001;
    exports.sRGBEncoding = Ye;
    const Ze = 3007;
    exports.GammaEncoding = Ze;
    const Je = 3002;
    exports.RGBEEncoding = Je;
    const Qe = 3003;
    exports.LogLuvEncoding = Qe;
    const Ke = 3004;
    exports.RGBM7Encoding = Ke;
    const $e = 3005;
    exports.RGBM16Encoding = $e;
    const tn = 3006;
    exports.RGBDEncoding = tn;
    const en = 3200;
    exports.BasicDepthPacking = en;
    const nn = 3201;
    exports.RGBADepthPacking = nn;
    const rn = 0;
    exports.TangentSpaceNormalMap = rn;
    const sn = 1;
    exports.ObjectSpaceNormalMap = sn;
    const on = 0;
    exports.ZeroStencilOp = 0;
    const an = 7680;
    exports.KeepStencilOp = an;
    const ln = 7681;
    exports.ReplaceStencilOp = 7681;
    const cn = 7682;
    exports.IncrementStencilOp = 7682;
    const hn = 7683;
    exports.DecrementStencilOp = 7683;
    const un = 34055;
    exports.IncrementWrapStencilOp = 34055;
    const pn = 34056;
    exports.DecrementWrapStencilOp = 34056;
    const dn = 5386;
    exports.InvertStencilOp = 5386;
    const mn = 512;
    exports.NeverStencilFunc = 512;
    const fn = 513;
    exports.LessStencilFunc = 513;
    const gn = 514;
    exports.EqualStencilFunc = 514;
    const xn = 515;
    exports.LessEqualStencilFunc = 515;
    const vn = 516;
    exports.GreaterStencilFunc = 516;
    const yn = 517;
    exports.NotEqualStencilFunc = 517;
    const _n = 518;
    exports.GreaterEqualStencilFunc = 518;
    const bn = 519;
    exports.AlwaysStencilFunc = bn;
    const wn = 35044;
    exports.StaticDrawUsage = wn;
    const Mn = 35048;
    exports.DynamicDrawUsage = Mn;
    const Sn = 35040;
    exports.StreamDrawUsage = 35040;
    const Tn = 35045;
    exports.StaticReadUsage = 35045;
    const En = 35049;
    exports.DynamicReadUsage = 35049;
    const An = 35041;
    exports.StreamReadUsage = 35041;
    const Ln = 35046;
    exports.StaticCopyUsage = 35046;
    const Rn = 35050;
    exports.DynamicCopyUsage = 35050;
    const Cn = 35042;
    exports.StreamCopyUsage = 35042;
    const Pn = "100";
    exports.GLSL1 = "100";
    const Dn = "300 es";
    exports.GLSL3 = Dn;
    class In {
      addEventListener(t, e) {
        void 0 === this._listeners && (this._listeners = {});
        const n = this._listeners;
        void 0 === n[t] && (n[t] = []), -1 === n[t].indexOf(e) && n[t].push(e)
      }
      hasEventListener(t, e) {
        if (void 0 === this._listeners) return !1;
        const n = this._listeners;
        return void 0 !== n[t] && -1 !== n[t].indexOf(e)
      }
      removeEventListener(t, e) {
        if (void 0 === this._listeners) return;
        const n = this._listeners[t];
        if (void 0 !== n) {
          const t = n.indexOf(e); - 1 !== t && n.splice(t, 1)
        }
      }
      dispatchEvent(t) {
        if (void 0 === this._listeners) return;
        const e = this._listeners[t.type];
        if (void 0 !== e) {
          t.target = this;
          const n = e.slice(0);
          for (let e = 0, r = n.length; e < r; e++) n[e].call(this, t);
          t.target = null
        }
      }
    }
    exports.EventDispatcher = In;
    const Bn = [];
    for (let Kx = 0; Kx < 256; Kx++) Bn[Kx] = (Kx < 16 ? "0" : "") + Kx.toString(16);
    let Nn = 1234567;
    const Fn = Math.PI / 180,
      zn = 180 / Math.PI;

    function Gn() {
      const t = 4294967295 * Math.random() | 0,
        e = 4294967295 * Math.random() | 0,
        n = 4294967295 * Math.random() | 0,
        r = 4294967295 * Math.random() | 0;
      return (Bn[255 & t] + Bn[t >> 8 & 255] + Bn[t >> 16 & 255] + Bn[t >> 24 & 255] + "-" + Bn[255 & e] + Bn[e >> 8 & 255] + "-" + Bn[e >> 16 & 15 | 64] + Bn[e >> 24 & 255] + "-" + Bn[63 & n | 128] + Bn[n >> 8 & 255] + "-" + Bn[n >> 16 & 255] + Bn[n >> 24 & 255] + Bn[255 & r] + Bn[r >> 8 & 255] + Bn[r >> 16 & 255] + Bn[r >> 24 & 255]).toUpperCase()
    }

    function On(t, e, n) {
      return Math.max(e, Math.min(n, t))
    }

    function Hn(t, e) {
      return (t % e + e) % e
    }

    function Un(t, e, n, r, i) {
      return r + (t - e) * (i - r) / (n - e)
    }

    function kn(t, e, n) {
      return t !== e ? (n - t) / (e - t) : 0
    }

    function Vn(t, e, n) {
      return (1 - n) * t + n * e
    }

    function Wn(t, e, n, r) {
      return Vn(t, e, 1 - Math.exp(-n * r))
    }

    function jn(t, e = 1) {
      return e - Math.abs(Hn(t, 2 * e) - e)
    }

    function qn(t, e, n) {
      return t <= e ? 0 : t >= n ? 1 : (t = (t - e) / (n - e)) * t * (3 - 2 * t)
    }

    function Xn(t, e, n) {
      return t <= e ? 0 : t >= n ? 1 : (t = (t - e) / (n - e)) * t * t * (t * (6 * t - 15) + 10)
    }

    function Yn(t, e) {
      return t + Math.floor(Math.random() * (e - t + 1))
    }

    function Zn(t, e) {
      return t + Math.random() * (e - t)
    }

    function Jn(t) {
      return t * (.5 - Math.random())
    }

    function Qn(t) {
      return void 0 !== t && (Nn = t % 2147483647), ((Nn = 16807 * Nn % 2147483647) - 1) / 2147483646
    }

    function Kn(t) {
      return t * Fn
    }

    function $n(t) {
      return t * zn
    }

    function tr(t) {
      return 0 == (t & t - 1) && 0 !== t
    }

    function er(t) {
      return Math.pow(2, Math.ceil(Math.log(t) / Math.LN2))
    }

    function nr(t) {
      return Math.pow(2, Math.floor(Math.log(t) / Math.LN2))
    }

    function rr(t, e, n, r, i) {
      const s = Math.cos,
        o = Math.sin,
        a = s(n / 2),
        l = o(n / 2),
        c = s((e + r) / 2),
        h = o((e + r) / 2),
        u = s((e - r) / 2),
        p = o((e - r) / 2),
        d = s((r - e) / 2),
        m = o((r - e) / 2);
      switch (i) {
        case "XYX":
          t.set(a * h, l * u, l * p, a * c);
          break;
        case "YZY":
          t.set(l * p, a * h, l * u, a * c);
          break;
        case "ZXZ":
          t.set(l * u, l * p, a * h, a * c);
          break;
        case "XZX":
          t.set(a * h, l * m, l * d, a * c);
          break;
        case "YXY":
          t.set(l * d, a * h, l * m, a * c);
          break;
        case "ZYZ":
          t.set(l * m, l * d, a * h, a * c);
          break;
        default:
          console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + i)
      }
    }
    var ir = Object.freeze({
      __proto__: null,
      DEG2RAD: Fn,
      RAD2DEG: zn,
      generateUUID: Gn,
      clamp: On,
      euclideanModulo: Hn,
      mapLinear: Un,
      inverseLerp: kn,
      lerp: Vn,
      damp: Wn,
      pingpong: jn,
      smoothstep: qn,
      smootherstep: Xn,
      randInt: Yn,
      randFloat: Zn,
      randFloatSpread: Jn,
      seededRandom: Qn,
      degToRad: Kn,
      radToDeg: $n,
      isPowerOfTwo: tr,
      ceilPowerOfTwo: er,
      floorPowerOfTwo: nr,
      setQuaternionFromProperEuler: rr
    });
    exports.MathUtils = exports.Math = ir;
    class sr {
      constructor(t = 0, e = 0) {
        this.x = t, this.y = e
      }
      get width() {
        return this.x
      }
      set width(t) {
        this.x = t
      }
      get height() {
        return this.y
      }
      set height(t) {
        this.y = t
      }
      set(t, e) {
        return this.x = t, this.y = e, this
      }
      setScalar(t) {
        return this.x = t, this.y = t, this
      }
      setX(t) {
        return this.x = t, this
      }
      setY(t) {
        return this.y = t, this
      }
      setComponent(t, e) {
        switch (t) {
          case 0:
            this.x = e;
            break;
          case 1:
            this.y = e;
            break;
          default:
            throw new Error("index is out of range: " + t)
        }
        return this
      }
      getComponent(t) {
        switch (t) {
          case 0:
            return this.x;
          case 1:
            return this.y;
          default:
            throw new Error("index is out of range: " + t)
        }
      }
      clone() {
        return new this.constructor(this.x, this.y)
      }
      copy(t) {
        return this.x = t.x, this.y = t.y, this
      }
      add(t, e) {
        return void 0 !== e ? (console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(t, e)) : (this.x += t.x, this.y += t.y, this)
      }
      addScalar(t) {
        return this.x += t, this.y += t, this
      }
      addVectors(t, e) {
        return this.x = t.x + e.x, this.y = t.y + e.y, this
      }
      addScaledVector(t, e) {
        return this.x += t.x * e, this.y += t.y * e, this
      }
      sub(t, e) {
        return void 0 !== e ? (console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(t, e)) : (this.x -= t.x, this.y -= t.y, this)
      }
      subScalar(t) {
        return this.x -= t, this.y -= t, this
      }
      subVectors(t, e) {
        return this.x = t.x - e.x, this.y = t.y - e.y, this
      }
      multiply(t) {
        return this.x *= t.x, this.y *= t.y, this
      }
      multiplyScalar(t) {
        return this.x *= t, this.y *= t, this
      }
      divide(t) {
        return this.x /= t.x, this.y /= t.y, this
      }
      divideScalar(t) {
        return this.multiplyScalar(1 / t)
      }
      applyMatrix3(t) {
        const e = this.x,
          n = this.y,
          r = t.elements;
        return this.x = r[0] * e + r[3] * n + r[6], this.y = r[1] * e + r[4] * n + r[7], this
      }
      min(t) {
        return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this
      }
      max(t) {
        return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this
      }
      clamp(t, e) {
        return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this
      }
      clampScalar(t, e) {
        return this.x = Math.max(t, Math.min(e, this.x)), this.y = Math.max(t, Math.min(e, this.y)), this
      }
      clampLength(t, e) {
        const n = this.length();
        return this.divideScalar(n || 1).multiplyScalar(Math.max(t, Math.min(e, n)))
      }
      floor() {
        return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this
      }
      ceil() {
        return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this
      }
      round() {
        return this.x = Math.round(this.x), this.y = Math.round(this.y), this
      }
      roundToZero() {
        return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this
      }
      negate() {
        return this.x = -this.x, this.y = -this.y, this
      }
      dot(t) {
        return this.x * t.x + this.y * t.y
      }
      cross(t) {
        return this.x * t.y - this.y * t.x
      }
      lengthSq() {
        return this.x * this.x + this.y * this.y
      }
      length() {
        return Math.sqrt(this.x * this.x + this.y * this.y)
      }
      manhattanLength() {
        return Math.abs(this.x) + Math.abs(this.y)
      }
      normalize() {
        return this.divideScalar(this.length() || 1)
      }
      angle() {
        return Math.atan2(-this.y, -this.x) + Math.PI
      }
      distanceTo(t) {
        return Math.sqrt(this.distanceToSquared(t))
      }
      distanceToSquared(t) {
        const e = this.x - t.x,
          n = this.y - t.y;
        return e * e + n * n
      }
      manhattanDistanceTo(t) {
        return Math.abs(this.x - t.x) + Math.abs(this.y - t.y)
      }
      setLength(t) {
        return this.normalize().multiplyScalar(t)
      }
      lerp(t, e) {
        return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this
      }
      lerpVectors(t, e, n) {
        return this.x = t.x + (e.x - t.x) * n, this.y = t.y + (e.y - t.y) * n, this
      }
      equals(t) {
        return t.x === this.x && t.y === this.y
      }
      fromArray(t, e = 0) {
        return this.x = t[e], this.y = t[e + 1], this
      }
      toArray(t = [], e = 0) {
        return t[e] = this.x, t[e + 1] = this.y, t
      }
      fromBufferAttribute(t, e, n) {
        return void 0 !== n && console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute()."), this.x = t.getX(e), this.y = t.getY(e), this
      }
      rotateAround(t, e) {
        const n = Math.cos(e),
          r = Math.sin(e),
          i = this.x - t.x,
          s = this.y - t.y;
        return this.x = i * n - s * r + t.x, this.y = i * r + s * n + t.y, this
      }
      random() {
        return this.x = Math.random(), this.y = Math.random(), this
      }
    }
    exports.Vector2 = sr, sr.prototype.isVector2 = !0;
    class or {
      constructor() {
        this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1], arguments.length > 0 && console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.")
      }
      set(t, e, n, r, i, s, o, a, l) {
        const c = this.elements;
        return c[0] = t, c[1] = r, c[2] = o, c[3] = e, c[4] = i, c[5] = a, c[6] = n, c[7] = s, c[8] = l, this
      }
      identity() {
        return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this
      }
      copy(t) {
        const e = this.elements,
          n = t.elements;
        return e[0] = n[0], e[1] = n[1], e[2] = n[2], e[3] = n[3], e[4] = n[4], e[5] = n[5], e[6] = n[6], e[7] = n[7], e[8] = n[8], this
      }
      extractBasis(t, e, n) {
        return t.setFromMatrix3Column(this, 0), e.setFromMatrix3Column(this, 1), n.setFromMatrix3Column(this, 2), this
      }
      setFromMatrix4(t) {
        const e = t.elements;
        return this.set(e[0], e[4], e[8], e[1], e[5], e[9], e[2], e[6], e[10]), this
      }
      multiply(t) {
        return this.multiplyMatrices(this, t)
      }
      premultiply(t) {
        return this.multiplyMatrices(t, this)
      }
      multiplyMatrices(t, e) {
        const n = t.elements,
          r = e.elements,
          i = this.elements,
          s = n[0],
          o = n[3],
          a = n[6],
          l = n[1],
          c = n[4],
          h = n[7],
          u = n[2],
          p = n[5],
          d = n[8],
          m = r[0],
          f = r[3],
          g = r[6],
          x = r[1],
          v = r[4],
          y = r[7],
          _ = r[2],
          b = r[5],
          w = r[8];
        return i[0] = s * m + o * x + a * _, i[3] = s * f + o * v + a * b, i[6] = s * g + o * y + a * w, i[1] = l * m + c * x + h * _, i[4] = l * f + c * v + h * b, i[7] = l * g + c * y + h * w, i[2] = u * m + p * x + d * _, i[5] = u * f + p * v + d * b, i[8] = u * g + p * y + d * w, this
      }
      multiplyScalar(t) {
        const e = this.elements;
        return e[0] *= t, e[3] *= t, e[6] *= t, e[1] *= t, e[4] *= t, e[7] *= t, e[2] *= t, e[5] *= t, e[8] *= t, this
      }
      determinant() {
        const t = this.elements,
          e = t[0],
          n = t[1],
          r = t[2],
          i = t[3],
          s = t[4],
          o = t[5],
          a = t[6],
          l = t[7],
          c = t[8];
        return e * s * c - e * o * l - n * i * c + n * o * a + r * i * l - r * s * a
      }
      invert() {
        const t = this.elements,
          e = t[0],
          n = t[1],
          r = t[2],
          i = t[3],
          s = t[4],
          o = t[5],
          a = t[6],
          l = t[7],
          c = t[8],
          h = c * s - o * l,
          u = o * a - c * i,
          p = l * i - s * a,
          d = e * h + n * u + r * p;
        if (0 === d) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
        const m = 1 / d;
        return t[0] = h * m, t[1] = (r * l - c * n) * m, t[2] = (o * n - r * s) * m, t[3] = u * m, t[4] = (c * e - r * a) * m, t[5] = (r * i - o * e) * m, t[6] = p * m, t[7] = (n * a - l * e) * m, t[8] = (s * e - n * i) * m, this
      }
      transpose() {
        let t;
        const e = this.elements;
        return t = e[1], e[1] = e[3], e[3] = t, t = e[2], e[2] = e[6], e[6] = t, t = e[5], e[5] = e[7], e[7] = t, this
      }
      getNormalMatrix(t) {
        return this.setFromMatrix4(t).invert().transpose()
      }
      transposeIntoArray(t) {
        const e = this.elements;
        return t[0] = e[0], t[1] = e[3], t[2] = e[6], t[3] = e[1], t[4] = e[4], t[5] = e[7], t[6] = e[2], t[7] = e[5], t[8] = e[8], this
      }
      setUvTransform(t, e, n, r, i, s, o) {
        const a = Math.cos(i),
          l = Math.sin(i);
        return this.set(n * a, n * l, -n * (a * s + l * o) + s + t, -r * l, r * a, -r * (-l * s + a * o) + o + e, 0, 0, 1), this
      }
      scale(t, e) {
        const n = this.elements;
        return n[0] *= t, n[3] *= t, n[6] *= t, n[1] *= e, n[4] *= e, n[7] *= e, this
      }
      rotate(t) {
        const e = Math.cos(t),
          n = Math.sin(t),
          r = this.elements,
          i = r[0],
          s = r[3],
          o = r[6],
          a = r[1],
          l = r[4],
          c = r[7];
        return r[0] = e * i + n * a, r[3] = e * s + n * l, r[6] = e * o + n * c, r[1] = -n * i + e * a, r[4] = -n * s + e * l, r[7] = -n * o + e * c, this
      }
      translate(t, e) {
        const n = this.elements;
        return n[0] += t * n[2], n[3] += t * n[5], n[6] += t * n[8], n[1] += e * n[2], n[4] += e * n[5], n[7] += e * n[8], this
      }
      equals(t) {
        const e = this.elements,
          n = t.elements;
        for (let r = 0; r < 9; r++)
          if (e[r] !== n[r]) return !1;
        return !0
      }
      fromArray(t, e = 0) {
        for (let n = 0; n < 9; n++) this.elements[n] = t[n + e];
        return this
      }
      toArray(t = [], e = 0) {
        const n = this.elements;
        return t[e] = n[0], t[e + 1] = n[1], t[e + 2] = n[2], t[e + 3] = n[3], t[e + 4] = n[4], t[e + 5] = n[5], t[e + 6] = n[6], t[e + 7] = n[7], t[e + 8] = n[8], t
      }
      clone() {
        return (new this.constructor).fromArray(this.elements)
      }
    }
    let ar;
    exports.Matrix3 = or, or.prototype.isMatrix3 = !0;
    class lr {
      static getDataURL(t) {
        if (/^data:/i.test(t.src)) return t.src;
        if ("undefined" == typeof HTMLCanvasElement) return t.src;
        let e;
        if (t instanceof HTMLCanvasElement) e = t;
        else {
          void 0 === ar && (ar = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas")), ar.width = t.width, ar.height = t.height;
          const n = ar.getContext("2d");
          t instanceof ImageData ? n.putImageData(t, 0, 0) : n.drawImage(t, 0, 0, t.width, t.height), e = ar
        }
        return e.width > 2048 || e.height > 2048 ? (console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons", t), e.toDataURL("image/jpeg", .6)) : e.toDataURL("image/png")
      }
    }
    exports.ImageUtils = lr;
    let cr = 0;
    class hr extends In {
      constructor(t = hr.DEFAULT_IMAGE, e = hr.DEFAULT_MAPPING, n = ct, r = ct, i = gt, s = yt, o = Nt, a = bt, l = 1, c = Xe) {
        super(), Object.defineProperty(this, "id", {
          value: cr++
        }), this.uuid = Gn(), this.name = "", this.image = t, this.mipmaps = [], this.mapping = e, this.wrapS = n, this.wrapT = r, this.magFilter = i, this.minFilter = s, this.anisotropy = l, this.format = o, this.internalFormat = null, this.type = a, this.offset = new sr(0, 0), this.repeat = new sr(1, 1), this.center = new sr(0, 0), this.rotation = 0, this.matrixAutoUpdate = !0, this.matrix = new or, this.generateMipmaps = !0, this.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment = 4, this.encoding = c, this.version = 0, this.onUpdate = null
      }
      updateMatrix() {
        this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y)
      }
      clone() {
        return (new this.constructor).copy(this)
      }
      copy(t) {
        return this.name = t.name, this.image = t.image, this.mipmaps = t.mipmaps.slice(0), this.mapping = t.mapping, this.wrapS = t.wrapS, this.wrapT = t.wrapT, this.magFilter = t.magFilter, this.minFilter = t.minFilter, this.anisotropy = t.anisotropy, this.format = t.format, this.internalFormat = t.internalFormat, this.type = t.type, this.offset.copy(t.offset), this.repeat.copy(t.repeat), this.center.copy(t.center), this.rotation = t.rotation, this.matrixAutoUpdate = t.matrixAutoUpdate, this.matrix.copy(t.matrix), this.generateMipmaps = t.generateMipmaps, this.premultiplyAlpha = t.premultiplyAlpha, this.flipY = t.flipY, this.unpackAlignment = t.unpackAlignment, this.encoding = t.encoding, this
      }
      toJSON(t) {
        const e = void 0 === t || "string" == typeof t;
        if (!e && void 0 !== t.textures[this.uuid]) return t.textures[this.uuid];
        const n = {
          metadata: {
            version: 4.5,
            type: "Texture",
            generator: "Texture.toJSON"
          },
          uuid: this.uuid,
          name: this.name,
          mapping: this.mapping,
          repeat: [this.repeat.x, this.repeat.y],
          offset: [this.offset.x, this.offset.y],
          center: [this.center.x, this.center.y],
          rotation: this.rotation,
          wrap: [this.wrapS, this.wrapT],
          format: this.format,
          type: this.type,
          encoding: this.encoding,
          minFilter: this.minFilter,
          magFilter: this.magFilter,
          anisotropy: this.anisotropy,
          flipY: this.flipY,
          premultiplyAlpha: this.premultiplyAlpha,
          unpackAlignment: this.unpackAlignment
        };
        if (void 0 !== this.image) {
          const r = this.image;
          if (void 0 === r.uuid && (r.uuid = Gn()), !e && void 0 === t.images[r.uuid]) {
            let e;
            if (Array.isArray(r)) {
              e = [];
              for (let t = 0, n = r.length; t < n; t++) r[t].isDataTexture ? e.push(ur(r[t].image)) : e.push(ur(r[t]))
            } else e = ur(r);
            t.images[r.uuid] = {
              uuid: r.uuid,
              url: e
            }
          }
          n.image = r.uuid
        }
        return e || (t.textures[this.uuid] = n), n
      }
      dispose() {
        this.dispatchEvent({
          type: "dispose"
        })
      }
      transformUv(t) {
        if (this.mapping !== et) return t;
        if (t.applyMatrix3(this.matrix), t.x < 0 || t.x > 1) switch (this.wrapS) {
          case lt:
            t.x = t.x - Math.floor(t.x);
            break;
          case ct:
            t.x = t.x < 0 ? 0 : 1;
            break;
          case ht:
            1 === Math.abs(Math.floor(t.x) % 2) ? t.x = Math.ceil(t.x) - t.x : t.x = t.x - Math.floor(t.x)
        }
        if (t.y < 0 || t.y > 1) switch (this.wrapT) {
          case lt:
            t.y = t.y - Math.floor(t.y);
            break;
          case ct:
            t.y = t.y < 0 ? 0 : 1;
            break;
          case ht:
            1 === Math.abs(Math.floor(t.y) % 2) ? t.y = Math.ceil(t.y) - t.y : t.y = t.y - Math.floor(t.y)
        }
        return this.flipY && (t.y = 1 - t.y), t
      }
      set needsUpdate(t) {
        !0 === t && this.version++
      }
    }

    function ur(t) {
      return "undefined" != typeof HTMLImageElement && t instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && t instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && t instanceof ImageBitmap ? lr.getDataURL(t) : t.data ? {
        data: Array.prototype.slice.call(t.data),
        width: t.width,
        height: t.height,
        type: t.data.constructor.name
      } : (console.warn("THREE.Texture: Unable to serialize Texture."), {})
    }
    exports.Texture = hr, hr.DEFAULT_IMAGE = void 0, hr.DEFAULT_MAPPING = et, hr.prototype.isTexture = !0;
    class pr {
      constructor(t = 0, e = 0, n = 0, r = 1) {
        this.x = t, this.y = e, this.z = n, this.w = r
      }
      get width() {
        return this.z
      }
      set width(t) {
        this.z = t
      }
      get height() {
        return this.w
      }
      set height(t) {
        this.w = t
      }
      set(t, e, n, r) {
        return this.x = t, this.y = e, this.z = n, this.w = r, this
      }
      setScalar(t) {
        return this.x = t, this.y = t, this.z = t, this.w = t, this
      }
      setX(t) {
        return this.x = t, this
      }
      setY(t) {
        return this.y = t, this
      }
      setZ(t) {
        return this.z = t, this
      }
      setW(t) {
        return this.w = t, this
      }
      setComponent(t, e) {
        switch (t) {
          case 0:
            this.x = e;
            break;
          case 1:
            this.y = e;
            break;
          case 2:
            this.z = e;
            break;
          case 3:
            this.w = e;
            break;
          default:
            throw new Error("index is out of range: " + t)
        }
        return this
      }
      getComponent(t) {
        switch (t) {
          case 0:
            return this.x;
          case 1:
            return this.y;
          case 2:
            return this.z;
          case 3:
            return this.w;
          default:
            throw new Error("index is out of range: " + t)
        }
      }
      clone() {
        return new this.constructor(this.x, this.y, this.z, this.w)
      }
      copy(t) {
        return this.x = t.x, this.y = t.y, this.z = t.z, this.w = void 0 !== t.w ? t.w : 1, this
      }
      add(t, e) {
        return void 0 !== e ? (console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(t, e)) : (this.x += t.x, this.y += t.y, this.z += t.z, this.w += t.w, this)
      }
      addScalar(t) {
        return this.x += t, this.y += t, this.z += t, this.w += t, this
      }
      addVectors(t, e) {
        return this.x = t.x + e.x, this.y = t.y + e.y, this.z = t.z + e.z, this.w = t.w + e.w, this
      }
      addScaledVector(t, e) {
        return this.x += t.x * e, this.y += t.y * e, this.z += t.z * e, this.w += t.w * e, this
      }
      sub(t, e) {
        return void 0 !== e ? (console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(t, e)) : (this.x -= t.x, this.y -= t.y, this.z -= t.z, this.w -= t.w, this)
      }
      subScalar(t) {
        return this.x -= t, this.y -= t, this.z -= t, this.w -= t, this
      }
      subVectors(t, e) {
        return this.x = t.x - e.x, this.y = t.y - e.y, this.z = t.z - e.z, this.w = t.w - e.w, this
      }
      multiply(t) {
        return this.x *= t.x, this.y *= t.y, this.z *= t.z, this.w *= t.w, this
      }
      multiplyScalar(t) {
        return this.x *= t, this.y *= t, this.z *= t, this.w *= t, this
      }
      applyMatrix4(t) {
        const e = this.x,
          n = this.y,
          r = this.z,
          i = this.w,
          s = t.elements;
        return this.x = s[0] * e + s[4] * n + s[8] * r + s[12] * i, this.y = s[1] * e + s[5] * n + s[9] * r + s[13] * i, this.z = s[2] * e + s[6] * n + s[10] * r + s[14] * i, this.w = s[3] * e + s[7] * n + s[11] * r + s[15] * i, this
      }
      divideScalar(t) {
        return this.multiplyScalar(1 / t)
      }
      setAxisAngleFromQuaternion(t) {
        this.w = 2 * Math.acos(t.w);
        const e = Math.sqrt(1 - t.w * t.w);
        return e < 1e-4 ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = t.x / e, this.y = t.y / e, this.z = t.z / e), this
      }
      setAxisAngleFromRotationMatrix(t) {
        let e, n, r, i;
        const s = t.elements,
          o = s[0],
          a = s[4],
          l = s[8],
          c = s[1],
          h = s[5],
          u = s[9],
          p = s[2],
          d = s[6],
          m = s[10];
        if (Math.abs(a - c) < .01 && Math.abs(l - p) < .01 && Math.abs(u - d) < .01) {
          if (Math.abs(a + c) < .1 && Math.abs(l + p) < .1 && Math.abs(u + d) < .1 && Math.abs(o + h + m - 3) < .1) return this.set(1, 0, 0, 0), this;
          e = Math.PI;
          const t = (o + 1) / 2,
            s = (h + 1) / 2,
            f = (m + 1) / 2,
            g = (a + c) / 4,
            x = (l + p) / 4,
            v = (u + d) / 4;
          return t > s && t > f ? t < .01 ? (n = 0, r = .707106781, i = .707106781) : (r = g / (n = Math.sqrt(t)), i = x / n) : s > f ? s < .01 ? (n = .707106781, r = 0, i = .707106781) : (n = g / (r = Math.sqrt(s)), i = v / r) : f < .01 ? (n = .707106781, r = .707106781, i = 0) : (n = x / (i = Math.sqrt(f)), r = v / i), this.set(n, r, i, e), this
        }
        let f = Math.sqrt((d - u) * (d - u) + (l - p) * (l - p) + (c - a) * (c - a));
        return Math.abs(f) < .001 && (f = 1), this.x = (d - u) / f, this.y = (l - p) / f, this.z = (c - a) / f, this.w = Math.acos((o + h + m - 1) / 2), this
      }
      min(t) {
        return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this.z = Math.min(this.z, t.z), this.w = Math.min(this.w, t.w), this
      }
      max(t) {
        return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this.z = Math.max(this.z, t.z), this.w = Math.max(this.w, t.w), this
      }
      clamp(t, e) {
        return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this.z = Math.max(t.z, Math.min(e.z, this.z)), this.w = Math.max(t.w, Math.min(e.w, this.w)), this
      }
      clampScalar(t, e) {
        return this.x = Math.max(t, Math.min(e, this.x)), this.y = Math.max(t, Math.min(e, this.y)), this.z = Math.max(t, Math.min(e, this.z)), this.w = Math.max(t, Math.min(e, this.w)), this
      }
      clampLength(t, e) {
        const n = this.length();
        return this.divideScalar(n || 1).multiplyScalar(Math.max(t, Math.min(e, n)))
      }
      floor() {
        return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this
      }
      ceil() {
        return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this
      }
      round() {
        return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this
      }
      roundToZero() {
        return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w), this
      }
      negate() {
        return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this
      }
      dot(t) {
        return this.x * t.x + this.y * t.y + this.z * t.z + this.w * t.w
      }
      lengthSq() {
        return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
      }
      length() {
        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)
      }
      manhattanLength() {
        return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
      }
      normalize() {
        return this.divideScalar(this.length() || 1)
      }
      setLength(t) {
        return this.normalize().multiplyScalar(t)
      }
      lerp(t, e) {
        return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this.z += (t.z - this.z) * e, this.w += (t.w - this.w) * e, this
      }
      lerpVectors(t, e, n) {
        return this.x = t.x + (e.x - t.x) * n, this.y = t.y + (e.y - t.y) * n, this.z = t.z + (e.z - t.z) * n, this.w = t.w + (e.w - t.w) * n, this
      }
      equals(t) {
        return t.x === this.x && t.y === this.y && t.z === this.z && t.w === this.w
      }
      fromArray(t, e = 0) {
        return this.x = t[e], this.y = t[e + 1], this.z = t[e + 2], this.w = t[e + 3], this
      }
      toArray(t = [], e = 0) {
        return t[e] = this.x, t[e + 1] = this.y, t[e + 2] = this.z, t[e + 3] = this.w, t
      }
      fromBufferAttribute(t, e, n) {
        return void 0 !== n && console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute()."), this.x = t.getX(e), this.y = t.getY(e), this.z = t.getZ(e), this.w = t.getW(e), this
      }
      random() {
        return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this.w = Math.random(), this
      }
    }
    exports.Vector4 = pr, pr.prototype.isVector4 = !0;
    class dr extends In {
      constructor(t, e, n) {
        super(), this.width = t, this.height = e, this.depth = 1, this.scissor = new pr(0, 0, t, e), this.scissorTest = !1, this.viewport = new pr(0, 0, t, e), n = n || {}, this.texture = new hr(void 0, n.mapping, n.wrapS, n.wrapT, n.magFilter, n.minFilter, n.format, n.type, n.anisotropy, n.encoding), this.texture.image = {}, this.texture.image.width = t, this.texture.image.height = e, this.texture.image.depth = 1, this.texture.generateMipmaps = void 0 !== n.generateMipmaps && n.generateMipmaps, this.texture.minFilter = void 0 !== n.minFilter ? n.minFilter : gt, this.depthBuffer = void 0 === n.depthBuffer || n.depthBuffer, this.stencilBuffer = void 0 !== n.stencilBuffer && n.stencilBuffer, this.depthTexture = void 0 !== n.depthTexture ? n.depthTexture : null
      }
      setTexture(t) {
        t.image = {
          width: this.width,
          height: this.height,
          depth: this.depth
        }, this.texture = t
      }
      setSize(t, e, n = 1) {
        this.width === t && this.height === e && this.depth === n || (this.width = t, this.height = e, this.depth = n, this.texture.image.width = t, this.texture.image.height = e, this.texture.image.depth = n, this.dispose()), this.viewport.set(0, 0, t, e), this.scissor.set(0, 0, t, e)
      }
      clone() {
        return (new this.constructor).copy(this)
      }
      copy(t) {
        return this.width = t.width, this.height = t.height, this.depth = t.depth, this.viewport.copy(t.viewport), this.texture = t.texture.clone(), this.depthBuffer = t.depthBuffer, this.stencilBuffer = t.stencilBuffer, this.depthTexture = t.depthTexture, this
      }
      dispose() {
        this.dispatchEvent({
          type: "dispose"
        })
      }
    }
    exports.WebGLRenderTarget = dr, dr.prototype.isWebGLRenderTarget = !0;
    class mr extends dr {
      constructor(t, e, n) {
        super(t, e, n), this.samples = 4
      }
      copy(t) {
        return super.copy.call(this, t), this.samples = t.samples, this
      }
    }
    exports.WebGLMultisampleRenderTarget = mr, mr.prototype.isWebGLMultisampleRenderTarget = !0;
    class fr {
      constructor(t = 0, e = 0, n = 0, r = 1) {
        this._x = t, this._y = e, this._z = n, this._w = r
      }
      static slerp(t, e, n, r) {
        return console.warn("THREE.Quaternion: Static .slerp() has been deprecated. Use qm.slerpQuaternions( qa, qb, t ) instead."), n.slerpQuaternions(t, e, r)
      }
      static slerpFlat(t, e, n, r, i, s, o) {
        let a = n[r + 0],
          l = n[r + 1],
          c = n[r + 2],
          h = n[r + 3];
        const u = i[s + 0],
          p = i[s + 1],
          d = i[s + 2],
          m = i[s + 3];
        if (0 === o) return t[e + 0] = a, t[e + 1] = l, t[e + 2] = c, void(t[e + 3] = h);
        if (1 === o) return t[e + 0] = u, t[e + 1] = p, t[e + 2] = d, void(t[e + 3] = m);
        if (h !== m || a !== u || l !== p || c !== d) {
          let t = 1 - o;
          const e = a * u + l * p + c * d + h * m,
            n = e >= 0 ? 1 : -1,
            r = 1 - e * e;
          if (r > Number.EPSILON) {
            const i = Math.sqrt(r),
              s = Math.atan2(i, e * n);
            t = Math.sin(t * s) / i, o = Math.sin(o * s) / i
          }
          const i = o * n;
          if (a = a * t + u * i, l = l * t + p * i, c = c * t + d * i, h = h * t + m * i, t === 1 - o) {
            const t = 1 / Math.sqrt(a * a + l * l + c * c + h * h);
            a *= t, l *= t, c *= t, h *= t
          }
        }
        t[e] = a, t[e + 1] = l, t[e + 2] = c, t[e + 3] = h
      }
      static multiplyQuaternionsFlat(t, e, n, r, i, s) {
        const o = n[r],
          a = n[r + 1],
          l = n[r + 2],
          c = n[r + 3],
          h = i[s],
          u = i[s + 1],
          p = i[s + 2],
          d = i[s + 3];
        return t[e] = o * d + c * h + a * p - l * u, t[e + 1] = a * d + c * u + l * h - o * p, t[e + 2] = l * d + c * p + o * u - a * h, t[e + 3] = c * d - o * h - a * u - l * p, t
      }
      get x() {
        return this._x
      }
      set x(t) {
        this._x = t, this._onChangeCallback()
      }
      get y() {
        return this._y
      }
      set y(t) {
        this._y = t, this._onChangeCallback()
      }
      get z() {
        return this._z
      }
      set z(t) {
        this._z = t, this._onChangeCallback()
      }
      get w() {
        return this._w
      }
      set w(t) {
        this._w = t, this._onChangeCallback()
      }
      set(t, e, n, r) {
        return this._x = t, this._y = e, this._z = n, this._w = r, this._onChangeCallback(), this
      }
      clone() {
        return new this.constructor(this._x, this._y, this._z, this._w)
      }
      copy(t) {
        return this._x = t.x, this._y = t.y, this._z = t.z, this._w = t.w, this._onChangeCallback(), this
      }
      setFromEuler(t, e) {
        if (!t || !t.isEuler) throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");
        const n = t._x,
          r = t._y,
          i = t._z,
          s = t._order,
          o = Math.cos,
          a = Math.sin,
          l = o(n / 2),
          c = o(r / 2),
          h = o(i / 2),
          u = a(n / 2),
          p = a(r / 2),
          d = a(i / 2);
        switch (s) {
          case "XYZ":
            this._x = u * c * h + l * p * d, this._y = l * p * h - u * c * d, this._z = l * c * d + u * p * h, this._w = l * c * h - u * p * d;
            break;
          case "YXZ":
            this._x = u * c * h + l * p * d, this._y = l * p * h - u * c * d, this._z = l * c * d - u * p * h, this._w = l * c * h + u * p * d;
            break;
          case "ZXY":
            this._x = u * c * h - l * p * d, this._y = l * p * h + u * c * d, this._z = l * c * d + u * p * h, this._w = l * c * h - u * p * d;
            break;
          case "ZYX":
            this._x = u * c * h - l * p * d, this._y = l * p * h + u * c * d, this._z = l * c * d - u * p * h, this._w = l * c * h + u * p * d;
            break;
          case "YZX":
            this._x = u * c * h + l * p * d, this._y = l * p * h + u * c * d, this._z = l * c * d - u * p * h, this._w = l * c * h - u * p * d;
            break;
          case "XZY":
            this._x = u * c * h - l * p * d, this._y = l * p * h - u * c * d, this._z = l * c * d + u * p * h, this._w = l * c * h + u * p * d;
            break;
          default:
            console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + s)
        }
        return !1 !== e && this._onChangeCallback(), this
      }
      setFromAxisAngle(t, e) {
        const n = e / 2,
          r = Math.sin(n);
        return this._x = t.x * r, this._y = t.y * r, this._z = t.z * r, this._w = Math.cos(n), this._onChangeCallback(), this
      }
      setFromRotationMatrix(t) {
        const e = t.elements,
          n = e[0],
          r = e[4],
          i = e[8],
          s = e[1],
          o = e[5],
          a = e[9],
          l = e[2],
          c = e[6],
          h = e[10],
          u = n + o + h;
        if (u > 0) {
          const t = .5 / Math.sqrt(u + 1);
          this._w = .25 / t, this._x = (c - a) * t, this._y = (i - l) * t, this._z = (s - r) * t
        } else if (n > o && n > h) {
          const t = 2 * Math.sqrt(1 + n - o - h);
          this._w = (c - a) / t, this._x = .25 * t, this._y = (r + s) / t, this._z = (i + l) / t
        } else if (o > h) {
          const t = 2 * Math.sqrt(1 + o - n - h);
          this._w = (i - l) / t, this._x = (r + s) / t, this._y = .25 * t, this._z = (a + c) / t
        } else {
          const t = 2 * Math.sqrt(1 + h - n - o);
          this._w = (s - r) / t, this._x = (i + l) / t, this._y = (a + c) / t, this._z = .25 * t
        }
        return this._onChangeCallback(), this
      }
      setFromUnitVectors(t, e) {
        let n = t.dot(e) + 1;
        return n < Number.EPSILON ? (n = 0, Math.abs(t.x) > Math.abs(t.z) ? (this._x = -t.y, this._y = t.x, this._z = 0, this._w = n) : (this._x = 0, this._y = -t.z, this._z = t.y, this._w = n)) : (this._x = t.y * e.z - t.z * e.y, this._y = t.z * e.x - t.x * e.z, this._z = t.x * e.y - t.y * e.x, this._w = n), this.normalize()
      }
      angleTo(t) {
        return 2 * Math.acos(Math.abs(On(this.dot(t), -1, 1)))
      }
      rotateTowards(t, e) {
        const n = this.angleTo(t);
        if (0 === n) return this;
        const r = Math.min(1, e / n);
        return this.slerp(t, r), this
      }
      identity() {
        return this.set(0, 0, 0, 1)
      }
      invert() {
        return this.conjugate()
      }
      conjugate() {
        return this._x *= -1, this._y *= -1, this._z *= -1, this._onChangeCallback(), this
      }
      dot(t) {
        return this._x * t._x + this._y * t._y + this._z * t._z + this._w * t._w
      }
      lengthSq() {
        return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w
      }
      length() {
        return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w)
      }
      normalize() {
        let t = this.length();
        return 0 === t ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (t = 1 / t, this._x = this._x * t, this._y = this._y * t, this._z = this._z * t, this._w = this._w * t), this._onChangeCallback(), this
      }
      multiply(t, e) {
        return void 0 !== e ? (console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."), this.multiplyQuaternions(t, e)) : this.multiplyQuaternions(this, t)
      }
      premultiply(t) {
        return this.multiplyQuaternions(t, this)
      }
      multiplyQuaternions(t, e) {
        const n = t._x,
          r = t._y,
          i = t._z,
          s = t._w,
          o = e._x,
          a = e._y,
          l = e._z,
          c = e._w;
        return this._x = n * c + s * o + r * l - i * a, this._y = r * c + s * a + i * o - n * l, this._z = i * c + s * l + n * a - r * o, this._w = s * c - n * o - r * a - i * l, this._onChangeCallback(), this
      }
      slerp(t, e) {
        if (0 === e) return this;
        if (1 === e) return this.copy(t);
        const n = this._x,
          r = this._y,
          i = this._z,
          s = this._w;
        let o = s * t._w + n * t._x + r * t._y + i * t._z;
        if (o < 0 ? (this._w = -t._w, this._x = -t._x, this._y = -t._y, this._z = -t._z, o = -o) : this.copy(t), o >= 1) return this._w = s, this._x = n, this._y = r, this._z = i, this;
        const a = 1 - o * o;
        if (a <= Number.EPSILON) {
          const t = 1 - e;
          return this._w = t * s + e * this._w, this._x = t * n + e * this._x, this._y = t * r + e * this._y, this._z = t * i + e * this._z, this.normalize(), this._onChangeCallback(), this
        }
        const l = Math.sqrt(a),
          c = Math.atan2(l, o),
          h = Math.sin((1 - e) * c) / l,
          u = Math.sin(e * c) / l;
        return this._w = s * h + this._w * u, this._x = n * h + this._x * u, this._y = r * h + this._y * u, this._z = i * h + this._z * u, this._onChangeCallback(), this
      }
      slerpQuaternions(t, e, n) {
        this.copy(t).slerp(e, n)
      }
      equals(t) {
        return t._x === this._x && t._y === this._y && t._z === this._z && t._w === this._w
      }
      fromArray(t, e = 0) {
        return this._x = t[e], this._y = t[e + 1], this._z = t[e + 2], this._w = t[e + 3], this._onChangeCallback(), this
      }
      toArray(t = [], e = 0) {
        return t[e] = this._x, t[e + 1] = this._y, t[e + 2] = this._z, t[e + 3] = this._w, t
      }
      fromBufferAttribute(t, e) {
        return this._x = t.getX(e), this._y = t.getY(e), this._z = t.getZ(e), this._w = t.getW(e), this
      }
      _onChange(t) {
        return this._onChangeCallback = t, this
      }
      _onChangeCallback() {}
    }
    exports.Quaternion = fr, fr.prototype.isQuaternion = !0;
    class gr {
      constructor(t = 0, e = 0, n = 0) {
        this.x = t, this.y = e, this.z = n
      }
      set(t, e, n) {
        return void 0 === n && (n = this.z), this.x = t, this.y = e, this.z = n, this
      }
      setScalar(t) {
        return this.x = t, this.y = t, this.z = t, this
      }
      setX(t) {
        return this.x = t, this
      }
      setY(t) {
        return this.y = t, this
      }
      setZ(t) {
        return this.z = t, this
      }
      setComponent(t, e) {
        switch (t) {
          case 0:
            this.x = e;
            break;
          case 1:
            this.y = e;
            break;
          case 2:
            this.z = e;
            break;
          default:
            throw new Error("index is out of range: " + t)
        }
        return this
      }
      getComponent(t) {
        switch (t) {
          case 0:
            return this.x;
          case 1:
            return this.y;
          case 2:
            return this.z;
          default:
            throw new Error("index is out of range: " + t)
        }
      }
      clone() {
        return new this.constructor(this.x, this.y, this.z)
      }
      copy(t) {
        return this.x = t.x, this.y = t.y, this.z = t.z, this
      }
      add(t, e) {
        return void 0 !== e ? (console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(t, e)) : (this.x += t.x, this.y += t.y, this.z += t.z, this)
      }
      addScalar(t) {
        return this.x += t, this.y += t, this.z += t, this
      }
      addVectors(t, e) {
        return this.x = t.x + e.x, this.y = t.y + e.y, this.z = t.z + e.z, this
      }
      addScaledVector(t, e) {
        return this.x += t.x * e, this.y += t.y * e, this.z += t.z * e, this
      }
      sub(t, e) {
        return void 0 !== e ? (console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(t, e)) : (this.x -= t.x, this.y -= t.y, this.z -= t.z, this)
      }
      subScalar(t) {
        return this.x -= t, this.y -= t, this.z -= t, this
      }
      subVectors(t, e) {
        return this.x = t.x - e.x, this.y = t.y - e.y, this.z = t.z - e.z, this
      }
      multiply(t, e) {
        return void 0 !== e ? (console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."), this.multiplyVectors(t, e)) : (this.x *= t.x, this.y *= t.y, this.z *= t.z, this)
      }
      multiplyScalar(t) {
        return this.x *= t, this.y *= t, this.z *= t, this
      }
      multiplyVectors(t, e) {
        return this.x = t.x * e.x, this.y = t.y * e.y, this.z = t.z * e.z, this
      }
      applyEuler(t) {
        return t && t.isEuler || console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."), this.applyQuaternion(vr.setFromEuler(t))
      }
      applyAxisAngle(t, e) {
        return this.applyQuaternion(vr.setFromAxisAngle(t, e))
      }
      applyMatrix3(t) {
        const e = this.x,
          n = this.y,
          r = this.z,
          i = t.elements;
        return this.x = i[0] * e + i[3] * n + i[6] * r, this.y = i[1] * e + i[4] * n + i[7] * r, this.z = i[2] * e + i[5] * n + i[8] * r, this
      }
      applyNormalMatrix(t) {
        return this.applyMatrix3(t).normalize()
      }
      applyMatrix4(t) {
        const e = this.x,
          n = this.y,
          r = this.z,
          i = t.elements,
          s = 1 / (i[3] * e + i[7] * n + i[11] * r + i[15]);
        return this.x = (i[0] * e + i[4] * n + i[8] * r + i[12]) * s, this.y = (i[1] * e + i[5] * n + i[9] * r + i[13]) * s, this.z = (i[2] * e + i[6] * n + i[10] * r + i[14]) * s, this
      }
      applyQuaternion(t) {
        const e = this.x,
          n = this.y,
          r = this.z,
          i = t.x,
          s = t.y,
          o = t.z,
          a = t.w,
          l = a * e + s * r - o * n,
          c = a * n + o * e - i * r,
          h = a * r + i * n - s * e,
          u = -i * e - s * n - o * r;
        return this.x = l * a + u * -i + c * -o - h * -s, this.y = c * a + u * -s + h * -i - l * -o, this.z = h * a + u * -o + l * -s - c * -i, this
      }
      project(t) {
        return this.applyMatrix4(t.matrixWorldInverse).applyMatrix4(t.projectionMatrix)
      }
      unproject(t) {
        return this.applyMatrix4(t.projectionMatrixInverse).applyMatrix4(t.matrixWorld)
      }
      transformDirection(t) {
        const e = this.x,
          n = this.y,
          r = this.z,
          i = t.elements;
        return this.x = i[0] * e + i[4] * n + i[8] * r, this.y = i[1] * e + i[5] * n + i[9] * r, this.z = i[2] * e + i[6] * n + i[10] * r, this.normalize()
      }
      divide(t) {
        return this.x /= t.x, this.y /= t.y, this.z /= t.z, this
      }
      divideScalar(t) {
        return this.multiplyScalar(1 / t)
      }
      min(t) {
        return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this.z = Math.min(this.z, t.z), this
      }
      max(t) {
        return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this.z = Math.max(this.z, t.z), this
      }
      clamp(t, e) {
        return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this.z = Math.max(t.z, Math.min(e.z, this.z)), this
      }
      clampScalar(t, e) {
        return this.x = Math.max(t, Math.min(e, this.x)), this.y = Math.max(t, Math.min(e, this.y)), this.z = Math.max(t, Math.min(e, this.z)), this
      }
      clampLength(t, e) {
        const n = this.length();
        return this.divideScalar(n || 1).multiplyScalar(Math.max(t, Math.min(e, n)))
      }
      floor() {
        return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this
      }
      ceil() {
        return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this
      }
      round() {
        return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this
      }
      roundToZero() {
        return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this
      }
      negate() {
        return this.x = -this.x, this.y = -this.y, this.z = -this.z, this
      }
      dot(t) {
        return this.x * t.x + this.y * t.y + this.z * t.z
      }
      lengthSq() {
        return this.x * this.x + this.y * this.y + this.z * this.z
      }
      length() {
        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
      }
      manhattanLength() {
        return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z)
      }
      normalize() {
        return this.divideScalar(this.length() || 1)
      }
      setLength(t) {
        return this.normalize().multiplyScalar(t)
      }
      lerp(t, e) {
        return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this.z += (t.z - this.z) * e, this
      }
      lerpVectors(t, e, n) {
        return this.x = t.x + (e.x - t.x) * n, this.y = t.y + (e.y - t.y) * n, this.z = t.z + (e.z - t.z) * n, this
      }
      cross(t, e) {
        return void 0 !== e ? (console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."), this.crossVectors(t, e)) : this.crossVectors(this, t)
      }
      crossVectors(t, e) {
        const n = t.x,
          r = t.y,
          i = t.z,
          s = e.x,
          o = e.y,
          a = e.z;
        return this.x = r * a - i * o, this.y = i * s - n * a, this.z = n * o - r * s, this
      }
      projectOnVector(t) {
        const e = t.lengthSq();
        if (0 === e) return this.set(0, 0, 0);
        const n = t.dot(this) / e;
        return this.copy(t).multiplyScalar(n)
      }
      projectOnPlane(t) {
        return xr.copy(this).projectOnVector(t), this.sub(xr)
      }
      reflect(t) {
        return this.sub(xr.copy(t).multiplyScalar(2 * this.dot(t)))
      }
      angleTo(t) {
        const e = Math.sqrt(this.lengthSq() * t.lengthSq());
        if (0 === e) return Math.PI / 2;
        const n = this.dot(t) / e;
        return Math.acos(On(n, -1, 1))
      }
      distanceTo(t) {
        return Math.sqrt(this.distanceToSquared(t))
      }
      distanceToSquared(t) {
        const e = this.x - t.x,
          n = this.y - t.y,
          r = this.z - t.z;
        return e * e + n * n + r * r
      }
      manhattanDistanceTo(t) {
        return Math.abs(this.x - t.x) + Math.abs(this.y - t.y) + Math.abs(this.z - t.z)
      }
      setFromSpherical(t) {
        return this.setFromSphericalCoords(t.radius, t.phi, t.theta)
      }
      setFromSphericalCoords(t, e, n) {
        const r = Math.sin(e) * t;
        return this.x = r * Math.sin(n), this.y = Math.cos(e) * t, this.z = r * Math.cos(n), this
      }
      setFromCylindrical(t) {
        return this.setFromCylindricalCoords(t.radius, t.theta, t.y)
      }
      setFromCylindricalCoords(t, e, n) {
        return this.x = t * Math.sin(e), this.y = n, this.z = t * Math.cos(e), this
      }
      setFromMatrixPosition(t) {
        const e = t.elements;
        return this.x = e[12], this.y = e[13], this.z = e[14], this
      }
      setFromMatrixScale(t) {
        const e = this.setFromMatrixColumn(t, 0).length(),
          n = this.setFromMatrixColumn(t, 1).length(),
          r = this.setFromMatrixColumn(t, 2).length();
        return this.x = e, this.y = n, this.z = r, this
      }
      setFromMatrixColumn(t, e) {
        return this.fromArray(t.elements, 4 * e)
      }
      setFromMatrix3Column(t, e) {
        return this.fromArray(t.elements, 3 * e)
      }
      equals(t) {
        return t.x === this.x && t.y === this.y && t.z === this.z
      }
      fromArray(t, e = 0) {
        return this.x = t[e], this.y = t[e + 1], this.z = t[e + 2], this
      }
      toArray(t = [], e = 0) {
        return t[e] = this.x, t[e + 1] = this.y, t[e + 2] = this.z, t
      }
      fromBufferAttribute(t, e, n) {
        return void 0 !== n && console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute()."), this.x = t.getX(e), this.y = t.getY(e), this.z = t.getZ(e), this
      }
      random() {
        return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this
      }
    }
    exports.Vector3 = gr, gr.prototype.isVector3 = !0;
    const xr = new gr,
      vr = new fr;
    class yr {
      constructor(t = new gr(1 / 0, 1 / 0, 1 / 0), e = new gr(-1 / 0, -1 / 0, -1 / 0)) {
        this.min = t, this.max = e
      }
      set(t, e) {
        return this.min.copy(t), this.max.copy(e), this
      }
      setFromArray(t) {
        let e = 1 / 0,
          n = 1 / 0,
          r = 1 / 0,
          i = -1 / 0,
          s = -1 / 0,
          o = -1 / 0;
        for (let a = 0, l = t.length; a < l; a += 3) {
          const l = t[a],
            c = t[a + 1],
            h = t[a + 2];
          l < e && (e = l), c < n && (n = c), h < r && (r = h), l > i && (i = l), c > s && (s = c), h > o && (o = h)
        }
        return this.min.set(e, n, r), this.max.set(i, s, o), this
      }
      setFromBufferAttribute(t) {
        let e = 1 / 0,
          n = 1 / 0,
          r = 1 / 0,
          i = -1 / 0,
          s = -1 / 0,
          o = -1 / 0;
        for (let a = 0, l = t.count; a < l; a++) {
          const l = t.getX(a),
            c = t.getY(a),
            h = t.getZ(a);
          l < e && (e = l), c < n && (n = c), h < r && (r = h), l > i && (i = l), c > s && (s = c), h > o && (o = h)
        }
        return this.min.set(e, n, r), this.max.set(i, s, o), this
      }
      setFromPoints(t) {
        this.makeEmpty();
        for (let e = 0, n = t.length; e < n; e++) this.expandByPoint(t[e]);
        return this
      }
      setFromCenterAndSize(t, e) {
        const n = br.copy(e).multiplyScalar(.5);
        return this.min.copy(t).sub(n), this.max.copy(t).add(n), this
      }
      setFromObject(t) {
        return this.makeEmpty(), this.expandByObject(t)
      }
      clone() {
        return (new this.constructor).copy(this)
      }
      copy(t) {
        return this.min.copy(t.min), this.max.copy(t.max), this
      }
      makeEmpty() {
        return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this
      }
      isEmpty() {
        return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z
      }
      getCenter(t) {
        return void 0 === t && (console.warn("THREE.Box3: .getCenter() target is now required"), t = new gr), this.isEmpty() ? t.set(0, 0, 0) : t.addVectors(this.min, this.max).multiplyScalar(.5)
      }
      getSize(t) {
        return void 0 === t && (console.warn("THREE.Box3: .getSize() target is now required"), t = new gr), this.isEmpty() ? t.set(0, 0, 0) : t.subVectors(this.max, this.min)
      }
      expandByPoint(t) {
        return this.min.min(t), this.max.max(t), this
      }
      expandByVector(t) {
        return this.min.sub(t), this.max.add(t), this
      }
      expandByScalar(t) {
        return this.min.addScalar(-t), this.max.addScalar(t), this
      }
      expandByObject(t) {
        t.updateWorldMatrix(!1, !1);
        const e = t.geometry;
        void 0 !== e && (null === e.boundingBox && e.computeBoundingBox(), wr.copy(e.boundingBox), wr.applyMatrix4(t.matrixWorld), this.union(wr));
        const n = t.children;
        for (let r = 0, i = n.length; r < i; r++) this.expandByObject(n[r]);
        return this
      }
      containsPoint(t) {
        return !(t.x < this.min.x || t.x > this.max.x || t.y < this.min.y || t.y > this.max.y || t.z < this.min.z || t.z > this.max.z)
      }
      containsBox(t) {
        return this.min.x <= t.min.x && t.max.x <= this.max.x && this.min.y <= t.min.y && t.max.y <= this.max.y && this.min.z <= t.min.z && t.max.z <= this.max.z
      }
      getParameter(t, e) {
        return void 0 === e && (console.warn("THREE.Box3: .getParameter() target is now required"), e = new gr), e.set((t.x - this.min.x) / (this.max.x - this.min.x), (t.y - this.min.y) / (this.max.y - this.min.y), (t.z - this.min.z) / (this.max.z - this.min.z))
      }
      intersectsBox(t) {
        return !(t.max.x < this.min.x || t.min.x > this.max.x || t.max.y < this.min.y || t.min.y > this.max.y || t.max.z < this.min.z || t.min.z > this.max.z)
      }
      intersectsSphere(t) {
        return this.clampPoint(t.center, br), br.distanceToSquared(t.center) <= t.radius * t.radius
      }
      intersectsPlane(t) {
        let e, n;
        return t.normal.x > 0 ? (e = t.normal.x * this.min.x, n = t.normal.x * this.max.x) : (e = t.normal.x * this.max.x, n = t.normal.x * this.min.x), t.normal.y > 0 ? (e += t.normal.y * this.min.y, n += t.normal.y * this.max.y) : (e += t.normal.y * this.max.y, n += t.normal.y * this.min.y), t.normal.z > 0 ? (e += t.normal.z * this.min.z, n += t.normal.z * this.max.z) : (e += t.normal.z * this.max.z, n += t.normal.z * this.min.z), e <= -t.constant && n >= -t.constant
      }
      intersectsTriangle(t) {
        if (this.isEmpty()) return !1;
        this.getCenter(Rr), Cr.subVectors(this.max, Rr), Mr.subVectors(t.a, Rr), Sr.subVectors(t.b, Rr), Tr.subVectors(t.c, Rr), Er.subVectors(Sr, Mr), Ar.subVectors(Tr, Sr), Lr.subVectors(Mr, Tr);
        let e = [0, -Er.z, Er.y, 0, -Ar.z, Ar.y, 0, -Lr.z, Lr.y, Er.z, 0, -Er.x, Ar.z, 0, -Ar.x, Lr.z, 0, -Lr.x, -Er.y, Er.x, 0, -Ar.y, Ar.x, 0, -Lr.y, Lr.x, 0];
        return !!Ir(e, Mr, Sr, Tr, Cr) && (!!Ir(e = [1, 0, 0, 0, 1, 0, 0, 0, 1], Mr, Sr, Tr, Cr) && (Pr.crossVectors(Er, Ar), Ir(e = [Pr.x, Pr.y, Pr.z], Mr, Sr, Tr, Cr)))
      }
      clampPoint(t, e) {
        return void 0 === e && (console.warn("THREE.Box3: .clampPoint() target is now required"), e = new gr), e.copy(t).clamp(this.min, this.max)
      }
      distanceToPoint(t) {
        return br.copy(t).clamp(this.min, this.max).sub(t).length()
      }
      getBoundingSphere(t) {
        return void 0 === t && console.error("THREE.Box3: .getBoundingSphere() target is now required"), this.getCenter(t.center), t.radius = .5 * this.getSize(br).length(), t
      }
      intersect(t) {
        return this.min.max(t.min), this.max.min(t.max), this.isEmpty() && this.makeEmpty(), this
      }
      union(t) {
        return this.min.min(t.min), this.max.max(t.max), this
      }
      applyMatrix4(t) {
        return this.isEmpty() ? this : (_r[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(t), _r[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(t), _r[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(t), _r[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(t), _r[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(t), _r[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(t), _r[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(t), _r[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(t), this.setFromPoints(_r), this)
      }
      translate(t) {
        return this.min.add(t), this.max.add(t), this
      }
      equals(t) {
        return t.min.equals(this.min) && t.max.equals(this.max)
      }
    }
    exports.Box3 = yr, yr.prototype.isBox3 = !0;
    const _r = [new gr, new gr, new gr, new gr, new gr, new gr, new gr, new gr],
      br = new gr,
      wr = new yr,
      Mr = new gr,
      Sr = new gr,
      Tr = new gr,
      Er = new gr,
      Ar = new gr,
      Lr = new gr,
      Rr = new gr,
      Cr = new gr,
      Pr = new gr,
      Dr = new gr;

    function Ir(t, e, n, r, i) {
      for (let s = 0, o = t.length - 3; s <= o; s += 3) {
        Dr.fromArray(t, s);
        const o = i.x * Math.abs(Dr.x) + i.y * Math.abs(Dr.y) + i.z * Math.abs(Dr.z),
          a = e.dot(Dr),
          l = n.dot(Dr),
          c = r.dot(Dr);
        if (Math.max(-Math.max(a, l, c), Math.min(a, l, c)) > o) return !1
      }
      return !0
    }
    const Br = new yr,
      Nr = new gr,
      Fr = new gr,
      zr = new gr;
    class Gr {
      constructor(t = new gr, e = -1) {
        this.center = t, this.radius = e
      }
      set(t, e) {
        return this.center.copy(t), this.radius = e, this
      }
      setFromPoints(t, e) {
        const n = this.center;
        void 0 !== e ? n.copy(e) : Br.setFromPoints(t).getCenter(n);
        let r = 0;
        for (let i = 0, s = t.length; i < s; i++) r = Math.max(r, n.distanceToSquared(t[i]));
        return this.radius = Math.sqrt(r), this
      }
      copy(t) {
        return this.center.copy(t.center), this.radius = t.radius, this
      }
      isEmpty() {
        return this.radius < 0
      }
      makeEmpty() {
        return this.center.set(0, 0, 0), this.radius = -1, this
      }
      containsPoint(t) {
        return t.distanceToSquared(this.center) <= this.radius * this.radius
      }
      distanceToPoint(t) {
        return t.distanceTo(this.center) - this.radius
      }
      intersectsSphere(t) {
        const e = this.radius + t.radius;
        return t.center.distanceToSquared(this.center) <= e * e
      }
      intersectsBox(t) {
        return t.intersectsSphere(this)
      }
      intersectsPlane(t) {
        return Math.abs(t.distanceToPoint(this.center)) <= this.radius
      }
      clampPoint(t, e) {
        const n = this.center.distanceToSquared(t);
        return void 0 === e && (console.warn("THREE.Sphere: .clampPoint() target is now required"), e = new gr), e.copy(t), n > this.radius * this.radius && (e.sub(this.center).normalize(), e.multiplyScalar(this.radius).add(this.center)), e
      }
      getBoundingBox(t) {
        return void 0 === t && (console.warn("THREE.Sphere: .getBoundingBox() target is now required"), t = new yr), this.isEmpty() ? (t.makeEmpty(), t) : (t.set(this.center, this.center), t.expandByScalar(this.radius), t)
      }
      applyMatrix4(t) {
        return this.center.applyMatrix4(t), this.radius = this.radius * t.getMaxScaleOnAxis(), this
      }
      translate(t) {
        return this.center.add(t), this
      }
      expandByPoint(t) {
        zr.subVectors(t, this.center);
        const e = zr.lengthSq();
        if (e > this.radius * this.radius) {
          const t = Math.sqrt(e),
            n = .5 * (t - this.radius);
          this.center.add(zr.multiplyScalar(n / t)), this.radius += n
        }
        return this
      }
      union(t) {
        return Fr.subVectors(t.center, this.center).normalize().multiplyScalar(t.radius), this.expandByPoint(Nr.copy(t.center).add(Fr)), this.expandByPoint(Nr.copy(t.center).sub(Fr)), this
      }
      equals(t) {
        return t.center.equals(this.center) && t.radius === this.radius
      }
      clone() {
        return (new this.constructor).copy(this)
      }
    }
    exports.Sphere = Gr;
    const Or = new gr,
      Hr = new gr,
      Ur = new gr,
      kr = new gr,
      Vr = new gr,
      Wr = new gr,
      jr = new gr;
    class qr {
      constructor(t = new gr, e = new gr(0, 0, -1)) {
        this.origin = t, this.direction = e
      }
      set(t, e) {
        return this.origin.copy(t), this.direction.copy(e), this
      }
      copy(t) {
        return this.origin.copy(t.origin), this.direction.copy(t.direction), this
      }
      at(t, e) {
        return void 0 === e && (console.warn("THREE.Ray: .at() target is now required"), e = new gr), e.copy(this.direction).multiplyScalar(t).add(this.origin)
      }
      lookAt(t) {
        return this.direction.copy(t).sub(this.origin).normalize(), this
      }
      recast(t) {
        return this.origin.copy(this.at(t, Or)), this
      }
      closestPointToPoint(t, e) {
        void 0 === e && (console.warn("THREE.Ray: .closestPointToPoint() target is now required"), e = new gr), e.subVectors(t, this.origin);
        const n = e.dot(this.direction);
        return n < 0 ? e.copy(this.origin) : e.copy(this.direction).multiplyScalar(n).add(this.origin)
      }
      distanceToPoint(t) {
        return Math.sqrt(this.distanceSqToPoint(t))
      }
      distanceSqToPoint(t) {
        const e = Or.subVectors(t, this.origin).dot(this.direction);
        return e < 0 ? this.origin.distanceToSquared(t) : (Or.copy(this.direction).multiplyScalar(e).add(this.origin), Or.distanceToSquared(t))
      }
      distanceSqToSegment(t, e, n, r) {
        Hr.copy(t).add(e).multiplyScalar(.5), Ur.copy(e).sub(t).normalize(), kr.copy(this.origin).sub(Hr);
        const i = .5 * t.distanceTo(e),
          s = -this.direction.dot(Ur),
          o = kr.dot(this.direction),
          a = -kr.dot(Ur),
          l = kr.lengthSq(),
          c = Math.abs(1 - s * s);
        let h, u, p, d;
        if (c > 0)
          if (u = s * o - a, d = i * c, (h = s * a - o) >= 0)
            if (u >= -d)
              if (u <= d) {
                const t = 1 / c;
                p = (h *= t) * (h + s * (u *= t) + 2 * o) + u * (s * h + u + 2 * a) + l
              } else u = i, p = -(h = Math.max(0, -(s * u + o))) * h + u * (u + 2 * a) + l;
        else u = -i, p = -(h = Math.max(0, -(s * u + o))) * h + u * (u + 2 * a) + l;
        else u <= -d ? p = -(h = Math.max(0, -(-s * i + o))) * h + (u = h > 0 ? -i : Math.min(Math.max(-i, -a), i)) * (u + 2 * a) + l : u <= d ? (h = 0, p = (u = Math.min(Math.max(-i, -a), i)) * (u + 2 * a) + l) : p = -(h = Math.max(0, -(s * i + o))) * h + (u = h > 0 ? i : Math.min(Math.max(-i, -a), i)) * (u + 2 * a) + l;
        else u = s > 0 ? -i : i, p = -(h = Math.max(0, -(s * u + o))) * h + u * (u + 2 * a) + l;
        return n && n.copy(this.direction).multiplyScalar(h).add(this.origin), r && r.copy(Ur).multiplyScalar(u).add(Hr), p
      }
      intersectSphere(t, e) {
        Or.subVectors(t.center, this.origin);
        const n = Or.dot(this.direction),
          r = Or.dot(Or) - n * n,
          i = t.radius * t.radius;
        if (r > i) return null;
        const s = Math.sqrt(i - r),
          o = n - s,
          a = n + s;
        return o < 0 && a < 0 ? null : o < 0 ? this.at(a, e) : this.at(o, e)
      }
      intersectsSphere(t) {
        return this.distanceSqToPoint(t.center) <= t.radius * t.radius
      }
      distanceToPlane(t) {
        const e = t.normal.dot(this.direction);
        if (0 === e) return 0 === t.distanceToPoint(this.origin) ? 0 : null;
        const n = -(this.origin.dot(t.normal) + t.constant) / e;
        return n >= 0 ? n : null
      }
      intersectPlane(t, e) {
        const n = this.distanceToPlane(t);
        return null === n ? null : this.at(n, e)
      }
      intersectsPlane(t) {
        const e = t.distanceToPoint(this.origin);
        return 0 === e || t.normal.dot(this.direction) * e < 0
      }
      intersectBox(t, e) {
        let n, r, i, s, o, a;
        const l = 1 / this.direction.x,
          c = 1 / this.direction.y,
          h = 1 / this.direction.z,
          u = this.origin;
        return l >= 0 ? (n = (t.min.x - u.x) * l, r = (t.max.x - u.x) * l) : (n = (t.max.x - u.x) * l, r = (t.min.x - u.x) * l), c >= 0 ? (i = (t.min.y - u.y) * c, s = (t.max.y - u.y) * c) : (i = (t.max.y - u.y) * c, s = (t.min.y - u.y) * c), n > s || i > r ? null : ((i > n || n != n) && (n = i), (s < r || r != r) && (r = s), h >= 0 ? (o = (t.min.z - u.z) * h, a = (t.max.z - u.z) * h) : (o = (t.max.z - u.z) * h, a = (t.min.z - u.z) * h), n > a || o > r ? null : ((o > n || n != n) && (n = o), (a < r || r != r) && (r = a), r < 0 ? null : this.at(n >= 0 ? n : r, e)))
      }
      intersectsBox(t) {
        return null !== this.intersectBox(t, Or)
      }
      intersectTriangle(t, e, n, r, i) {
        Vr.subVectors(e, t), Wr.subVectors(n, t), jr.crossVectors(Vr, Wr);
        let s, o = this.direction.dot(jr);
        if (o > 0) {
          if (r) return null;
          s = 1
        } else {
          if (!(o < 0)) return null;
          s = -1, o = -o
        }
        kr.subVectors(this.origin, t);
        const a = s * this.direction.dot(Wr.crossVectors(kr, Wr));
        if (a < 0) return null;
        const l = s * this.direction.dot(Vr.cross(kr));
        if (l < 0) return null;
        if (a + l > o) return null;
        const c = -s * kr.dot(jr);
        return c < 0 ? null : this.at(c / o, i)
      }
      applyMatrix4(t) {
        return this.origin.applyMatrix4(t), this.direction.transformDirection(t), this
      }
      equals(t) {
        return t.origin.equals(this.origin) && t.direction.equals(this.direction)
      }
      clone() {
        return (new this.constructor).copy(this)
      }
    }
    exports.Ray = qr;
    class Xr {
      constructor() {
        this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], arguments.length > 0 && console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.")
      }
      set(t, e, n, r, i, s, o, a, l, c, h, u, p, d, m, f) {
        const g = this.elements;
        return g[0] = t, g[4] = e, g[8] = n, g[12] = r, g[1] = i, g[5] = s, g[9] = o, g[13] = a, g[2] = l, g[6] = c, g[10] = h, g[14] = u, g[3] = p, g[7] = d, g[11] = m, g[15] = f, this
      }
      identity() {
        return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
      }
      clone() {
        return (new Xr).fromArray(this.elements)
      }
      copy(t) {
        const e = this.elements,
          n = t.elements;
        return e[0] = n[0], e[1] = n[1], e[2] = n[2], e[3] = n[3], e[4] = n[4], e[5] = n[5], e[6] = n[6], e[7] = n[7], e[8] = n[8], e[9] = n[9], e[10] = n[10], e[11] = n[11], e[12] = n[12], e[13] = n[13], e[14] = n[14], e[15] = n[15], this
      }
      copyPosition(t) {
        const e = this.elements,
          n = t.elements;
        return e[12] = n[12], e[13] = n[13], e[14] = n[14], this
      }
      setFromMatrix3(t) {
        const e = t.elements;
        return this.set(e[0], e[3], e[6], 0, e[1], e[4], e[7], 0, e[2], e[5], e[8], 0, 0, 0, 0, 1), this
      }
      extractBasis(t, e, n) {
        return t.setFromMatrixColumn(this, 0), e.setFromMatrixColumn(this, 1), n.setFromMatrixColumn(this, 2), this
      }
      makeBasis(t, e, n) {
        return this.set(t.x, e.x, n.x, 0, t.y, e.y, n.y, 0, t.z, e.z, n.z, 0, 0, 0, 0, 1), this
      }
      extractRotation(t) {
        const e = this.elements,
          n = t.elements,
          r = 1 / Yr.setFromMatrixColumn(t, 0).length(),
          i = 1 / Yr.setFromMatrixColumn(t, 1).length(),
          s = 1 / Yr.setFromMatrixColumn(t, 2).length();
        return e[0] = n[0] * r, e[1] = n[1] * r, e[2] = n[2] * r, e[3] = 0, e[4] = n[4] * i, e[5] = n[5] * i, e[6] = n[6] * i, e[7] = 0, e[8] = n[8] * s, e[9] = n[9] * s, e[10] = n[10] * s, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, this
      }
      makeRotationFromEuler(t) {
        t && t.isEuler || console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");
        const e = this.elements,
          n = t.x,
          r = t.y,
          i = t.z,
          s = Math.cos(n),
          o = Math.sin(n),
          a = Math.cos(r),
          l = Math.sin(r),
          c = Math.cos(i),
          h = Math.sin(i);
        if ("XYZ" === t.order) {
          const t = s * c,
            n = s * h,
            r = o * c,
            i = o * h;
          e[0] = a * c, e[4] = -a * h, e[8] = l, e[1] = n + r * l, e[5] = t - i * l, e[9] = -o * a, e[2] = i - t * l, e[6] = r + n * l, e[10] = s * a
        } else if ("YXZ" === t.order) {
          const t = a * c,
            n = a * h,
            r = l * c,
            i = l * h;
          e[0] = t + i * o, e[4] = r * o - n, e[8] = s * l, e[1] = s * h, e[5] = s * c, e[9] = -o, e[2] = n * o - r, e[6] = i + t * o, e[10] = s * a
        } else if ("ZXY" === t.order) {
          const t = a * c,
            n = a * h,
            r = l * c,
            i = l * h;
          e[0] = t - i * o, e[4] = -s * h, e[8] = r + n * o, e[1] = n + r * o, e[5] = s * c, e[9] = i - t * o, e[2] = -s * l, e[6] = o, e[10] = s * a
        } else if ("ZYX" === t.order) {
          const t = s * c,
            n = s * h,
            r = o * c,
            i = o * h;
          e[0] = a * c, e[4] = r * l - n, e[8] = t * l + i, e[1] = a * h, e[5] = i * l + t, e[9] = n * l - r, e[2] = -l, e[6] = o * a, e[10] = s * a
        } else if ("YZX" === t.order) {
          const t = s * a,
            n = s * l,
            r = o * a,
            i = o * l;
          e[0] = a * c, e[4] = i - t * h, e[8] = r * h + n, e[1] = h, e[5] = s * c, e[9] = -o * c, e[2] = -l * c, e[6] = n * h + r, e[10] = t - i * h
        } else if ("XZY" === t.order) {
          const t = s * a,
            n = s * l,
            r = o * a,
            i = o * l;
          e[0] = a * c, e[4] = -h, e[8] = l * c, e[1] = t * h + i, e[5] = s * c, e[9] = n * h - r, e[2] = r * h - n, e[6] = o * c, e[10] = i * h + t
        }
        return e[3] = 0, e[7] = 0, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, this
      }
      makeRotationFromQuaternion(t) {
        return this.compose(Jr, t, Qr)
      }
      lookAt(t, e, n) {
        const r = this.elements;
        return ti.subVectors(t, e), 0 === ti.lengthSq() && (ti.z = 1), ti.normalize(), Kr.crossVectors(n, ti), 0 === Kr.lengthSq() && (1 === Math.abs(n.z) ? ti.x += 1e-4 : ti.z += 1e-4, ti.normalize(), Kr.crossVectors(n, ti)), Kr.normalize(), $r.crossVectors(ti, Kr), r[0] = Kr.x, r[4] = $r.x, r[8] = ti.x, r[1] = Kr.y, r[5] = $r.y, r[9] = ti.y, r[2] = Kr.z, r[6] = $r.z, r[10] = ti.z, this
      }
      multiply(t, e) {
        return void 0 !== e ? (console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."), this.multiplyMatrices(t, e)) : this.multiplyMatrices(this, t)
      }
      premultiply(t) {
        return this.multiplyMatrices(t, this)
      }
      multiplyMatrices(t, e) {
        const n = t.elements,
          r = e.elements,
          i = this.elements,
          s = n[0],
          o = n[4],
          a = n[8],
          l = n[12],
          c = n[1],
          h = n[5],
          u = n[9],
          p = n[13],
          d = n[2],
          m = n[6],
          f = n[10],
          g = n[14],
          x = n[3],
          v = n[7],
          y = n[11],
          _ = n[15],
          b = r[0],
          w = r[4],
          M = r[8],
          S = r[12],
          T = r[1],
          E = r[5],
          A = r[9],
          L = r[13],
          R = r[2],
          C = r[6],
          P = r[10],
          D = r[14],
          I = r[3],
          B = r[7],
          N = r[11],
          F = r[15];
        return i[0] = s * b + o * T + a * R + l * I, i[4] = s * w + o * E + a * C + l * B, i[8] = s * M + o * A + a * P + l * N, i[12] = s * S + o * L + a * D + l * F, i[1] = c * b + h * T + u * R + p * I, i[5] = c * w + h * E + u * C + p * B, i[9] = c * M + h * A + u * P + p * N, i[13] = c * S + h * L + u * D + p * F, i[2] = d * b + m * T + f * R + g * I, i[6] = d * w + m * E + f * C + g * B, i[10] = d * M + m * A + f * P + g * N, i[14] = d * S + m * L + f * D + g * F, i[3] = x * b + v * T + y * R + _ * I, i[7] = x * w + v * E + y * C + _ * B, i[11] = x * M + v * A + y * P + _ * N, i[15] = x * S + v * L + y * D + _ * F, this
      }
      multiplyScalar(t) {
        const e = this.elements;
        return e[0] *= t, e[4] *= t, e[8] *= t, e[12] *= t, e[1] *= t, e[5] *= t, e[9] *= t, e[13] *= t, e[2] *= t, e[6] *= t, e[10] *= t, e[14] *= t, e[3] *= t, e[7] *= t, e[11] *= t, e[15] *= t, this
      }
      determinant() {
        const t = this.elements,
          e = t[0],
          n = t[4],
          r = t[8],
          i = t[12],
          s = t[1],
          o = t[5],
          a = t[9],
          l = t[13],
          c = t[2],
          h = t[6],
          u = t[10],
          p = t[14];
        return t[3] * (+i * a * h - r * l * h - i * o * u + n * l * u + r * o * p - n * a * p) + t[7] * (+e * a * p - e * l * u + i * s * u - r * s * p + r * l * c - i * a * c) + t[11] * (+e * l * h - e * o * p - i * s * h + n * s * p + i * o * c - n * l * c) + t[15] * (-r * o * c - e * a * h + e * o * u + r * s * h - n * s * u + n * a * c)
      }
      transpose() {
        const t = this.elements;
        let e;
        return e = t[1], t[1] = t[4], t[4] = e, e = t[2], t[2] = t[8], t[8] = e, e = t[6], t[6] = t[9], t[9] = e, e = t[3], t[3] = t[12], t[12] = e, e = t[7], t[7] = t[13], t[13] = e, e = t[11], t[11] = t[14], t[14] = e, this
      }
      setPosition(t, e, n) {
        const r = this.elements;
        return t.isVector3 ? (r[12] = t.x, r[13] = t.y, r[14] = t.z) : (r[12] = t, r[13] = e, r[14] = n), this
      }
      invert() {
        const t = this.elements,
          e = t[0],
          n = t[1],
          r = t[2],
          i = t[3],
          s = t[4],
          o = t[5],
          a = t[6],
          l = t[7],
          c = t[8],
          h = t[9],
          u = t[10],
          p = t[11],
          d = t[12],
          m = t[13],
          f = t[14],
          g = t[15],
          x = h * f * l - m * u * l + m * a * p - o * f * p - h * a * g + o * u * g,
          v = d * u * l - c * f * l - d * a * p + s * f * p + c * a * g - s * u * g,
          y = c * m * l - d * h * l + d * o * p - s * m * p - c * o * g + s * h * g,
          _ = d * h * a - c * m * a - d * o * u + s * m * u + c * o * f - s * h * f,
          b = e * x + n * v + r * y + i * _;
        if (0 === b) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
        const w = 1 / b;
        return t[0] = x * w, t[1] = (m * u * i - h * f * i - m * r * p + n * f * p + h * r * g - n * u * g) * w, t[2] = (o * f * i - m * a * i + m * r * l - n * f * l - o * r * g + n * a * g) * w, t[3] = (h * a * i - o * u * i - h * r * l + n * u * l + o * r * p - n * a * p) * w, t[4] = v * w, t[5] = (c * f * i - d * u * i + d * r * p - e * f * p - c * r * g + e * u * g) * w, t[6] = (d * a * i - s * f * i - d * r * l + e * f * l + s * r * g - e * a * g) * w, t[7] = (s * u * i - c * a * i + c * r * l - e * u * l - s * r * p + e * a * p) * w, t[8] = y * w, t[9] = (d * h * i - c * m * i - d * n * p + e * m * p + c * n * g - e * h * g) * w, t[10] = (s * m * i - d * o * i + d * n * l - e * m * l - s * n * g + e * o * g) * w, t[11] = (c * o * i - s * h * i - c * n * l + e * h * l + s * n * p - e * o * p) * w, t[12] = _ * w, t[13] = (c * m * r - d * h * r + d * n * u - e * m * u - c * n * f + e * h * f) * w, t[14] = (d * o * r - s * m * r - d * n * a + e * m * a + s * n * f - e * o * f) * w, t[15] = (s * h * r - c * o * r + c * n * a - e * h * a - s * n * u + e * o * u) * w, this
      }
      scale(t) {
        const e = this.elements,
          n = t.x,
          r = t.y,
          i = t.z;
        return e[0] *= n, e[4] *= r, e[8] *= i, e[1] *= n, e[5] *= r, e[9] *= i, e[2] *= n, e[6] *= r, e[10] *= i, e[3] *= n, e[7] *= r, e[11] *= i, this
      }
      getMaxScaleOnAxis() {
        const t = this.elements,
          e = t[0] * t[0] + t[1] * t[1] + t[2] * t[2],
          n = t[4] * t[4] + t[5] * t[5] + t[6] * t[6],
          r = t[8] * t[8] + t[9] * t[9] + t[10] * t[10];
        return Math.sqrt(Math.max(e, n, r))
      }
      makeTranslation(t, e, n) {
        return this.set(1, 0, 0, t, 0, 1, 0, e, 0, 0, 1, n, 0, 0, 0, 1), this
      }
      makeRotationX(t) {
        const e = Math.cos(t),
          n = Math.sin(t);
        return this.set(1, 0, 0, 0, 0, e, -n, 0, 0, n, e, 0, 0, 0, 0, 1), this
      }
      makeRotationY(t) {
        const e = Math.cos(t),
          n = Math.sin(t);
        return this.set(e, 0, n, 0, 0, 1, 0, 0, -n, 0, e, 0, 0, 0, 0, 1), this
      }
      makeRotationZ(t) {
        const e = Math.cos(t),
          n = Math.sin(t);
        return this.set(e, -n, 0, 0, n, e, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
      }
      makeRotationAxis(t, e) {
        const n = Math.cos(e),
          r = Math.sin(e),
          i = 1 - n,
          s = t.x,
          o = t.y,
          a = t.z,
          l = i * s,
          c = i * o;
        return this.set(l * s + n, l * o - r * a, l * a + r * o, 0, l * o + r * a, c * o + n, c * a - r * s, 0, l * a - r * o, c * a + r * s, i * a * a + n, 0, 0, 0, 0, 1), this
      }
      makeScale(t, e, n) {
        return this.set(t, 0, 0, 0, 0, e, 0, 0, 0, 0, n, 0, 0, 0, 0, 1), this
      }
      makeShear(t, e, n) {
        return this.set(1, e, n, 0, t, 1, n, 0, t, e, 1, 0, 0, 0, 0, 1), this
      }
      compose(t, e, n) {
        const r = this.elements,
          i = e._x,
          s = e._y,
          o = e._z,
          a = e._w,
          l = i + i,
          c = s + s,
          h = o + o,
          u = i * l,
          p = i * c,
          d = i * h,
          m = s * c,
          f = s * h,
          g = o * h,
          x = a * l,
          v = a * c,
          y = a * h,
          _ = n.x,
          b = n.y,
          w = n.z;
        return r[0] = (1 - (m + g)) * _, r[1] = (p + y) * _, r[2] = (d - v) * _, r[3] = 0, r[4] = (p - y) * b, r[5] = (1 - (u + g)) * b, r[6] = (f + x) * b, r[7] = 0, r[8] = (d + v) * w, r[9] = (f - x) * w, r[10] = (1 - (u + m)) * w, r[11] = 0, r[12] = t.x, r[13] = t.y, r[14] = t.z, r[15] = 1, this
      }
      decompose(t, e, n) {
        const r = this.elements;
        let i = Yr.set(r[0], r[1], r[2]).length();
        const s = Yr.set(r[4], r[5], r[6]).length(),
          o = Yr.set(r[8], r[9], r[10]).length();
        this.determinant() < 0 && (i = -i), t.x = r[12], t.y = r[13], t.z = r[14], Zr.copy(this);
        const a = 1 / i,
          l = 1 / s,
          c = 1 / o;
        return Zr.elements[0] *= a, Zr.elements[1] *= a, Zr.elements[2] *= a, Zr.elements[4] *= l, Zr.elements[5] *= l, Zr.elements[6] *= l, Zr.elements[8] *= c, Zr.elements[9] *= c, Zr.elements[10] *= c, e.setFromRotationMatrix(Zr), n.x = i, n.y = s, n.z = o, this
      }
      makePerspective(t, e, n, r, i, s) {
        void 0 === s && console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");
        const o = this.elements,
          a = 2 * i / (e - t),
          l = 2 * i / (n - r),
          c = (e + t) / (e - t),
          h = (n + r) / (n - r),
          u = -(s + i) / (s - i),
          p = -2 * s * i / (s - i);
        return o[0] = a, o[4] = 0, o[8] = c, o[12] = 0, o[1] = 0, o[5] = l, o[9] = h, o[13] = 0, o[2] = 0, o[6] = 0, o[10] = u, o[14] = p, o[3] = 0, o[7] = 0, o[11] = -1, o[15] = 0, this
      }
      makeOrthographic(t, e, n, r, i, s) {
        const o = this.elements,
          a = 1 / (e - t),
          l = 1 / (n - r),
          c = 1 / (s - i),
          h = (e + t) * a,
          u = (n + r) * l,
          p = (s + i) * c;
        return o[0] = 2 * a, o[4] = 0, o[8] = 0, o[12] = -h, o[1] = 0, o[5] = 2 * l, o[9] = 0, o[13] = -u, o[2] = 0, o[6] = 0, o[10] = -2 * c, o[14] = -p, o[3] = 0, o[7] = 0, o[11] = 0, o[15] = 1, this
      }
      equals(t) {
        const e = this.elements,
          n = t.elements;
        for (let r = 0; r < 16; r++)
          if (e[r] !== n[r]) return !1;
        return !0
      }
      fromArray(t, e = 0) {
        for (let n = 0; n < 16; n++) this.elements[n] = t[n + e];
        return this
      }
      toArray(t = [], e = 0) {
        const n = this.elements;
        return t[e] = n[0], t[e + 1] = n[1], t[e + 2] = n[2], t[e + 3] = n[3], t[e + 4] = n[4], t[e + 5] = n[5], t[e + 6] = n[6], t[e + 7] = n[7], t[e + 8] = n[8], t[e + 9] = n[9], t[e + 10] = n[10], t[e + 11] = n[11], t[e + 12] = n[12], t[e + 13] = n[13], t[e + 14] = n[14], t[e + 15] = n[15], t
      }
    }
    exports.Matrix4 = Xr, Xr.prototype.isMatrix4 = !0;
    const Yr = new gr,
      Zr = new Xr,
      Jr = new gr(0, 0, 0),
      Qr = new gr(1, 1, 1),
      Kr = new gr,
      $r = new gr,
      ti = new gr,
      ei = new Xr,
      ni = new fr;
    class ri {
      constructor(t = 0, e = 0, n = 0, r = ri.DefaultOrder) {
        this._x = t, this._y = e, this._z = n, this._order = r
      }
      get x() {
        return this._x
      }
      set x(t) {
        this._x = t, this._onChangeCallback()
      }
      get y() {
        return this._y
      }
      set y(t) {
        this._y = t, this._onChangeCallback()
      }
      get z() {
        return this._z
      }
      set z(t) {
        this._z = t, this._onChangeCallback()
      }
      get order() {
        return this._order
      }
      set order(t) {
        this._order = t, this._onChangeCallback()
      }
      set(t, e, n, r) {
        return this._x = t, this._y = e, this._z = n, this._order = r || this._order, this._onChangeCallback(), this
      }
      clone() {
        return new this.constructor(this._x, this._y, this._z, this._order)
      }
      copy(t) {
        return this._x = t._x, this._y = t._y, this._z = t._z, this._order = t._order, this._onChangeCallback(), this
      }
      setFromRotationMatrix(t, e, n) {
        const r = t.elements,
          i = r[0],
          s = r[4],
          o = r[8],
          a = r[1],
          l = r[5],
          c = r[9],
          h = r[2],
          u = r[6],
          p = r[10];
        switch (e = e || this._order) {
          case "XYZ":
            this._y = Math.asin(On(o, -1, 1)), Math.abs(o) < .9999999 ? (this._x = Math.atan2(-c, p), this._z = Math.atan2(-s, i)) : (this._x = Math.atan2(u, l), this._z = 0);
            break;
          case "YXZ":
            this._x = Math.asin(-On(c, -1, 1)), Math.abs(c) < .9999999 ? (this._y = Math.atan2(o, p), this._z = Math.atan2(a, l)) : (this._y = Math.atan2(-h, i), this._z = 0);
            break;
          case "ZXY":
            this._x = Math.asin(On(u, -1, 1)), Math.abs(u) < .9999999 ? (this._y = Math.atan2(-h, p), this._z = Math.atan2(-s, l)) : (this._y = 0, this._z = Math.atan2(a, i));
            break;
          case "ZYX":
            this._y = Math.asin(-On(h, -1, 1)), Math.abs(h) < .9999999 ? (this._x = Math.atan2(u, p), this._z = Math.atan2(a, i)) : (this._x = 0, this._z = Math.atan2(-s, l));
            break;
          case "YZX":
            this._z = Math.asin(On(a, -1, 1)), Math.abs(a) < .9999999 ? (this._x = Math.atan2(-c, l), this._y = Math.atan2(-h, i)) : (this._x = 0, this._y = Math.atan2(o, p));
            break;
          case "XZY":
            this._z = Math.asin(-On(s, -1, 1)), Math.abs(s) < .9999999 ? (this._x = Math.atan2(u, l), this._y = Math.atan2(o, i)) : (this._x = Math.atan2(-c, p), this._y = 0);
            break;
          default:
            console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + e)
        }
        return this._order = e, !1 !== n && this._onChangeCallback(), this
      }
      setFromQuaternion(t, e, n) {
        return ei.makeRotationFromQuaternion(t), this.setFromRotationMatrix(ei, e, n)
      }
      setFromVector3(t, e) {
        return this.set(t.x, t.y, t.z, e || this._order)
      }
      reorder(t) {
        return ni.setFromEuler(this), this.setFromQuaternion(ni, t)
      }
      equals(t) {
        return t._x === this._x && t._y === this._y && t._z === this._z && t._order === this._order
      }
      fromArray(t) {
        return this._x = t[0], this._y = t[1], this._z = t[2], void 0 !== t[3] && (this._order = t[3]), this._onChangeCallback(), this
      }
      toArray(t = [], e = 0) {
        return t[e] = this._x, t[e + 1] = this._y, t[e + 2] = this._z, t[e + 3] = this._order, t
      }
      toVector3(t) {
        return t ? t.set(this._x, this._y, this._z) : new gr(this._x, this._y, this._z)
      }
      _onChange(t) {
        return this._onChangeCallback = t, this
      }
      _onChangeCallback() {}
    }
    exports.Euler = ri, ri.prototype.isEuler = !0, ri.DefaultOrder = "XYZ", ri.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"];
    class ii {
      constructor() {
        this.mask = 1
      }
      set(t) {
        this.mask = 1 << t | 0
      }
      enable(t) {
        this.mask |= 1 << t | 0
      }
      enableAll() {
        this.mask = -1
      }
      toggle(t) {
        this.mask ^= 1 << t | 0
      }
      disable(t) {
        this.mask &= ~(1 << t | 0)
      }
      disableAll() {
        this.mask = 0
      }
      test(t) {
        return 0 != (this.mask & t.mask)
      }
    }
    exports.Layers = ii;
    let si = 0;
    const oi = new gr,
      ai = new fr,
      li = new Xr,
      ci = new gr,
      hi = new gr,
      ui = new gr,
      pi = new fr,
      di = new gr(1, 0, 0),
      mi = new gr(0, 1, 0),
      fi = new gr(0, 0, 1),
      gi = {
        type: "added"
      },
      xi = {
        type: "removed"
      };
    class vi extends In {
      constructor() {
        super(), Object.defineProperty(this, "id", {
          value: si++
        }), this.uuid = Gn(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = vi.DefaultUp.clone();
        const t = new gr,
          e = new ri,
          n = new fr,
          r = new gr(1, 1, 1);
        e._onChange(function() {
          n.setFromEuler(e, !1)
        }), n._onChange(function() {
          e.setFromQuaternion(n, void 0, !1)
        }), Object.defineProperties(this, {
          position: {
            configurable: !0,
            enumerable: !0,
            value: t
          },
          rotation: {
            configurable: !0,
            enumerable: !0,
            value: e
          },
          quaternion: {
            configurable: !0,
            enumerable: !0,
            value: n
          },
          scale: {
            configurable: !0,
            enumerable: !0,
            value: r
          },
          modelViewMatrix: {
            value: new Xr
          },
          normalMatrix: {
            value: new or
          }
        }), this.matrix = new Xr, this.matrixWorld = new Xr, this.matrixAutoUpdate = vi.DefaultMatrixAutoUpdate, this.matrixWorldNeedsUpdate = !1, this.layers = new ii, this.visible = !0, this.castShadow = !1, this.receiveShadow = !1, this.frustumCulled = !0, this.renderOrder = 0, this.animations = [], this.userData = {}
      }
      onBeforeRender() {}
      onAfterRender() {}
      applyMatrix4(t) {
        this.matrixAutoUpdate && this.updateMatrix(), this.matrix.premultiply(t), this.matrix.decompose(this.position, this.quaternion, this.scale)
      }
      applyQuaternion(t) {
        return this.quaternion.premultiply(t), this
      }
      setRotationFromAxisAngle(t, e) {
        this.quaternion.setFromAxisAngle(t, e)
      }
      setRotationFromEuler(t) {
        this.quaternion.setFromEuler(t, !0)
      }
      setRotationFromMatrix(t) {
        this.quaternion.setFromRotationMatrix(t)
      }
      setRotationFromQuaternion(t) {
        this.quaternion.copy(t)
      }
      rotateOnAxis(t, e) {
        return ai.setFromAxisAngle(t, e), this.quaternion.multiply(ai), this
      }
      rotateOnWorldAxis(t, e) {
        return ai.setFromAxisAngle(t, e), this.quaternion.premultiply(ai), this
      }
      rotateX(t) {
        return this.rotateOnAxis(di, t)
      }
      rotateY(t) {
        return this.rotateOnAxis(mi, t)
      }
      rotateZ(t) {
        return this.rotateOnAxis(fi, t)
      }
      translateOnAxis(t, e) {
        return oi.copy(t).applyQuaternion(this.quaternion), this.position.add(oi.multiplyScalar(e)), this
      }
      translateX(t) {
        return this.translateOnAxis(di, t)
      }
      translateY(t) {
        return this.translateOnAxis(mi, t)
      }
      translateZ(t) {
        return this.translateOnAxis(fi, t)
      }
      localToWorld(t) {
        return t.applyMatrix4(this.matrixWorld)
      }
      worldToLocal(t) {
        return t.applyMatrix4(li.copy(this.matrixWorld).invert())
      }
      lookAt(t, e, n) {
        t.isVector3 ? ci.copy(t) : ci.set(t, e, n);
        const r = this.parent;
        this.updateWorldMatrix(!0, !1), hi.setFromMatrixPosition(this.matrixWorld), this.isCamera || this.isLight ? li.lookAt(hi, ci, this.up) : li.lookAt(ci, hi, this.up), this.quaternion.setFromRotationMatrix(li), r && (li.extractRotation(r.matrixWorld), ai.setFromRotationMatrix(li), this.quaternion.premultiply(ai.invert()))
      }
      add(t) {
        if (arguments.length > 1) {
          for (let t = 0; t < arguments.length; t++) this.add(arguments[t]);
          return this
        }
        return t === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", t), this) : (t && t.isObject3D ? (null !== t.parent && t.parent.remove(t), t.parent = this, this.children.push(t), t.dispatchEvent(gi)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", t), this)
      }
      remove(t) {
        if (arguments.length > 1) {
          for (let t = 0; t < arguments.length; t++) this.remove(arguments[t]);
          return this
        }
        const e = this.children.indexOf(t);
        return -1 !== e && (t.parent = null, this.children.splice(e, 1), t.dispatchEvent(xi)), this
      }
      clear() {
        for (let t = 0; t < this.children.length; t++) {
          const e = this.children[t];
          e.parent = null, e.dispatchEvent(xi)
        }
        return this.children.length = 0, this
      }
      attach(t) {
        return this.updateWorldMatrix(!0, !1), li.copy(this.matrixWorld).invert(), null !== t.parent && (t.parent.updateWorldMatrix(!0, !1), li.multiply(t.parent.matrixWorld)), t.applyMatrix4(li), this.add(t), t.updateWorldMatrix(!1, !0), this
      }
      getObjectById(t) {
        return this.getObjectByProperty("id", t)
      }
      getObjectByName(t) {
        return this.getObjectByProperty("name", t)
      }
      getObjectByProperty(t, e) {
        if (this[t] === e) return this;
        for (let n = 0, r = this.children.length; n < r; n++) {
          const r = this.children[n].getObjectByProperty(t, e);
          if (void 0 !== r) return r
        }
      }
      getWorldPosition(t) {
        return void 0 === t && (console.warn("THREE.Object3D: .getWorldPosition() target is now required"), t = new gr), this.updateWorldMatrix(!0, !1), t.setFromMatrixPosition(this.matrixWorld)
      }
      getWorldQuaternion(t) {
        return void 0 === t && (console.warn("THREE.Object3D: .getWorldQuaternion() target is now required"), t = new fr), this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(hi, t, ui), t
      }
      getWorldScale(t) {
        return void 0 === t && (console.warn("THREE.Object3D: .getWorldScale() target is now required"), t = new gr), this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(hi, pi, t), t
      }
      getWorldDirection(t) {
        void 0 === t && (console.warn("THREE.Object3D: .getWorldDirection() target is now required"), t = new gr), this.updateWorldMatrix(!0, !1);
        const e = this.matrixWorld.elements;
        return t.set(e[8], e[9], e[10]).normalize()
      }
      raycast() {}
      traverse(t) {
        t(this);
        const e = this.children;
        for (let n = 0, r = e.length; n < r; n++) e[n].traverse(t)
      }
      traverseVisible(t) {
        if (!1 === this.visible) return;
        t(this);
        const e = this.children;
        for (let n = 0, r = e.length; n < r; n++) e[n].traverseVisible(t)
      }
      traverseAncestors(t) {
        const e = this.parent;
        null !== e && (t(e), e.traverseAncestors(t))
      }
      updateMatrix() {
        this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0
      }
      updateMatrixWorld(t) {
        this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || t) && (null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), this.matrixWorldNeedsUpdate = !1, t = !0);
        const e = this.children;
        for (let n = 0, r = e.length; n < r; n++) e[n].updateMatrixWorld(t)
      }
      updateWorldMatrix(t, e) {
        const n = this.parent;
        if (!0 === t && null !== n && n.updateWorldMatrix(!0, !1), this.matrixAutoUpdate && this.updateMatrix(), null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), !0 === e) {
          const t = this.children;
          for (let e = 0, n = t.length; e < n; e++) t[e].updateWorldMatrix(!1, !0)
        }
      }
      toJSON(t) {
        const e = void 0 === t || "string" == typeof t,
          n = {};
        e && (t = {
          geometries: {},
          materials: {},
          textures: {},
          images: {},
          shapes: {},
          skeletons: {},
          animations: {}
        }, n.metadata = {
          version: 4.5,
          type: "Object",
          generator: "Object3D.toJSON"
        });
        const r = {};

        function i(e, n) {
          return void 0 === e[n.uuid] && (e[n.uuid] = n.toJSON(t)), n.uuid
        }
        if (r.uuid = this.uuid, r.type = this.type, "" !== this.name && (r.name = this.name), !0 === this.castShadow && (r.castShadow = !0), !0 === this.receiveShadow && (r.receiveShadow = !0), !1 === this.visible && (r.visible = !1), !1 === this.frustumCulled && (r.frustumCulled = !1), 0 !== this.renderOrder && (r.renderOrder = this.renderOrder), "{}" !== JSON.stringify(this.userData) && (r.userData = this.userData), r.layers = this.layers.mask, r.matrix = this.matrix.toArray(), !1 === this.matrixAutoUpdate && (r.matrixAutoUpdate = !1), this.isInstancedMesh && (r.type = "InstancedMesh", r.count = this.count, r.instanceMatrix = this.instanceMatrix.toJSON(), null !== this.instanceColor && (r.instanceColor = this.instanceColor.toJSON())), this.isMesh || this.isLine || this.isPoints) {
          r.geometry = i(t.geometries, this.geometry);
          const e = this.geometry.parameters;
          if (void 0 !== e && void 0 !== e.shapes) {
            const n = e.shapes;
            if (Array.isArray(n))
              for (let e = 0, r = n.length; e < r; e++) {
                const r = n[e];
                i(t.shapes, r)
              } else i(t.shapes, n)
          }
        }
        if (this.isSkinnedMesh && (r.bindMode = this.bindMode, r.bindMatrix = this.bindMatrix.toArray(), void 0 !== this.skeleton && (i(t.skeletons, this.skeleton), r.skeleton = this.skeleton.uuid)), void 0 !== this.material)
          if (Array.isArray(this.material)) {
            const e = [];
            for (let n = 0, r = this.material.length; n < r; n++) e.push(i(t.materials, this.material[n]));
            r.material = e
          } else r.material = i(t.materials, this.material);
        if (this.children.length > 0) {
          r.children = [];
          for (let e = 0; e < this.children.length; e++) r.children.push(this.children[e].toJSON(t).object)
        }
        if (this.animations.length > 0) {
          r.animations = [];
          for (let e = 0; e < this.animations.length; e++) {
            const n = this.animations[e];
            r.animations.push(i(t.animations, n))
          }
        }
        if (e) {
          const e = s(t.geometries),
            r = s(t.materials),
            i = s(t.textures),
            o = s(t.images),
            a = s(t.shapes),
            l = s(t.skeletons),
            c = s(t.animations);
          e.length > 0 && (n.geometries = e), r.length > 0 && (n.materials = r), i.length > 0 && (n.textures = i), o.length > 0 && (n.images = o), a.length > 0 && (n.shapes = a), l.length > 0 && (n.skeletons = l), c.length > 0 && (n.animations = c)
        }
        return n.object = r, n;

        function s(t) {
          const e = [];
          for (const n in t) {
            const r = t[n];
            delete r.metadata, e.push(r)
          }
          return e
        }
      }
      clone(t) {
        return (new this.constructor).copy(this, t)
      }
      copy(t, e = !0) {
        if (this.name = t.name, this.up.copy(t.up), this.position.copy(t.position), this.rotation.order = t.rotation.order, this.quaternion.copy(t.quaternion), this.scale.copy(t.scale), this.matrix.copy(t.matrix), this.matrixWorld.copy(t.matrixWorld), this.matrixAutoUpdate = t.matrixAutoUpdate, this.matrixWorldNeedsUpdate = t.matrixWorldNeedsUpdate, this.layers.mask = t.layers.mask, this.visible = t.visible, this.castShadow = t.castShadow, this.receiveShadow = t.receiveShadow, this.frustumCulled = t.frustumCulled, this.renderOrder = t.renderOrder, this.userData = JSON.parse(JSON.stringify(t.userData)), !0 === e)
          for (let n = 0; n < t.children.length; n++) {
            const e = t.children[n];
            this.add(e.clone())
          }
        return this
      }
    }
    exports.Object3D = vi, vi.DefaultUp = new gr(0, 1, 0), vi.DefaultMatrixAutoUpdate = !0, vi.prototype.isObject3D = !0;
    const yi = new gr,
      _i = new gr,
      bi = new or;
    class wi {
      constructor(t = new gr(1, 0, 0), e = 0) {
        this.normal = t, this.constant = e
      }
      set(t, e) {
        return this.normal.copy(t), this.constant = e, this
      }
      setComponents(t, e, n, r) {
        return this.normal.set(t, e, n), this.constant = r, this
      }
      setFromNormalAndCoplanarPoint(t, e) {
        return this.normal.copy(t), this.constant = -e.dot(this.normal), this
      }
      setFromCoplanarPoints(t, e, n) {
        const r = yi.subVectors(n, e).cross(_i.subVectors(t, e)).normalize();
        return this.setFromNormalAndCoplanarPoint(r, t), this
      }
      copy(t) {
        return this.normal.copy(t.normal), this.constant = t.constant, this
      }
      normalize() {
        const t = 1 / this.normal.length();
        return this.normal.multiplyScalar(t), this.constant *= t, this
      }
      negate() {
        return this.constant *= -1, this.normal.negate(), this
      }
      distanceToPoint(t) {
        return this.normal.dot(t) + this.constant
      }
      distanceToSphere(t) {
        return this.distanceToPoint(t.center) - t.radius
      }
      projectPoint(t, e) {
        return void 0 === e && (console.warn("THREE.Plane: .projectPoint() target is now required"), e = new gr), e.copy(this.normal).multiplyScalar(-this.distanceToPoint(t)).add(t)
      }
      intersectLine(t, e) {
        void 0 === e && (console.warn("THREE.Plane: .intersectLine() target is now required"), e = new gr);
        const n = t.delta(yi),
          r = this.normal.dot(n);
        if (0 === r) return 0 === this.distanceToPoint(t.start) ? e.copy(t.start) : null;
        const i = -(t.start.dot(this.normal) + this.constant) / r;
        return i < 0 || i > 1 ? null : e.copy(n).multiplyScalar(i).add(t.start)
      }
      intersectsLine(t) {
        const e = this.distanceToPoint(t.start),
          n = this.distanceToPoint(t.end);
        return e < 0 && n > 0 || n < 0 && e > 0
      }
      intersectsBox(t) {
        return t.intersectsPlane(this)
      }
      intersectsSphere(t) {
        return t.intersectsPlane(this)
      }
      coplanarPoint(t) {
        return void 0 === t && (console.warn("THREE.Plane: .coplanarPoint() target is now required"), t = new gr), t.copy(this.normal).multiplyScalar(-this.constant)
      }
      applyMatrix4(t, e) {
        const n = e || bi.getNormalMatrix(t),
          r = this.coplanarPoint(yi).applyMatrix4(t),
          i = this.normal.applyMatrix3(n).normalize();
        return this.constant = -r.dot(i), this
      }
      translate(t) {
        return this.constant -= t.dot(this.normal), this
      }
      equals(t) {
        return t.normal.equals(this.normal) && t.constant === this.constant
      }
      clone() {
        return (new this.constructor).copy(this)
      }
    }
    exports.Plane = wi, wi.prototype.isPlane = !0;
    const Mi = new gr,
      Si = new gr,
      Ti = new gr,
      Ei = new gr,
      Ai = new gr,
      Li = new gr,
      Ri = new gr,
      Ci = new gr,
      Pi = new gr,
      Di = new gr;
    class Ii {
      constructor(t = new gr, e = new gr, n = new gr) {
        this.a = t, this.b = e, this.c = n
      }
      static getNormal(t, e, n, r) {
        void 0 === r && (console.warn("THREE.Triangle: .getNormal() target is now required"), r = new gr), r.subVectors(n, e), Mi.subVectors(t, e), r.cross(Mi);
        const i = r.lengthSq();
        return i > 0 ? r.multiplyScalar(1 / Math.sqrt(i)) : r.set(0, 0, 0)
      }
      static getBarycoord(t, e, n, r, i) {
        Mi.subVectors(r, e), Si.subVectors(n, e), Ti.subVectors(t, e);
        const s = Mi.dot(Mi),
          o = Mi.dot(Si),
          a = Mi.dot(Ti),
          l = Si.dot(Si),
          c = Si.dot(Ti),
          h = s * l - o * o;
        if (void 0 === i && (console.warn("THREE.Triangle: .getBarycoord() target is now required"), i = new gr), 0 === h) return i.set(-2, -1, -1);
        const u = 1 / h,
          p = (l * a - o * c) * u,
          d = (s * c - o * a) * u;
        return i.set(1 - p - d, d, p)
      }
      static containsPoint(t, e, n, r) {
        return this.getBarycoord(t, e, n, r, Ei), Ei.x >= 0 && Ei.y >= 0 && Ei.x + Ei.y <= 1
      }
      static getUV(t, e, n, r, i, s, o, a) {
        return this.getBarycoord(t, e, n, r, Ei), a.set(0, 0), a.addScaledVector(i, Ei.x), a.addScaledVector(s, Ei.y), a.addScaledVector(o, Ei.z), a
      }
      static isFrontFacing(t, e, n, r) {
        return Mi.subVectors(n, e), Si.subVectors(t, e), Mi.cross(Si).dot(r) < 0
      }
      set(t, e, n) {
        return this.a.copy(t), this.b.copy(e), this.c.copy(n), this
      }
      setFromPointsAndIndices(t, e, n, r) {
        return this.a.copy(t[e]), this.b.copy(t[n]), this.c.copy(t[r]), this
      }
      clone() {
        return (new this.constructor).copy(this)
      }
      copy(t) {
        return this.a.copy(t.a), this.b.copy(t.b), this.c.copy(t.c), this
      }
      getArea() {
        return Mi.subVectors(this.c, this.b), Si.subVectors(this.a, this.b), .5 * Mi.cross(Si).length()
      }
      getMidpoint(t) {
        return void 0 === t && (console.warn("THREE.Triangle: .getMidpoint() target is now required"), t = new gr), t.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3)
      }
      getNormal(t) {
        return Ii.getNormal(this.a, this.b, this.c, t)
      }
      getPlane(t) {
        return void 0 === t && (console.warn("THREE.Triangle: .getPlane() target is now required"), t = new wi), t.setFromCoplanarPoints(this.a, this.b, this.c)
      }
      getBarycoord(t, e) {
        return Ii.getBarycoord(t, this.a, this.b, this.c, e)
      }
      getUV(t, e, n, r, i) {
        return Ii.getUV(t, this.a, this.b, this.c, e, n, r, i)
      }
      containsPoint(t) {
        return Ii.containsPoint(t, this.a, this.b, this.c)
      }
      isFrontFacing(t) {
        return Ii.isFrontFacing(this.a, this.b, this.c, t)
      }
      intersectsBox(t) {
        return t.intersectsTriangle(this)
      }
      closestPointToPoint(t, e) {
        void 0 === e && (console.warn("THREE.Triangle: .closestPointToPoint() target is now required"), e = new gr);
        const n = this.a,
          r = this.b,
          i = this.c;
        let s, o;
        Ai.subVectors(r, n), Li.subVectors(i, n), Ci.subVectors(t, n);
        const a = Ai.dot(Ci),
          l = Li.dot(Ci);
        if (a <= 0 && l <= 0) return e.copy(n);
        Pi.subVectors(t, r);
        const c = Ai.dot(Pi),
          h = Li.dot(Pi);
        if (c >= 0 && h <= c) return e.copy(r);
        const u = a * h - c * l;
        if (u <= 0 && a >= 0 && c <= 0) return s = a / (a - c), e.copy(n).addScaledVector(Ai, s);
        Di.subVectors(t, i);
        const p = Ai.dot(Di),
          d = Li.dot(Di);
        if (d >= 0 && p <= d) return e.copy(i);
        const m = p * l - a * d;
        if (m <= 0 && l >= 0 && d <= 0) return o = l / (l - d), e.copy(n).addScaledVector(Li, o);
        const f = c * d - p * h;
        if (f <= 0 && h - c >= 0 && p - d >= 0) return Ri.subVectors(i, r), o = (h - c) / (h - c + (p - d)), e.copy(r).addScaledVector(Ri, o);
        const g = 1 / (f + m + u);
        return s = m * g, o = u * g, e.copy(n).addScaledVector(Ai, s).addScaledVector(Li, o)
      }
      equals(t) {
        return t.a.equals(this.a) && t.b.equals(this.b) && t.c.equals(this.c)
      }
    }
    exports.Triangle = Ii;
    let Bi = 0;

    function Ni() {
      Object.defineProperty(this, "id", {
        value: Bi++
      }), this.uuid = Gn(), this.name = "", this.type = "Material", this.fog = !0, this.blending = x, this.side = u, this.vertexColors = !1, this.opacity = 1, this.transparent = !1, this.blendSrc = P, this.blendDst = D, this.blendEquation = w, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null, this.depthFunc = U, this.depthTest = !0, this.depthWrite = !0, this.stencilWriteMask = 255, this.stencilFunc = bn, this.stencilRef = 0, this.stencilFuncMask = 255, this.stencilFail = an, this.stencilZFail = an, this.stencilZPass = an, this.stencilWrite = !1, this.clippingPlanes = null, this.clipIntersection = !1, this.clipShadows = !1, this.shadowSide = null, this.colorWrite = !0, this.precision = null, this.polygonOffset = !1, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.dithering = !1, this.alphaTest = 0, this.alphaToCoverage = !1, this.premultipliedAlpha = !1, this.visible = !0, this.toneMapped = !0, this.userData = {}, this.version = 0
    }
    Ni.prototype = Object.assign(Object.create(In.prototype), {
      constructor: Ni,
      isMaterial: !0,
      onBuild: function() {},
      onBeforeCompile: function() {},
      customProgramCacheKey: function() {
        return this.onBeforeCompile.toString()
      },
      setValues: function(t) {
        if (void 0 !== t)
          for (const e in t) {
            const n = t[e];
            if (void 0 === n) {
              console.warn("THREE.Material: '" + e + "' parameter is undefined.");
              continue
            }
            if ("shading" === e) {
              console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."), this.flatShading = 1 === n;
              continue
            }
            const r = this[e];
            void 0 !== r ? r && r.isColor ? r.set(n) : r && r.isVector3 && n && n.isVector3 ? r.copy(n) : this[e] = n : console.warn("THREE." + this.type + ": '" + e + "' is not a property of this material.")
          }
      },
      toJSON: function(t) {
        const e = void 0 === t || "string" == typeof t;
        e && (t = {
          textures: {},
          images: {}
        });
        const n = {
          metadata: {
            version: 4.5,
            type: "Material",
            generator: "Material.toJSON"
          }
        };

        function r(t) {
          const e = [];
          for (const n in t) {
            const r = t[n];
            delete r.metadata, e.push(r)
          }
          return e
        }
        if (n.uuid = this.uuid, n.type = this.type, "" !== this.name && (n.name = this.name), this.color && this.color.isColor && (n.color = this.color.getHex()), void 0 !== this.roughness && (n.roughness = this.roughness), void 0 !== this.metalness && (n.metalness = this.metalness), this.sheen && this.sheen.isColor && (n.sheen = this.sheen.getHex()), this.emissive && this.emissive.isColor && (n.emissive = this.emissive.getHex()), this.emissiveIntensity && 1 !== this.emissiveIntensity && (n.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (n.specular = this.specular.getHex()), void 0 !== this.shininess && (n.shininess = this.shininess), void 0 !== this.clearcoat && (n.clearcoat = this.clearcoat), void 0 !== this.clearcoatRoughness && (n.clearcoatRoughness = this.clearcoatRoughness), this.clearcoatMap && this.clearcoatMap.isTexture && (n.clearcoatMap = this.clearcoatMap.toJSON(t).uuid), this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (n.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(t).uuid), this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (n.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(t).uuid, n.clearcoatNormalScale = this.clearcoatNormalScale.toArray()), this.map && this.map.isTexture && (n.map = this.map.toJSON(t).uuid), this.matcap && this.matcap.isTexture && (n.matcap = this.matcap.toJSON(t).uuid), this.alphaMap && this.alphaMap.isTexture && (n.alphaMap = this.alphaMap.toJSON(t).uuid), this.lightMap && this.lightMap.isTexture && (n.lightMap = this.lightMap.toJSON(t).uuid, n.lightMapIntensity = this.lightMapIntensity), this.aoMap && this.aoMap.isTexture && (n.aoMap = this.aoMap.toJSON(t).uuid, n.aoMapIntensity = this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (n.bumpMap = this.bumpMap.toJSON(t).uuid, n.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (n.normalMap = this.normalMap.toJSON(t).uuid, n.normalMapType = this.normalMapType, n.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (n.displacementMap = this.displacementMap.toJSON(t).uuid, n.displacementScale = this.displacementScale, n.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (n.roughnessMap = this.roughnessMap.toJSON(t).uuid), this.metalnessMap && this.metalnessMap.isTexture && (n.metalnessMap = this.metalnessMap.toJSON(t).uuid), this.emissiveMap && this.emissiveMap.isTexture && (n.emissiveMap = this.emissiveMap.toJSON(t).uuid), this.specularMap && this.specularMap.isTexture && (n.specularMap = this.specularMap.toJSON(t).uuid), this.envMap && this.envMap.isTexture && (n.envMap = this.envMap.toJSON(t).uuid, void 0 !== this.combine && (n.combine = this.combine)), void 0 !== this.envMapIntensity && (n.envMapIntensity = this.envMapIntensity), void 0 !== this.reflectivity && (n.reflectivity = this.reflectivity), void 0 !== this.refractionRatio && (n.refractionRatio = this.refractionRatio), this.gradientMap && this.gradientMap.isTexture && (n.gradientMap = this.gradientMap.toJSON(t).uuid), void 0 !== this.size && (n.size = this.size), null !== this.shadowSide && (n.shadowSide = this.shadowSide), void 0 !== this.sizeAttenuation && (n.sizeAttenuation = this.sizeAttenuation), this.blending !== x && (n.blending = this.blending), this.side !== u && (n.side = this.side), this.vertexColors && (n.vertexColors = !0), this.opacity < 1 && (n.opacity = this.opacity), !0 === this.transparent && (n.transparent = this.transparent), n.depthFunc = this.depthFunc, n.depthTest = this.depthTest, n.depthWrite = this.depthWrite, n.colorWrite = this.colorWrite, n.stencilWrite = this.stencilWrite, n.stencilWriteMask = this.stencilWriteMask, n.stencilFunc = this.stencilFunc, n.stencilRef = this.stencilRef, n.stencilFuncMask = this.stencilFuncMask, n.stencilFail = this.stencilFail, n.stencilZFail = this.stencilZFail, n.stencilZPass = this.stencilZPass, this.rotation && 0 !== this.rotation && (n.rotation = this.rotation), !0 === this.polygonOffset && (n.polygonOffset = !0), 0 !== this.polygonOffsetFactor && (n.polygonOffsetFactor = this.polygonOffsetFactor), 0 !== this.polygonOffsetUnits && (n.polygonOffsetUnits = this.polygonOffsetUnits), this.linewidth && 1 !== this.linewidth && (n.linewidth = this.linewidth), void 0 !== this.dashSize && (n.dashSize = this.dashSize), void 0 !== this.gapSize && (n.gapSize = this.gapSize), void 0 !== this.scale && (n.scale = this.scale), !0 === this.dithering && (n.dithering = !0), this.alphaTest > 0 && (n.alphaTest = this.alphaTest), !0 === this.alphaToCoverage && (n.alphaToCoverage = this.alphaToCoverage), !0 === this.premultipliedAlpha && (n.premultipliedAlpha = this.premultipliedAlpha), !0 === this.wireframe && (n.wireframe = this.wireframe), this.wireframeLinewidth > 1 && (n.wireframeLinewidth = this.wireframeLinewidth), "round" !== this.wireframeLinecap && (n.wireframeLinecap = this.wireframeLinecap), "round" !== this.wireframeLinejoin && (n.wireframeLinejoin = this.wireframeLinejoin), !0 === this.morphTargets && (n.morphTargets = !0), !0 === this.morphNormals && (n.morphNormals = !0), !0 === this.skinning && (n.skinning = !0), !0 === this.flatShading && (n.flatShading = this.flatShading), !1 === this.visible && (n.visible = !1), !1 === this.toneMapped && (n.toneMapped = !1), "{}" !== JSON.stringify(this.userData) && (n.userData = this.userData), e) {
          const e = r(t.textures),
            i = r(t.images);
          e.length > 0 && (n.textures = e), i.length > 0 && (n.images = i)
        }
        return n
      },
      clone: function() {
        return (new this.constructor).copy(this)
      },
      copy: function(t) {
        this.name = t.name, this.fog = t.fog, this.blending = t.blending, this.side = t.side, this.vertexColors = t.vertexColors, this.opacity = t.opacity, this.transparent = t.transparent, this.blendSrc = t.blendSrc, this.blendDst = t.blendDst, this.blendEquation = t.blendEquation, this.blendSrcAlpha = t.blendSrcAlpha, this.blendDstAlpha = t.blendDstAlpha, this.blendEquationAlpha = t.blendEquationAlpha, this.depthFunc = t.depthFunc, this.depthTest = t.depthTest, this.depthWrite = t.depthWrite, this.stencilWriteMask = t.stencilWriteMask, this.stencilFunc = t.stencilFunc, this.stencilRef = t.stencilRef, this.stencilFuncMask = t.stencilFuncMask, this.stencilFail = t.stencilFail, this.stencilZFail = t.stencilZFail, this.stencilZPass = t.stencilZPass, this.stencilWrite = t.stencilWrite;
        const e = t.clippingPlanes;
        let n = null;
        if (null !== e) {
          const t = e.length;
          n = new Array(t);
          for (let r = 0; r !== t; ++r) n[r] = e[r].clone()
        }
        return this.clippingPlanes = n, this.clipIntersection = t.clipIntersection, this.clipShadows = t.clipShadows, this.shadowSide = t.shadowSide, this.colorWrite = t.colorWrite, this.precision = t.precision, this.polygonOffset = t.polygonOffset, this.polygonOffsetFactor = t.polygonOffsetFactor, this.polygonOffsetUnits = t.polygonOffsetUnits, this.dithering = t.dithering, this.alphaTest = t.alphaTest, this.alphaToCoverage = t.alphaToCoverage, this.premultipliedAlpha = t.premultipliedAlpha, this.visible = t.visible, this.toneMapped = t.toneMapped, this.userData = JSON.parse(JSON.stringify(t.userData)), this
      },
      dispose: function() {
        this.dispatchEvent({
          type: "dispose"
        })
      }
    }), Object.defineProperty(Ni.prototype, "needsUpdate", {
      set: function(t) {
        !0 === t && this.version++
      }
    });
    const Fi = {
        aliceblue: 15792383,
        antiquewhite: 16444375,
        aqua: 65535,
        aquamarine: 8388564,
        azure: 15794175,
        beige: 16119260,
        bisque: 16770244,
        black: 0,
        blanchedalmond: 16772045,
        blue: 255,
        blueviolet: 9055202,
        brown: 10824234,
        burlywood: 14596231,
        cadetblue: 6266528,
        chartreuse: 8388352,
        chocolate: 13789470,
        coral: 16744272,
        cornflowerblue: 6591981,
        cornsilk: 16775388,
        crimson: 14423100,
        cyan: 65535,
        darkblue: 139,
        darkcyan: 35723,
        darkgoldenrod: 12092939,
        darkgray: 11119017,
        darkgreen: 25600,
        darkgrey: 11119017,
        darkkhaki: 12433259,
        darkmagenta: 9109643,
        darkolivegreen: 5597999,
        darkorange: 16747520,
        darkorchid: 10040012,
        darkred: 9109504,
        darksalmon: 15308410,
        darkseagreen: 9419919,
        darkslateblue: 4734347,
        darkslategray: 3100495,
        darkslategrey: 3100495,
        darkturquoise: 52945,
        darkviolet: 9699539,
        deeppink: 16716947,
        deepskyblue: 49151,
        dimgray: 6908265,
        dimgrey: 6908265,
        dodgerblue: 2003199,
        firebrick: 11674146,
        floralwhite: 16775920,
        forestgreen: 2263842,
        fuchsia: 16711935,
        gainsboro: 14474460,
        ghostwhite: 16316671,
        gold: 16766720,
        goldenrod: 14329120,
        gray: 8421504,
        green: 32768,
        greenyellow: 11403055,
        grey: 8421504,
        honeydew: 15794160,
        hotpink: 16738740,
        indianred: 13458524,
        indigo: 4915330,
        ivory: 16777200,
        khaki: 15787660,
        lavender: 15132410,
        lavenderblush: 16773365,
        lawngreen: 8190976,
        lemonchiffon: 16775885,
        lightblue: 11393254,
        lightcoral: 15761536,
        lightcyan: 14745599,
        lightgoldenrodyellow: 16448210,
        lightgray: 13882323,
        lightgreen: 9498256,
        lightgrey: 13882323,
        lightpink: 16758465,
        lightsalmon: 16752762,
        lightseagreen: 2142890,
        lightskyblue: 8900346,
        lightslategray: 7833753,
        lightslategrey: 7833753,
        lightsteelblue: 11584734,
        lightyellow: 16777184,
        lime: 65280,
        limegreen: 3329330,
        linen: 16445670,
        magenta: 16711935,
        maroon: 8388608,
        mediumaquamarine: 6737322,
        mediumblue: 205,
        mediumorchid: 12211667,
        mediumpurple: 9662683,
        mediumseagreen: 3978097,
        mediumslateblue: 8087790,
        mediumspringgreen: 64154,
        mediumturquoise: 4772300,
        mediumvioletred: 13047173,
        midnightblue: 1644912,
        mintcream: 16121850,
        mistyrose: 16770273,
        moccasin: 16770229,
        navajowhite: 16768685,
        navy: 128,
        oldlace: 16643558,
        olive: 8421376,
        olivedrab: 7048739,
        orange: 16753920,
        orangered: 16729344,
        orchid: 14315734,
        palegoldenrod: 15657130,
        palegreen: 10025880,
        paleturquoise: 11529966,
        palevioletred: 14381203,
        papayawhip: 16773077,
        peachpuff: 16767673,
        peru: 13468991,
        pink: 16761035,
        plum: 14524637,
        powderblue: 11591910,
        purple: 8388736,
        rebeccapurple: 6697881,
        red: 16711680,
        rosybrown: 12357519,
        royalblue: 4286945,
        saddlebrown: 9127187,
        salmon: 16416882,
        sandybrown: 16032864,
        seagreen: 3050327,
        seashell: 16774638,
        sienna: 10506797,
        silver: 12632256,
        skyblue: 8900331,
        slateblue: 6970061,
        slategray: 7372944,
        slategrey: 7372944,
        snow: 16775930,
        springgreen: 65407,
        steelblue: 4620980,
        tan: 13808780,
        teal: 32896,
        thistle: 14204888,
        tomato: 16737095,
        turquoise: 4251856,
        violet: 15631086,
        wheat: 16113331,
        white: 16777215,
        whitesmoke: 16119285,
        yellow: 16776960,
        yellowgreen: 10145074
      },
      zi = {
        h: 0,
        s: 0,
        l: 0
      },
      Gi = {
        h: 0,
        s: 0,
        l: 0
      };

    function Oi(t, e, n) {
      return n < 0 && (n += 1), n > 1 && (n -= 1), n < 1 / 6 ? t + 6 * (e - t) * n : n < .5 ? e : n < 2 / 3 ? t + 6 * (e - t) * (2 / 3 - n) : t
    }

    function Hi(t) {
      return t < .04045 ? .0773993808 * t : Math.pow(.9478672986 * t + .0521327014, 2.4)
    }

    function Ui(t) {
      return t < .0031308 ? 12.92 * t : 1.055 * Math.pow(t, .41666) - .055
    }
    class ki {
      constructor(t, e, n) {
        return void 0 === e && void 0 === n ? this.set(t) : this.setRGB(t, e, n)
      }
      set(t) {
        return t && t.isColor ? this.copy(t) : "number" == typeof t ? this.setHex(t) : "string" == typeof t && this.setStyle(t), this
      }
      setScalar(t) {
        return this.r = t, this.g = t, this.b = t, this
      }
      setHex(t) {
        return t = Math.floor(t), this.r = (t >> 16 & 255) / 255, this.g = (t >> 8 & 255) / 255, this.b = (255 & t) / 255, this
      }
      setRGB(t, e, n) {
        return this.r = t, this.g = e, this.b = n, this
      }
      setHSL(t, e, n) {
        if (t = Hn(t, 1), e = On(e, 0, 1), n = On(n, 0, 1), 0 === e) this.r = this.g = this.b = n;
        else {
          const r = n <= .5 ? n * (1 + e) : n + e - n * e,
            i = 2 * n - r;
          this.r = Oi(i, r, t + 1 / 3), this.g = Oi(i, r, t), this.b = Oi(i, r, t - 1 / 3)
        }
        return this
      }
      setStyle(t) {
        function e(e) {
          void 0 !== e && parseFloat(e) < 1 && console.warn("THREE.Color: Alpha component of " + t + " will be ignored.")
        }
        let n;
        if (n = /^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(t)) {
          let t;
          const r = n[1],
            i = n[2];
          switch (r) {
            case "rgb":
            case "rgba":
              if (t = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(i)) return this.r = Math.min(255, parseInt(t[1], 10)) / 255, this.g = Math.min(255, parseInt(t[2], 10)) / 255, this.b = Math.min(255, parseInt(t[3], 10)) / 255, e(t[4]), this;
              if (t = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(i)) return this.r = Math.min(100, parseInt(t[1], 10)) / 100, this.g = Math.min(100, parseInt(t[2], 10)) / 100, this.b = Math.min(100, parseInt(t[3], 10)) / 100, e(t[4]), this;
              break;
            case "hsl":
            case "hsla":
              if (t = /^\s*(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(i)) {
                const n = parseFloat(t[1]) / 360,
                  r = parseInt(t[2], 10) / 100,
                  i = parseInt(t[3], 10) / 100;
                return e(t[4]), this.setHSL(n, r, i)
              }
          }
        } else if (n = /^\#([A-Fa-f\d]+)$/.exec(t)) {
          const t = n[1],
            e = t.length;
          if (3 === e) return this.r = parseInt(t.charAt(0) + t.charAt(0), 16) / 255, this.g = parseInt(t.charAt(1) + t.charAt(1), 16) / 255, this.b = parseInt(t.charAt(2) + t.charAt(2), 16) / 255, this;
          if (6 === e) return this.r = parseInt(t.charAt(0) + t.charAt(1), 16) / 255, this.g = parseInt(t.charAt(2) + t.charAt(3), 16) / 255, this.b = parseInt(t.charAt(4) + t.charAt(5), 16) / 255, this
        }
        return t && t.length > 0 ? this.setColorName(t) : this
      }
      setColorName(t) {
        const e = Fi[t.toLowerCase()];
        return void 0 !== e ? this.setHex(e) : console.warn("THREE.Color: Unknown color " + t), this
      }
      clone() {
        return new this.constructor(this.r, this.g, this.b)
      }
      copy(t) {
        return this.r = t.r, this.g = t.g, this.b = t.b, this
      }
      copyGammaToLinear(t, e = 2) {
        return this.r = Math.pow(t.r, e), this.g = Math.pow(t.g, e), this.b = Math.pow(t.b, e), this
      }
      copyLinearToGamma(t, e = 2) {
        const n = e > 0 ? 1 / e : 1;
        return this.r = Math.pow(t.r, n), this.g = Math.pow(t.g, n), this.b = Math.pow(t.b, n), this
      }
      convertGammaToLinear(t) {
        return this.copyGammaToLinear(this, t), this
      }
      convertLinearToGamma(t) {
        return this.copyLinearToGamma(this, t), this
      }
      copySRGBToLinear(t) {
        return this.r = Hi(t.r), this.g = Hi(t.g), this.b = Hi(t.b), this
      }
      copyLinearToSRGB(t) {
        return this.r = Ui(t.r), this.g = Ui(t.g), this.b = Ui(t.b), this
      }
      convertSRGBToLinear() {
        return this.copySRGBToLinear(this), this
      }
      convertLinearToSRGB() {
        return this.copyLinearToSRGB(this), this
      }
      getHex() {
        return 255 * this.r << 16 ^ 255 * this.g << 8 ^ 255 * this.b << 0
      }
      getHexString() {
        return ("000000" + this.getHex().toString(16)).slice(-6)
      }
      getHSL(t) {
        void 0 === t && (console.warn("THREE.Color: .getHSL() target is now required"), t = {
          h: 0,
          s: 0,
          l: 0
        });
        const e = this.r,
          n = this.g,
          r = this.b,
          i = Math.max(e, n, r),
          s = Math.min(e, n, r);
        let o, a;
        const l = (s + i) / 2;
        if (s === i) o = 0, a = 0;
        else {
          const t = i - s;
          switch (a = l <= .5 ? t / (i + s) : t / (2 - i - s), i) {
            case e:
              o = (n - r) / t + (n < r ? 6 : 0);
              break;
            case n:
              o = (r - e) / t + 2;
              break;
            case r:
              o = (e - n) / t + 4
          }
          o /= 6
        }
        return t.h = o, t.s = a, t.l = l, t
      }
      getStyle() {
        return "rgb(" + (255 * this.r | 0) + "," + (255 * this.g | 0) + "," + (255 * this.b | 0) + ")"
      }
      offsetHSL(t, e, n) {
        return this.getHSL(zi), zi.h += t, zi.s += e, zi.l += n, this.setHSL(zi.h, zi.s, zi.l), this
      }
      add(t) {
        return this.r += t.r, this.g += t.g, this.b += t.b, this
      }
      addColors(t, e) {
        return this.r = t.r + e.r, this.g = t.g + e.g, this.b = t.b + e.b, this
      }
      addScalar(t) {
        return this.r += t, this.g += t, this.b += t, this
      }
      sub(t) {
        return this.r = Math.max(0, this.r - t.r), this.g = Math.max(0, this.g - t.g), this.b = Math.max(0, this.b - t.b), this
      }
      multiply(t) {
        return this.r *= t.r, this.g *= t.g, this.b *= t.b, this
      }
      multiplyScalar(t) {
        return this.r *= t, this.g *= t, this.b *= t, this
      }
      lerp(t, e) {
        return this.r += (t.r - this.r) * e, this.g += (t.g - this.g) * e, this.b += (t.b - this.b) * e, this
      }
      lerpColors(t, e, n) {
        return this.r = t.r + (e.r - t.r) * n, this.g = t.g + (e.g - t.g) * n, this.b = t.b + (e.b - t.b) * n, this
      }
      lerpHSL(t, e) {
        this.getHSL(zi), t.getHSL(Gi);
        const n = Vn(zi.h, Gi.h, e),
          r = Vn(zi.s, Gi.s, e),
          i = Vn(zi.l, Gi.l, e);
        return this.setHSL(n, r, i), this
      }
      equals(t) {
        return t.r === this.r && t.g === this.g && t.b === this.b
      }
      fromArray(t, e = 0) {
        return this.r = t[e], this.g = t[e + 1], this.b = t[e + 2], this
      }
      toArray(t = [], e = 0) {
        return t[e] = this.r, t[e + 1] = this.g, t[e + 2] = this.b, t
      }
      fromBufferAttribute(t, e) {
        return this.r = t.getX(e), this.g = t.getY(e), this.b = t.getZ(e), !0 === t.normalized && (this.r /= 255, this.g /= 255, this.b /= 255), this
      }
      toJSON() {
        return this.getHex()
      }
    }
    exports.Color = ki, ki.NAMES = Fi, ki.prototype.isColor = !0, ki.prototype.r = 1, ki.prototype.g = 1, ki.prototype.b = 1;
    class Vi extends Ni {
      constructor(t) {
        super(), this.type = "MeshBasicMaterial", this.color = new ki(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = q, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.setValues(t)
      }
      copy(t) {
        return super.copy(t), this.color.copy(t.color), this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.combine = t.combine, this.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this
      }
    }
    exports.MeshBasicMaterial = Vi, Vi.prototype.isMeshBasicMaterial = !0;
    const Wi = new gr,
      ji = new sr;
    class qi {
      constructor(t, e, n) {
        if (Array.isArray(t)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
        this.name = "", this.array = t, this.itemSize = e, this.count = void 0 !== t ? t.length / e : 0, this.normalized = !0 === n, this.usage = wn, this.updateRange = {
          offset: 0,
          count: -1
        }, this.version = 0, this.onUploadCallback = function() {}
      }
      set needsUpdate(t) {
        !0 === t && this.version++
      }
      setUsage(t) {
        return this.usage = t, this
      }
      copy(t) {
        return this.name = t.name, this.array = new t.array.constructor(t.array), this.itemSize = t.itemSize, this.count = t.count, this.normalized = t.normalized, this.usage = t.usage, this
      }
      copyAt(t, e, n) {
        t *= this.itemSize, n *= e.itemSize;
        for (let r = 0, i = this.itemSize; r < i; r++) this.array[t + r] = e.array[n + r];
        return this
      }
      copyArray(t) {
        return this.array.set(t), this
      }
      copyColorsArray(t) {
        const e = this.array;
        let n = 0;
        for (let r = 0, i = t.length; r < i; r++) {
          let i = t[r];
          void 0 === i && (console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined", r), i = new ki), e[n++] = i.r, e[n++] = i.g, e[n++] = i.b
        }
        return this
      }
      copyVector2sArray(t) {
        const e = this.array;
        let n = 0;
        for (let r = 0, i = t.length; r < i; r++) {
          let i = t[r];
          void 0 === i && (console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined", r), i = new sr), e[n++] = i.x, e[n++] = i.y
        }
        return this
      }
      copyVector3sArray(t) {
        const e = this.array;
        let n = 0;
        for (let r = 0, i = t.length; r < i; r++) {
          let i = t[r];
          void 0 === i && (console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined", r), i = new gr), e[n++] = i.x, e[n++] = i.y, e[n++] = i.z
        }
        return this
      }
      copyVector4sArray(t) {
        const e = this.array;
        let n = 0;
        for (let r = 0, i = t.length; r < i; r++) {
          let i = t[r];
          void 0 === i && (console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined", r), i = new pr), e[n++] = i.x, e[n++] = i.y, e[n++] = i.z, e[n++] = i.w
        }
        return this
      }
      applyMatrix3(t) {
        if (2 === this.itemSize)
          for (let e = 0, n = this.count; e < n; e++) ji.fromBufferAttribute(this, e), ji.applyMatrix3(t), this.setXY(e, ji.x, ji.y);
        else if (3 === this.itemSize)
          for (let e = 0, n = this.count; e < n; e++) Wi.fromBufferAttribute(this, e), Wi.applyMatrix3(t), this.setXYZ(e, Wi.x, Wi.y, Wi.z);
        return this
      }
      applyMatrix4(t) {
        for (let e = 0, n = this.count; e < n; e++) Wi.x = this.getX(e), Wi.y = this.getY(e), Wi.z = this.getZ(e), Wi.applyMatrix4(t), this.setXYZ(e, Wi.x, Wi.y, Wi.z);
        return this
      }
      applyNormalMatrix(t) {
        for (let e = 0, n = this.count; e < n; e++) Wi.x = this.getX(e), Wi.y = this.getY(e), Wi.z = this.getZ(e), Wi.applyNormalMatrix(t), this.setXYZ(e, Wi.x, Wi.y, Wi.z);
        return this
      }
      transformDirection(t) {
        for (let e = 0, n = this.count; e < n; e++) Wi.x = this.getX(e), Wi.y = this.getY(e), Wi.z = this.getZ(e), Wi.transformDirection(t), this.setXYZ(e, Wi.x, Wi.y, Wi.z);
        return this
      }
      set(t, e = 0) {
        return this.array.set(t, e), this
      }
      getX(t) {
        return this.array[t * this.itemSize]
      }
      setX(t, e) {
        return this.array[t * this.itemSize] = e, this
      }
      getY(t) {
        return this.array[t * this.itemSize + 1]
      }
      setY(t, e) {
        return this.array[t * this.itemSize + 1] = e, this
      }
      getZ(t) {
        return this.array[t * this.itemSize + 2]
      }
      setZ(t, e) {
        return this.array[t * this.itemSize + 2] = e, this
      }
      getW(t) {
        return this.array[t * this.itemSize + 3]
      }
      setW(t, e) {
        return this.array[t * this.itemSize + 3] = e, this
      }
      setXY(t, e, n) {
        return t *= this.itemSize, this.array[t + 0] = e, this.array[t + 1] = n, this
      }
      setXYZ(t, e, n, r) {
        return t *= this.itemSize, this.array[t + 0] = e, this.array[t + 1] = n, this.array[t + 2] = r, this
      }
      setXYZW(t, e, n, r, i) {
        return t *= this.itemSize, this.array[t + 0] = e, this.array[t + 1] = n, this.array[t + 2] = r, this.array[t + 3] = i, this
      }
      onUpload(t) {
        return this.onUploadCallback = t, this
      }
      clone() {
        return new this.constructor(this.array, this.itemSize).copy(this)
      }
      toJSON() {
        const t = {
          itemSize: this.itemSize,
          type: this.array.constructor.name,
          array: Array.prototype.slice.call(this.array),
          normalized: this.normalized
        };
        return "" !== this.name && (t.name = this.name), this.usage !== wn && (t.usage = this.usage), 0 === this.updateRange.offset && -1 === this.updateRange.count || (t.updateRange = this.updateRange), t
      }
    }
    exports.BufferAttribute = qi, qi.prototype.isBufferAttribute = !0;
    class Xi extends qi {
      constructor(t, e, n) {
        super(new Int8Array(t), e, n)
      }
    }
    exports.Int8BufferAttribute = Xi;
    class Yi extends qi {
      constructor(t, e, n) {
        super(new Uint8Array(t), e, n)
      }
    }
    exports.Uint8BufferAttribute = Yi;
    class Zi extends qi {
      constructor(t, e, n) {
        super(new Uint8ClampedArray(t), e, n)
      }
    }
    exports.Uint8ClampedBufferAttribute = Zi;
    class Ji extends qi {
      constructor(t, e, n) {
        super(new Int16Array(t), e, n)
      }
    }
    exports.Int16BufferAttribute = Ji;
    class Qi extends qi {
      constructor(t, e, n) {
        super(new Uint16Array(t), e, n)
      }
    }
    exports.Uint16BufferAttribute = Qi;
    class Ki extends qi {
      constructor(t, e, n) {
        super(new Int32Array(t), e, n)
      }
    }
    exports.Int32BufferAttribute = Ki;
    class $i extends qi {
      constructor(t, e, n) {
        super(new Uint32Array(t), e, n)
      }
    }
    exports.Uint32BufferAttribute = $i;
    class ts extends qi {
      constructor(t, e, n) {
        super(new Uint16Array(t), e, n)
      }
    }
    exports.Float16BufferAttribute = ts, ts.prototype.isFloat16BufferAttribute = !0;
    class es extends qi {
      constructor(t, e, n) {
        super(new Float32Array(t), e, n)
      }
    }
    exports.Float32BufferAttribute = es;
    class ns extends qi {
      constructor(t, e, n) {
        super(new Float64Array(t), e, n)
      }
    }

    function rs(t) {
      if (0 === t.length) return -1 / 0;
      let e = t[0];
      for (let n = 1, r = t.length; n < r; ++n) t[n] > e && (e = t[n]);
      return e
    }
    exports.Float64BufferAttribute = ns;
    const is = {
      Int8Array: Int8Array,
      Uint8Array: Uint8Array,
      Uint8ClampedArray: Uint8ClampedArray,
      Int16Array: Int16Array,
      Uint16Array: Uint16Array,
      Int32Array: Int32Array,
      Uint32Array: Uint32Array,
      Float32Array: Float32Array,
      Float64Array: Float64Array
    };

    function ss(t, e) {
      return new is[t](e)
    }
    let os = 0;
    const as = new Xr,
      ls = new vi,
      cs = new gr,
      hs = new yr,
      us = new yr,
      ps = new gr;
    class ds extends In {
      constructor() {
        super(), Object.defineProperty(this, "id", {
          value: os++
        }), this.uuid = Gn(), this.name = "", this.type = "BufferGeometry", this.index = null, this.attributes = {}, this.morphAttributes = {}, this.morphTargetsRelative = !1, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = {
          start: 0,
          count: 1 / 0
        }, this.userData = {}
      }
      getIndex() {
        return this.index
      }
      setIndex(t) {
        return Array.isArray(t) ? this.index = new(rs(t) > 65535 ? $i : Qi)(t, 1) : this.index = t, this
      }
      getAttribute(t) {
        return this.attributes[t]
      }
      setAttribute(t, e) {
        return this.attributes[t] = e, this
      }
      deleteAttribute(t) {
        return delete this.attributes[t], this
      }
      hasAttribute(t) {
        return void 0 !== this.attributes[t]
      }
      addGroup(t, e, n = 0) {
        this.groups.push({
          start: t,
          count: e,
          materialIndex: n
        })
      }
      clearGroups() {
        this.groups = []
      }
      setDrawRange(t, e) {
        this.drawRange.start = t, this.drawRange.count = e
      }
      applyMatrix4(t) {
        const e = this.attributes.position;
        void 0 !== e && (e.applyMatrix4(t), e.needsUpdate = !0);
        const n = this.attributes.normal;
        if (void 0 !== n) {
          const e = (new or).getNormalMatrix(t);
          n.applyNormalMatrix(e), n.needsUpdate = !0
        }
        const r = this.attributes.tangent;
        return void 0 !== r && (r.transformDirection(t), r.needsUpdate = !0), null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), this
      }
      rotateX(t) {
        return as.makeRotationX(t), this.applyMatrix4(as), this
      }
      rotateY(t) {
        return as.makeRotationY(t), this.applyMatrix4(as), this
      }
      rotateZ(t) {
        return as.makeRotationZ(t), this.applyMatrix4(as), this
      }
      translate(t, e, n) {
        return as.makeTranslation(t, e, n), this.applyMatrix4(as), this
      }
      scale(t, e, n) {
        return as.makeScale(t, e, n), this.applyMatrix4(as), this
      }
      lookAt(t) {
        return ls.lookAt(t), ls.updateMatrix(), this.applyMatrix4(ls.matrix), this
      }
      center() {
        return this.computeBoundingBox(), this.boundingBox.getCenter(cs).negate(), this.translate(cs.x, cs.y, cs.z), this
      }
      setFromPoints(t) {
        const e = [];
        for (let n = 0, r = t.length; n < r; n++) {
          const r = t[n];
          e.push(r.x, r.y, r.z || 0)
        }
        return this.setAttribute("position", new es(e, 3)), this
      }
      computeBoundingBox() {
        null === this.boundingBox && (this.boundingBox = new yr);
        const t = this.attributes.position,
          e = this.morphAttributes.position;
        if (t && t.isGLBufferAttribute) return console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".', this), void this.boundingBox.set(new gr(-1 / 0, -1 / 0, -1 / 0), new gr(1 / 0, 1 / 0, 1 / 0));
        if (void 0 !== t) {
          if (this.boundingBox.setFromBufferAttribute(t), e)
            for (let n = 0, r = e.length; n < r; n++) {
              const t = e[n];
              hs.setFromBufferAttribute(t), this.morphTargetsRelative ? (ps.addVectors(this.boundingBox.min, hs.min), this.boundingBox.expandByPoint(ps), ps.addVectors(this.boundingBox.max, hs.max), this.boundingBox.expandByPoint(ps)) : (this.boundingBox.expandByPoint(hs.min), this.boundingBox.expandByPoint(hs.max))
            }
        } else this.boundingBox.makeEmpty();
        (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this)
      }
      computeBoundingSphere() {
        null === this.boundingSphere && (this.boundingSphere = new Gr);
        const t = this.attributes.position,
          e = this.morphAttributes.position;
        if (t && t.isGLBufferAttribute) return console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".', this), void this.boundingSphere.set(new gr, 1 / 0);
        if (t) {
          const n = this.boundingSphere.center;
          if (hs.setFromBufferAttribute(t), e)
            for (let t = 0, i = e.length; t < i; t++) {
              const n = e[t];
              us.setFromBufferAttribute(n), this.morphTargetsRelative ? (ps.addVectors(hs.min, us.min), hs.expandByPoint(ps), ps.addVectors(hs.max, us.max), hs.expandByPoint(ps)) : (hs.expandByPoint(us.min), hs.expandByPoint(us.max))
            }
          hs.getCenter(n);
          let r = 0;
          for (let e = 0, i = t.count; e < i; e++) ps.fromBufferAttribute(t, e), r = Math.max(r, n.distanceToSquared(ps));
          if (e)
            for (let i = 0, s = e.length; i < s; i++) {
              const s = e[i],
                o = this.morphTargetsRelative;
              for (let e = 0, i = s.count; e < i; e++) ps.fromBufferAttribute(s, e), o && (cs.fromBufferAttribute(t, e), ps.add(cs)), r = Math.max(r, n.distanceToSquared(ps))
            }
          this.boundingSphere.radius = Math.sqrt(r), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this)
        }
      }
      computeFaceNormals() {}
      computeTangents() {
        const t = this.index,
          e = this.attributes;
        if (null === t || void 0 === e.position || void 0 === e.normal || void 0 === e.uv) return void console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
        const n = t.array,
          r = e.position.array,
          i = e.normal.array,
          s = e.uv.array,
          o = r.length / 3;
        void 0 === e.tangent && this.setAttribute("tangent", new qi(new Float32Array(4 * o), 4));
        const a = e.tangent.array,
          l = [],
          c = [];
        for (let T = 0; T < o; T++) l[T] = new gr, c[T] = new gr;
        const h = new gr,
          u = new gr,
          p = new gr,
          d = new sr,
          m = new sr,
          f = new sr,
          g = new gr,
          x = new gr;

        function v(t, e, n) {
          h.fromArray(r, 3 * t), u.fromArray(r, 3 * e), p.fromArray(r, 3 * n), d.fromArray(s, 2 * t), m.fromArray(s, 2 * e), f.fromArray(s, 2 * n), u.sub(h), p.sub(h), m.sub(d), f.sub(d);
          const i = 1 / (m.x * f.y - f.x * m.y);
          isFinite(i) && (g.copy(u).multiplyScalar(f.y).addScaledVector(p, -m.y).multiplyScalar(i), x.copy(p).multiplyScalar(m.x).addScaledVector(u, -f.x).multiplyScalar(i), l[t].add(g), l[e].add(g), l[n].add(g), c[t].add(x), c[e].add(x), c[n].add(x))
        }
        let y = this.groups;
        0 === y.length && (y = [{
          start: 0,
          count: n.length
        }]);
        for (let T = 0, E = y.length; T < E; ++T) {
          const t = y[T],
            e = t.start;
          for (let r = e, i = e + t.count; r < i; r += 3) v(n[r + 0], n[r + 1], n[r + 2])
        }
        const _ = new gr,
          b = new gr,
          w = new gr,
          M = new gr;

        function S(t) {
          w.fromArray(i, 3 * t), M.copy(w);
          const e = l[t];
          _.copy(e), _.sub(w.multiplyScalar(w.dot(e))).normalize(), b.crossVectors(M, e);
          const n = b.dot(c[t]) < 0 ? -1 : 1;
          a[4 * t] = _.x, a[4 * t + 1] = _.y, a[4 * t + 2] = _.z, a[4 * t + 3] = n
        }
        for (let T = 0, E = y.length; T < E; ++T) {
          const t = y[T],
            e = t.start;
          for (let r = e, i = e + t.count; r < i; r += 3) S(n[r + 0]), S(n[r + 1]), S(n[r + 2])
        }
      }
      computeVertexNormals() {
        const t = this.index,
          e = this.getAttribute("position");
        if (void 0 !== e) {
          let n = this.getAttribute("normal");
          if (void 0 === n) n = new qi(new Float32Array(3 * e.count), 3), this.setAttribute("normal", n);
          else
            for (let t = 0, e = n.count; t < e; t++) n.setXYZ(t, 0, 0, 0);
          const r = new gr,
            i = new gr,
            s = new gr,
            o = new gr,
            a = new gr,
            l = new gr,
            c = new gr,
            h = new gr;
          if (t)
            for (let u = 0, p = t.count; u < p; u += 3) {
              const p = t.getX(u + 0),
                d = t.getX(u + 1),
                m = t.getX(u + 2);
              r.fromBufferAttribute(e, p), i.fromBufferAttribute(e, d), s.fromBufferAttribute(e, m), c.subVectors(s, i), h.subVectors(r, i), c.cross(h), o.fromBufferAttribute(n, p), a.fromBufferAttribute(n, d), l.fromBufferAttribute(n, m), o.add(c), a.add(c), l.add(c), n.setXYZ(p, o.x, o.y, o.z), n.setXYZ(d, a.x, a.y, a.z), n.setXYZ(m, l.x, l.y, l.z)
            } else
              for (let t = 0, u = e.count; t < u; t += 3) r.fromBufferAttribute(e, t + 0), i.fromBufferAttribute(e, t + 1), s.fromBufferAttribute(e, t + 2), c.subVectors(s, i), h.subVectors(r, i), c.cross(h), n.setXYZ(t + 0, c.x, c.y, c.z), n.setXYZ(t + 1, c.x, c.y, c.z), n.setXYZ(t + 2, c.x, c.y, c.z);
          this.normalizeNormals(), n.needsUpdate = !0
        }
      }
      merge(t, e) {
        if (!t || !t.isBufferGeometry) return void console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.", t);
        void 0 === e && (e = 0, console.warn("THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."));
        const n = this.attributes;
        for (const r in n) {
          if (void 0 === t.attributes[r]) continue;
          const i = n[r].array,
            s = t.attributes[r],
            o = s.array,
            a = s.itemSize * e,
            l = Math.min(o.length, i.length - a);
          for (let t = 0, e = a; t < l; t++, e++) i[e] = o[t]
        }
        return this
      }
      normalizeNormals() {
        const t = this.attributes.normal;
        for (let e = 0, n = t.count; e < n; e++) ps.fromBufferAttribute(t, e), ps.normalize(), t.setXYZ(e, ps.x, ps.y, ps.z)
      }
      toNonIndexed() {
        function t(t, e) {
          const n = t.array,
            r = t.itemSize,
            i = t.normalized,
            s = new n.constructor(e.length * r);
          let o = 0,
            a = 0;
          for (let l = 0, c = e.length; l < c; l++) {
            o = e[l] * r;
            for (let t = 0; t < r; t++) s[a++] = n[o++]
          }
          return new qi(s, r, i)
        }
        if (null === this.index) return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."), this;
        const e = new ds,
          n = this.index.array,
          r = this.attributes;
        for (const o in r) {
          const i = t(r[o], n);
          e.setAttribute(o, i)
        }
        const i = this.morphAttributes;
        for (const o in i) {
          const r = [],
            s = i[o];
          for (let e = 0, i = s.length; e < i; e++) {
            const i = t(s[e], n);
            r.push(i)
          }
          e.morphAttributes[o] = r
        }
        e.morphTargetsRelative = this.morphTargetsRelative;
        const s = this.groups;
        for (let o = 0, a = s.length; o < a; o++) {
          const t = s[o];
          e.addGroup(t.start, t.count, t.materialIndex)
        }
        return e
      }
      toJSON() {
        const t = {
          metadata: {
            version: 4.5,
            type: "BufferGeometry",
            generator: "BufferGeometry.toJSON"
          }
        };
        if (t.uuid = this.uuid, t.type = this.type, "" !== this.name && (t.name = this.name), Object.keys(this.userData).length > 0 && (t.userData = this.userData), void 0 !== this.parameters) {
          const e = this.parameters;
          for (const n in e) void 0 !== e[n] && (t[n] = e[n]);
          return t
        }
        t.data = {
          attributes: {}
        };
        const e = this.index;
        null !== e && (t.data.index = {
          type: e.array.constructor.name,
          array: Array.prototype.slice.call(e.array)
        });
        const n = this.attributes;
        for (const a in n) {
          const e = n[a];
          t.data.attributes[a] = e.toJSON(t.data)
        }
        const r = {};
        let i = !1;
        for (const a in this.morphAttributes) {
          const e = this.morphAttributes[a],
            n = [];
          for (let r = 0, i = e.length; r < i; r++) {
            const i = e[r];
            n.push(i.toJSON(t.data))
          }
          n.length > 0 && (r[a] = n, i = !0)
        }
        i && (t.data.morphAttributes = r, t.data.morphTargetsRelative = this.morphTargetsRelative);
        const s = this.groups;
        s.length > 0 && (t.data.groups = JSON.parse(JSON.stringify(s)));
        const o = this.boundingSphere;
        return null !== o && (t.data.boundingSphere = {
          center: o.center.toArray(),
          radius: o.radius
        }), t
      }
      clone() {
        return (new ds).copy(this)
      }
      copy(t) {
        this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null;
        const e = {};
        this.name = t.name;
        const n = t.index;
        null !== n && this.setIndex(n.clone(e));
        const r = t.attributes;
        for (const l in r) {
          const t = r[l];
          this.setAttribute(l, t.clone(e))
        }
        const i = t.morphAttributes;
        for (const l in i) {
          const t = [],
            n = i[l];
          for (let r = 0, i = n.length; r < i; r++) t.push(n[r].clone(e));
          this.morphAttributes[l] = t
        }
        this.morphTargetsRelative = t.morphTargetsRelative;
        const s = t.groups;
        for (let l = 0, c = s.length; l < c; l++) {
          const t = s[l];
          this.addGroup(t.start, t.count, t.materialIndex)
        }
        const o = t.boundingBox;
        null !== o && (this.boundingBox = o.clone());
        const a = t.boundingSphere;
        return null !== a && (this.boundingSphere = a.clone()), this.drawRange.start = t.drawRange.start, this.drawRange.count = t.drawRange.count, this.userData = t.userData, this
      }
      dispose() {
        this.dispatchEvent({
          type: "dispose"
        })
      }
    }
    exports.BufferGeometry = ds, ds.prototype.isBufferGeometry = !0;
    const ms = new Xr,
      fs = new qr,
      gs = new Gr,
      xs = new gr,
      vs = new gr,
      ys = new gr,
      _s = new gr,
      bs = new gr,
      ws = new gr,
      Ms = new gr,
      Ss = new gr,
      Ts = new gr,
      Es = new sr,
      As = new sr,
      Ls = new sr,
      Rs = new gr,
      Cs = new gr;
    class Ps extends vi {
      constructor(t = new ds, e = new Vi) {
        super(), this.type = "Mesh", this.geometry = t, this.material = e, this.updateMorphTargets()
      }
      copy(t) {
        return super.copy(t), void 0 !== t.morphTargetInfluences && (this.morphTargetInfluences = t.morphTargetInfluences.slice()), void 0 !== t.morphTargetDictionary && (this.morphTargetDictionary = Object.assign({}, t.morphTargetDictionary)), this.material = t.material, this.geometry = t.geometry, this
      }
      updateMorphTargets() {
        const t = this.geometry;
        if (t.isBufferGeometry) {
          const e = t.morphAttributes,
            n = Object.keys(e);
          if (n.length > 0) {
            const t = e[n[0]];
            if (void 0 !== t) {
              this.morphTargetInfluences = [], this.morphTargetDictionary = {};
              for (let e = 0, n = t.length; e < n; e++) {
                const n = t[e].name || String(e);
                this.morphTargetInfluences.push(0), this.morphTargetDictionary[n] = e
              }
            }
          }
        } else {
          const e = t.morphTargets;
          void 0 !== e && e.length > 0 && console.error("THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")
        }
      }
      raycast(t, e) {
        const n = this.geometry,
          r = this.material,
          i = this.matrixWorld;
        if (void 0 === r) return;
        if (null === n.boundingSphere && n.computeBoundingSphere(), gs.copy(n.boundingSphere), gs.applyMatrix4(i), !1 === t.ray.intersectsSphere(gs)) return;
        if (ms.copy(i).invert(), fs.copy(t.ray).applyMatrix4(ms), null !== n.boundingBox && !1 === fs.intersectsBox(n.boundingBox)) return;
        let s;
        if (n.isBufferGeometry) {
          const i = n.index,
            o = n.attributes.position,
            a = n.morphAttributes.position,
            l = n.morphTargetsRelative,
            c = n.attributes.uv,
            h = n.attributes.uv2,
            u = n.groups,
            p = n.drawRange;
          if (null !== i)
            if (Array.isArray(r))
              for (let n = 0, d = u.length; n < d; n++) {
                const d = u[n],
                  m = r[d.materialIndex];
                for (let n = Math.max(d.start, p.start), r = Math.min(d.start + d.count, p.start + p.count); n < r; n += 3) {
                  const r = i.getX(n),
                    u = i.getX(n + 1),
                    p = i.getX(n + 2);
                  (s = Is(this, m, t, fs, o, a, l, c, h, r, u, p)) && (s.faceIndex = Math.floor(n / 3), s.face.materialIndex = d.materialIndex, e.push(s))
                }
              } else {
                for (let n = Math.max(0, p.start), u = Math.min(i.count, p.start + p.count); n < u; n += 3) {
                  const u = i.getX(n),
                    p = i.getX(n + 1),
                    d = i.getX(n + 2);
                  (s = Is(this, r, t, fs, o, a, l, c, h, u, p, d)) && (s.faceIndex = Math.floor(n / 3), e.push(s))
                }
              } else if (void 0 !== o)
                if (Array.isArray(r))
                  for (let n = 0, d = u.length; n < d; n++) {
                    const i = u[n],
                      d = r[i.materialIndex];
                    for (let n = Math.max(i.start, p.start), r = Math.min(i.start + i.count, p.start + p.count); n < r; n += 3) {
                      (s = Is(this, d, t, fs, o, a, l, c, h, n, n + 1, n + 2)) && (s.faceIndex = Math.floor(n / 3), s.face.materialIndex = i.materialIndex, e.push(s))
                    }
                  } else {
                    for (let n = Math.max(0, p.start), i = Math.min(o.count, p.start + p.count); n < i; n += 3) {
                      (s = Is(this, r, t, fs, o, a, l, c, h, n, n + 1, n + 2)) && (s.faceIndex = Math.floor(n / 3), e.push(s))
                    }
                  }
        } else n.isGeometry && console.error("THREE.Mesh.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")
      }
    }

    function Ds(t, e, n, r, i, s, o, a) {
      let l;
      if (null === (l = e.side === p ? r.intersectTriangle(o, s, i, !0, a) : r.intersectTriangle(i, s, o, e.side !== d, a))) return null;
      Cs.copy(a), Cs.applyMatrix4(t.matrixWorld);
      const c = n.ray.origin.distanceTo(Cs);
      return c < n.near || c > n.far ? null : {
        distance: c,
        point: Cs.clone(),
        object: t
      }
    }

    function Is(t, e, n, r, i, s, o, a, l, c, h, u) {
      xs.fromBufferAttribute(i, c), vs.fromBufferAttribute(i, h), ys.fromBufferAttribute(i, u);
      const p = t.morphTargetInfluences;
      if (e.morphTargets && s && p) {
        Ms.set(0, 0, 0), Ss.set(0, 0, 0), Ts.set(0, 0, 0);
        for (let t = 0, e = s.length; t < e; t++) {
          const e = p[t],
            n = s[t];
          0 !== e && (_s.fromBufferAttribute(n, c), bs.fromBufferAttribute(n, h), ws.fromBufferAttribute(n, u), o ? (Ms.addScaledVector(_s, e), Ss.addScaledVector(bs, e), Ts.addScaledVector(ws, e)) : (Ms.addScaledVector(_s.sub(xs), e), Ss.addScaledVector(bs.sub(vs), e), Ts.addScaledVector(ws.sub(ys), e)))
        }
        xs.add(Ms), vs.add(Ss), ys.add(Ts)
      }
      t.isSkinnedMesh && e.skinning && (t.boneTransform(c, xs), t.boneTransform(h, vs), t.boneTransform(u, ys));
      const d = Ds(t, e, n, r, xs, vs, ys, Rs);
      if (d) {
        a && (Es.fromBufferAttribute(a, c), As.fromBufferAttribute(a, h), Ls.fromBufferAttribute(a, u), d.uv = Ii.getUV(Rs, xs, vs, ys, Es, As, Ls, new sr)), l && (Es.fromBufferAttribute(l, c), As.fromBufferAttribute(l, h), Ls.fromBufferAttribute(l, u), d.uv2 = Ii.getUV(Rs, xs, vs, ys, Es, As, Ls, new sr));
        const t = {
          a: c,
          b: h,
          c: u,
          normal: new gr,
          materialIndex: 0
        };
        Ii.getNormal(xs, vs, ys, t.normal), d.face = t
      }
      return d
    }
    exports.Mesh = Ps, Ps.prototype.isMesh = !0;
    class Bs extends ds {
      constructor(t = 1, e = 1, n = 1, r = 1, i = 1, s = 1) {
        super(), this.type = "BoxGeometry", this.parameters = {
          width: t,
          height: e,
          depth: n,
          widthSegments: r,
          heightSegments: i,
          depthSegments: s
        };
        const o = this;
        r = Math.floor(r), i = Math.floor(i), s = Math.floor(s);
        const a = [],
          l = [],
          c = [],
          h = [];
        let u = 0,
          p = 0;

        function d(t, e, n, r, i, s, d, m, f, g, x) {
          const v = s / f,
            y = d / g,
            _ = s / 2,
            b = d / 2,
            w = m / 2,
            M = f + 1,
            S = g + 1;
          let T = 0,
            E = 0;
          const A = new gr;
          for (let o = 0; o < S; o++) {
            const s = o * y - b;
            for (let a = 0; a < M; a++) {
              const u = a * v - _;
              A[t] = u * r, A[e] = s * i, A[n] = w, l.push(A.x, A.y, A.z), A[t] = 0, A[e] = 0, A[n] = m > 0 ? 1 : -1, c.push(A.x, A.y, A.z), h.push(a / f), h.push(1 - o / g), T += 1
            }
          }
          for (let o = 0; o < g; o++)
            for (let t = 0; t < f; t++) {
              const e = u + t + M * o,
                n = u + t + M * (o + 1),
                r = u + (t + 1) + M * (o + 1),
                i = u + (t + 1) + M * o;
              a.push(e, n, i), a.push(n, r, i), E += 6
            }
          o.addGroup(p, E, x), p += E, u += T
        }
        d("z", "y", "x", -1, -1, n, e, t, s, i, 0), d("z", "y", "x", 1, -1, n, e, -t, s, i, 1), d("x", "z", "y", 1, 1, t, n, e, r, s, 2), d("x", "z", "y", 1, -1, t, n, -e, r, s, 3), d("x", "y", "z", 1, -1, t, e, n, r, i, 4), d("x", "y", "z", -1, -1, t, e, -n, r, i, 5), this.setIndex(a), this.setAttribute("position", new es(l, 3)), this.setAttribute("normal", new es(c, 3)), this.setAttribute("uv", new es(h, 2))
      }
    }

    function Ns(t) {
      const e = {};
      for (const n in t) {
        e[n] = {};
        for (const r in t[n]) {
          const i = t[n][r];
          i && (i.isColor || i.isMatrix3 || i.isMatrix4 || i.isVector2 || i.isVector3 || i.isVector4 || i.isTexture || i.isQuaternion) ? e[n][r] = i.clone() : Array.isArray(i) ? e[n][r] = i.slice() : e[n][r] = i
        }
      }
      return e
    }

    function Fs(t) {
      const e = {};
      for (let n = 0; n < t.length; n++) {
        const r = Ns(t[n]);
        for (const t in r) e[t] = r[t]
      }
      return e
    }
    exports.BoxGeometry = exports.BoxBufferGeometry = Bs;
    const zs = {
      clone: Ns,
      merge: Fs
    };
    exports.UniformsUtils = zs;
    var Gs = "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}",
      Os = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}";
    class Hs extends Ni {
      constructor(t) {
        super(), this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, this.vertexShader = Gs, this.fragmentShader = Os, this.linewidth = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.clipping = !1, this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.extensions = {
          derivatives: !1,
          fragDepth: !1,
          drawBuffers: !1,
          shaderTextureLOD: !1
        }, this.defaultAttributeValues = {
          color: [1, 1, 1],
          uv: [0, 0],
          uv2: [0, 0]
        }, this.index0AttributeName = void 0, this.uniformsNeedUpdate = !1, this.glslVersion = null, void 0 !== t && (void 0 !== t.attributes && console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."), this.setValues(t))
      }
      copy(t) {
        return super.copy(t), this.fragmentShader = t.fragmentShader, this.vertexShader = t.vertexShader, this.uniforms = Ns(t.uniforms), this.defines = Object.assign({}, t.defines), this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.lights = t.lights, this.clipping = t.clipping, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this.extensions = Object.assign({}, t.extensions), this.glslVersion = t.glslVersion, this
      }
      toJSON(t) {
        const e = super.toJSON(t);
        e.glslVersion = this.glslVersion, e.uniforms = {};
        for (const r in this.uniforms) {
          const n = this.uniforms[r].value;
          n && n.isTexture ? e.uniforms[r] = {
            type: "t",
            value: n.toJSON(t).uuid
          } : n && n.isColor ? e.uniforms[r] = {
            type: "c",
            value: n.getHex()
          } : n && n.isVector2 ? e.uniforms[r] = {
            type: "v2",
            value: n.toArray()
          } : n && n.isVector3 ? e.uniforms[r] = {
            type: "v3",
            value: n.toArray()
          } : n && n.isVector4 ? e.uniforms[r] = {
            type: "v4",
            value: n.toArray()
          } : n && n.isMatrix3 ? e.uniforms[r] = {
            type: "m3",
            value: n.toArray()
          } : n && n.isMatrix4 ? e.uniforms[r] = {
            type: "m4",
            value: n.toArray()
          } : e.uniforms[r] = {
            value: n
          }
        }
        Object.keys(this.defines).length > 0 && (e.defines = this.defines), e.vertexShader = this.vertexShader, e.fragmentShader = this.fragmentShader;
        const n = {};
        for (const r in this.extensions) !0 === this.extensions[r] && (n[r] = !0);
        return Object.keys(n).length > 0 && (e.extensions = n), e
      }
    }
    exports.ShaderMaterial = Hs, Hs.prototype.isShaderMaterial = !0;
    class Us extends vi {
      constructor() {
        super(), this.type = "Camera", this.matrixWorldInverse = new Xr, this.projectionMatrix = new Xr, this.projectionMatrixInverse = new Xr
      }
      copy(t, e) {
        return super.copy(t, e), this.matrixWorldInverse.copy(t.matrixWorldInverse), this.projectionMatrix.copy(t.projectionMatrix), this.projectionMatrixInverse.copy(t.projectionMatrixInverse), this
      }
      getWorldDirection(t) {
        void 0 === t && (console.warn("THREE.Camera: .getWorldDirection() target is now required"), t = new gr), this.updateWorldMatrix(!0, !1);
        const e = this.matrixWorld.elements;
        return t.set(-e[8], -e[9], -e[10]).normalize()
      }
      updateMatrixWorld(t) {
        super.updateMatrixWorld(t), this.matrixWorldInverse.copy(this.matrixWorld).invert()
      }
      updateWorldMatrix(t, e) {
        super.updateWorldMatrix(t, e), this.matrixWorldInverse.copy(this.matrixWorld).invert()
      }
      clone() {
        return (new this.constructor).copy(this)
      }
    }
    exports.Camera = Us, Us.prototype.isCamera = !0;
    class ks extends Us {
      constructor(t = 50, e = 1, n = .1, r = 2e3) {
        super(), this.type = "PerspectiveCamera", this.fov = t, this.zoom = 1, this.near = n, this.far = r, this.focus = 10, this.aspect = e, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix()
      }
      copy(t, e) {
        return super.copy(t, e), this.fov = t.fov, this.zoom = t.zoom, this.near = t.near, this.far = t.far, this.focus = t.focus, this.aspect = t.aspect, this.view = null === t.view ? null : Object.assign({}, t.view), this.filmGauge = t.filmGauge, this.filmOffset = t.filmOffset, this
      }
      setFocalLength(t) {
        const e = .5 * this.getFilmHeight() / t;
        this.fov = 2 * zn * Math.atan(e), this.updateProjectionMatrix()
      }
      getFocalLength() {
        const t = Math.tan(.5 * Fn * this.fov);
        return .5 * this.getFilmHeight() / t
      }
      getEffectiveFOV() {
        return 2 * zn * Math.atan(Math.tan(.5 * Fn * this.fov) / this.zoom)
      }
      getFilmWidth() {
        return this.filmGauge * Math.min(this.aspect, 1)
      }
      getFilmHeight() {
        return this.filmGauge / Math.max(this.aspect, 1)
      }
      setViewOffset(t, e, n, r, i, s) {
        this.aspect = t / e, null === this.view && (this.view = {
          enabled: !0,
          fullWidth: 1,
          fullHeight: 1,
          offsetX: 0,
          offsetY: 0,
          width: 1,
          height: 1
        }), this.view.enabled = !0, this.view.fullWidth = t, this.view.fullHeight = e, this.view.offsetX = n, this.view.offsetY = r, this.view.width = i, this.view.height = s, this.updateProjectionMatrix()
      }
      clearViewOffset() {
        null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix()
      }
      updateProjectionMatrix() {
        const t = this.near;
        let e = t * Math.tan(.5 * Fn * this.fov) / this.zoom,
          n = 2 * e,
          r = this.aspect * n,
          i = -.5 * r;
        const s = this.view;
        if (null !== this.view && this.view.enabled) {
          const t = s.fullWidth,
            o = s.fullHeight;
          i += s.offsetX * r / t, e -= s.offsetY * n / o, r *= s.width / t, n *= s.height / o
        }
        const o = this.filmOffset;
        0 !== o && (i += t * o / this.getFilmWidth()), this.projectionMatrix.makePerspective(i, i + r, e, e - n, t, this.far), this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
      }
      toJSON(t) {
        const e = super.toJSON(t);
        return e.object.fov = this.fov, e.object.zoom = this.zoom, e.object.near = this.near, e.object.far = this.far, e.object.focus = this.focus, e.object.aspect = this.aspect, null !== this.view && (e.object.view = Object.assign({}, this.view)), e.object.filmGauge = this.filmGauge, e.object.filmOffset = this.filmOffset, e
      }
    }
    exports.PerspectiveCamera = ks, ks.prototype.isPerspectiveCamera = !0;
    const Vs = 90,
      Ws = 1;
    class js extends vi {
      constructor(t, e, n) {
        if (super(), this.type = "CubeCamera", !0 !== n.isWebGLCubeRenderTarget) return void console.error("THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter.");
        this.renderTarget = n;
        const r = new ks(Vs, Ws, t, e);
        r.layers = this.layers, r.up.set(0, -1, 0), r.lookAt(new gr(1, 0, 0)), this.add(r);
        const i = new ks(Vs, Ws, t, e);
        i.layers = this.layers, i.up.set(0, -1, 0), i.lookAt(new gr(-1, 0, 0)), this.add(i);
        const s = new ks(Vs, Ws, t, e);
        s.layers = this.layers, s.up.set(0, 0, 1), s.lookAt(new gr(0, 1, 0)), this.add(s);
        const o = new ks(Vs, Ws, t, e);
        o.layers = this.layers, o.up.set(0, 0, -1), o.lookAt(new gr(0, -1, 0)), this.add(o);
        const a = new ks(Vs, Ws, t, e);
        a.layers = this.layers, a.up.set(0, -1, 0), a.lookAt(new gr(0, 0, 1)), this.add(a);
        const l = new ks(Vs, Ws, t, e);
        l.layers = this.layers, l.up.set(0, -1, 0), l.lookAt(new gr(0, 0, -1)), this.add(l)
      }
      update(t, e) {
        null === this.parent && this.updateMatrixWorld();
        const n = this.renderTarget,
          [r, i, s, o, a, l] = this.children,
          c = t.xr.enabled,
          h = t.getRenderTarget();
        t.xr.enabled = !1;
        const u = n.texture.generateMipmaps;
        n.texture.generateMipmaps = !1, t.setRenderTarget(n, 0), t.render(e, r), t.setRenderTarget(n, 1), t.render(e, i), t.setRenderTarget(n, 2), t.render(e, s), t.setRenderTarget(n, 3), t.render(e, o), t.setRenderTarget(n, 4), t.render(e, a), n.texture.generateMipmaps = u, t.setRenderTarget(n, 5), t.render(e, l), t.setRenderTarget(h), t.xr.enabled = c
      }
    }
    exports.CubeCamera = js;
    class qs extends hr {
      constructor(t, e, n, r, i, s, o, a, l, c) {
        super(t = void 0 !== t ? t : [], e = void 0 !== e ? e : nt, n, r, i, s, o = void 0 !== o ? o : Bt, a, l, c), this._needsFlipEnvMap = !0, this.flipY = !1
      }
      get images() {
        return this.image
      }
      set images(t) {
        this.image = t
      }
    }
    exports.CubeTexture = qs, qs.prototype.isCubeTexture = !0;
    class Xs extends dr {
      constructor(t, e, n) {
        Number.isInteger(e) && (console.warn("THREE.WebGLCubeRenderTarget: constructor signature is now WebGLCubeRenderTarget( size, options )"), e = n), super(t, t, e), e = e || {}, this.texture = new qs(void 0, e.mapping, e.wrapS, e.wrapT, e.magFilter, e.minFilter, e.format, e.type, e.anisotropy, e.encoding), this.texture.generateMipmaps = void 0 !== e.generateMipmaps && e.generateMipmaps, this.texture.minFilter = void 0 !== e.minFilter ? e.minFilter : gt, this.texture._needsFlipEnvMap = !1
      }
      fromEquirectangularTexture(t, e) {
        this.texture.type = e.type, this.texture.format = Nt, this.texture.encoding = e.encoding, this.texture.generateMipmaps = e.generateMipmaps, this.texture.minFilter = e.minFilter, this.texture.magFilter = e.magFilter;
        const n = {
            uniforms: {
              tEquirect: {
                value: null
              }
            },
            vertexShader: "\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\tvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n\t\t\t\t\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvWorldDirection = transformDirection( position, modelMatrix );\n\n\t\t\t\t\t#include <begin_vertex>\n\t\t\t\t\t#include <project_vertex>\n\n\t\t\t\t}\n\t\t\t",
            fragmentShader: "\n\n\t\t\t\tuniform sampler2D tEquirect;\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\t#include <common>\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec3 direction = normalize( vWorldDirection );\n\n\t\t\t\t\tvec2 sampleUV = equirectUv( direction );\n\n\t\t\t\t\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\n\t\t\t\t}\n\t\t\t"
          },
          r = new Bs(5, 5, 5),
          i = new Hs({
            name: "CubemapFromEquirect",
            uniforms: Ns(n.uniforms),
            vertexShader: n.vertexShader,
            fragmentShader: n.fragmentShader,
            side: p,
            blending: g
          });
        i.uniforms.tEquirect.value = e;
        const s = new Ps(r, i),
          o = e.minFilter;
        return e.minFilter === yt && (e.minFilter = gt), new js(1, 10, this).update(t, s), e.minFilter = o, s.geometry.dispose(), s.material.dispose(), this
      }
      clear(t, e, n, r) {
        const i = t.getRenderTarget();
        for (let s = 0; s < 6; s++) t.setRenderTarget(this, s), t.clear(e, n, r);
        t.setRenderTarget(i)
      }
    }
    exports.WebGLCubeRenderTarget = Xs, Xs.prototype.isWebGLCubeRenderTarget = !0;
    class Ys extends hr {
      constructor(t, e, n, r, i, s, o, a, l, c, h, u) {
        super(null, s, o, a, l, c, r, i, h, u), this.image = {
          data: t || null,
          width: e || 1,
          height: n || 1
        }, this.magFilter = void 0 !== l ? l : ut, this.minFilter = void 0 !== c ? c : ut, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1, this.needsUpdate = !0
      }
    }
    exports.DataTexture = Ys, Ys.prototype.isDataTexture = !0;
    const Zs = new Gr,
      Js = new gr;
    class Qs {
      constructor(t = new wi, e = new wi, n = new wi, r = new wi, i = new wi, s = new wi) {
        this.planes = [t, e, n, r, i, s]
      }
      set(t, e, n, r, i, s) {
        const o = this.planes;
        return o[0].copy(t), o[1].copy(e), o[2].copy(n), o[3].copy(r), o[4].copy(i), o[5].copy(s), this
      }
      copy(t) {
        const e = this.planes;
        for (let n = 0; n < 6; n++) e[n].copy(t.planes[n]);
        return this
      }
      setFromProjectionMatrix(t) {
        const e = this.planes,
          n = t.elements,
          r = n[0],
          i = n[1],
          s = n[2],
          o = n[3],
          a = n[4],
          l = n[5],
          c = n[6],
          h = n[7],
          u = n[8],
          p = n[9],
          d = n[10],
          m = n[11],
          f = n[12],
          g = n[13],
          x = n[14],
          v = n[15];
        return e[0].setComponents(o - r, h - a, m - u, v - f).normalize(), e[1].setComponents(o + r, h + a, m + u, v + f).normalize(), e[2].setComponents(o + i, h + l, m + p, v + g).normalize(), e[3].setComponents(o - i, h - l, m - p, v - g).normalize(), e[4].setComponents(o - s, h - c, m - d, v - x).normalize(), e[5].setComponents(o + s, h + c, m + d, v + x).normalize(), this
      }
      intersectsObject(t) {
        const e = t.geometry;
        return null === e.boundingSphere && e.computeBoundingSphere(), Zs.copy(e.boundingSphere).applyMatrix4(t.matrixWorld), this.intersectsSphere(Zs)
      }
      intersectsSprite(t) {
        return Zs.center.set(0, 0, 0), Zs.radius = .7071067811865476, Zs.applyMatrix4(t.matrixWorld), this.intersectsSphere(Zs)
      }
      intersectsSphere(t) {
        const e = this.planes,
          n = t.center,
          r = -t.radius;
        for (let i = 0; i < 6; i++) {
          if (e[i].distanceToPoint(n) < r) return !1
        }
        return !0
      }
      intersectsBox(t) {
        const e = this.planes;
        for (let n = 0; n < 6; n++) {
          const r = e[n];
          if (Js.x = r.normal.x > 0 ? t.max.x : t.min.x, Js.y = r.normal.y > 0 ? t.max.y : t.min.y, Js.z = r.normal.z > 0 ? t.max.z : t.min.z, r.distanceToPoint(Js) < 0) return !1
        }
        return !0
      }
      containsPoint(t) {
        const e = this.planes;
        for (let n = 0; n < 6; n++)
          if (e[n].distanceToPoint(t) < 0) return !1;
        return !0
      }
      clone() {
        return (new this.constructor).copy(this)
      }
    }

    function Ks() {
      let t = null,
        e = !1,
        n = null,
        r = null;

      function i(e, s) {
        n(e, s), r = t.requestAnimationFrame(i)
      }
      return {
        start: function() {
          !0 !== e && null !== n && (r = t.requestAnimationFrame(i), e = !0)
        },
        stop: function() {
          t.cancelAnimationFrame(r), e = !1
        },
        setAnimationLoop: function(t) {
          n = t
        },
        setContext: function(e) {
          t = e
        }
      }
    }

    function $s(t, e) {
      const n = e.isWebGL2,
        r = new WeakMap;
      return {
        get: function(t) {
          return t.isInterleavedBufferAttribute && (t = t.data), r.get(t)
        },
        remove: function(e) {
          e.isInterleavedBufferAttribute && (e = e.data);
          const n = r.get(e);
          n && (t.deleteBuffer(n.buffer), r.delete(e))
        },
        update: function(e, i) {
          if (e.isGLBufferAttribute) {
            const t = r.get(e);
            return void((!t || t.version < e.version) && r.set(e, {
              buffer: e.buffer,
              type: e.type,
              bytesPerElement: e.elementSize,
              version: e.version
            }))
          }
          e.isInterleavedBufferAttribute && (e = e.data);
          const s = r.get(e);
          void 0 === s ? r.set(e, function(e, r) {
            const i = e.array,
              s = e.usage,
              o = t.createBuffer();
            t.bindBuffer(r, o), t.bufferData(r, i, s), e.onUploadCallback();
            let a = 5126;
            return i instanceof Float32Array ? a = 5126 : i instanceof Float64Array ? console.warn("THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.") : i instanceof Uint16Array ? e.isFloat16BufferAttribute ? n ? a = 5131 : console.warn("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.") : a = 5123 : i instanceof Int16Array ? a = 5122 : i instanceof Uint32Array ? a = 5125 : i instanceof Int32Array ? a = 5124 : i instanceof Int8Array ? a = 5120 : i instanceof Uint8Array && (a = 5121), {
              buffer: o,
              type: a,
              bytesPerElement: i.BYTES_PER_ELEMENT,
              version: e.version
            }
          }(e, i)) : s.version < e.version && (function(e, r, i) {
            const s = r.array,
              o = r.updateRange;
            t.bindBuffer(i, e), -1 === o.count ? t.bufferSubData(i, 0, s) : (n ? t.bufferSubData(i, o.offset * s.BYTES_PER_ELEMENT, s, o.offset, o.count) : t.bufferSubData(i, o.offset * s.BYTES_PER_ELEMENT, s.subarray(o.offset, o.offset + o.count)), o.count = -1)
          }(s.buffer, e, i), s.version = e.version)
        }
      }
    }
    exports.Frustum = Qs;
    class to extends ds {
      constructor(t = 1, e = 1, n = 1, r = 1) {
        super(), this.type = "PlaneGeometry", this.parameters = {
          width: t,
          height: e,
          widthSegments: n,
          heightSegments: r
        };
        const i = t / 2,
          s = e / 2,
          o = Math.floor(n),
          a = Math.floor(r),
          l = o + 1,
          c = a + 1,
          h = t / o,
          u = e / a,
          p = [],
          d = [],
          m = [],
          f = [];
        for (let g = 0; g < c; g++) {
          const t = g * u - s;
          for (let e = 0; e < l; e++) {
            const n = e * h - i;
            d.push(n, -t, 0), m.push(0, 0, 1), f.push(e / o), f.push(1 - g / a)
          }
        }
        for (let g = 0; g < a; g++)
          for (let t = 0; t < o; t++) {
            const e = t + l * g,
              n = t + l * (g + 1),
              r = t + 1 + l * (g + 1),
              i = t + 1 + l * g;
            p.push(e, n, i), p.push(n, r, i)
          }
        this.setIndex(p), this.setAttribute("position", new es(d, 3)), this.setAttribute("normal", new es(m, 3)), this.setAttribute("uv", new es(f, 2))
      }
    }
    exports.PlaneGeometry = exports.PlaneBufferGeometry = to;
    var eo = "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif",
      no = "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
      ro = "#ifdef ALPHATEST\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n#endif",
      io = "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\t#endif\n#endif",
      so = "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif",
      oo = "vec3 transformed = vec3( position );",
      ao = "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif",
      lo = "vec2 integrateSpecularBRDF( const in float dotNV, const in float roughness ) {\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\treturn vec2( -1.04, 1.04 ) * a004 + r.zw;\n}\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\tif( cutoffDistance > 0.0 ) {\n\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t}\n\treturn distanceFalloff;\n#else\n\tif( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t}\n\treturn 1.0;\n#endif\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nvec3 F_Schlick_RoughnessDependent( const in vec3 F0, const in float dotNV, const in float roughness ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotNV - 6.98316 ) * dotNV );\n\tvec3 Fr = max( vec3( 1.0 - roughness ), F0 ) - F0;\n\treturn Fr * fresnel + F0;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\treturn 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( incidentLight.direction + viewDir );\n\tfloat dotNL = saturate( dot( normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( G * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nvec3 BRDF_Specular_GGX_Environment( const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\treturn specularColor * brdf.x + brdf.y;\n}\nvoid BRDF_Specular_Multiscattering_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tvec3 F = F_Schlick_RoughnessDependent( specularColor, dotNV, roughness );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\tvec3 FssEss = F * brdf.x + brdf.y;\n\tfloat Ess = brdf.x + brdf.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie(float roughness, float NoH) {\n\tfloat invAlpha = 1.0 / roughness;\n\tfloat cos2h = NoH * NoH;\n\tfloat sin2h = max(1.0 - cos2h, 0.0078125);\treturn (2.0 + invAlpha) * pow(sin2h, invAlpha * 0.5) / (2.0 * PI);\n}\nfloat V_Neubelt(float NoV, float NoL) {\n\treturn saturate(1.0 / (4.0 * (NoL + NoV - NoL * NoV)));\n}\nvec3 BRDF_Specular_Sheen( const in float roughness, const in vec3 L, const in GeometricContext geometry, vec3 specularColor ) {\n\tvec3 N = geometry.normal;\n\tvec3 V = geometry.viewDir;\n\tvec3 H = normalize( V + L );\n\tfloat dotNH = saturate( dot( N, H ) );\n\treturn specularColor * D_Charlie( roughness, dotNH ) * V_Neubelt( dot(N, V), dot(N, L) );\n}\n#endif",
      co = "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 ) * faceDirection;\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif",
      ho = "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#pragma unroll_loop_end\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\tif ( clipped ) discard;\n\t#endif\n#endif",
      uo = "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif",
      po = "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n#endif",
      mo = "#if NUM_CLIPPING_PLANES > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif",
      fo = "#if defined( USE_COLOR_ALPHA )\n\tdiffuseColor *= vColor;\n#elif defined( USE_COLOR )\n\tdiffuseColor.rgb *= vColor;\n#endif",
      go = "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR )\n\tvarying vec3 vColor;\n#endif",
      xo = "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvarying vec3 vColor;\n#endif",
      vo = "#if defined( USE_COLOR_ALPHA )\n\tvColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif",
      yo = "#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract(sin(sn) * c);\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat max3( vec3 v ) { return max( max( v.x, v.y ), v.z ); }\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\treturn - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}",
      _o = "#ifdef ENVMAP_TYPE_CUBE_UV\n\t#define cubeUV_maxMipLevel 8.0\n\t#define cubeUV_minMipLevel 4.0\n\t#define cubeUV_maxTileSize 256.0\n\t#define cubeUV_minTileSize 16.0\n\tfloat getFace( vec3 direction ) {\n\t\tvec3 absDirection = abs( direction );\n\t\tfloat face = - 1.0;\n\t\tif ( absDirection.x > absDirection.z ) {\n\t\t\tif ( absDirection.x > absDirection.y )\n\t\t\t\tface = direction.x > 0.0 ? 0.0 : 3.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t} else {\n\t\t\tif ( absDirection.z > absDirection.y )\n\t\t\t\tface = direction.z > 0.0 ? 2.0 : 5.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t}\n\t\treturn face;\n\t}\n\tvec2 getUV( vec3 direction, float face ) {\n\t\tvec2 uv;\n\t\tif ( face == 0.0 ) {\n\t\t\tuv = vec2( direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 1.0 ) {\n\t\t\tuv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n\t\t} else if ( face == 2.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.y ) / abs( direction.z );\n\t\t} else if ( face == 3.0 ) {\n\t\t\tuv = vec2( - direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 4.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.z ) / abs( direction.y );\n\t\t} else {\n\t\t\tuv = vec2( direction.x, direction.y ) / abs( direction.z );\n\t\t}\n\t\treturn 0.5 * ( uv + 1.0 );\n\t}\n\tvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n\t\tfloat face = getFace( direction );\n\t\tfloat filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n\t\tmipInt = max( mipInt, cubeUV_minMipLevel );\n\t\tfloat faceSize = exp2( mipInt );\n\t\tfloat texelSize = 1.0 / ( 3.0 * cubeUV_maxTileSize );\n\t\tvec2 uv = getUV( direction, face ) * ( faceSize - 1.0 );\n\t\tvec2 f = fract( uv );\n\t\tuv += 0.5 - f;\n\t\tif ( face > 2.0 ) {\n\t\t\tuv.y += faceSize;\n\t\t\tface -= 3.0;\n\t\t}\n\t\tuv.x += face * faceSize;\n\t\tif ( mipInt < cubeUV_maxMipLevel ) {\n\t\t\tuv.y += 2.0 * cubeUV_maxTileSize;\n\t\t}\n\t\tuv.y += filterInt * 2.0 * cubeUV_minTileSize;\n\t\tuv.x += 3.0 * max( 0.0, cubeUV_maxTileSize - 2.0 * faceSize );\n\t\tuv *= texelSize;\n\t\tvec3 tl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.x += texelSize;\n\t\tvec3 tr = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.y += texelSize;\n\t\tvec3 br = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.x -= texelSize;\n\t\tvec3 bl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tvec3 tm = mix( tl, tr, f.x );\n\t\tvec3 bm = mix( bl, br, f.x );\n\t\treturn mix( tm, bm, f.y );\n\t}\n\t#define r0 1.0\n\t#define v0 0.339\n\t#define m0 - 2.0\n\t#define r1 0.8\n\t#define v1 0.276\n\t#define m1 - 1.0\n\t#define r4 0.4\n\t#define v4 0.046\n\t#define m4 2.0\n\t#define r5 0.305\n\t#define v5 0.016\n\t#define m5 3.0\n\t#define r6 0.21\n\t#define v6 0.0038\n\t#define m6 4.0\n\tfloat roughnessToMip( float roughness ) {\n\t\tfloat mip = 0.0;\n\t\tif ( roughness >= r1 ) {\n\t\t\tmip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;\n\t\t} else if ( roughness >= r4 ) {\n\t\t\tmip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;\n\t\t} else if ( roughness >= r5 ) {\n\t\t\tmip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;\n\t\t} else if ( roughness >= r6 ) {\n\t\t\tmip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;\n\t\t} else {\n\t\t\tmip = - 2.0 * log2( 1.16 * roughness );\t\t}\n\t\treturn mip;\n\t}\n\tvec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n\t\tfloat mip = clamp( roughnessToMip( roughness ), m0, cubeUV_maxMipLevel );\n\t\tfloat mipF = fract( mip );\n\t\tfloat mipInt = floor( mip );\n\t\tvec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n\t\tif ( mipF == 0.0 ) {\n\t\t\treturn vec4( color0, 1.0 );\n\t\t} else {\n\t\t\tvec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n\t\t\treturn vec4( mix( color0, color1, mipF ), 1.0 );\n\t\t}\n\t}\n#endif",
      bo = "vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\tmat3 m = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\ttransformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif",
      wo = "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif",
      Mo = "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif",
      So = "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif",
      To = "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif",
      Eo = "gl_FragColor = linearToOutputTexel( gl_FragColor );",
      Ao = "\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * value.a * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat M = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat D = max( maxRange / maxRGB, 1.0 );\n\tD = clamp( floor( D ) / 255.0, 0.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value ) {\n\tvec3 Xp_Y_XYZp = cLogLuvM * value.rgb;\n\tXp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );\n\tvec4 vResult;\n\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n\tvResult.w = fract( Le );\n\tvResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;\n\treturn vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n\tfloat Le = value.z * 255.0 + value.w;\n\tvec3 Xp_Y_XYZp;\n\tXp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );\n\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n\tvec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;\n\treturn vec4( max( vRGB, 0.0 ), 1.0 );\n}",
      Lo = "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifndef ENVMAP_TYPE_CUBE_UV\n\t\tenvColor = envMapTexelToLinear( envColor );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif",
      Ro = "#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\tuniform int maxMipLevel;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif",
      Co = "#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif",
      Po = "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif",
      Do = "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif",
      Io = "#ifdef USE_FOG\n\tfogDepth = - mvPosition.z;\n#endif",
      Bo = "#ifdef USE_FOG\n\tvarying float fogDepth;\n#endif",
      No = "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * fogDepth * fogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif",
      Fo = "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float fogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif",
      zo = "#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn texture2D( gradientMap, coord ).rgb;\n\t#else\n\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t#endif\n}",
      Go = "#ifdef USE_LIGHTMAP\n\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\treflectedLight.indirectDiffuse += PI * lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n#endif",
      Oo = "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif",
      Ho = "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n\tvIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\nvIndirectFront += getAmbientLightIrradiance( ambientLightColor );\nvIndirectFront += getLightProbeIrradiance( lightProbe, geometry );\n#ifdef DOUBLE_SIDED\n\tvIndirectBack += getAmbientLightIrradiance( ambientLightColor );\n\tvIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry );\n#endif\n#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif",
      Uo = "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in GeometricContext geometry ) {\n\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treturn irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\t\tdirectLight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tdirectLight.color = pointLight.color;\n\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\t\tif ( angleCos > spotLight.coneCos ) {\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tirradiance *= PI;\n\t\t#endif\n\t\treturn irradiance;\n\t}\n#endif",
      ko = "#if defined( USE_ENVMAP )\n\t#ifdef ENVMAP_MODE_REFRACTION\n\t\tuniform float refractionRatio;\n\t#endif\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n\t\t#else\n\t\t\tvec4 envMapColor = vec4( 0.0 );\n\t\t#endif\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t}\n\tfloat getSpecularMIPLevel( const in float roughness, const in int maxMIPLevel ) {\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\t\tfloat sigma = PI * roughness * roughness / ( 1.0 + roughness );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar + log2( sigma );\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\t}\n\tvec3 getLightProbeIndirectRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in int maxMIPLevel ) {\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( -viewDir, normal );\n\t\t\treflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( -viewDir, normal, refractionRatio );\n\t\t#endif\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( roughness, maxMIPLevel );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n\t\t#endif\n\t\treturn envMapColor.rgb * envMapIntensity;\n\t}\n#endif",
      Vo = "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;",
      Wo = "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct ToonMaterial {\n\tvec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon\n#define Material_LightProbeLOD( material )\t(0)",
      jo = "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;",
      qo = "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n\tvec3 diffuseColor;\n\tvec3 specularColor;\n\tfloat specularShininess;\n\tfloat specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)",
      Xo = "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.specularRoughness = max( roughnessFactor, 0.0525 );material.specularRoughness += geometryRoughness;\nmaterial.specularRoughness = min( material.specularRoughness, 1.0 );\n#ifdef REFLECTIVITY\n\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#endif\n#ifdef CLEARCOAT\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\t#ifdef USE_CLEARCOATMAP\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vUv ).x;\n\t#endif\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\n\t#endif\n\tmaterial.clearcoat = saturate( material.clearcoat );\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheen;\n#endif",
      Yo = "struct PhysicalMaterial {\n\tvec3 diffuseColor;\n\tfloat specularRoughness;\n\tvec3 specularColor;\n#ifdef CLEARCOAT\n\tfloat clearcoat;\n\tfloat clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tvec3 sheenColor;\n#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearcoatDHRApprox( const in float roughness, const in float dotNL ) {\n\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.specularRoughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\t#ifdef CLEARCOAT\n\t\tfloat ccDotNL = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = ccDotNL * directLight.color;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tccIrradiance *= PI;\n\t\t#endif\n\t\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\t\treflectedLight.directSpecular += ccIrradiance * material.clearcoat * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n\t#else\n\t\tfloat clearcoatDHR = 0.0;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_Sheen(\n\t\t\tmaterial.specularRoughness,\n\t\t\tdirectLight.direction,\n\t\t\tgeometry,\n\t\t\tmaterial.sheenColor\n\t\t);\n\t#else\n\t\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.normal, material.specularColor, material.specularRoughness);\n\t#endif\n\treflectedLight.directDiffuse += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef CLEARCOAT\n\t\tfloat ccDotNV = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular += clearcoatRadiance * material.clearcoat * BRDF_Specular_GGX_Environment( geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n\t\tfloat ccDotNL = ccDotNV;\n\t\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\t#else\n\t\tfloat clearcoatDHR = 0.0;\n\t#endif\n\tfloat clearcoatInv = 1.0 - clearcoatDHR;\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\tBRDF_Specular_Multiscattering_Environment( geometry, material.specularColor, material.specularRoughness, singleScattering, multiScattering );\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );\n\treflectedLight.indirectSpecular += clearcoatInv * radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}",
      Zo = "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef CLEARCOAT\n\tgeometry.clearcoatNormal = clearcoatNormal;\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif",
      Jo = "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\tvec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.normal, material.specularRoughness, maxMipLevel );\n\t#ifdef CLEARCOAT\n\t\tclearcoatRadiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness, maxMipLevel );\n\t#endif\n#endif",
      Qo = "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif",
      Ko = "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif",
      $o = "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif",
      ta = "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif",
      ea = "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif",
      na = "#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif",
      ra = "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif",
      ia = "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n#endif\n#ifdef USE_MAP\n\tvec4 mapTexel = texture2D( map, uv );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif",
      sa = "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tuniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
      oa = "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif",
      aa = "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif",
      la = "#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n#endif",
      ca = "#ifdef USE_MORPHTARGETS\n\tuniform float morphTargetBaseInfluence;\n\t#ifndef USE_MORPHNORMALS\n\t\tuniform float morphTargetInfluences[ 8 ];\n\t#else\n\t\tuniform float morphTargetInfluences[ 4 ];\n\t#endif\n#endif",
      ha = "#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t#ifndef USE_MORPHNORMALS\n\t\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\t\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\t\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\t\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t#endif\n#endif",
      ua = "float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\t#ifdef USE_TANGENT\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\ttangent = tangent * faceDirection;\n\t\t\tbitangent = bitangent * faceDirection;\n\t\t#endif\n\t\t#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\t\t#endif\n\t#endif\n#endif\nvec3 geometryNormal = normal;",
      pa = "#ifdef OBJECTSPACE_NORMALMAP\n\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\t#ifdef USE_TANGENT\n\t\tnormal = normalize( vTBN * mapN );\n\t#else\n\t\tnormal = perturbNormal2Arb( -vViewPosition, normal, mapN, faceDirection );\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif",
      da = "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {\n\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tvec3 N = surf_norm;\n\t\tvec3 q1perp = cross( q1, N );\n\t\tvec3 q0perp = cross( N, q0 );\n\t\tvec3 T = q1perp * st0.x + q0perp * st1.x;\n\t\tvec3 B = q1perp * st0.y + q0perp * st1.y;\n\t\tfloat det = max( dot( T, T ), dot( B, B ) );\n\t\tfloat scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );\n\t\treturn normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );\n\t}\n#endif",
      ma = "#ifdef CLEARCOAT\n\tvec3 clearcoatNormal = geometryNormal;\n#endif",
      fa = "#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\t#ifdef USE_TANGENT\n\t\tclearcoatNormal = normalize( vTBN * clearcoatMapN );\n\t#else\n\t\tclearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );\n\t#endif\n#endif",
      ga = "#ifdef USE_CLEARCOATMAP\n\tuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform sampler2D clearcoatRoughnessMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif",
      xa = "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ));\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w);\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}",
      va = "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif",
      ya = "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;",
      _a = "#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif",
      ba = "#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif",
      wa = "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif",
      Ma = "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif",
      Sa = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif",
      Ta = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif",
      Ea = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0\n\t\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\tvec4 shadowWorldPosition;\n\t#endif\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n#endif",
      Aa = "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#endif\n\treturn shadow;\n}",
      La = "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif",
      Ra = "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform highp sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif",
      Ca = "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif",
      Pa = "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif",
      Da = "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif",
      Ia = "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif",
      Ba = "#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif",
      Na = "#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n\treturn a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tconst mat3 ACESInputMat = mat3(\n\t\tvec3( 0.59719, 0.07600, 0.02840 ),\t\tvec3( 0.35458, 0.90834, 0.13383 ),\n\t\tvec3( 0.04823, 0.01566, 0.83777 )\n\t);\n\tconst mat3 ACESOutputMat = mat3(\n\t\tvec3(  1.60475, -0.10208, -0.00327 ),\t\tvec3( -0.53108,  1.10813, -0.07276 ),\n\t\tvec3( -0.07367, -0.00605,  1.07602 )\n\t);\n\tcolor *= toneMappingExposure / 0.6;\n\tcolor = ACESInputMat * color;\n\tcolor = RRTAndODTFit( color );\n\tcolor = ACESOutputMat * color;\n\treturn saturate( color );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }",
      Fa = "#ifdef USE_TRANSMISSIONMAP\n\ttotalTransmission *= texture2D( transmissionMap, vUv ).r;\n#endif",
      za = "#ifdef USE_TRANSMISSIONMAP\n\tuniform sampler2D transmissionMap;\n#endif",
      Ga = "#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n\tvarying vec2 vUv;\n#endif",
      Oa = "#ifdef USE_UV\n\t#ifdef UVS_VERTEX_ONLY\n\t\tvec2 vUv;\n\t#else\n\t\tvarying vec2 vUv;\n\t#endif\n\tuniform mat3 uvTransform;\n#endif",
      Ha = "#ifdef USE_UV\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif",
      Ua = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif",
      ka = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n\tuniform mat3 uv2Transform;\n#endif",
      Va = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif",
      Wa = "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif",
      ja = "uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
      qa = "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}",
      Xa = "#include <envmap_common_pars_fragment>\nuniform float opacity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\tvec3 vReflect = vWorldDirection;\n\t#include <envmap_fragment>\n\tgl_FragColor = envColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
      Ya = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}",
      Za = "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t#endif\n}",
      Ja = "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}",
      Qa = "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}",
      Ka = "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}",
      $a = "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV = equirectUv( direction );\n\tvec4 texColor = texture2D( tEquirect, sampleUV );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
      tl = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}",
      el = "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",
      nl = "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvLineDistance = scale * lineDistance;\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",
      rl = "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\treflectedLight.indirectDiffuse += lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
      il = "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_ENVMAP\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}",
      sl = "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n\t#else\n\t\treflectedLight.indirectDiffuse += vIndirectFront;\n\t#endif\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
      ol = "#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
      al = "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t\tmatcapColor = matcapTexelToLinear( matcapColor );\n\t#else\n\t\tvec4 matcapColor = vec4( 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
      ll = "#define MATCAP\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#ifndef FLAT_SHADED\n\t\tvNormal = normalize( transformedNormal );\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}",
      cl = "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
      hl = "#define TOON\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
      ul = "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
      pl = "#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
      dl = "#define STANDARD\n#ifdef PHYSICAL\n\t#define REFLECTIVITY\n\t#define CLEARCOAT\n\t#define TRANSMISSION\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef TRANSMISSION\n\tuniform float transmission;\n#endif\n#ifdef REFLECTIVITY\n\tuniform float reflectivity;\n#endif\n#ifdef CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheen;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <transmissionmap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#ifdef TRANSMISSION\n\t\tfloat totalTransmission = transmission;\n\t#endif\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <transmissionmap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#ifdef TRANSMISSION\n\t\tdiffuseColor.a *= mix( saturate( 1. - totalTransmission + linearToRelativeLuminance( reflectedLight.directSpecular + reflectedLight.indirectSpecular ) ), 1.0, metalness );\n\t#endif\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
      ml = "#define STANDARD\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
      fl = "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}",
      gl = "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}",
      xl = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",
      vl = "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}",
      yl = "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
      _l = "#include <common>\n#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
      bl = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
      wl = "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}";
    const Ml = {
      alphamap_fragment: eo,
      alphamap_pars_fragment: no,
      alphatest_fragment: ro,
      aomap_fragment: io,
      aomap_pars_fragment: so,
      begin_vertex: oo,
      beginnormal_vertex: ao,
      bsdfs: lo,
      bumpmap_pars_fragment: co,
      clipping_planes_fragment: ho,
      clipping_planes_pars_fragment: uo,
      clipping_planes_pars_vertex: po,
      clipping_planes_vertex: mo,
      color_fragment: fo,
      color_pars_fragment: go,
      color_pars_vertex: xo,
      color_vertex: vo,
      common: yo,
      cube_uv_reflection_fragment: _o,
      defaultnormal_vertex: bo,
      displacementmap_pars_vertex: wo,
      displacementmap_vertex: Mo,
      emissivemap_fragment: So,
      emissivemap_pars_fragment: To,
      encodings_fragment: Eo,
      encodings_pars_fragment: Ao,
      envmap_fragment: Lo,
      envmap_common_pars_fragment: Ro,
      envmap_pars_fragment: Co,
      envmap_pars_vertex: Po,
      envmap_physical_pars_fragment: ko,
      envmap_vertex: Do,
      fog_vertex: Io,
      fog_pars_vertex: Bo,
      fog_fragment: No,
      fog_pars_fragment: Fo,
      gradientmap_pars_fragment: zo,
      lightmap_fragment: Go,
      lightmap_pars_fragment: Oo,
      lights_lambert_vertex: Ho,
      lights_pars_begin: Uo,
      lights_toon_fragment: Vo,
      lights_toon_pars_fragment: Wo,
      lights_phong_fragment: jo,
      lights_phong_pars_fragment: qo,
      lights_physical_fragment: Xo,
      lights_physical_pars_fragment: Yo,
      lights_fragment_begin: Zo,
      lights_fragment_maps: Jo,
      lights_fragment_end: Qo,
      logdepthbuf_fragment: Ko,
      logdepthbuf_pars_fragment: $o,
      logdepthbuf_pars_vertex: ta,
      logdepthbuf_vertex: ea,
      map_fragment: na,
      map_pars_fragment: ra,
      map_particle_fragment: ia,
      map_particle_pars_fragment: sa,
      metalnessmap_fragment: oa,
      metalnessmap_pars_fragment: aa,
      morphnormal_vertex: la,
      morphtarget_pars_vertex: ca,
      morphtarget_vertex: ha,
      normal_fragment_begin: ua,
      normal_fragment_maps: pa,
      normalmap_pars_fragment: da,
      clearcoat_normal_fragment_begin: ma,
      clearcoat_normal_fragment_maps: fa,
      clearcoat_pars_fragment: ga,
      packing: xa,
      premultiplied_alpha_fragment: va,
      project_vertex: ya,
      dithering_fragment: _a,
      dithering_pars_fragment: ba,
      roughnessmap_fragment: wa,
      roughnessmap_pars_fragment: Ma,
      shadowmap_pars_fragment: Sa,
      shadowmap_pars_vertex: Ta,
      shadowmap_vertex: Ea,
      shadowmask_pars_fragment: Aa,
      skinbase_vertex: La,
      skinning_pars_vertex: Ra,
      skinning_vertex: Ca,
      skinnormal_vertex: Pa,
      specularmap_fragment: Da,
      specularmap_pars_fragment: Ia,
      tonemapping_fragment: Ba,
      tonemapping_pars_fragment: Na,
      transmissionmap_fragment: Fa,
      transmissionmap_pars_fragment: za,
      uv_pars_fragment: Ga,
      uv_pars_vertex: Oa,
      uv_vertex: Ha,
      uv2_pars_fragment: Ua,
      uv2_pars_vertex: ka,
      uv2_vertex: Va,
      worldpos_vertex: Wa,
      background_frag: ja,
      background_vert: qa,
      cube_frag: Xa,
      cube_vert: Ya,
      depth_frag: Za,
      depth_vert: Ja,
      distanceRGBA_frag: Qa,
      distanceRGBA_vert: Ka,
      equirect_frag: $a,
      equirect_vert: tl,
      linedashed_frag: el,
      linedashed_vert: nl,
      meshbasic_frag: rl,
      meshbasic_vert: il,
      meshlambert_frag: sl,
      meshlambert_vert: ol,
      meshmatcap_frag: al,
      meshmatcap_vert: ll,
      meshtoon_frag: cl,
      meshtoon_vert: hl,
      meshphong_frag: ul,
      meshphong_vert: pl,
      meshphysical_frag: dl,
      meshphysical_vert: ml,
      normal_frag: fl,
      normal_vert: gl,
      points_frag: xl,
      points_vert: vl,
      shadow_frag: yl,
      shadow_vert: _l,
      sprite_frag: bl,
      sprite_vert: wl
    };
    exports.ShaderChunk = Ml;
    const Sl = {
      common: {
        diffuse: {
          value: new ki(15658734)
        },
        opacity: {
          value: 1
        },
        map: {
          value: null
        },
        uvTransform: {
          value: new or
        },
        uv2Transform: {
          value: new or
        },
        alphaMap: {
          value: null
        }
      },
      specularmap: {
        specularMap: {
          value: null
        }
      },
      envmap: {
        envMap: {
          value: null
        },
        flipEnvMap: {
          value: -1
        },
        reflectivity: {
          value: 1
        },
        refractionRatio: {
          value: .98
        },
        maxMipLevel: {
          value: 0
        }
      },
      aomap: {
        aoMap: {
          value: null
        },
        aoMapIntensity: {
          value: 1
        }
      },
      lightmap: {
        lightMap: {
          value: null
        },
        lightMapIntensity: {
          value: 1
        }
      },
      emissivemap: {
        emissiveMap: {
          value: null
        }
      },
      bumpmap: {
        bumpMap: {
          value: null
        },
        bumpScale: {
          value: 1
        }
      },
      normalmap: {
        normalMap: {
          value: null
        },
        normalScale: {
          value: new sr(1, 1)
        }
      },
      displacementmap: {
        displacementMap: {
          value: null
        },
        displacementScale: {
          value: 1
        },
        displacementBias: {
          value: 0
        }
      },
      roughnessmap: {
        roughnessMap: {
          value: null
        }
      },
      metalnessmap: {
        metalnessMap: {
          value: null
        }
      },
      gradientmap: {
        gradientMap: {
          value: null
        }
      },
      fog: {
        fogDensity: {
          value: 25e-5
        },
        fogNear: {
          value: 1
        },
        fogFar: {
          value: 2e3
        },
        fogColor: {
          value: new ki(16777215)
        }
      },
      lights: {
        ambientLightColor: {
          value: []
        },
        lightProbe: {
          value: []
        },
        directionalLights: {
          value: [],
          properties: {
            direction: {},
            color: {}
          }
        },
        directionalLightShadows: {
          value: [],
          properties: {
            shadowBias: {},
            shadowNormalBias: {},
            shadowRadius: {},
            shadowMapSize: {}
          }
        },
        directionalShadowMap: {
          value: []
        },
        directionalShadowMatrix: {
          value: []
        },
        spotLights: {
          value: [],
          properties: {
            color: {},
            position: {},
            direction: {},
            distance: {},
            coneCos: {},
            penumbraCos: {},
            decay: {}
          }
        },
        spotLightShadows: {
          value: [],
          properties: {
            shadowBias: {},
            shadowNormalBias: {},
            shadowRadius: {},
            shadowMapSize: {}
          }
        },
        spotShadowMap: {
          value: []
        },
        spotShadowMatrix: {
          value: []
        },
        pointLights: {
          value: [],
          properties: {
            color: {},
            position: {},
            decay: {},
            distance: {}
          }
        },
        pointLightShadows: {
          value: [],
          properties: {
            shadowBias: {},
            shadowNormalBias: {},
            shadowRadius: {},
            shadowMapSize: {},
            shadowCameraNear: {},
            shadowCameraFar: {}
          }
        },
        pointShadowMap: {
          value: []
        },
        pointShadowMatrix: {
          value: []
        },
        hemisphereLights: {
          value: [],
          properties: {
            direction: {},
            skyColor: {},
            groundColor: {}
          }
        },
        rectAreaLights: {
          value: [],
          properties: {
            color: {},
            position: {},
            width: {},
            height: {}
          }
        },
        ltc_1: {
          value: null
        },
        ltc_2: {
          value: null
        }
      },
      points: {
        diffuse: {
          value: new ki(15658734)
        },
        opacity: {
          value: 1
        },
        size: {
          value: 1
        },
        scale: {
          value: 1
        },
        map: {
          value: null
        },
        alphaMap: {
          value: null
        },
        uvTransform: {
          value: new or
        }
      },
      sprite: {
        diffuse: {
          value: new ki(15658734)
        },
        opacity: {
          value: 1
        },
        center: {
          value: new sr(.5, .5)
        },
        rotation: {
          value: 0
        },
        map: {
          value: null
        },
        alphaMap: {
          value: null
        },
        uvTransform: {
          value: new or
        }
      }
    };
    exports.UniformsLib = Sl;
    const Tl = {
      basic: {
        uniforms: Fs([Sl.common, Sl.specularmap, Sl.envmap, Sl.aomap, Sl.lightmap, Sl.fog]),
        vertexShader: Ml.meshbasic_vert,
        fragmentShader: Ml.meshbasic_frag
      },
      lambert: {
        uniforms: Fs([Sl.common, Sl.specularmap, Sl.envmap, Sl.aomap, Sl.lightmap, Sl.emissivemap, Sl.fog, Sl.lights, {
          emissive: {
            value: new ki(0)
          }
        }]),
        vertexShader: Ml.meshlambert_vert,
        fragmentShader: Ml.meshlambert_frag
      },
      phong: {
        uniforms: Fs([Sl.common, Sl.specularmap, Sl.envmap, Sl.aomap, Sl.lightmap, Sl.emissivemap, Sl.bumpmap, Sl.normalmap, Sl.displacementmap, Sl.fog, Sl.lights, {
          emissive: {
            value: new ki(0)
          },
          specular: {
            value: new ki(1118481)
          },
          shininess: {
            value: 30
          }
        }]),
        vertexShader: Ml.meshphong_vert,
        fragmentShader: Ml.meshphong_frag
      },
      standard: {
        uniforms: Fs([Sl.common, Sl.envmap, Sl.aomap, Sl.lightmap, Sl.emissivemap, Sl.bumpmap, Sl.normalmap, Sl.displacementmap, Sl.roughnessmap, Sl.metalnessmap, Sl.fog, Sl.lights, {
          emissive: {
            value: new ki(0)
          },
          roughness: {
            value: 1
          },
          metalness: {
            value: 0
          },
          envMapIntensity: {
            value: 1
          }
        }]),
        vertexShader: Ml.meshphysical_vert,
        fragmentShader: Ml.meshphysical_frag
      },
      toon: {
        uniforms: Fs([Sl.common, Sl.aomap, Sl.lightmap, Sl.emissivemap, Sl.bumpmap, Sl.normalmap, Sl.displacementmap, Sl.gradientmap, Sl.fog, Sl.lights, {
          emissive: {
            value: new ki(0)
          }
        }]),
        vertexShader: Ml.meshtoon_vert,
        fragmentShader: Ml.meshtoon_frag
      },
      matcap: {
        uniforms: Fs([Sl.common, Sl.bumpmap, Sl.normalmap, Sl.displacementmap, Sl.fog, {
          matcap: {
            value: null
          }
        }]),
        vertexShader: Ml.meshmatcap_vert,
        fragmentShader: Ml.meshmatcap_frag
      },
      points: {
        uniforms: Fs([Sl.points, Sl.fog]),
        vertexShader: Ml.points_vert,
        fragmentShader: Ml.points_frag
      },
      dashed: {
        uniforms: Fs([Sl.common, Sl.fog, {
          scale: {
            value: 1
          },
          dashSize: {
            value: 1
          },
          totalSize: {
            value: 2
          }
        }]),
        vertexShader: Ml.linedashed_vert,
        fragmentShader: Ml.linedashed_frag
      },
      depth: {
        uniforms: Fs([Sl.common, Sl.displacementmap]),
        vertexShader: Ml.depth_vert,
        fragmentShader: Ml.depth_frag
      },
      normal: {
        uniforms: Fs([Sl.common, Sl.bumpmap, Sl.normalmap, Sl.displacementmap, {
          opacity: {
            value: 1
          }
        }]),
        vertexShader: Ml.normal_vert,
        fragmentShader: Ml.normal_frag
      },
      sprite: {
        uniforms: Fs([Sl.sprite, Sl.fog]),
        vertexShader: Ml.sprite_vert,
        fragmentShader: Ml.sprite_frag
      },
      background: {
        uniforms: {
          uvTransform: {
            value: new or
          },
          t2D: {
            value: null
          }
        },
        vertexShader: Ml.background_vert,
        fragmentShader: Ml.background_frag
      },
      cube: {
        uniforms: Fs([Sl.envmap, {
          opacity: {
            value: 1
          }
        }]),
        vertexShader: Ml.cube_vert,
        fragmentShader: Ml.cube_frag
      },
      equirect: {
        uniforms: {
          tEquirect: {
            value: null
          }
        },
        vertexShader: Ml.equirect_vert,
        fragmentShader: Ml.equirect_frag
      },
      distanceRGBA: {
        uniforms: Fs([Sl.common, Sl.displacementmap, {
          referencePosition: {
            value: new gr
          },
          nearDistance: {
            value: 1
          },
          farDistance: {
            value: 1e3
          }
        }]),
        vertexShader: Ml.distanceRGBA_vert,
        fragmentShader: Ml.distanceRGBA_frag
      },
      shadow: {
        uniforms: Fs([Sl.lights, Sl.fog, {
          color: {
            value: new ki(0)
          },
          opacity: {
            value: 1
          }
        }]),
        vertexShader: Ml.shadow_vert,
        fragmentShader: Ml.shadow_frag
      }
    };

    function El(t, e, n, r, i) {
      const s = new ki(0);
      let o, a, l = 0,
        c = null,
        h = 0,
        d = null;

      function m(t, e) {
        n.buffers.color.setClear(t.r, t.g, t.b, e, i)
      }
      return {
        getClearColor: function() {
          return s
        },
        setClearColor: function(t, e = 1) {
          s.set(t), m(s, l = e)
        },
        getClearAlpha: function() {
          return l
        },
        setClearAlpha: function(t) {
          m(s, l = t)
        },
        render: function(n, i, f, g) {
          let x = !0 === i.isScene ? i.background : null;
          x && x.isTexture && (x = e.get(x));
          const v = t.xr,
            y = v.getSession && v.getSession();
          y && "additive" === y.environmentBlendMode && (x = null), null === x ? m(s, l) : x && x.isColor && (m(x, 1), g = !0), (t.autoClear || g) && t.clear(t.autoClearColor, t.autoClearDepth, t.autoClearStencil), x && (x.isCubeTexture || x.mapping === ot) ? (void 0 === a && ((a = new Ps(new Bs(1, 1, 1), new Hs({
            name: "BackgroundCubeMaterial",
            uniforms: Ns(Tl.cube.uniforms),
            vertexShader: Tl.cube.vertexShader,
            fragmentShader: Tl.cube.fragmentShader,
            side: p,
            depthTest: !1,
            depthWrite: !1,
            fog: !1
          }))).geometry.deleteAttribute("normal"), a.geometry.deleteAttribute("uv"), a.onBeforeRender = function(t, e, n) {
            this.matrixWorld.copyPosition(n.matrixWorld)
          }, Object.defineProperty(a.material, "envMap", {
            get: function() {
              return this.uniforms.envMap.value
            }
          }), r.update(a)), a.material.uniforms.envMap.value = x, a.material.uniforms.flipEnvMap.value = x.isCubeTexture && x._needsFlipEnvMap ? -1 : 1, c === x && h === x.version && d === t.toneMapping || (a.material.needsUpdate = !0, c = x, h = x.version, d = t.toneMapping), n.unshift(a, a.geometry, a.material, 0, 0, null)) : x && x.isTexture && (void 0 === o && ((o = new Ps(new to(2, 2), new Hs({
            name: "BackgroundMaterial",
            uniforms: Ns(Tl.background.uniforms),
            vertexShader: Tl.background.vertexShader,
            fragmentShader: Tl.background.fragmentShader,
            side: u,
            depthTest: !1,
            depthWrite: !1,
            fog: !1
          }))).geometry.deleteAttribute("normal"), Object.defineProperty(o.material, "map", {
            get: function() {
              return this.uniforms.t2D.value
            }
          }), r.update(o)), o.material.uniforms.t2D.value = x, !0 === x.matrixAutoUpdate && x.updateMatrix(), o.material.uniforms.uvTransform.value.copy(x.matrix), c === x && h === x.version && d === t.toneMapping || (o.material.needsUpdate = !0, c = x, h = x.version, d = t.toneMapping), n.unshift(o, o.geometry, o.material, 0, 0, null))
        }
      }
    }

    function Al(t, e, n, r) {
      const i = t.getParameter(34921),
        s = r.isWebGL2 ? null : e.get("OES_vertex_array_object"),
        o = r.isWebGL2 || null !== s,
        a = {},
        l = p(null);
      let c = l;

      function h(e) {
        return r.isWebGL2 ? t.bindVertexArray(e) : s.bindVertexArrayOES(e)
      }

      function u(e) {
        return r.isWebGL2 ? t.deleteVertexArray(e) : s.deleteVertexArrayOES(e)
      }

      function p(t) {
        const e = [],
          n = [],
          r = [];
        for (let s = 0; s < i; s++) e[s] = 0, n[s] = 0, r[s] = 0;
        return {
          geometry: null,
          program: null,
          wireframe: !1,
          newAttributes: e,
          enabledAttributes: n,
          attributeDivisors: r,
          object: t,
          attributes: {},
          index: null
        }
      }

      function d() {
        const t = c.newAttributes;
        for (let e = 0, n = t.length; e < n; e++) t[e] = 0
      }

      function m(t) {
        f(t, 0)
      }

      function f(n, i) {
        const s = c.newAttributes,
          o = c.enabledAttributes,
          a = c.attributeDivisors;
        if (s[n] = 1, 0 === o[n] && (t.enableVertexAttribArray(n), o[n] = 1), a[n] !== i) {
          (r.isWebGL2 ? t : e.get("ANGLE_instanced_arrays"))[r.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](n, i), a[n] = i
        }
      }

      function g() {
        const e = c.newAttributes,
          n = c.enabledAttributes;
        for (let r = 0, i = n.length; r < i; r++) n[r] !== e[r] && (t.disableVertexAttribArray(r), n[r] = 0)
      }

      function x(e, n, i, s, o, a) {
        !0 !== r.isWebGL2 || 5124 !== i && 5125 !== i ? t.vertexAttribPointer(e, n, i, s, o, a) : t.vertexAttribIPointer(e, n, i, o, a)
      }

      function v() {
        y(), c !== l && h((c = l).object)
      }

      function y() {
        l.geometry = null, l.program = null, l.wireframe = !1
      }
      return {
        setup: function(i, l, u, v, y) {
          let _ = !1;
          if (o) {
            const e = function(e, n, i) {
              const o = !0 === i.wireframe;
              let l = a[e.id];
              void 0 === l && (l = {}, a[e.id] = l);
              let c = l[n.id];
              void 0 === c && (c = {}, l[n.id] = c);
              let h = c[o];
              return void 0 === h && (h = p(r.isWebGL2 ? t.createVertexArray() : s.createVertexArrayOES()), c[o] = h), h
            }(v, u, l);
            c !== e && h((c = e).object), (_ = function(t, e) {
              const n = c.attributes,
                r = t.attributes;
              let i = 0;
              for (const s in r) {
                const t = n[s],
                  e = r[s];
                if (void 0 === t) return !0;
                if (t.attribute !== e) return !0;
                if (t.data !== e.data) return !0;
                i++
              }
              return c.attributesNum !== i || c.index !== e
            }(v, y)) && function(t, e) {
              const n = {},
                r = t.attributes;
              let i = 0;
              for (const s in r) {
                const t = r[s],
                  e = {};
                e.attribute = t, t.data && (e.data = t.data), n[s] = e, i++
              }
              c.attributes = n, c.attributesNum = i, c.index = e
            }(v, y)
          } else {
            const t = !0 === l.wireframe;
            c.geometry === v.id && c.program === u.id && c.wireframe === t || (c.geometry = v.id, c.program = u.id, c.wireframe = t, _ = !0)
          }!0 === i.isInstancedMesh && (_ = !0), null !== y && n.update(y, 34963), _ && (function(i, s, o, a) {
            if (!1 === r.isWebGL2 && (i.isInstancedMesh || a.isInstancedBufferGeometry) && null === e.get("ANGLE_instanced_arrays")) return;
            d();
            const l = a.attributes,
              c = o.getAttributes(),
              h = s.defaultAttributeValues;
            for (const e in c) {
              const r = c[e];
              if (r >= 0) {
                const s = l[e];
                if (void 0 !== s) {
                  const e = s.normalized,
                    i = s.itemSize,
                    o = n.get(s);
                  if (void 0 === o) continue;
                  const l = o.buffer,
                    c = o.type,
                    h = o.bytesPerElement;
                  if (s.isInterleavedBufferAttribute) {
                    const n = s.data,
                      o = n.stride,
                      u = s.offset;
                    n && n.isInstancedInterleavedBuffer ? (f(r, n.meshPerAttribute), void 0 === a._maxInstanceCount && (a._maxInstanceCount = n.meshPerAttribute * n.count)) : m(r), t.bindBuffer(34962, l), x(r, i, c, e, o * h, u * h)
                  } else s.isInstancedBufferAttribute ? (f(r, s.meshPerAttribute), void 0 === a._maxInstanceCount && (a._maxInstanceCount = s.meshPerAttribute * s.count)) : m(r), t.bindBuffer(34962, l), x(r, i, c, e, 0, 0)
                } else if ("instanceMatrix" === e) {
                  const e = n.get(i.instanceMatrix);
                  if (void 0 === e) continue;
                  const s = e.buffer,
                    o = e.type;
                  f(r + 0, 1), f(r + 1, 1), f(r + 2, 1), f(r + 3, 1), t.bindBuffer(34962, s), t.vertexAttribPointer(r + 0, 4, o, !1, 64, 0), t.vertexAttribPointer(r + 1, 4, o, !1, 64, 16), t.vertexAttribPointer(r + 2, 4, o, !1, 64, 32), t.vertexAttribPointer(r + 3, 4, o, !1, 64, 48)
                } else if ("instanceColor" === e) {
                  const e = n.get(i.instanceColor);
                  if (void 0 === e) continue;
                  const s = e.buffer,
                    o = e.type;
                  f(r, 1), t.bindBuffer(34962, s), t.vertexAttribPointer(r, 3, o, !1, 12, 0)
                } else if (void 0 !== h) {
                  const n = h[e];
                  if (void 0 !== n) switch (n.length) {
                    case 2:
                      t.vertexAttrib2fv(r, n);
                      break;
                    case 3:
                      t.vertexAttrib3fv(r, n);
                      break;
                    case 4:
                      t.vertexAttrib4fv(r, n);
                      break;
                    default:
                      t.vertexAttrib1fv(r, n)
                  }
                }
              }
            }
            g()
          }(i, l, u, v), null !== y && t.bindBuffer(34963, n.get(y).buffer))
        },
        reset: v,
        resetDefaultState: y,
        dispose: function() {
          v();
          for (const t in a) {
            const e = a[t];
            for (const t in e) {
              const n = e[t];
              for (const t in n) u(n[t].object), delete n[t];
              delete e[t]
            }
            delete a[t]
          }
        },
        releaseStatesOfGeometry: function(t) {
          if (void 0 === a[t.id]) return;
          const e = a[t.id];
          for (const n in e) {
            const t = e[n];
            for (const e in t) u(t[e].object), delete t[e];
            delete e[n]
          }
          delete a[t.id]
        },
        releaseStatesOfProgram: function(t) {
          for (const e in a) {
            const n = a[e];
            if (void 0 === n[t.id]) continue;
            const r = n[t.id];
            for (const t in r) u(r[t].object), delete r[t];
            delete n[t.id]
          }
        },
        initAttributes: d,
        enableAttribute: m,
        disableUnusedAttributes: g
      }
    }

    function Ll(t, e, n, r) {
      const i = r.isWebGL2;
      let s;
      this.setMode = function(t) {
        s = t
      }, this.render = function(e, r) {
        t.drawArrays(s, e, r), n.update(r, s, 1)
      }, this.renderInstances = function(r, o, a) {
        if (0 === a) return;
        let l, c;
        if (i) l = t, c = "drawArraysInstanced";
        else if (c = "drawArraysInstancedANGLE", null === (l = e.get("ANGLE_instanced_arrays"))) return void console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
        l[c](s, r, o, a), n.update(o, s, a)
      }
    }

    function Rl(t, e, n) {
      let r;

      function i(e) {
        if ("highp" === e) {
          if (t.getShaderPrecisionFormat(35633, 36338).precision > 0 && t.getShaderPrecisionFormat(35632, 36338).precision > 0) return "highp";
          e = "mediump"
        }
        return "mediump" === e && t.getShaderPrecisionFormat(35633, 36337).precision > 0 && t.getShaderPrecisionFormat(35632, 36337).precision > 0 ? "mediump" : "lowp"
      }
      const s = "undefined" != typeof WebGL2RenderingContext && t instanceof WebGL2RenderingContext || "undefined" != typeof WebGL2ComputeRenderingContext && t instanceof WebGL2ComputeRenderingContext;
      let o = void 0 !== n.precision ? n.precision : "highp";
      const a = i(o);
      a !== o && (console.warn("THREE.WebGLRenderer:", o, "not supported, using", a, "instead."), o = a);
      const l = !0 === n.logarithmicDepthBuffer,
        c = t.getParameter(34930),
        h = t.getParameter(35660),
        u = t.getParameter(3379),
        p = t.getParameter(34076),
        d = t.getParameter(34921),
        m = t.getParameter(36347),
        f = t.getParameter(36348),
        g = t.getParameter(36349),
        x = h > 0,
        v = s || e.has("OES_texture_float");
      return {
        isWebGL2: s,
        getMaxAnisotropy: function() {
          if (void 0 !== r) return r;
          if (!0 === e.has("EXT_texture_filter_anisotropic")) {
            const n = e.get("EXT_texture_filter_anisotropic");
            r = t.getParameter(n.MAX_TEXTURE_MAX_ANISOTROPY_EXT)
          } else r = 0;
          return r
        },
        getMaxPrecision: i,
        precision: o,
        logarithmicDepthBuffer: l,
        maxTextures: c,
        maxVertexTextures: h,
        maxTextureSize: u,
        maxCubemapSize: p,
        maxAttributes: d,
        maxVertexUniforms: m,
        maxVaryings: f,
        maxFragmentUniforms: g,
        vertexTextures: x,
        floatFragmentTextures: v,
        floatVertexTextures: x && v,
        maxSamples: s ? t.getParameter(36183) : 0
      }
    }

    function Cl(t) {
      const e = this;
      let n = null,
        r = 0,
        i = !1,
        s = !1;
      const o = new wi,
        a = new or,
        l = {
          value: null,
          needsUpdate: !1
        };

      function c() {
        l.value !== n && (l.value = n, l.needsUpdate = r > 0), e.numPlanes = r, e.numIntersection = 0
      }

      function h(t, n, r, i) {
        const s = null !== t ? t.length : 0;
        let c = null;
        if (0 !== s) {
          if (c = l.value, !0 !== i || null === c) {
            const e = r + 4 * s,
              i = n.matrixWorldInverse;
            a.getNormalMatrix(i), (null === c || c.length < e) && (c = new Float32Array(e));
            for (let n = 0, l = r; n !== s; ++n, l += 4) o.copy(t[n]).applyMatrix4(i, a), o.normal.toArray(c, l), c[l + 3] = o.constant
          }
          l.value = c, l.needsUpdate = !0
        }
        return e.numPlanes = s, e.numIntersection = 0, c
      }
      this.uniform = l, this.numPlanes = 0, this.numIntersection = 0, this.init = function(t, e, s) {
        const o = 0 !== t.length || e || 0 !== r || i;
        return i = e, n = h(t, s, 0), r = t.length, o
      }, this.beginShadows = function() {
        s = !0, h(null)
      }, this.endShadows = function() {
        s = !1, c()
      }, this.setState = function(e, o, a) {
        const u = e.clippingPlanes,
          p = e.clipIntersection,
          d = e.clipShadows,
          m = t.get(e);
        if (!i || null === u || 0 === u.length || s && !d) s ? h(null) : c();
        else {
          const t = s ? 0 : r,
            e = 4 * t;
          let i = m.clippingState || null;
          l.value = i, i = h(u, o, e, a);
          for (let r = 0; r !== e; ++r) i[r] = n[r];
          m.clippingState = i, this.numIntersection = p ? this.numPlanes : 0, this.numPlanes += t
        }
      }
    }

    function Pl(t) {
      let e = new WeakMap;

      function n(t, e) {
        return e === it ? t.mapping = nt : e === st && (t.mapping = rt), t
      }

      function r(t) {
        const n = t.target;
        n.removeEventListener("dispose", r);
        const i = e.get(n);
        void 0 !== i && (e.delete(n), i.dispose())
      }
      return {
        get: function(i) {
          if (i && i.isTexture) {
            const s = i.mapping;
            if (s === it || s === st) {
              if (e.has(i)) return n(e.get(i).texture, i.mapping); {
                const s = i.image;
                if (s && s.height > 0) {
                  const o = t.getRenderTarget(),
                    a = new Xs(s.height / 2);
                  return a.fromEquirectangularTexture(t, i), e.set(i, a), t.setRenderTarget(o), i.addEventListener("dispose", r), n(a.texture, i.mapping)
                }
                return null
              }
            }
          }
          return i
        },
        dispose: function() {
          e = new WeakMap
        }
      }
    }

    function Dl(t) {
      const e = {};

      function n(n) {
        if (void 0 !== e[n]) return e[n];
        let r;
        switch (n) {
          case "WEBGL_depth_texture":
            r = t.getExtension("WEBGL_depth_texture") || t.getExtension("MOZ_WEBGL_depth_texture") || t.getExtension("WEBKIT_WEBGL_depth_texture");
            break;
          case "EXT_texture_filter_anisotropic":
            r = t.getExtension("EXT_texture_filter_anisotropic") || t.getExtension("MOZ_EXT_texture_filter_anisotropic") || t.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
            break;
          case "WEBGL_compressed_texture_s3tc":
            r = t.getExtension("WEBGL_compressed_texture_s3tc") || t.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || t.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
            break;
          case "WEBGL_compressed_texture_pvrtc":
            r = t.getExtension("WEBGL_compressed_texture_pvrtc") || t.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
            break;
          default:
            r = t.getExtension(n)
        }
        return e[n] = r, r
      }
      return {
        has: function(t) {
          return null !== n(t)
        },
        init: function(t) {
          t.isWebGL2 ? n("EXT_color_buffer_float") : (n("WEBGL_depth_texture"), n("OES_texture_float"), n("OES_texture_half_float"), n("OES_texture_half_float_linear"), n("OES_standard_derivatives"), n("OES_element_index_uint"), n("OES_vertex_array_object"), n("ANGLE_instanced_arrays")), n("OES_texture_float_linear"), n("EXT_color_buffer_half_float")
        },
        get: function(t) {
          const e = n(t);
          return null === e && console.warn("THREE.WebGLRenderer: " + t + " extension not supported."), e
        }
      }
    }

    function Il(t, e, n, r) {
      const i = {},
        s = new WeakMap;

      function o(t) {
        const a = t.target;
        null !== a.index && e.remove(a.index);
        for (const n in a.attributes) e.remove(a.attributes[n]);
        a.removeEventListener("dispose", o), delete i[a.id];
        const l = s.get(a);
        l && (e.remove(l), s.delete(a)), r.releaseStatesOfGeometry(a), !0 === a.isInstancedBufferGeometry && delete a._maxInstanceCount, n.memory.geometries--
      }

      function a(t) {
        const n = [],
          r = t.index,
          i = t.attributes.position;
        let o = 0;
        if (null !== r) {
          const t = r.array;
          o = r.version;
          for (let e = 0, r = t.length; e < r; e += 3) {
            const r = t[e + 0],
              i = t[e + 1],
              s = t[e + 2];
            n.push(r, i, i, s, s, r)
          }
        } else {
          const t = i.array;
          o = i.version;
          for (let e = 0, r = t.length / 3 - 1; e < r; e += 3) {
            const t = e + 0,
              r = e + 1,
              i = e + 2;
            n.push(t, r, r, i, i, t)
          }
        }
        const a = new(rs(n) > 65535 ? $i : Qi)(n, 1);
        a.version = o;
        const l = s.get(t);
        l && e.remove(l), s.set(t, a)
      }
      return {
        get: function(t, e) {
          return !0 === i[e.id] ? e : (e.addEventListener("dispose", o), i[e.id] = !0, n.memory.geometries++, e)
        },
        update: function(t) {
          const n = t.attributes;
          for (const i in n) e.update(n[i], 34962);
          const r = t.morphAttributes;
          for (const i in r) {
            const t = r[i];
            for (let n = 0, r = t.length; n < r; n++) e.update(t[n], 34962)
          }
        },
        getWireframeAttribute: function(t) {
          const e = s.get(t);
          if (e) {
            const n = t.index;
            null !== n && e.version < n.version && a(t)
          } else a(t);
          return s.get(t)
        }
      }
    }

    function Bl(t, e, n, r) {
      const i = r.isWebGL2;
      let s, o, a;
      this.setMode = function(t) {
        s = t
      }, this.setIndex = function(t) {
        o = t.type, a = t.bytesPerElement
      }, this.render = function(e, r) {
        t.drawElements(s, r, o, e * a), n.update(r, s, 1)
      }, this.renderInstances = function(r, l, c) {
        if (0 === c) return;
        let h, u;
        if (i) h = t, u = "drawElementsInstanced";
        else if (u = "drawElementsInstancedANGLE", null === (h = e.get("ANGLE_instanced_arrays"))) return void console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
        h[u](s, l, o, r * a, c), n.update(l, s, c)
      }
    }

    function Nl(t) {
      const e = {
        frame: 0,
        calls: 0,
        triangles: 0,
        points: 0,
        lines: 0
      };
      return {
        memory: {
          geometries: 0,
          textures: 0
        },
        render: e,
        programs: null,
        autoReset: !0,
        reset: function() {
          e.frame++, e.calls = 0, e.triangles = 0, e.points = 0, e.lines = 0
        },
        update: function(t, n, r) {
          switch (e.calls++, n) {
            case 4:
              e.triangles += r * (t / 3);
              break;
            case 1:
              e.lines += r * (t / 2);
              break;
            case 3:
              e.lines += r * (t - 1);
              break;
            case 2:
              e.lines += r * t;
              break;
            case 0:
              e.points += r * t;
              break;
            default:
              console.error("THREE.WebGLInfo: Unknown draw mode:", n)
          }
        }
      }
    }

    function Fl(t, e) {
      return t[0] - e[0]
    }

    function zl(t, e) {
      return Math.abs(e[1]) - Math.abs(t[1])
    }

    function Gl(t) {
      const e = {},
        n = new Float32Array(8),
        r = [];
      for (let i = 0; i < 8; i++) r[i] = [i, 0];
      return {
        update: function(i, s, o, a) {
          const l = i.morphTargetInfluences,
            c = void 0 === l ? 0 : l.length;
          let h = e[s.id];
          if (void 0 === h) {
            h = [];
            for (let t = 0; t < c; t++) h[t] = [t, 0];
            e[s.id] = h
          }
          for (let t = 0; t < c; t++) {
            const e = h[t];
            e[0] = t, e[1] = l[t]
          }
          h.sort(zl);
          for (let t = 0; t < 8; t++) t < c && h[t][1] ? (r[t][0] = h[t][0], r[t][1] = h[t][1]) : (r[t][0] = Number.MAX_SAFE_INTEGER, r[t][1] = 0);
          r.sort(Fl);
          const u = o.morphTargets && s.morphAttributes.position,
            p = o.morphNormals && s.morphAttributes.normal;
          let d = 0;
          for (let t = 0; t < 8; t++) {
            const e = r[t],
              i = e[0],
              o = e[1];
            i !== Number.MAX_SAFE_INTEGER && o ? (u && s.getAttribute("morphTarget" + t) !== u[i] && s.setAttribute("morphTarget" + t, u[i]), p && s.getAttribute("morphNormal" + t) !== p[i] && s.setAttribute("morphNormal" + t, p[i]), n[t] = o, d += o) : (u && !0 === s.hasAttribute("morphTarget" + t) && s.deleteAttribute("morphTarget" + t), p && !0 === s.hasAttribute("morphNormal" + t) && s.deleteAttribute("morphNormal" + t), n[t] = 0)
          }
          const m = s.morphTargetsRelative ? 1 : 1 - d;
          a.getUniforms().setValue(t, "morphTargetBaseInfluence", m), a.getUniforms().setValue(t, "morphTargetInfluences", n)
        }
      }
    }

    function Ol(t, e, n, r) {
      let i = new WeakMap;

      function s(t) {
        const e = t.target;
        e.removeEventListener("dispose", s), n.remove(e.instanceMatrix), null !== e.instanceColor && n.remove(e.instanceColor)
      }
      return {
        update: function(t) {
          const o = r.render.frame,
            a = t.geometry,
            l = e.get(t, a);
          return i.get(l) !== o && (e.update(l), i.set(l, o)), t.isInstancedMesh && (!1 === t.hasEventListener("dispose", s) && t.addEventListener("dispose", s), n.update(t.instanceMatrix, 34962), null !== t.instanceColor && n.update(t.instanceColor, 34962)), l
        },
        dispose: function() {
          i = new WeakMap
        }
      }
    }
    exports.ShaderLib = Tl, Tl.physical = {
      uniforms: Fs([Tl.standard.uniforms, {
        clearcoat: {
          value: 0
        },
        clearcoatMap: {
          value: null
        },
        clearcoatRoughness: {
          value: 0
        },
        clearcoatRoughnessMap: {
          value: null
        },
        clearcoatNormalScale: {
          value: new sr(1, 1)
        },
        clearcoatNormalMap: {
          value: null
        },
        sheen: {
          value: new ki(0)
        },
        transmission: {
          value: 0
        },
        transmissionMap: {
          value: null
        }
      }]),
      vertexShader: Ml.meshphysical_vert,
      fragmentShader: Ml.meshphysical_frag
    };
    class Hl extends hr {
      constructor(t = null, e = 1, n = 1, r = 1) {
        super(null), this.image = {
          data: t,
          width: e,
          height: n,
          depth: r
        }, this.magFilter = ut, this.minFilter = ut, this.wrapR = ct, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1, this.needsUpdate = !0
      }
    }
    exports.DataTexture2DArray = Hl, Hl.prototype.isDataTexture2DArray = !0;
    class Ul extends hr {
      constructor(t = null, e = 1, n = 1, r = 1) {
        super(null), this.image = {
          data: t,
          width: e,
          height: n,
          depth: r
        }, this.magFilter = ut, this.minFilter = ut, this.wrapR = ct, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1, this.needsUpdate = !0
      }
    }
    exports.DataTexture3D = Ul, Ul.prototype.isDataTexture3D = !0;
    const kl = new hr,
      Vl = new Hl,
      Wl = new Ul,
      jl = new qs,
      ql = [],
      Xl = [],
      Yl = new Float32Array(16),
      Zl = new Float32Array(9),
      Jl = new Float32Array(4);

    function Ql(t, e, n) {
      const r = t[0];
      if (r <= 0 || r > 0) return t;
      const i = e * n;
      let s = ql[i];
      if (void 0 === s && (s = new Float32Array(i), ql[i] = s), 0 !== e) {
        r.toArray(s, 0);
        for (let r = 1, i = 0; r !== e; ++r) i += n, t[r].toArray(s, i)
      }
      return s
    }

    function Kl(t, e) {
      if (t.length !== e.length) return !1;
      for (let n = 0, r = t.length; n < r; n++)
        if (t[n] !== e[n]) return !1;
      return !0
    }

    function $l(t, e) {
      for (let n = 0, r = e.length; n < r; n++) t[n] = e[n]
    }

    function tc(t, e) {
      let n = Xl[e];
      void 0 === n && (n = new Int32Array(e), Xl[e] = n);
      for (let r = 0; r !== e; ++r) n[r] = t.allocateTextureUnit();
      return n
    }

    function ec(t, e) {
      const n = this.cache;
      n[0] !== e && (t.uniform1f(this.addr, e), n[0] = e)
    }

    function nc(t, e) {
      const n = this.cache;
      if (void 0 !== e.x) n[0] === e.x && n[1] === e.y || (t.uniform2f(this.addr, e.x, e.y), n[0] = e.x, n[1] = e.y);
      else {
        if (Kl(n, e)) return;
        t.uniform2fv(this.addr, e), $l(n, e)
      }
    }

    function rc(t, e) {
      const n = this.cache;
      if (void 0 !== e.x) n[0] === e.x && n[1] === e.y && n[2] === e.z || (t.uniform3f(this.addr, e.x, e.y, e.z), n[0] = e.x, n[1] = e.y, n[2] = e.z);
      else if (void 0 !== e.r) n[0] === e.r && n[1] === e.g && n[2] === e.b || (t.uniform3f(this.addr, e.r, e.g, e.b), n[0] = e.r, n[1] = e.g, n[2] = e.b);
      else {
        if (Kl(n, e)) return;
        t.uniform3fv(this.addr, e), $l(n, e)
      }
    }

    function ic(t, e) {
      const n = this.cache;
      if (void 0 !== e.x) n[0] === e.x && n[1] === e.y && n[2] === e.z && n[3] === e.w || (t.uniform4f(this.addr, e.x, e.y, e.z, e.w), n[0] = e.x, n[1] = e.y, n[2] = e.z, n[3] = e.w);
      else {
        if (Kl(n, e)) return;
        t.uniform4fv(this.addr, e), $l(n, e)
      }
    }

    function sc(t, e) {
      const n = this.cache,
        r = e.elements;
      if (void 0 === r) {
        if (Kl(n, e)) return;
        t.uniformMatrix2fv(this.addr, !1, e), $l(n, e)
      } else {
        if (Kl(n, r)) return;
        Jl.set(r), t.uniformMatrix2fv(this.addr, !1, Jl), $l(n, r)
      }
    }

    function oc(t, e) {
      const n = this.cache,
        r = e.elements;
      if (void 0 === r) {
        if (Kl(n, e)) return;
        t.uniformMatrix3fv(this.addr, !1, e), $l(n, e)
      } else {
        if (Kl(n, r)) return;
        Zl.set(r), t.uniformMatrix3fv(this.addr, !1, Zl), $l(n, r)
      }
    }

    function ac(t, e) {
      const n = this.cache,
        r = e.elements;
      if (void 0 === r) {
        if (Kl(n, e)) return;
        t.uniformMatrix4fv(this.addr, !1, e), $l(n, e)
      } else {
        if (Kl(n, r)) return;
        Yl.set(r), t.uniformMatrix4fv(this.addr, !1, Yl), $l(n, r)
      }
    }

    function lc(t, e) {
      const n = this.cache;
      n[0] !== e && (t.uniform1i(this.addr, e), n[0] = e)
    }

    function cc(t, e) {
      const n = this.cache;
      Kl(n, e) || (t.uniform2iv(this.addr, e), $l(n, e))
    }

    function hc(t, e) {
      const n = this.cache;
      Kl(n, e) || (t.uniform3iv(this.addr, e), $l(n, e))
    }

    function uc(t, e) {
      const n = this.cache;
      Kl(n, e) || (t.uniform4iv(this.addr, e), $l(n, e))
    }

    function pc(t, e) {
      const n = this.cache;
      n[0] !== e && (t.uniform1ui(this.addr, e), n[0] = e)
    }

    function dc(t, e) {
      const n = this.cache;
      Kl(n, e) || (t.uniform2uiv(this.addr, e), $l(n, e))
    }

    function mc(t, e) {
      const n = this.cache;
      Kl(n, e) || (t.uniform3uiv(this.addr, e), $l(n, e))
    }

    function fc(t, e) {
      const n = this.cache;
      Kl(n, e) || (t.uniform4uiv(this.addr, e), $l(n, e))
    }

    function gc(t, e, n) {
      const r = this.cache,
        i = n.allocateTextureUnit();
      r[0] !== i && (t.uniform1i(this.addr, i), r[0] = i), n.safeSetTexture2D(e || kl, i)
    }

    function xc(t, e, n) {
      const r = this.cache,
        i = n.allocateTextureUnit();
      r[0] !== i && (t.uniform1i(this.addr, i), r[0] = i), n.setTexture3D(e || Wl, i)
    }

    function vc(t, e, n) {
      const r = this.cache,
        i = n.allocateTextureUnit();
      r[0] !== i && (t.uniform1i(this.addr, i), r[0] = i), n.safeSetTextureCube(e || jl, i)
    }

    function yc(t, e, n) {
      const r = this.cache,
        i = n.allocateTextureUnit();
      r[0] !== i && (t.uniform1i(this.addr, i), r[0] = i), n.setTexture2DArray(e || Vl, i)
    }

    function _c(t) {
      switch (t) {
        case 5126:
          return ec;
        case 35664:
          return nc;
        case 35665:
          return rc;
        case 35666:
          return ic;
        case 35674:
          return sc;
        case 35675:
          return oc;
        case 35676:
          return ac;
        case 5124:
        case 35670:
          return lc;
        case 35667:
        case 35671:
          return cc;
        case 35668:
        case 35672:
          return hc;
        case 35669:
        case 35673:
          return uc;
        case 5125:
          return pc;
        case 36294:
          return dc;
        case 36295:
          return mc;
        case 36296:
          return fc;
        case 35678:
        case 36198:
        case 36298:
        case 36306:
        case 35682:
          return gc;
        case 35679:
        case 36299:
        case 36307:
          return xc;
        case 35680:
        case 36300:
        case 36308:
        case 36293:
          return vc;
        case 36289:
        case 36303:
        case 36311:
        case 36292:
          return yc
      }
    }

    function bc(t, e) {
      t.uniform1fv(this.addr, e)
    }

    function wc(t, e) {
      const n = Ql(e, this.size, 2);
      t.uniform2fv(this.addr, n)
    }

    function Mc(t, e) {
      const n = Ql(e, this.size, 3);
      t.uniform3fv(this.addr, n)
    }

    function Sc(t, e) {
      const n = Ql(e, this.size, 4);
      t.uniform4fv(this.addr, n)
    }

    function Tc(t, e) {
      const n = Ql(e, this.size, 4);
      t.uniformMatrix2fv(this.addr, !1, n)
    }

    function Ec(t, e) {
      const n = Ql(e, this.size, 9);
      t.uniformMatrix3fv(this.addr, !1, n)
    }

    function Ac(t, e) {
      const n = Ql(e, this.size, 16);
      t.uniformMatrix4fv(this.addr, !1, n)
    }

    function Lc(t, e) {
      t.uniform1iv(this.addr, e)
    }

    function Rc(t, e) {
      t.uniform2iv(this.addr, e)
    }

    function Cc(t, e) {
      t.uniform3iv(this.addr, e)
    }

    function Pc(t, e) {
      t.uniform4iv(this.addr, e)
    }

    function Dc(t, e) {
      t.uniform1uiv(this.addr, e)
    }

    function Ic(t, e) {
      t.uniform2uiv(this.addr, e)
    }

    function Bc(t, e) {
      t.uniform3uiv(this.addr, e)
    }

    function Nc(t, e) {
      t.uniform4uiv(this.addr, e)
    }

    function Fc(t, e, n) {
      const r = e.length,
        i = tc(n, r);
      t.uniform1iv(this.addr, i);
      for (let s = 0; s !== r; ++s) n.safeSetTexture2D(e[s] || kl, i[s])
    }

    function zc(t, e, n) {
      const r = e.length,
        i = tc(n, r);
      t.uniform1iv(this.addr, i);
      for (let s = 0; s !== r; ++s) n.safeSetTextureCube(e[s] || jl, i[s])
    }

    function Gc(t) {
      switch (t) {
        case 5126:
          return bc;
        case 35664:
          return wc;
        case 35665:
          return Mc;
        case 35666:
          return Sc;
        case 35674:
          return Tc;
        case 35675:
          return Ec;
        case 35676:
          return Ac;
        case 5124:
        case 35670:
          return Lc;
        case 35667:
        case 35671:
          return Rc;
        case 35668:
        case 35672:
          return Cc;
        case 35669:
        case 35673:
          return Pc;
        case 5125:
          return Dc;
        case 36294:
          return Ic;
        case 36295:
          return Bc;
        case 36296:
          return Nc;
        case 35678:
        case 36198:
        case 36298:
        case 36306:
        case 35682:
          return Fc;
        case 35680:
        case 36300:
        case 36308:
        case 36293:
          return zc
      }
    }

    function Oc(t, e, n) {
      this.id = t, this.addr = n, this.cache = [], this.setValue = _c(e.type)
    }

    function Hc(t, e, n) {
      this.id = t, this.addr = n, this.cache = [], this.size = e.size, this.setValue = Gc(e.type)
    }

    function Uc(t) {
      this.id = t, this.seq = [], this.map = {}
    }
    Hc.prototype.updateCache = function(t) {
      const e = this.cache;
      t instanceof Float32Array && e.length !== t.length && (this.cache = new Float32Array(t.length)), $l(e, t)
    }, Uc.prototype.setValue = function(t, e, n) {
      const r = this.seq;
      for (let i = 0, s = r.length; i !== s; ++i) {
        const s = r[i];
        s.setValue(t, e[s.id], n)
      }
    };
    const kc = /(\w+)(\])?(\[|\.)?/g;

    function Vc(t, e) {
      t.seq.push(e), t.map[e.id] = e
    }

    function Wc(t, e, n) {
      const r = t.name,
        i = r.length;
      for (kc.lastIndex = 0;;) {
        const s = kc.exec(r),
          o = kc.lastIndex;
        let a = s[1];
        const l = "]" === s[2],
          c = s[3];
        if (l && (a |= 0), void 0 === c || "[" === c && o + 2 === i) {
          Vc(n, void 0 === c ? new Oc(a, t, e) : new Hc(a, t, e));
          break
        } {
          let t = n.map[a];
          void 0 === t && Vc(n, t = new Uc(a)), n = t
        }
      }
    }

    function jc(t, e) {
      this.seq = [], this.map = {};
      const n = t.getProgramParameter(e, 35718);
      for (let r = 0; r < n; ++r) {
        const n = t.getActiveUniform(e, r);
        Wc(n, t.getUniformLocation(e, n.name), this)
      }
    }

    function qc(t, e, n) {
      const r = t.createShader(e);
      return t.shaderSource(r, n), t.compileShader(r), r
    }
    jc.prototype.setValue = function(t, e, n, r) {
      const i = this.map[e];
      void 0 !== i && i.setValue(t, n, r)
    }, jc.prototype.setOptional = function(t, e, n) {
      const r = e[n];
      void 0 !== r && this.setValue(t, n, r)
    }, jc.upload = function(t, e, n, r) {
      for (let i = 0, s = e.length; i !== s; ++i) {
        const s = e[i],
          o = n[s.id];
        !1 !== o.needsUpdate && s.setValue(t, o.value, r)
      }
    }, jc.seqWithValue = function(t, e) {
      const n = [];
      for (let r = 0, i = t.length; r !== i; ++r) {
        const i = t[r];
        i.id in e && n.push(i)
      }
      return n
    };
    let Xc = 0;

    function Yc(t) {
      const e = t.split("\n");
      for (let n = 0; n < e.length; n++) e[n] = n + 1 + ": " + e[n];
      return e.join("\n")
    }

    function Zc(t) {
      switch (t) {
        case Xe:
          return ["Linear", "( value )"];
        case Ye:
          return ["sRGB", "( value )"];
        case Je:
          return ["RGBE", "( value )"];
        case Ke:
          return ["RGBM", "( value, 7.0 )"];
        case $e:
          return ["RGBM", "( value, 16.0 )"];
        case tn:
          return ["RGBD", "( value, 256.0 )"];
        case Ze:
          return ["Gamma", "( value, float( GAMMA_FACTOR ) )"];
        case Qe:
          return ["LogLuv", "( value )"];
        default:
          return console.warn("THREE.WebGLProgram: Unsupported encoding:", t), ["Linear", "( value )"]
      }
    }

    function Jc(t, e, n) {
      const r = t.getShaderParameter(e, 35713),
        i = t.getShaderInfoLog(e).trim();
      return r && "" === i ? "" : "THREE.WebGLShader: gl.getShaderInfoLog() " + n + "\n" + i + Yc(t.getShaderSource(e))
    }

    function Qc(t, e) {
      const n = Zc(e);
      return "vec4 " + t + "( vec4 value ) { return " + n[0] + "ToLinear" + n[1] + "; }"
    }

    function Kc(t, e) {
      const n = Zc(e);
      return "vec4 " + t + "( vec4 value ) { return LinearTo" + n[0] + n[1] + "; }"
    }

    function $c(t, e) {
      let n;
      switch (e) {
        case J:
          n = "Linear";
          break;
        case Q:
          n = "Reinhard";
          break;
        case K:
          n = "OptimizedCineon";
          break;
        case $:
          n = "ACESFilmic";
          break;
        case tt:
          n = "Custom";
          break;
        default:
          console.warn("THREE.WebGLProgram: Unsupported toneMapping:", e), n = "Linear"
      }
      return "vec3 " + t + "( vec3 color ) { return " + n + "ToneMapping( color ); }"
    }

    function th(t) {
      return [t.extensionDerivatives || t.envMapCubeUV || t.bumpMap || t.tangentSpaceNormalMap || t.clearcoatNormalMap || t.flatShading || "physical" === t.shaderID ? "#extension GL_OES_standard_derivatives : enable" : "", (t.extensionFragDepth || t.logarithmicDepthBuffer) && t.rendererExtensionFragDepth ? "#extension GL_EXT_frag_depth : enable" : "", t.extensionDrawBuffers && t.rendererExtensionDrawBuffers ? "#extension GL_EXT_draw_buffers : require" : "", (t.extensionShaderTextureLOD || t.envMap) && t.rendererExtensionShaderTextureLod ? "#extension GL_EXT_shader_texture_lod : enable" : ""].filter(rh).join("\n")
    }

    function eh(t) {
      const e = [];
      for (const n in t) {
        const r = t[n];
        !1 !== r && e.push("#define " + n + " " + r)
      }
      return e.join("\n")
    }

    function nh(t, e) {
      const n = {},
        r = t.getProgramParameter(e, 35721);
      for (let i = 0; i < r; i++) {
        const r = t.getActiveAttrib(e, i).name;
        n[r] = t.getAttribLocation(e, r)
      }
      return n
    }

    function rh(t) {
      return "" !== t
    }

    function ih(t, e) {
      return t.replace(/NUM_DIR_LIGHTS/g, e.numDirLights).replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, e.numPointLights).replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows)
    }

    function sh(t, e) {
      return t.replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, e.numClippingPlanes - e.numClipIntersection)
    }
    const oh = /^[ \t]*#include +<([\w\d./]+)>/gm;

    function ah(t) {
      return t.replace(oh, lh)
    }

    function lh(t, e) {
      const n = Ml[e];
      if (void 0 === n) throw new Error("Can not resolve #include <" + e + ">");
      return ah(n)
    }
    const ch = /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g,
      hh = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;

    function uh(t) {
      return t.replace(hh, dh).replace(ch, ph)
    }

    function ph(t, e, n, r) {
      return console.warn("WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead."), dh(t, e, n, r)
    }

    function dh(t, e, n, r) {
      let i = "";
      for (let s = parseInt(e); s < parseInt(n); s++) i += r.replace(/\[\s*i\s*\]/g, "[ " + s + " ]").replace(/UNROLLED_LOOP_INDEX/g, s);
      return i
    }

    function mh(t) {
      let e = "precision " + t.precision + " float;\nprecision " + t.precision + " int;";
      return "highp" === t.precision ? e += "\n#define HIGH_PRECISION" : "mediump" === t.precision ? e += "\n#define MEDIUM_PRECISION" : "lowp" === t.precision && (e += "\n#define LOW_PRECISION"), e
    }

    function fh(t) {
      let e = "SHADOWMAP_TYPE_BASIC";
      return t.shadowMapType === l ? e = "SHADOWMAP_TYPE_PCF" : t.shadowMapType === c ? e = "SHADOWMAP_TYPE_PCF_SOFT" : t.shadowMapType === h && (e = "SHADOWMAP_TYPE_VSM"), e
    }

    function gh(t) {
      let e = "ENVMAP_TYPE_CUBE";
      if (t.envMap) switch (t.envMapMode) {
        case nt:
        case rt:
          e = "ENVMAP_TYPE_CUBE";
          break;
        case ot:
        case at:
          e = "ENVMAP_TYPE_CUBE_UV"
      }
      return e
    }

    function xh(t) {
      let e = "ENVMAP_MODE_REFLECTION";
      if (t.envMap) switch (t.envMapMode) {
        case rt:
        case at:
          e = "ENVMAP_MODE_REFRACTION"
      }
      return e
    }

    function vh(t) {
      let e = "ENVMAP_BLENDING_NONE";
      if (t.envMap) switch (t.combine) {
        case q:
          e = "ENVMAP_BLENDING_MULTIPLY";
          break;
        case X:
          e = "ENVMAP_BLENDING_MIX";
          break;
        case Y:
          e = "ENVMAP_BLENDING_ADD"
      }
      return e
    }

    function yh(t, e, n, r) {
      const i = t.getContext(),
        s = n.defines;
      let o = n.vertexShader,
        a = n.fragmentShader;
      const l = fh(n),
        c = gh(n),
        h = xh(n),
        u = vh(n),
        p = t.gammaFactor > 0 ? t.gammaFactor : 1,
        d = n.isWebGL2 ? "" : th(n),
        m = eh(s),
        f = i.createProgram();
      let g, x, v = n.glslVersion ? "#version " + n.glslVersion + "\n" : "";
      n.isRawShaderMaterial ? ((g = [m].filter(rh).join("\n")).length > 0 && (g += "\n"), (x = [d, m].filter(rh).join("\n")).length > 0 && (x += "\n")) : (g = [mh(n), "#define SHADER_NAME " + n.shaderName, m, n.instancing ? "#define USE_INSTANCING" : "", n.instancingColor ? "#define USE_INSTANCING_COLOR" : "", n.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "", "#define GAMMA_FACTOR " + p, "#define MAX_BONES " + n.maxBones, n.useFog && n.fog ? "#define USE_FOG" : "", n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "", n.map ? "#define USE_MAP" : "", n.envMap ? "#define USE_ENVMAP" : "", n.envMap ? "#define " + h : "", n.lightMap ? "#define USE_LIGHTMAP" : "", n.aoMap ? "#define USE_AOMAP" : "", n.emissiveMap ? "#define USE_EMISSIVEMAP" : "", n.bumpMap ? "#define USE_BUMPMAP" : "", n.normalMap ? "#define USE_NORMALMAP" : "", n.normalMap && n.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", n.normalMap && n.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", n.displacementMap && n.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "", n.specularMap ? "#define USE_SPECULARMAP" : "", n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", n.metalnessMap ? "#define USE_METALNESSMAP" : "", n.alphaMap ? "#define USE_ALPHAMAP" : "", n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", n.vertexTangents ? "#define USE_TANGENT" : "", n.vertexColors ? "#define USE_COLOR" : "", n.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", n.vertexUvs ? "#define USE_UV" : "", n.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", n.flatShading ? "#define FLAT_SHADED" : "", n.skinning ? "#define USE_SKINNING" : "", n.useVertexTexture ? "#define BONE_TEXTURE" : "", n.morphTargets ? "#define USE_MORPHTARGETS" : "", n.morphNormals && !1 === n.flatShading ? "#define USE_MORPHNORMALS" : "", n.doubleSided ? "#define DOUBLE_SIDED" : "", n.flipSided ? "#define FLIP_SIDED" : "", n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", n.shadowMapEnabled ? "#define " + l : "", n.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", n.logarithmicDepthBuffer && n.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", "#ifdef USE_INSTANCING", "\tattribute mat4 instanceMatrix;", "#endif", "#ifdef USE_INSTANCING_COLOR", "\tattribute vec3 instanceColor;", "#endif", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_TANGENT", "\tattribute vec4 tangent;", "#endif", "#if defined( USE_COLOR_ALPHA )", "\tattribute vec4 color;", "#elif defined( USE_COLOR )", "\tattribute vec3 color;", "#endif", "#ifdef USE_MORPHTARGETS", "\tattribute vec3 morphTarget0;", "\tattribute vec3 morphTarget1;", "\tattribute vec3 morphTarget2;", "\tattribute vec3 morphTarget3;", "\t#ifdef USE_MORPHNORMALS", "\t\tattribute vec3 morphNormal0;", "\t\tattribute vec3 morphNormal1;", "\t\tattribute vec3 morphNormal2;", "\t\tattribute vec3 morphNormal3;", "\t#else", "\t\tattribute vec3 morphTarget4;", "\t\tattribute vec3 morphTarget5;", "\t\tattribute vec3 morphTarget6;", "\t\tattribute vec3 morphTarget7;", "\t#endif", "#endif", "#ifdef USE_SKINNING", "\tattribute vec4 skinIndex;", "\tattribute vec4 skinWeight;", "#endif", "\n"].filter(rh).join("\n"), x = [d, mh(n), "#define SHADER_NAME " + n.shaderName, m, n.alphaTest ? "#define ALPHATEST " + n.alphaTest + (n.alphaTest % 1 ? "" : ".0") : "", "#define GAMMA_FACTOR " + p, n.useFog && n.fog ? "#define USE_FOG" : "", n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "", n.map ? "#define USE_MAP" : "", n.matcap ? "#define USE_MATCAP" : "", n.envMap ? "#define USE_ENVMAP" : "", n.envMap ? "#define " + c : "", n.envMap ? "#define " + h : "", n.envMap ? "#define " + u : "", n.lightMap ? "#define USE_LIGHTMAP" : "", n.aoMap ? "#define USE_AOMAP" : "", n.emissiveMap ? "#define USE_EMISSIVEMAP" : "", n.bumpMap ? "#define USE_BUMPMAP" : "", n.normalMap ? "#define USE_NORMALMAP" : "", n.normalMap && n.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", n.normalMap && n.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", n.specularMap ? "#define USE_SPECULARMAP" : "", n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", n.metalnessMap ? "#define USE_METALNESSMAP" : "", n.alphaMap ? "#define USE_ALPHAMAP" : "", n.sheen ? "#define USE_SHEEN" : "", n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", n.vertexTangents ? "#define USE_TANGENT" : "", n.vertexColors || n.instancingColor ? "#define USE_COLOR" : "", n.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", n.vertexUvs ? "#define USE_UV" : "", n.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", n.gradientMap ? "#define USE_GRADIENTMAP" : "", n.flatShading ? "#define FLAT_SHADED" : "", n.doubleSided ? "#define DOUBLE_SIDED" : "", n.flipSided ? "#define FLIP_SIDED" : "", n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", n.shadowMapEnabled ? "#define " + l : "", n.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", n.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "", n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", n.logarithmicDepthBuffer && n.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", (n.extensionShaderTextureLOD || n.envMap) && n.rendererExtensionShaderTextureLod ? "#define TEXTURE_LOD_EXT" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", n.toneMapping !== Z ? "#define TONE_MAPPING" : "", n.toneMapping !== Z ? Ml.tonemapping_pars_fragment : "", n.toneMapping !== Z ? $c("toneMapping", n.toneMapping) : "", n.dithering ? "#define DITHERING" : "", Ml.encodings_pars_fragment, n.map ? Qc("mapTexelToLinear", n.mapEncoding) : "", n.matcap ? Qc("matcapTexelToLinear", n.matcapEncoding) : "", n.envMap ? Qc("envMapTexelToLinear", n.envMapEncoding) : "", n.emissiveMap ? Qc("emissiveMapTexelToLinear", n.emissiveMapEncoding) : "", n.lightMap ? Qc("lightMapTexelToLinear", n.lightMapEncoding) : "", Kc("linearToOutputTexel", n.outputEncoding), n.depthPacking ? "#define DEPTH_PACKING " + n.depthPacking : "", "\n"].filter(rh).join("\n")), o = sh(o = ih(o = ah(o), n), n), a = sh(a = ih(a = ah(a), n), n), o = uh(o), a = uh(a), n.isWebGL2 && !0 !== n.isRawShaderMaterial && (v = "#version 300 es\n", g = ["#define attribute in", "#define varying out", "#define texture2D texture"].join("\n") + "\n" + g, x = ["#define varying in", n.glslVersion === Dn ? "" : "out highp vec4 pc_fragColor;", n.glslVersion === Dn ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth", "#define texture2D texture", "#define textureCube texture", "#define texture2DProj textureProj", "#define texture2DLodEXT textureLod", "#define texture2DProjLodEXT textureProjLod", "#define textureCubeLodEXT textureLod", "#define texture2DGradEXT textureGrad", "#define texture2DProjGradEXT textureProjGrad", "#define textureCubeGradEXT textureGrad"].join("\n") + "\n" + x);
      const y = v + x + a,
        _ = qc(i, 35633, v + g + o),
        b = qc(i, 35632, y);
      if (i.attachShader(f, _), i.attachShader(f, b), void 0 !== n.index0AttributeName ? i.bindAttribLocation(f, 0, n.index0AttributeName) : !0 === n.morphTargets && i.bindAttribLocation(f, 0, "position"), i.linkProgram(f), t.debug.checkShaderErrors) {
        const t = i.getProgramInfoLog(f).trim(),
          e = i.getShaderInfoLog(_).trim(),
          n = i.getShaderInfoLog(b).trim();
        let r = !0,
          s = !0;
        if (!1 === i.getProgramParameter(f, 35714)) {
          r = !1;
          const e = Jc(i, _, "vertex"),
            n = Jc(i, b, "fragment");
          console.error("THREE.WebGLProgram: shader error: ", i.getError(), "35715", i.getProgramParameter(f, 35715), "gl.getProgramInfoLog", t, e, n)
        } else "" !== t ? console.warn("THREE.WebGLProgram: gl.getProgramInfoLog()", t) : "" !== e && "" !== n || (s = !1);
        s && (this.diagnostics = {
          runnable: r,
          programLog: t,
          vertexShader: {
            log: e,
            prefix: g
          },
          fragmentShader: {
            log: n,
            prefix: x
          }
        })
      }
      let w, M;
      return i.deleteShader(_), i.deleteShader(b), this.getUniforms = function() {
        return void 0 === w && (w = new jc(i, f)), w
      }, this.getAttributes = function() {
        return void 0 === M && (M = nh(i, f)), M
      }, this.destroy = function() {
        r.releaseStatesOfProgram(this), i.deleteProgram(f), this.program = void 0
      }, this.name = n.shaderName, this.id = Xc++, this.cacheKey = e, this.usedTimes = 1, this.program = f, this.vertexShader = _, this.fragmentShader = b, this
    }

    function _h(t, e, n, r, i, s) {
      const o = [],
        a = r.isWebGL2,
        l = r.logarithmicDepthBuffer,
        c = r.floatVertexTextures,
        h = r.maxVertexUniforms,
        u = r.vertexTextures;
      let m = r.precision;
      const f = {
          MeshDepthMaterial: "depth",
          MeshDistanceMaterial: "distanceRGBA",
          MeshNormalMaterial: "normal",
          MeshBasicMaterial: "basic",
          MeshLambertMaterial: "lambert",
          MeshPhongMaterial: "phong",
          MeshToonMaterial: "toon",
          MeshStandardMaterial: "physical",
          MeshPhysicalMaterial: "physical",
          MeshMatcapMaterial: "matcap",
          LineBasicMaterial: "basic",
          LineDashedMaterial: "dashed",
          PointsMaterial: "points",
          ShadowMaterial: "shadow",
          SpriteMaterial: "sprite"
        },
        g = ["precision", "isWebGL2", "supportsVertexTextures", "outputEncoding", "instancing", "instancingColor", "map", "mapEncoding", "matcap", "matcapEncoding", "envMap", "envMapMode", "envMapEncoding", "envMapCubeUV", "lightMap", "lightMapEncoding", "aoMap", "emissiveMap", "emissiveMapEncoding", "bumpMap", "normalMap", "objectSpaceNormalMap", "tangentSpaceNormalMap", "clearcoatMap", "clearcoatRoughnessMap", "clearcoatNormalMap", "displacementMap", "specularMap", "roughnessMap", "metalnessMap", "gradientMap", "alphaMap", "combine", "vertexColors", "vertexAlphas", "vertexTangents", "vertexUvs", "uvsVertexOnly", "fog", "useFog", "fogExp2", "flatShading", "sizeAttenuation", "logarithmicDepthBuffer", "skinning", "maxBones", "useVertexTexture", "morphTargets", "morphNormals", "premultipliedAlpha", "numDirLights", "numPointLights", "numSpotLights", "numHemiLights", "numRectAreaLights", "numDirLightShadows", "numPointLightShadows", "numSpotLightShadows", "shadowMapEnabled", "shadowMapType", "toneMapping", "physicallyCorrectLights", "alphaTest", "doubleSided", "flipSided", "numClippingPlanes", "numClipIntersection", "depthPacking", "dithering", "sheen", "transmissionMap"];

      function x(t) {
        let e;
        return t && t.isTexture ? e = t.encoding : t && t.isWebGLRenderTarget ? (console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead."), e = t.texture.encoding) : e = Xe, e
      }
      return {
        getParameters: function(i, o, g, v, y) {
          const _ = v.fog,
            b = i.isMeshStandardMaterial ? v.environment : null,
            w = e.get(i.envMap || b),
            M = f[i.type],
            S = y.isSkinnedMesh ? function(t) {
              const e = t.skeleton.bones;
              if (c) return 1024; {
                const t = h,
                  n = Math.floor((t - 20) / 4),
                  r = Math.min(n, e.length);
                return r < e.length ? (console.warn("THREE.WebGLRenderer: Skeleton has " + e.length + " bones. This GPU supports " + r + "."), 0) : r
              }
            }(y) : 0;
          let T, E;
          if (null !== i.precision && (m = r.getMaxPrecision(i.precision)) !== i.precision && console.warn("THREE.WebGLProgram.getParameters:", i.precision, "not supported, using", m, "instead."), M) {
            const t = Tl[M];
            T = t.vertexShader, E = t.fragmentShader
          } else T = i.vertexShader, E = i.fragmentShader;
          const A = t.getRenderTarget();
          return {
            isWebGL2: a,
            shaderID: M,
            shaderName: i.type,
            vertexShader: T,
            fragmentShader: E,
            defines: i.defines,
            isRawShaderMaterial: !0 === i.isRawShaderMaterial,
            glslVersion: i.glslVersion,
            precision: m,
            instancing: !0 === y.isInstancedMesh,
            instancingColor: !0 === y.isInstancedMesh && null !== y.instanceColor,
            supportsVertexTextures: u,
            outputEncoding: null !== A ? x(A.texture) : t.outputEncoding,
            map: !!i.map,
            mapEncoding: x(i.map),
            matcap: !!i.matcap,
            matcapEncoding: x(i.matcap),
            envMap: !!w,
            envMapMode: w && w.mapping,
            envMapEncoding: x(w),
            envMapCubeUV: !!w && (w.mapping === ot || w.mapping === at),
            lightMap: !!i.lightMap,
            lightMapEncoding: x(i.lightMap),
            aoMap: !!i.aoMap,
            emissiveMap: !!i.emissiveMap,
            emissiveMapEncoding: x(i.emissiveMap),
            bumpMap: !!i.bumpMap,
            normalMap: !!i.normalMap,
            objectSpaceNormalMap: i.normalMapType === sn,
            tangentSpaceNormalMap: i.normalMapType === rn,
            clearcoatMap: !!i.clearcoatMap,
            clearcoatRoughnessMap: !!i.clearcoatRoughnessMap,
            clearcoatNormalMap: !!i.clearcoatNormalMap,
            displacementMap: !!i.displacementMap,
            roughnessMap: !!i.roughnessMap,
            metalnessMap: !!i.metalnessMap,
            specularMap: !!i.specularMap,
            alphaMap: !!i.alphaMap,
            gradientMap: !!i.gradientMap,
            sheen: !!i.sheen,
            transmissionMap: !!i.transmissionMap,
            combine: i.combine,
            vertexTangents: i.normalMap && i.vertexTangents,
            vertexColors: i.vertexColors,
            vertexAlphas: !0 === i.vertexColors && y.geometry && y.geometry.attributes.color && 4 === y.geometry.attributes.color.itemSize,
            vertexUvs: !!(i.map || i.bumpMap || i.normalMap || i.specularMap || i.alphaMap || i.emissiveMap || i.roughnessMap || i.metalnessMap || i.clearcoatMap || i.clearcoatRoughnessMap || i.clearcoatNormalMap || i.displacementMap || i.transmissionMap),
            uvsVertexOnly: !(i.map || i.bumpMap || i.normalMap || i.specularMap || i.alphaMap || i.emissiveMap || i.roughnessMap || i.metalnessMap || i.clearcoatNormalMap || i.transmissionMap || !i.displacementMap),
            fog: !!_,
            useFog: i.fog,
            fogExp2: _ && _.isFogExp2,
            flatShading: !!i.flatShading,
            sizeAttenuation: i.sizeAttenuation,
            logarithmicDepthBuffer: l,
            skinning: i.skinning && S > 0,
            maxBones: S,
            useVertexTexture: c,
            morphTargets: i.morphTargets,
            morphNormals: i.morphNormals,
            numDirLights: o.directional.length,
            numPointLights: o.point.length,
            numSpotLights: o.spot.length,
            numRectAreaLights: o.rectArea.length,
            numHemiLights: o.hemi.length,
            numDirLightShadows: o.directionalShadowMap.length,
            numPointLightShadows: o.pointShadowMap.length,
            numSpotLightShadows: o.spotShadowMap.length,
            numClippingPlanes: s.numPlanes,
            numClipIntersection: s.numIntersection,
            dithering: i.dithering,
            shadowMapEnabled: t.shadowMap.enabled && g.length > 0,
            shadowMapType: t.shadowMap.type,
            toneMapping: i.toneMapped ? t.toneMapping : Z,
            physicallyCorrectLights: t.physicallyCorrectLights,
            premultipliedAlpha: i.premultipliedAlpha,
            alphaTest: i.alphaTest,
            doubleSided: i.side === d,
            flipSided: i.side === p,
            depthPacking: void 0 !== i.depthPacking && i.depthPacking,
            index0AttributeName: i.index0AttributeName,
            extensionDerivatives: i.extensions && i.extensions.derivatives,
            extensionFragDepth: i.extensions && i.extensions.fragDepth,
            extensionDrawBuffers: i.extensions && i.extensions.drawBuffers,
            extensionShaderTextureLOD: i.extensions && i.extensions.shaderTextureLOD,
            rendererExtensionFragDepth: a || n.has("EXT_frag_depth"),
            rendererExtensionDrawBuffers: a || n.has("WEBGL_draw_buffers"),
            rendererExtensionShaderTextureLod: a || n.has("EXT_shader_texture_lod"),
            customProgramCacheKey: i.customProgramCacheKey()
          }
        },
        getProgramCacheKey: function(e) {
          const n = [];
          if (e.shaderID ? n.push(e.shaderID) : (n.push(e.fragmentShader), n.push(e.vertexShader)), void 0 !== e.defines)
            for (const t in e.defines) n.push(t), n.push(e.defines[t]);
          if (!1 === e.isRawShaderMaterial) {
            for (let t = 0; t < g.length; t++) n.push(e[g[t]]);
            n.push(t.outputEncoding), n.push(t.gammaFactor)
          }
          return n.push(e.customProgramCacheKey), n.join()
        },
        getUniforms: function(t) {
          const e = f[t.type];
          let n;
          if (e) {
            const t = Tl[e];
            n = zs.clone(t.uniforms)
          } else n = t.uniforms;
          return n
        },
        acquireProgram: function(e, n) {
          let r;
          for (let t = 0, i = o.length; t < i; t++) {
            const e = o[t];
            if (e.cacheKey === n) {
              ++(r = e).usedTimes;
              break
            }
          }
          return void 0 === r && (r = new yh(t, n, e, i), o.push(r)), r
        },
        releaseProgram: function(t) {
          if (0 == --t.usedTimes) {
            const e = o.indexOf(t);
            o[e] = o[o.length - 1], o.pop(), t.destroy()
          }
        },
        programs: o
      }
    }

    function bh() {
      let t = new WeakMap;
      return {
        get: function(e) {
          let n = t.get(e);
          return void 0 === n && (n = {}, t.set(e, n)), n
        },
        remove: function(e) {
          t.delete(e)
        },
        update: function(e, n, r) {
          t.get(e)[n] = r
        },
        dispose: function() {
          t = new WeakMap
        }
      }
    }

    function wh(t, e) {
      return t.groupOrder !== e.groupOrder ? t.groupOrder - e.groupOrder : t.renderOrder !== e.renderOrder ? t.renderOrder - e.renderOrder : t.program !== e.program ? t.program.id - e.program.id : t.material.id !== e.material.id ? t.material.id - e.material.id : t.z !== e.z ? t.z - e.z : t.id - e.id
    }

    function Mh(t, e) {
      return t.groupOrder !== e.groupOrder ? t.groupOrder - e.groupOrder : t.renderOrder !== e.renderOrder ? t.renderOrder - e.renderOrder : t.z !== e.z ? e.z - t.z : t.id - e.id
    }

    function Sh(t) {
      const e = [];
      let n = 0;
      const r = [],
        i = [],
        s = {
          id: -1
        };

      function o(r, i, o, a, l, c) {
        let h = e[n];
        const u = t.get(o);
        return void 0 === h ? (h = {
          id: r.id,
          object: r,
          geometry: i,
          material: o,
          program: u.program || s,
          groupOrder: a,
          renderOrder: r.renderOrder,
          z: l,
          group: c
        }, e[n] = h) : (h.id = r.id, h.object = r, h.geometry = i, h.material = o, h.program = u.program || s, h.groupOrder = a, h.renderOrder = r.renderOrder, h.z = l, h.group = c), n++, h
      }
      return {
        opaque: r,
        transparent: i,
        init: function() {
          n = 0, r.length = 0, i.length = 0
        },
        push: function(t, e, n, s, a, l) {
          const c = o(t, e, n, s, a, l);
          (!0 === n.transparent ? i : r).push(c)
        },
        unshift: function(t, e, n, s, a, l) {
          const c = o(t, e, n, s, a, l);
          (!0 === n.transparent ? i : r).unshift(c)
        },
        finish: function() {
          for (let t = n, r = e.length; t < r; t++) {
            const n = e[t];
            if (null === n.id) break;
            n.id = null, n.object = null, n.geometry = null, n.material = null, n.program = null, n.group = null
          }
        },
        sort: function(t, e) {
          r.length > 1 && r.sort(t || wh), i.length > 1 && i.sort(e || Mh)
        }
      }
    }

    function Th(t) {
      let e = new WeakMap;
      return {
        get: function(n, r) {
          let i;
          return !1 === e.has(n) ? (i = new Sh(t), e.set(n, [i])) : r >= e.get(n).length ? (i = new Sh(t), e.get(n).push(i)) : i = e.get(n)[r], i
        },
        dispose: function() {
          e = new WeakMap
        }
      }
    }

    function Eh() {
      const t = {};
      return {
        get: function(e) {
          if (void 0 !== t[e.id]) return t[e.id];
          let n;
          switch (e.type) {
            case "DirectionalLight":
              n = {
                direction: new gr,
                color: new ki
              };
              break;
            case "SpotLight":
              n = {
                position: new gr,
                direction: new gr,
                color: new ki,
                distance: 0,
                coneCos: 0,
                penumbraCos: 0,
                decay: 0
              };
              break;
            case "PointLight":
              n = {
                position: new gr,
                color: new ki,
                distance: 0,
                decay: 0
              };
              break;
            case "HemisphereLight":
              n = {
                direction: new gr,
                skyColor: new ki,
                groundColor: new ki
              };
              break;
            case "RectAreaLight":
              n = {
                color: new ki,
                position: new gr,
                halfWidth: new gr,
                halfHeight: new gr
              }
          }
          return t[e.id] = n, n
        }
      }
    }

    function Ah() {
      const t = {};
      return {
        get: function(e) {
          if (void 0 !== t[e.id]) return t[e.id];
          let n;
          switch (e.type) {
            case "DirectionalLight":
            case "SpotLight":
              n = {
                shadowBias: 0,
                shadowNormalBias: 0,
                shadowRadius: 1,
                shadowMapSize: new sr
              };
              break;
            case "PointLight":
              n = {
                shadowBias: 0,
                shadowNormalBias: 0,
                shadowRadius: 1,
                shadowMapSize: new sr,
                shadowCameraNear: 1,
                shadowCameraFar: 1e3
              }
          }
          return t[e.id] = n, n
        }
      }
    }
    let Lh = 0;

    function Rh(t, e) {
      return (e.castShadow ? 1 : 0) - (t.castShadow ? 1 : 0)
    }

    function Ch(t, e) {
      const n = new Eh,
        r = Ah(),
        i = {
          version: 0,
          hash: {
            directionalLength: -1,
            pointLength: -1,
            spotLength: -1,
            rectAreaLength: -1,
            hemiLength: -1,
            numDirectionalShadows: -1,
            numPointShadows: -1,
            numSpotShadows: -1
          },
          ambient: [0, 0, 0],
          probe: [],
          directional: [],
          directionalShadow: [],
          directionalShadowMap: [],
          directionalShadowMatrix: [],
          spot: [],
          spotShadow: [],
          spotShadowMap: [],
          spotShadowMatrix: [],
          rectArea: [],
          rectAreaLTC1: null,
          rectAreaLTC2: null,
          point: [],
          pointShadow: [],
          pointShadowMap: [],
          pointShadowMatrix: [],
          hemi: []
        };
      for (let l = 0; l < 9; l++) i.probe.push(new gr);
      const s = new gr,
        o = new Xr,
        a = new Xr;
      return {
        setup: function(s) {
          let o = 0,
            a = 0,
            l = 0;
          for (let t = 0; t < 9; t++) i.probe[t].set(0, 0, 0);
          let c = 0,
            h = 0,
            u = 0,
            p = 0,
            d = 0,
            m = 0,
            f = 0,
            g = 0;
          s.sort(Rh);
          for (let t = 0, e = s.length; t < e; t++) {
            const e = s[t],
              x = e.color,
              v = e.intensity,
              y = e.distance,
              _ = e.shadow && e.shadow.map ? e.shadow.map.texture : null;
            if (e.isAmbientLight) o += x.r * v, a += x.g * v, l += x.b * v;
            else if (e.isLightProbe)
              for (let t = 0; t < 9; t++) i.probe[t].addScaledVector(e.sh.coefficients[t], v);
            else if (e.isDirectionalLight) {
              const t = n.get(e);
              if (t.color.copy(e.color).multiplyScalar(e.intensity), e.castShadow) {
                const t = e.shadow,
                  n = r.get(e);
                n.shadowBias = t.bias, n.shadowNormalBias = t.normalBias, n.shadowRadius = t.radius, n.shadowMapSize = t.mapSize, i.directionalShadow[c] = n, i.directionalShadowMap[c] = _, i.directionalShadowMatrix[c] = e.shadow.matrix, m++
              }
              i.directional[c] = t, c++
            } else if (e.isSpotLight) {
              const t = n.get(e);
              if (t.position.setFromMatrixPosition(e.matrixWorld), t.color.copy(x).multiplyScalar(v), t.distance = y, t.coneCos = Math.cos(e.angle), t.penumbraCos = Math.cos(e.angle * (1 - e.penumbra)), t.decay = e.decay, e.castShadow) {
                const t = e.shadow,
                  n = r.get(e);
                n.shadowBias = t.bias, n.shadowNormalBias = t.normalBias, n.shadowRadius = t.radius, n.shadowMapSize = t.mapSize, i.spotShadow[u] = n, i.spotShadowMap[u] = _, i.spotShadowMatrix[u] = e.shadow.matrix, g++
              }
              i.spot[u] = t, u++
            } else if (e.isRectAreaLight) {
              const t = n.get(e);
              t.color.copy(x).multiplyScalar(v), t.halfWidth.set(.5 * e.width, 0, 0), t.halfHeight.set(0, .5 * e.height, 0), i.rectArea[p] = t, p++
            } else if (e.isPointLight) {
              const t = n.get(e);
              if (t.color.copy(e.color).multiplyScalar(e.intensity), t.distance = e.distance, t.decay = e.decay, e.castShadow) {
                const t = e.shadow,
                  n = r.get(e);
                n.shadowBias = t.bias, n.shadowNormalBias = t.normalBias, n.shadowRadius = t.radius, n.shadowMapSize = t.mapSize, n.shadowCameraNear = t.camera.near, n.shadowCameraFar = t.camera.far, i.pointShadow[h] = n, i.pointShadowMap[h] = _, i.pointShadowMatrix[h] = e.shadow.matrix, f++
              }
              i.point[h] = t, h++
            } else if (e.isHemisphereLight) {
              const t = n.get(e);
              t.skyColor.copy(e.color).multiplyScalar(v), t.groundColor.copy(e.groundColor).multiplyScalar(v), i.hemi[d] = t, d++
            }
          }
          p > 0 && (e.isWebGL2 ? (i.rectAreaLTC1 = Sl.LTC_FLOAT_1, i.rectAreaLTC2 = Sl.LTC_FLOAT_2) : !0 === t.has("OES_texture_float_linear") ? (i.rectAreaLTC1 = Sl.LTC_FLOAT_1, i.rectAreaLTC2 = Sl.LTC_FLOAT_2) : !0 === t.has("OES_texture_half_float_linear") ? (i.rectAreaLTC1 = Sl.LTC_HALF_1, i.rectAreaLTC2 = Sl.LTC_HALF_2) : console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")), i.ambient[0] = o, i.ambient[1] = a, i.ambient[2] = l;
          const x = i.hash;
          x.directionalLength === c && x.pointLength === h && x.spotLength === u && x.rectAreaLength === p && x.hemiLength === d && x.numDirectionalShadows === m && x.numPointShadows === f && x.numSpotShadows === g || (i.directional.length = c, i.spot.length = u, i.rectArea.length = p, i.point.length = h, i.hemi.length = d, i.directionalShadow.length = m, i.directionalShadowMap.length = m, i.pointShadow.length = f, i.pointShadowMap.length = f, i.spotShadow.length = g, i.spotShadowMap.length = g, i.directionalShadowMatrix.length = m, i.pointShadowMatrix.length = f, i.spotShadowMatrix.length = g, x.directionalLength = c, x.pointLength = h, x.spotLength = u, x.rectAreaLength = p, x.hemiLength = d, x.numDirectionalShadows = m, x.numPointShadows = f, x.numSpotShadows = g, i.version = Lh++)
        },
        setupView: function(t, e) {
          let n = 0,
            r = 0,
            l = 0,
            c = 0,
            h = 0;
          const u = e.matrixWorldInverse;
          for (let p = 0, d = t.length; p < d; p++) {
            const e = t[p];
            if (e.isDirectionalLight) {
              const t = i.directional[n];
              t.direction.setFromMatrixPosition(e.matrixWorld), s.setFromMatrixPosition(e.target.matrixWorld), t.direction.sub(s), t.direction.transformDirection(u), n++
            } else if (e.isSpotLight) {
              const t = i.spot[l];
              t.position.setFromMatrixPosition(e.matrixWorld), t.position.applyMatrix4(u), t.direction.setFromMatrixPosition(e.matrixWorld), s.setFromMatrixPosition(e.target.matrixWorld), t.direction.sub(s), t.direction.transformDirection(u), l++
            } else if (e.isRectAreaLight) {
              const t = i.rectArea[c];
              t.position.setFromMatrixPosition(e.matrixWorld), t.position.applyMatrix4(u), a.identity(), o.copy(e.matrixWorld), o.premultiply(u), a.extractRotation(o), t.halfWidth.set(.5 * e.width, 0, 0), t.halfHeight.set(0, .5 * e.height, 0), t.halfWidth.applyMatrix4(a), t.halfHeight.applyMatrix4(a), c++
            } else if (e.isPointLight) {
              const t = i.point[r];
              t.position.setFromMatrixPosition(e.matrixWorld), t.position.applyMatrix4(u), r++
            } else if (e.isHemisphereLight) {
              const t = i.hemi[h];
              t.direction.setFromMatrixPosition(e.matrixWorld), t.direction.transformDirection(u), t.direction.normalize(), h++
            }
          }
        },
        state: i
      }
    }

    function Ph(t, e) {
      const n = new Ch(t, e),
        r = [],
        i = [];
      return {
        init: function() {
          r.length = 0, i.length = 0
        },
        state: {
          lightsArray: r,
          shadowsArray: i,
          lights: n
        },
        setupLights: function() {
          n.setup(r)
        },
        setupLightsView: function(t) {
          n.setupView(r, t)
        },
        pushLight: function(t) {
          r.push(t)
        },
        pushShadow: function(t) {
          i.push(t)
        }
      }
    }

    function Dh(t, e) {
      let n = new WeakMap;
      return {
        get: function(r, i = 0) {
          let s;
          return !1 === n.has(r) ? (s = new Ph(t, e), n.set(r, [s])) : i >= n.get(r).length ? (s = new Ph(t, e), n.get(r).push(s)) : s = n.get(r)[i], s
        },
        dispose: function() {
          n = new WeakMap
        }
      }
    }
    class Ih extends Ni {
      constructor(t) {
        super(), this.type = "MeshDepthMaterial", this.depthPacking = en, this.skinning = !1, this.morphTargets = !1, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.setValues(t)
      }
      copy(t) {
        return super.copy(t), this.depthPacking = t.depthPacking, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.map = t.map, this.alphaMap = t.alphaMap, this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this
      }
    }
    exports.MeshDepthMaterial = Ih, Ih.prototype.isMeshDepthMaterial = !0;
    class Bh extends Ni {
      constructor(t) {
        super(), this.type = "MeshDistanceMaterial", this.referencePosition = new gr, this.nearDistance = 1, this.farDistance = 1e3, this.skinning = !1, this.morphTargets = !1, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.fog = !1, this.setValues(t)
      }
      copy(t) {
        return super.copy(t), this.referencePosition.copy(t.referencePosition), this.nearDistance = t.nearDistance, this.farDistance = t.farDistance, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.map = t.map, this.alphaMap = t.alphaMap, this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this
      }
    }
    exports.MeshDistanceMaterial = Bh, Bh.prototype.isMeshDistanceMaterial = !0;
    var Nh = "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n\tfloat mean = 0.0;\n\tfloat squared_mean = 0.0;\n\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy ) / resolution ) );\n\tfor ( float i = -1.0; i < 1.0 ; i += SAMPLE_RATE) {\n\t\t#ifdef HORIZONTAL_PASS\n\t\t\tvec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( i, 0.0 ) * radius ) / resolution ) );\n\t\t\tmean += distribution.x;\n\t\t\tsquared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n\t\t#else\n\t\t\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, i ) * radius ) / resolution ) );\n\t\t\tmean += depth;\n\t\t\tsquared_mean += depth * depth;\n\t\t#endif\n\t}\n\tmean = mean * HALF_SAMPLE_RATE;\n\tsquared_mean = squared_mean * HALF_SAMPLE_RATE;\n\tfloat std_dev = sqrt( squared_mean - mean * mean );\n\tgl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}",
      Fh = "void main() {\n\tgl_Position = vec4( position, 1.0 );\n}";

    function zh(t, e, n) {
      let r = new Qs;
      const i = new sr,
        s = new sr,
        o = new pr,
        a = [],
        c = [],
        m = {},
        f = n.maxTextureSize,
        x = {
          0: p,
          1: u,
          2: d
        },
        v = new Hs({
          defines: {
            SAMPLE_RATE: .25,
            HALF_SAMPLE_RATE: 1 / 8
          },
          uniforms: {
            shadow_pass: {
              value: null
            },
            resolution: {
              value: new sr
            },
            radius: {
              value: 4
            }
          },
          vertexShader: Fh,
          fragmentShader: Nh
        }),
        y = v.clone();
      y.defines.HORIZONTAL_PASS = 1;
      const _ = new ds;
      _.setAttribute("position", new qi(new Float32Array([-1, -1, .5, 3, -1, .5, -1, 3, .5]), 3));
      const b = new Ps(_, v),
        w = this;

      function M(n, r) {
        const i = e.update(b);
        v.uniforms.shadow_pass.value = n.map.texture, v.uniforms.resolution.value = n.mapSize, v.uniforms.radius.value = n.radius, t.setRenderTarget(n.mapPass), t.clear(), t.renderBufferDirect(r, null, i, v, b, null), y.uniforms.shadow_pass.value = n.mapPass.texture, y.uniforms.resolution.value = n.mapSize, y.uniforms.radius.value = n.radius, t.setRenderTarget(n.map), t.clear(), t.renderBufferDirect(r, null, i, y, b, null)
      }

      function S(t, e, n) {
        const r = t << 0 | e << 1 | n << 2;
        let i = a[r];
        return void 0 === i && (i = new Ih({
          depthPacking: nn,
          morphTargets: t,
          skinning: e
        }), a[r] = i), i
      }

      function T(t, e, n) {
        const r = t << 0 | e << 1 | n << 2;
        let i = c[r];
        return void 0 === i && (i = new Bh({
          morphTargets: t,
          skinning: e
        }), c[r] = i), i
      }

      function E(e, n, r, i, s, o, a) {
        let l = null,
          c = S,
          u = e.customDepthMaterial;
        if (!0 === i.isPointLight && (c = T, u = e.customDistanceMaterial), void 0 === u) {
          let t = !1;
          !0 === r.morphTargets && (t = n.morphAttributes && n.morphAttributes.position && n.morphAttributes.position.length > 0);
          let i = !1;
          !0 === e.isSkinnedMesh && (!0 === r.skinning ? i = !0 : console.warn("THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:", e)), l = c(t, i, !0 === e.isInstancedMesh)
        } else l = u;
        if (t.localClippingEnabled && !0 === r.clipShadows && 0 !== r.clippingPlanes.length) {
          const t = l.uuid,
            e = r.uuid;
          let n = m[t];
          void 0 === n && (n = {}, m[t] = n);
          let i = n[e];
          void 0 === i && (i = l.clone(), n[e] = i), l = i
        }
        return l.visible = r.visible, l.wireframe = r.wireframe, l.side = a === h ? null !== r.shadowSide ? r.shadowSide : r.side : null !== r.shadowSide ? r.shadowSide : x[r.side], l.clipShadows = r.clipShadows, l.clippingPlanes = r.clippingPlanes, l.clipIntersection = r.clipIntersection, l.wireframeLinewidth = r.wireframeLinewidth, l.linewidth = r.linewidth, !0 === i.isPointLight && !0 === l.isMeshDistanceMaterial && (l.referencePosition.setFromMatrixPosition(i.matrixWorld), l.nearDistance = s, l.farDistance = o), l
      }

      function A(n, i, s, o, a) {
        if (!1 === n.visible) return;
        if (n.layers.test(i.layers) && (n.isMesh || n.isLine || n.isPoints) && (n.castShadow || n.receiveShadow && a === h) && (!n.frustumCulled || r.intersectsObject(n))) {
          n.modelViewMatrix.multiplyMatrices(s.matrixWorldInverse, n.matrixWorld);
          const r = e.update(n),
            i = n.material;
          if (Array.isArray(i)) {
            const e = r.groups;
            for (let l = 0, c = e.length; l < c; l++) {
              const c = e[l],
                h = i[c.materialIndex];
              if (h && h.visible) {
                const e = E(n, r, h, o, s.near, s.far, a);
                t.renderBufferDirect(s, null, r, e, n, c)
              }
            }
          } else if (i.visible) {
            const e = E(n, r, i, o, s.near, s.far, a);
            t.renderBufferDirect(s, null, r, e, n, null)
          }
        }
        const l = n.children;
        for (let t = 0, e = l.length; t < e; t++) A(l[t], i, s, o, a)
      }
      this.enabled = !1, this.autoUpdate = !0, this.needsUpdate = !1, this.type = l, this.render = function(e, n, a) {
        if (!1 === w.enabled) return;
        if (!1 === w.autoUpdate && !1 === w.needsUpdate) return;
        if (0 === e.length) return;
        const l = t.getRenderTarget(),
          c = t.getActiveCubeFace(),
          u = t.getActiveMipmapLevel(),
          p = t.state;
        p.setBlending(g), p.buffers.color.setClear(1, 1, 1, 1), p.buffers.depth.setTest(!0), p.setScissorTest(!1);
        for (let d = 0, m = e.length; d < m; d++) {
          const l = e[d],
            c = l.shadow;
          if (void 0 === c) {
            console.warn("THREE.WebGLShadowMap:", l, "has no shadow.");
            continue
          }
          if (!1 === c.autoUpdate && !1 === c.needsUpdate) continue;
          i.copy(c.mapSize);
          const u = c.getFrameExtents();
          if (i.multiply(u), s.copy(c.mapSize), (i.x > f || i.y > f) && (i.x > f && (s.x = Math.floor(f / u.x), i.x = s.x * u.x, c.mapSize.x = s.x), i.y > f && (s.y = Math.floor(f / u.y), i.y = s.y * u.y, c.mapSize.y = s.y)), null === c.map && !c.isPointLightShadow && this.type === h) {
            const t = {
              minFilter: gt,
              magFilter: gt,
              format: Nt
            };
            c.map = new dr(i.x, i.y, t), c.map.texture.name = l.name + ".shadowMap", c.mapPass = new dr(i.x, i.y, t), c.camera.updateProjectionMatrix()
          }
          if (null === c.map) {
            const t = {
              minFilter: ut,
              magFilter: ut,
              format: Nt
            };
            c.map = new dr(i.x, i.y, t), c.map.texture.name = l.name + ".shadowMap", c.camera.updateProjectionMatrix()
          }
          t.setRenderTarget(c.map), t.clear();
          const m = c.getViewportCount();
          for (let t = 0; t < m; t++) {
            const e = c.getViewport(t);
            o.set(s.x * e.x, s.y * e.y, s.x * e.z, s.y * e.w), p.viewport(o), c.updateMatrices(l, t), r = c.getFrustum(), A(n, a, c.camera, l, this.type)
          }
          c.isPointLightShadow || this.type !== h || M(c, a), c.needsUpdate = !1
        }
        w.needsUpdate = !1, t.setRenderTarget(l, c, u)
      }
    }

    function Gh(t, e, n) {
      const o = n.isWebGL2;
      const a = new function() {
          let e = !1;
          const n = new pr;
          let r = null;
          const i = new pr(0, 0, 0, 0);
          return {
            setMask: function(n) {
              r === n || e || (t.colorMask(n, n, n, n), r = n)
            },
            setLocked: function(t) {
              e = t
            },
            setClear: function(e, r, s, o, a) {
              !0 === a && (e *= o, r *= o, s *= o), n.set(e, r, s, o), !1 === i.equals(n) && (t.clearColor(e, r, s, o), i.copy(n))
            },
            reset: function() {
              e = !1, r = null, i.set(-1, 0, 0, 0)
            }
          }
        },
        l = new function() {
          let e = !1,
            n = null,
            r = null,
            i = null;
          return {
            setTest: function(t) {
              t ? gt(2929) : xt(2929)
            },
            setMask: function(r) {
              n === r || e || (t.depthMask(r), n = r)
            },
            setFunc: function(e) {
              if (r !== e) {
                if (e) switch (e) {
                  case G:
                    t.depthFunc(512);
                    break;
                  case O:
                    t.depthFunc(519);
                    break;
                  case H:
                    t.depthFunc(513);
                    break;
                  case U:
                    t.depthFunc(515);
                    break;
                  case k:
                    t.depthFunc(514);
                    break;
                  case V:
                    t.depthFunc(518);
                    break;
                  case W:
                    t.depthFunc(516);
                    break;
                  case j:
                    t.depthFunc(517);
                    break;
                  default:
                    t.depthFunc(515)
                } else t.depthFunc(515);
                r = e
              }
            },
            setLocked: function(t) {
              e = t
            },
            setClear: function(e) {
              i !== e && (t.clearDepth(e), i = e)
            },
            reset: function() {
              e = !1, n = null, r = null, i = null
            }
          }
        },
        c = new function() {
          let e = !1,
            n = null,
            r = null,
            i = null,
            s = null,
            o = null,
            a = null,
            l = null,
            c = null;
          return {
            setTest: function(t) {
              e || (t ? gt(2960) : xt(2960))
            },
            setMask: function(r) {
              n === r || e || (t.stencilMask(r), n = r)
            },
            setFunc: function(e, n, o) {
              r === e && i === n && s === o || (t.stencilFunc(e, n, o), r = e, i = n, s = o)
            },
            setOp: function(e, n, r) {
              o === e && a === n && l === r || (t.stencilOp(e, n, r), o = e, a = n, l = r)
            },
            setLocked: function(t) {
              e = t
            },
            setClear: function(e) {
              c !== e && (t.clearStencil(e), c = e)
            },
            reset: function() {
              e = !1, n = null, r = null, i = null, s = null, o = null, a = null, l = null, c = null
            }
          }
        };
      let h = {},
        u = null,
        m = {},
        f = null,
        q = !1,
        X = null,
        Y = null,
        Z = null,
        J = null,
        Q = null,
        K = null,
        $ = null,
        tt = !1,
        et = null,
        nt = null,
        rt = null,
        it = null,
        st = null;
      const ot = t.getParameter(35661);
      let at = !1,
        lt = 0;
      const ct = t.getParameter(7938); - 1 !== ct.indexOf("WebGL") ? (lt = parseFloat(/^WebGL (\d)/.exec(ct)[1]), at = lt >= 1) : -1 !== ct.indexOf("OpenGL ES") && (lt = parseFloat(/^OpenGL ES (\d)/.exec(ct)[1]), at = lt >= 2);
      let ht = null,
        ut = {};
      const pt = new pr(0, 0, t.canvas.width, t.canvas.height),
        dt = new pr(0, 0, t.canvas.width, t.canvas.height);

      function mt(e, n, r) {
        const i = new Uint8Array(4),
          s = t.createTexture();
        t.bindTexture(e, s), t.texParameteri(e, 10241, 9728), t.texParameteri(e, 10240, 9728);
        for (let o = 0; o < r; o++) t.texImage2D(n + o, 0, 6408, 1, 1, 0, 6408, 5121, i);
        return s
      }
      const ft = {};

      function gt(e) {
        !0 !== h[e] && (t.enable(e), h[e] = !0)
      }

      function xt(e) {
        !1 !== h[e] && (t.disable(e), h[e] = !1)
      }
      ft[3553] = mt(3553, 3553, 1), ft[34067] = mt(34067, 34069, 6), a.setClear(0, 0, 0, 1), l.setClear(1), c.setClear(0), gt(2929), l.setFunc(U), bt(!1), wt(i), gt(2884), _t(g);
      const vt = {
        [w]: 32774,
        [M]: 32778,
        [S]: 32779
      };
      if (o) vt[T] = 32775, vt[E] = 32776;
      else {
        const t = e.get("EXT_blend_minmax");
        null !== t && (vt[T] = t.MIN_EXT, vt[E] = t.MAX_EXT)
      }
      const yt = {
        [A]: 0,
        [L]: 1,
        [R]: 768,
        [P]: 770,
        [z]: 776,
        [N]: 774,
        [I]: 772,
        [C]: 769,
        [D]: 771,
        [F]: 775,
        [B]: 773
      };

      function _t(e, n, r, i, s, o, a, l) {
        if (e !== g) {
          if (!1 === q && (gt(3042), q = !0), e === b) s = s || n, o = o || r, a = a || i, n === Y && s === Q || (t.blendEquationSeparate(vt[n], vt[s]), Y = n, Q = s), r === Z && i === J && o === K && a === $ || (t.blendFuncSeparate(yt[r], yt[i], yt[o], yt[a]), Z = r, J = i, K = o, $ = a), X = e, tt = null;
          else if (e !== X || l !== tt) {
            if (Y === w && Q === w || (t.blendEquation(32774), Y = w, Q = w), l) switch (e) {
              case x:
                t.blendFuncSeparate(1, 771, 1, 771);
                break;
              case v:
                t.blendFunc(1, 1);
                break;
              case y:
                t.blendFuncSeparate(0, 0, 769, 771);
                break;
              case _:
                t.blendFuncSeparate(0, 768, 0, 770);
                break;
              default:
                console.error("THREE.WebGLState: Invalid blending: ", e)
            } else switch (e) {
              case x:
                t.blendFuncSeparate(770, 771, 1, 771);
                break;
              case v:
                t.blendFunc(770, 1);
                break;
              case y:
                t.blendFunc(0, 769);
                break;
              case _:
                t.blendFunc(0, 768);
                break;
              default:
                console.error("THREE.WebGLState: Invalid blending: ", e)
            }
            Z = null, J = null, K = null, $ = null, X = e, tt = l
          }
        } else !0 === q && (xt(3042), q = !1)
      }

      function bt(e) {
        et !== e && (e ? t.frontFace(2304) : t.frontFace(2305), et = e)
      }

      function wt(e) {
        e !== r ? (gt(2884), e !== nt && (e === i ? t.cullFace(1029) : e === s ? t.cullFace(1028) : t.cullFace(1032))) : xt(2884), nt = e
      }

      function Mt(e, n, r) {
        e ? (gt(32823), it === n && st === r || (t.polygonOffset(n, r), it = n, st = r)) : xt(32823)
      }

      function St(e) {
        void 0 === e && (e = 33984 + ot - 1), ht !== e && (t.activeTexture(e), ht = e)
      }
      return {
        buffers: {
          color: a,
          depth: l,
          stencil: c
        },
        enable: gt,
        disable: xt,
        bindFramebuffer: function(e, n) {
          null === n && null !== u && (n = u), m[e] !== n && (t.bindFramebuffer(e, n), m[e] = n, o && (36009 === e && (m[36160] = n), 36160 === e && (m[36009] = n)))
        },
        bindXRFramebuffer: function(e) {
          e !== u && (t.bindFramebuffer(36160, e), u = e)
        },
        useProgram: function(e) {
          return f !== e && (t.useProgram(e), f = e, !0)
        },
        setBlending: _t,
        setMaterial: function(t, e) {
          t.side === d ? xt(2884) : gt(2884);
          let n = t.side === p;
          e && (n = !n), bt(n), t.blending === x && !1 === t.transparent ? _t(g) : _t(t.blending, t.blendEquation, t.blendSrc, t.blendDst, t.blendEquationAlpha, t.blendSrcAlpha, t.blendDstAlpha, t.premultipliedAlpha), l.setFunc(t.depthFunc), l.setTest(t.depthTest), l.setMask(t.depthWrite), a.setMask(t.colorWrite);
          const r = t.stencilWrite;
          c.setTest(r), r && (c.setMask(t.stencilWriteMask), c.setFunc(t.stencilFunc, t.stencilRef, t.stencilFuncMask), c.setOp(t.stencilFail, t.stencilZFail, t.stencilZPass)), Mt(t.polygonOffset, t.polygonOffsetFactor, t.polygonOffsetUnits), !0 === t.alphaToCoverage ? gt(32926) : xt(32926)
        },
        setFlipSided: bt,
        setCullFace: wt,
        setLineWidth: function(e) {
          e !== rt && (at && t.lineWidth(e), rt = e)
        },
        setPolygonOffset: Mt,
        setScissorTest: function(t) {
          t ? gt(3089) : xt(3089)
        },
        activeTexture: St,
        bindTexture: function(e, n) {
          null === ht && St();
          let r = ut[ht];
          void 0 === r && (r = {
            type: void 0,
            texture: void 0
          }, ut[ht] = r), r.type === e && r.texture === n || (t.bindTexture(e, n || ft[e]), r.type = e, r.texture = n)
        },
        unbindTexture: function() {
          const e = ut[ht];
          void 0 !== e && void 0 !== e.type && (t.bindTexture(e.type, null), e.type = void 0, e.texture = void 0)
        },
        compressedTexImage2D: function() {
          try {
            t.compressedTexImage2D.apply(t, arguments)
          } catch (e) {
            console.error("THREE.WebGLState:", e)
          }
        },
        texImage2D: function() {
          try {
            t.texImage2D.apply(t, arguments)
          } catch (e) {
            console.error("THREE.WebGLState:", e)
          }
        },
        texImage3D: function() {
          try {
            t.texImage3D.apply(t, arguments)
          } catch (e) {
            console.error("THREE.WebGLState:", e)
          }
        },
        scissor: function(e) {
          !1 === pt.equals(e) && (t.scissor(e.x, e.y, e.z, e.w), pt.copy(e))
        },
        viewport: function(e) {
          !1 === dt.equals(e) && (t.viewport(e.x, e.y, e.z, e.w), dt.copy(e))
        },
        reset: function() {
          t.disable(3042), t.disable(2884), t.disable(2929), t.disable(32823), t.disable(3089), t.disable(2960), t.disable(32926), t.blendEquation(32774), t.blendFunc(1, 0), t.blendFuncSeparate(1, 0, 1, 0), t.colorMask(!0, !0, !0, !0), t.clearColor(0, 0, 0, 0), t.depthMask(!0), t.depthFunc(513), t.clearDepth(1), t.stencilMask(4294967295), t.stencilFunc(519, 0, 4294967295), t.stencilOp(7680, 7680, 7680), t.clearStencil(0), t.cullFace(1029), t.frontFace(2305), t.polygonOffset(0, 0), t.activeTexture(33984), t.bindFramebuffer(36160, null), !0 === o && (t.bindFramebuffer(36009, null), t.bindFramebuffer(36008, null)), t.useProgram(null), t.lineWidth(1), t.scissor(0, 0, t.canvas.width, t.canvas.height), t.viewport(0, 0, t.canvas.width, t.canvas.height), h = {}, ht = null, ut = {}, u = null, m = {}, f = null, q = !1, X = null, Y = null, Z = null, J = null, Q = null, K = null, $ = null, tt = !1, et = null, nt = null, rt = null, it = null, st = null, pt.set(0, 0, t.canvas.width, t.canvas.height), dt.set(0, 0, t.canvas.width, t.canvas.height), a.reset(), l.reset(), c.reset()
        }
      }
    }

    function Oh(t, e, n, r, i, s, o) {
      const a = i.isWebGL2,
        l = i.maxTextures,
        c = i.maxCubemapSize,
        h = i.maxTextureSize,
        u = i.maxSamples,
        p = new WeakMap;
      let d, m = !1;
      try {
        m = "undefined" != typeof OffscreenCanvas && null !== new OffscreenCanvas(1, 1).getContext("2d")
      } catch (G) {}

      function f(t, e) {
        return m ? new OffscreenCanvas(t, e) : document.createElementNS("http://www.w3.org/1999/xhtml", "canvas")
      }

      function g(t, e, n, r) {
        let i = 1;
        if ((t.width > r || t.height > r) && (i = r / Math.max(t.width, t.height)), i < 1 || !0 === e) {
          if ("undefined" != typeof HTMLImageElement && t instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && t instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && t instanceof ImageBitmap) {
            const r = e ? nr : Math.floor,
              s = r(i * t.width),
              o = r(i * t.height);
            void 0 === d && (d = f(s, o));
            const a = n ? f(s, o) : d;
            return a.width = s, a.height = o, a.getContext("2d").drawImage(t, 0, 0, s, o), console.warn("THREE.WebGLRenderer: Texture has been resized from (" + t.width + "x" + t.height + ") to (" + s + "x" + o + ")."), a
          }
          return "data" in t && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + t.width + "x" + t.height + ")."), t
        }
        return t
      }

      function x(t) {
        return tr(t.width) && tr(t.height)
      }

      function v(t, e) {
        return t.generateMipmaps && e && t.minFilter !== ut && t.minFilter !== gt
      }

      function y(e, n, i, s) {
        t.generateMipmap(e), r.get(n).__maxMipLevel = Math.log2(Math.max(i, s))
      }

      function _(n, r, i) {
        if (!1 === a) return r;
        if (null !== n) {
          if (void 0 !== t[n]) return t[n];
          console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + n + "'")
        }
        let s = r;
        return 6403 === r && (5126 === i && (s = 33326), 5131 === i && (s = 33325), 5121 === i && (s = 33321)), 6407 === r && (5126 === i && (s = 34837), 5131 === i && (s = 34843), 5121 === i && (s = 32849)), 6408 === r && (5126 === i && (s = 34836), 5131 === i && (s = 34842), 5121 === i && (s = 32856)), 33325 !== s && 33326 !== s && 34842 !== s && 34836 !== s || e.get("EXT_color_buffer_float"), s
      }

      function b(t) {
        return t === ut || t === pt || t === mt ? 9728 : 9729
      }

      function w(e) {
        const n = e.target;
        n.removeEventListener("dispose", w),
          function(e) {
            const n = r.get(e);
            if (void 0 === n.__webglInit) return;
            t.deleteTexture(n.__webglTexture), r.remove(e)
          }(n), n.isVideoTexture && p.delete(n), o.memory.textures--
      }

      function M(e) {
        const n = e.target;
        n.removeEventListener("dispose", M),
          function(e) {
            const n = e.texture,
              i = r.get(e),
              s = r.get(n);
            if (!e) return;
            void 0 !== s.__webglTexture && t.deleteTexture(s.__webglTexture);
            e.depthTexture && e.depthTexture.dispose();
            if (e.isWebGLCubeRenderTarget)
              for (let r = 0; r < 6; r++) t.deleteFramebuffer(i.__webglFramebuffer[r]), i.__webglDepthbuffer && t.deleteRenderbuffer(i.__webglDepthbuffer[r]);
            else t.deleteFramebuffer(i.__webglFramebuffer), i.__webglDepthbuffer && t.deleteRenderbuffer(i.__webglDepthbuffer), i.__webglMultisampledFramebuffer && t.deleteFramebuffer(i.__webglMultisampledFramebuffer), i.__webglColorRenderbuffer && t.deleteRenderbuffer(i.__webglColorRenderbuffer), i.__webglDepthRenderbuffer && t.deleteRenderbuffer(i.__webglDepthRenderbuffer);
            r.remove(n), r.remove(e)
          }(n), o.memory.textures--
      }
      let S = 0;

      function T(t, e) {
        const i = r.get(t);
        if (t.isVideoTexture && function(t) {
            const e = o.render.frame;
            p.get(t) !== e && (p.set(t, e), t.update())
          }(t), t.version > 0 && i.__version !== t.version) {
          const n = t.image;
          if (void 0 === n) console.warn("THREE.WebGLRenderer: Texture marked for update but image is undefined");
          else {
            if (!1 !== n.complete) return void P(i, t, e);
            console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete")
          }
        }
        n.activeTexture(33984 + e), n.bindTexture(3553, i.__webglTexture)
      }

      function E(e, i) {
        const o = r.get(e);
        e.version > 0 && o.__version !== e.version ? function(e, r, i) {
          if (6 !== r.image.length) return;
          C(e, r), n.activeTexture(33984 + i), n.bindTexture(34067, e.__webglTexture), t.pixelStorei(37440, r.flipY), t.pixelStorei(37441, r.premultiplyAlpha), t.pixelStorei(3317, r.unpackAlignment), t.pixelStorei(37443, 0);
          const o = r && (r.isCompressedTexture || r.image[0].isCompressedTexture),
            l = r.image[0] && r.image[0].isDataTexture,
            h = [];
          for (let t = 0; t < 6; t++) h[t] = o || l ? l ? r.image[t].image : r.image[t] : g(r.image[t], !1, !0, c);
          const u = h[0],
            p = x(u) || a,
            d = s.convert(r.format),
            m = s.convert(r.type),
            f = _(r.internalFormat, d, m);
          let b;
          if (R(34067, r, p), o) {
            for (let t = 0; t < 6; t++) {
              b = h[t].mipmaps;
              for (let e = 0; e < b.length; e++) {
                const i = b[e];
                r.format !== Nt && r.format !== Bt ? null !== d ? n.compressedTexImage2D(34069 + t, e, f, i.width, i.height, 0, i.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : n.texImage2D(34069 + t, e, f, i.width, i.height, 0, d, m, i.data)
              }
            }
            e.__maxMipLevel = b.length - 1
          } else {
            b = r.mipmaps;
            for (let t = 0; t < 6; t++)
              if (l) {
                n.texImage2D(34069 + t, 0, f, h[t].width, h[t].height, 0, d, m, h[t].data);
                for (let e = 0; e < b.length; e++) {
                  const r = b[e],
                    i = r.image[t].image;
                  n.texImage2D(34069 + t, e + 1, f, i.width, i.height, 0, d, m, i.data)
                }
              } else {
                n.texImage2D(34069 + t, 0, f, d, m, h[t]);
                for (let e = 0; e < b.length; e++) {
                  const r = b[e];
                  n.texImage2D(34069 + t, e + 1, f, d, m, r.image[t])
                }
              } e.__maxMipLevel = b.length
          }
          v(r, p) && y(34067, r, u.width, u.height);
          e.__version = r.version, r.onUpdate && r.onUpdate(r)
        }(o, e, i) : (n.activeTexture(33984 + i), n.bindTexture(34067, o.__webglTexture))
      }
      const A = {
          [lt]: 10497,
          [ct]: 33071,
          [ht]: 33648
        },
        L = {
          [ut]: 9728,
          [pt]: 9984,
          [mt]: 9986,
          [gt]: 9729,
          [xt]: 9985,
          [yt]: 9987
        };

      function R(n, s, o) {
        if (o ? (t.texParameteri(n, 10242, A[s.wrapS]), t.texParameteri(n, 10243, A[s.wrapT]), 32879 !== n && 35866 !== n || t.texParameteri(n, 32882, A[s.wrapR]), t.texParameteri(n, 10240, L[s.magFilter]), t.texParameteri(n, 10241, L[s.minFilter])) : (t.texParameteri(n, 10242, 33071), t.texParameteri(n, 10243, 33071), 32879 !== n && 35866 !== n || t.texParameteri(n, 32882, 33071), s.wrapS === ct && s.wrapT === ct || console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."), t.texParameteri(n, 10240, b(s.magFilter)), t.texParameteri(n, 10241, b(s.minFilter)), s.minFilter !== ut && s.minFilter !== gt && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")), !0 === e.has("EXT_texture_filter_anisotropic")) {
          const o = e.get("EXT_texture_filter_anisotropic");
          if (s.type === At && !1 === e.has("OES_texture_float_linear")) return;
          if (!1 === a && s.type === Lt && !1 === e.has("OES_texture_half_float_linear")) return;
          (s.anisotropy > 1 || r.get(s).__currentAnisotropy) && (t.texParameterf(n, o.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(s.anisotropy, i.getMaxAnisotropy())), r.get(s).__currentAnisotropy = s.anisotropy)
        }
      }

      function C(e, n) {
        void 0 === e.__webglInit && (e.__webglInit = !0, n.addEventListener("dispose", w), e.__webglTexture = t.createTexture(), o.memory.textures++)
      }

      function P(e, r, i) {
        let o = 3553;
        r.isDataTexture2DArray && (o = 35866), r.isDataTexture3D && (o = 32879), C(e, r), n.activeTexture(33984 + i), n.bindTexture(o, e.__webglTexture), t.pixelStorei(37440, r.flipY), t.pixelStorei(37441, r.premultiplyAlpha), t.pixelStorei(3317, r.unpackAlignment), t.pixelStorei(37443, 0);
        const l = function(t) {
            return !a && (t.wrapS !== ct || t.wrapT !== ct || t.minFilter !== ut && t.minFilter !== gt)
          }(r) && !1 === x(r.image),
          c = g(r.image, l, !1, h),
          u = x(c) || a,
          p = s.convert(r.format);
        let d, m = s.convert(r.type),
          f = _(r.internalFormat, p, m);
        R(o, r, u);
        const b = r.mipmaps;
        if (r.isDepthTexture) f = 6402, a ? f = r.type === At ? 36012 : r.type === Et ? 33190 : r.type === Dt ? 35056 : 33189 : r.type === At && console.error("WebGLRenderer: Floating point depth texture requires WebGL2."), r.format === Ot && 6402 === f && r.type !== St && r.type !== Et && (console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."), r.type = St, m = s.convert(r.type)), r.format === Ht && 6402 === f && (f = 34041, r.type !== Dt && (console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."), r.type = Dt, m = s.convert(r.type))), n.texImage2D(3553, 0, f, c.width, c.height, 0, p, m, null);
        else if (r.isDataTexture)
          if (b.length > 0 && u) {
            for (let t = 0, e = b.length; t < e; t++) d = b[t], n.texImage2D(3553, t, f, d.width, d.height, 0, p, m, d.data);
            r.generateMipmaps = !1, e.__maxMipLevel = b.length - 1
          } else n.texImage2D(3553, 0, f, c.width, c.height, 0, p, m, c.data), e.__maxMipLevel = 0;
        else if (r.isCompressedTexture) {
          for (let t = 0, e = b.length; t < e; t++) d = b[t], r.format !== Nt && r.format !== Bt ? null !== p ? n.compressedTexImage2D(3553, t, f, d.width, d.height, 0, d.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : n.texImage2D(3553, t, f, d.width, d.height, 0, p, m, d.data);
          e.__maxMipLevel = b.length - 1
        } else if (r.isDataTexture2DArray) n.texImage3D(35866, 0, f, c.width, c.height, c.depth, 0, p, m, c.data), e.__maxMipLevel = 0;
        else if (r.isDataTexture3D) n.texImage3D(32879, 0, f, c.width, c.height, c.depth, 0, p, m, c.data), e.__maxMipLevel = 0;
        else if (b.length > 0 && u) {
          for (let t = 0, e = b.length; t < e; t++) d = b[t], n.texImage2D(3553, t, f, p, m, d);
          r.generateMipmaps = !1, e.__maxMipLevel = b.length - 1
        } else n.texImage2D(3553, 0, f, p, m, c), e.__maxMipLevel = 0;
        v(r, u) && y(o, r, c.width, c.height), e.__version = r.version, r.onUpdate && r.onUpdate(r)
      }

      function D(e, i, o, a) {
        const l = i.texture,
          c = s.convert(l.format),
          h = s.convert(l.type),
          u = _(l.internalFormat, c, h);
        32879 === a || 35866 === a ? n.texImage3D(a, 0, u, i.width, i.height, i.depth, 0, c, h, null) : n.texImage2D(a, 0, u, i.width, i.height, 0, c, h, null), n.bindFramebuffer(36160, e), t.framebufferTexture2D(36160, o, a, r.get(l).__webglTexture, 0), n.bindFramebuffer(36160, null)
      }

      function I(e, n, r) {
        if (t.bindRenderbuffer(36161, e), n.depthBuffer && !n.stencilBuffer) {
          let i = 33189;
          if (r) {
            const e = n.depthTexture;
            e && e.isDepthTexture && (e.type === At ? i = 36012 : e.type === Et && (i = 33190));
            const r = N(n);
            t.renderbufferStorageMultisample(36161, r, i, n.width, n.height)
          } else t.renderbufferStorage(36161, i, n.width, n.height);
          t.framebufferRenderbuffer(36160, 36096, 36161, e)
        } else if (n.depthBuffer && n.stencilBuffer) {
          if (r) {
            const e = N(n);
            t.renderbufferStorageMultisample(36161, e, 35056, n.width, n.height)
          } else t.renderbufferStorage(36161, 34041, n.width, n.height);
          t.framebufferRenderbuffer(36160, 33306, 36161, e)
        } else {
          const e = n.texture,
            i = s.convert(e.format),
            o = s.convert(e.type),
            a = _(e.internalFormat, i, o);
          if (r) {
            const e = N(n);
            t.renderbufferStorageMultisample(36161, e, a, n.width, n.height)
          } else t.renderbufferStorage(36161, a, n.width, n.height)
        }
        t.bindRenderbuffer(36161, null)
      }

      function B(e) {
        const i = r.get(e),
          s = !0 === e.isWebGLCubeRenderTarget;
        if (e.depthTexture) {
          if (s) throw new Error("target.depthTexture not supported in Cube render targets");
          ! function(e, i) {
            if (i && i.isWebGLCubeRenderTarget) throw new Error("Depth Texture with cube render targets is not supported");
            if (n.bindFramebuffer(36160, e), !i.depthTexture || !i.depthTexture.isDepthTexture) throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
            r.get(i.depthTexture).__webglTexture && i.depthTexture.image.width === i.width && i.depthTexture.image.height === i.height || (i.depthTexture.image.width = i.width, i.depthTexture.image.height = i.height, i.depthTexture.needsUpdate = !0), T(i.depthTexture, 0);
            const s = r.get(i.depthTexture).__webglTexture;
            if (i.depthTexture.format === Ot) t.framebufferTexture2D(36160, 36096, 3553, s, 0);
            else {
              if (i.depthTexture.format !== Ht) throw new Error("Unknown depthTexture format");
              t.framebufferTexture2D(36160, 33306, 3553, s, 0)
            }
          }(i.__webglFramebuffer, e)
        } else if (s) {
          i.__webglDepthbuffer = [];
          for (let r = 0; r < 6; r++) n.bindFramebuffer(36160, i.__webglFramebuffer[r]), i.__webglDepthbuffer[r] = t.createRenderbuffer(), I(i.__webglDepthbuffer[r], e, !1)
        } else n.bindFramebuffer(36160, i.__webglFramebuffer), i.__webglDepthbuffer = t.createRenderbuffer(), I(i.__webglDepthbuffer, e, !1);
        n.bindFramebuffer(36160, null)
      }

      function N(t) {
        return a && t.isWebGLMultisampleRenderTarget ? Math.min(u, t.samples) : 0
      }
      let F = !1,
        z = !1;
      this.allocateTextureUnit = function() {
        const t = S;
        return t >= l && console.warn("THREE.WebGLTextures: Trying to use " + t + " texture units while this GPU supports only " + l), S += 1, t
      }, this.resetTextureUnits = function() {
        S = 0
      }, this.setTexture2D = T, this.setTexture2DArray = function(t, e) {
        const i = r.get(t);
        t.version > 0 && i.__version !== t.version ? P(i, t, e) : (n.activeTexture(33984 + e), n.bindTexture(35866, i.__webglTexture))
      }, this.setTexture3D = function(t, e) {
        const i = r.get(t);
        t.version > 0 && i.__version !== t.version ? P(i, t, e) : (n.activeTexture(33984 + e), n.bindTexture(32879, i.__webglTexture))
      }, this.setTextureCube = E, this.setupRenderTarget = function(e) {
        const i = e.texture,
          l = r.get(e),
          c = r.get(i);
        e.addEventListener("dispose", M), c.__webglTexture = t.createTexture(), c.__version = i.version, o.memory.textures++;
        const h = !0 === e.isWebGLCubeRenderTarget,
          u = !0 === e.isWebGLMultisampleRenderTarget,
          p = i.isDataTexture3D || i.isDataTexture2DArray,
          d = x(e) || a;
        if (!a || i.format !== Bt || i.type !== At && i.type !== Lt || (i.format = Nt, console.warn("THREE.WebGLRenderer: Rendering to textures with RGB format is not supported. Using RGBA format instead.")), h) {
          l.__webglFramebuffer = [];
          for (let e = 0; e < 6; e++) l.__webglFramebuffer[e] = t.createFramebuffer()
        } else if (l.__webglFramebuffer = t.createFramebuffer(), u)
          if (a) {
            l.__webglMultisampledFramebuffer = t.createFramebuffer(), l.__webglColorRenderbuffer = t.createRenderbuffer(), t.bindRenderbuffer(36161, l.__webglColorRenderbuffer);
            const r = s.convert(i.format),
              o = s.convert(i.type),
              a = _(i.internalFormat, r, o),
              c = N(e);
            t.renderbufferStorageMultisample(36161, c, a, e.width, e.height), n.bindFramebuffer(36160, l.__webglMultisampledFramebuffer), t.framebufferRenderbuffer(36160, 36064, 36161, l.__webglColorRenderbuffer), t.bindRenderbuffer(36161, null), e.depthBuffer && (l.__webglDepthRenderbuffer = t.createRenderbuffer(), I(l.__webglDepthRenderbuffer, e, !0)), n.bindFramebuffer(36160, null)
          } else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.");
        if (h) {
          n.bindTexture(34067, c.__webglTexture), R(34067, i, d);
          for (let t = 0; t < 6; t++) D(l.__webglFramebuffer[t], e, 36064, 34069 + t);
          v(i, d) && y(34067, i, e.width, e.height), n.bindTexture(34067, null)
        } else {
          let t = 3553;
          p && (a ? t = i.isDataTexture3D ? 32879 : 35866 : console.warn("THREE.DataTexture3D and THREE.DataTexture2DArray only supported with WebGL2.")), n.bindTexture(t, c.__webglTexture), R(t, i, d), D(l.__webglFramebuffer, e, 36064, t), v(i, d) && y(3553, i, e.width, e.height), n.bindTexture(3553, null)
        }
        e.depthBuffer && B(e)
      }, this.updateRenderTargetMipmap = function(t) {
        const e = t.texture;
        if (v(e, x(t) || a)) {
          const i = t.isWebGLCubeRenderTarget ? 34067 : 3553,
            s = r.get(e).__webglTexture;
          n.bindTexture(i, s), y(i, e, t.width, t.height), n.bindTexture(i, null)
        }
      }, this.updateMultisampleRenderTarget = function(e) {
        if (e.isWebGLMultisampleRenderTarget)
          if (a) {
            const i = e.width,
              s = e.height;
            let o = 16384;
            e.depthBuffer && (o |= 256), e.stencilBuffer && (o |= 1024);
            const a = r.get(e);
            n.bindFramebuffer(36008, a.__webglMultisampledFramebuffer), n.bindFramebuffer(36009, a.__webglFramebuffer), t.blitFramebuffer(0, 0, i, s, 0, 0, i, s, o, 9728), n.bindFramebuffer(36008, null), n.bindFramebuffer(36009, a.__webglMultisampledFramebuffer)
          } else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.")
      }, this.safeSetTexture2D = function(t, e) {
        t && t.isWebGLRenderTarget && (!1 === F && (console.warn("THREE.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead."), F = !0), t = t.texture), T(t, e)
      }, this.safeSetTextureCube = function(t, e) {
        t && t.isWebGLCubeRenderTarget && (!1 === z && (console.warn("THREE.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead."), z = !0), t = t.texture), E(t, e)
      }
    }

    function Hh(t, e, n) {
      const r = n.isWebGL2;
      return {
        convert: function(t) {
          let n;
          if (t === bt) return 5121;
          if (t === Rt) return 32819;
          if (t === Ct) return 32820;
          if (t === Pt) return 33635;
          if (t === wt) return 5120;
          if (t === Mt) return 5122;
          if (t === St) return 5123;
          if (t === Tt) return 5124;
          if (t === Et) return 5125;
          if (t === At) return 5126;
          if (t === Lt) return r ? 5131 : null !== (n = e.get("OES_texture_half_float")) ? n.HALF_FLOAT_OES : null;
          if (t === It) return 6406;
          if (t === Bt) return 6407;
          if (t === Nt) return 6408;
          if (t === Ft) return 6409;
          if (t === zt) return 6410;
          if (t === Ot) return 6402;
          if (t === Ht) return 34041;
          if (t === Ut) return 6403;
          if (t === kt) return 36244;
          if (t === Vt) return 33319;
          if (t === Wt) return 33320;
          if (t === jt) return 36248;
          if (t === qt) return 36249;
          if (t === Xt || t === Yt || t === Zt || t === Jt) {
            if (null === (n = e.get("WEBGL_compressed_texture_s3tc"))) return null;
            if (t === Xt) return n.COMPRESSED_RGB_S3TC_DXT1_EXT;
            if (t === Yt) return n.COMPRESSED_RGBA_S3TC_DXT1_EXT;
            if (t === Zt) return n.COMPRESSED_RGBA_S3TC_DXT3_EXT;
            if (t === Jt) return n.COMPRESSED_RGBA_S3TC_DXT5_EXT
          }
          if (t === Qt || t === Kt || t === $t || t === te) {
            if (null === (n = e.get("WEBGL_compressed_texture_pvrtc"))) return null;
            if (t === Qt) return n.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
            if (t === Kt) return n.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
            if (t === $t) return n.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
            if (t === te) return n.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG
          }
          if (t === ee) return null !== (n = e.get("WEBGL_compressed_texture_etc1")) ? n.COMPRESSED_RGB_ETC1_WEBGL : null;
          if ((t === ne || t === re) && null !== (n = e.get("WEBGL_compressed_texture_etc"))) {
            if (t === ne) return n.COMPRESSED_RGB8_ETC2;
            if (t === re) return n.COMPRESSED_RGBA8_ETC2_EAC
          }
          return t === ie || t === se || t === oe || t === ae || t === le || t === ce || t === he || t === ue || t === pe || t === de || t === me || t === fe || t === ge || t === xe || t === ye || t === _e || t === be || t === we || t === Me || t === Se || t === Te || t === Ee || t === Ae || t === Le || t === Re || t === Ce || t === Pe || t === De ? null !== (n = e.get("WEBGL_compressed_texture_astc")) ? t : null : t === ve ? null !== (n = e.get("EXT_texture_compression_bptc")) ? t : null : t === Dt ? r ? 34042 : null !== (n = e.get("WEBGL_depth_texture")) ? n.UNSIGNED_INT_24_8_WEBGL : null : void 0
        }
      }
    }
    class Uh extends ks {
      constructor(t = []) {
        super(), this.cameras = t
      }
    }
    exports.ArrayCamera = Uh, Uh.prototype.isArrayCamera = !0;
    class kh extends vi {
      constructor() {
        super(), this.type = "Group"
      }
    }
    exports.Group = kh, kh.prototype.isGroup = !0;
    const Vh = {
      type: "move"
    };
    class Wh {
      constructor() {
        this._targetRay = null, this._grip = null, this._hand = null
      }
      getHandSpace() {
        return null === this._hand && (this._hand = new kh, this._hand.matrixAutoUpdate = !1, this._hand.visible = !1, this._hand.joints = {}, this._hand.inputState = {
          pinching: !1
        }), this._hand
      }
      getTargetRaySpace() {
        return null === this._targetRay && (this._targetRay = new kh, this._targetRay.matrixAutoUpdate = !1, this._targetRay.visible = !1, this._targetRay.hasLinearVelocity = !1, this._targetRay.linearVelocity = new gr, this._targetRay.hasAngularVelocity = !1, this._targetRay.angularVelocity = new gr), this._targetRay
      }
      getGripSpace() {
        return null === this._grip && (this._grip = new kh, this._grip.matrixAutoUpdate = !1, this._grip.visible = !1, this._grip.hasLinearVelocity = !1, this._grip.linearVelocity = new gr, this._grip.hasAngularVelocity = !1, this._grip.angularVelocity = new gr), this._grip
      }
      dispatchEvent(t) {
        return null !== this._targetRay && this._targetRay.dispatchEvent(t), null !== this._grip && this._grip.dispatchEvent(t), null !== this._hand && this._hand.dispatchEvent(t), this
      }
      disconnect(t) {
        return this.dispatchEvent({
          type: "disconnected",
          data: t
        }), null !== this._targetRay && (this._targetRay.visible = !1), null !== this._grip && (this._grip.visible = !1), null !== this._hand && (this._hand.visible = !1), this
      }
      update(t, e, n) {
        let r = null,
          i = null,
          s = null;
        const o = this._targetRay,
          a = this._grip,
          l = this._hand;
        if (t && "visible-blurred" !== e.session.visibilityState)
          if (null !== o && null !== (r = e.getPose(t.targetRaySpace, n)) && (o.matrix.fromArray(r.transform.matrix), o.matrix.decompose(o.position, o.rotation, o.scale), r.linearVelocity ? (o.hasLinearVelocity = !0, o.linearVelocity.copy(r.linearVelocity)) : o.hasLinearVelocity = !1, r.angularVelocity ? (o.hasAngularVelocity = !0, o.angularVelocity.copy(r.angularVelocity)) : o.hasAngularVelocity = !1, this.dispatchEvent(Vh)), l && t.hand) {
            s = !0;
            for (const s of t.hand.values()) {
              const t = e.getJointPose(s, n);
              if (void 0 === l.joints[s.jointName]) {
                const t = new kh;
                t.matrixAutoUpdate = !1, t.visible = !1, l.joints[s.jointName] = t, l.add(t)
              }
              const r = l.joints[s.jointName];
              null !== t && (r.matrix.fromArray(t.transform.matrix), r.matrix.decompose(r.position, r.rotation, r.scale), r.jointRadius = t.radius), r.visible = null !== t
            }
            const r = l.joints["index-finger-tip"],
              i = l.joints["thumb-tip"],
              o = r.position.distanceTo(i.position),
              a = .02,
              c = .005;
            l.inputState.pinching && o > a + c ? (l.inputState.pinching = !1, this.dispatchEvent({
              type: "pinchend",
              handedness: t.handedness,
              target: this
            })) : !l.inputState.pinching && o <= a - c && (l.inputState.pinching = !0, this.dispatchEvent({
              type: "pinchstart",
              handedness: t.handedness,
              target: this
            }))
          } else null !== a && t.gripSpace && null !== (i = e.getPose(t.gripSpace, n)) && (a.matrix.fromArray(i.transform.matrix), a.matrix.decompose(a.position, a.rotation, a.scale), i.linearVelocity ? (a.hasLinearVelocity = !0, a.linearVelocity.copy(i.linearVelocity)) : a.hasLinearVelocity = !1, i.angularVelocity ? (a.hasAngularVelocity = !0, a.angularVelocity.copy(i.angularVelocity)) : a.hasAngularVelocity = !1);
        return null !== o && (o.visible = null !== r), null !== a && (a.visible = null !== i), null !== l && (l.visible = null !== s), this
      }
    }
    class jh extends In {
      constructor(t, e) {
        super();
        const n = this,
          r = t.state;
        let i = null,
          s = 1,
          o = null,
          a = "local-floor",
          l = null;
        const c = [],
          h = new Map,
          u = new ks;
        u.layers.enable(1), u.viewport = new pr;
        const p = new ks;
        p.layers.enable(2), p.viewport = new pr;
        const d = [u, p],
          m = new Uh;
        m.layers.enable(1), m.layers.enable(2);
        let f = null,
          g = null;

        function x(t) {
          const e = h.get(t.inputSource);
          e && e.dispatchEvent({
            type: t.type,
            data: t.inputSource
          })
        }

        function v() {
          h.forEach(function(t, e) {
            t.disconnect(e)
          }), h.clear(), f = null, g = null, r.bindXRFramebuffer(null), t.setRenderTarget(t.getRenderTarget()), S.stop(), n.isPresenting = !1, n.dispatchEvent({
            type: "sessionend"
          })
        }

        function y(t) {
          const e = i.inputSources;
          for (let n = 0; n < c.length; n++) h.set(e[n], c[n]);
          for (let n = 0; n < t.removed.length; n++) {
            const e = t.removed[n],
              r = h.get(e);
            r && (r.dispatchEvent({
              type: "disconnected",
              data: e
            }), h.delete(e))
          }
          for (let n = 0; n < t.added.length; n++) {
            const e = t.added[n],
              r = h.get(e);
            r && r.dispatchEvent({
              type: "connected",
              data: e
            })
          }
        }
        this.enabled = !1, this.isPresenting = !1, this.getController = function(t) {
          let e = c[t];
          return void 0 === e && (e = new Wh, c[t] = e), e.getTargetRaySpace()
        }, this.getControllerGrip = function(t) {
          let e = c[t];
          return void 0 === e && (e = new Wh, c[t] = e), e.getGripSpace()
        }, this.getHand = function(t) {
          let e = c[t];
          return void 0 === e && (e = new Wh, c[t] = e), e.getHandSpace()
        }, this.setFramebufferScaleFactor = function(t) {
          s = t, !0 === n.isPresenting && console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.")
        }, this.setReferenceSpaceType = function(t) {
          a = t, !0 === n.isPresenting && console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.")
        }, this.getReferenceSpace = function() {
          return o
        }, this.getSession = function() {
          return i
        }, this.setSession = async function(t) {
          if (null !== (i = t)) {
            i.addEventListener("select", x), i.addEventListener("selectstart", x), i.addEventListener("selectend", x), i.addEventListener("squeeze", x), i.addEventListener("squeezestart", x), i.addEventListener("squeezeend", x), i.addEventListener("end", v), i.addEventListener("inputsourceschange", y);
            const t = e.getContextAttributes();
            !0 !== t.xrCompatible && await e.makeXRCompatible();
            const r = {
                antialias: t.antialias,
                alpha: t.alpha,
                depth: t.depth,
                stencil: t.stencil,
                framebufferScaleFactor: s
              },
              l = new XRWebGLLayer(i, e, r);
            i.updateRenderState({
              baseLayer: l
            }), o = await i.requestReferenceSpace(a), S.setContext(i), S.start(), n.isPresenting = !0, n.dispatchEvent({
              type: "sessionstart"
            })
          }
        };
        const _ = new gr,
          b = new gr;

        function w(t, e) {
          null === e ? t.matrixWorld.copy(t.matrix) : t.matrixWorld.multiplyMatrices(e.matrixWorld, t.matrix), t.matrixWorldInverse.copy(t.matrixWorld).invert()
        }
        this.getCamera = function(t) {
          m.near = p.near = u.near = t.near, m.far = p.far = u.far = t.far, f === m.near && g === m.far || (i.updateRenderState({
            depthNear: m.near,
            depthFar: m.far
          }), f = m.near, g = m.far);
          const e = t.parent,
            n = m.cameras;
          w(m, e);
          for (let i = 0; i < n.length; i++) w(n[i], e);
          t.matrixWorld.copy(m.matrixWorld), t.matrix.copy(m.matrix), t.matrix.decompose(t.position, t.quaternion, t.scale);
          const r = t.children;
          for (let i = 0, s = r.length; i < s; i++) r[i].updateMatrixWorld(!0);
          return 2 === n.length ? function(t, e, n) {
            _.setFromMatrixPosition(e.matrixWorld), b.setFromMatrixPosition(n.matrixWorld);
            const r = _.distanceTo(b),
              i = e.projectionMatrix.elements,
              s = n.projectionMatrix.elements,
              o = i[14] / (i[10] - 1),
              a = i[14] / (i[10] + 1),
              l = (i[9] + 1) / i[5],
              c = (i[9] - 1) / i[5],
              h = (i[8] - 1) / i[0],
              u = (s[8] + 1) / s[0],
              p = o * h,
              d = o * u,
              m = r / (-h + u),
              f = m * -h;
            e.matrixWorld.decompose(t.position, t.quaternion, t.scale), t.translateX(f), t.translateZ(m), t.matrixWorld.compose(t.position, t.quaternion, t.scale), t.matrixWorldInverse.copy(t.matrixWorld).invert();
            const g = o + m,
              x = a + m,
              v = p - f,
              y = d + (r - f),
              w = l * a / x * g,
              M = c * a / x * g;
            t.projectionMatrix.makePerspective(v, y, w, M, g, x)
          }(m, u, p) : m.projectionMatrix.copy(u.projectionMatrix), m
        };
        let M = null;
        const S = new Ks;
        S.setAnimationLoop(function(t, e) {
          if (null !== (l = e.getViewerPose(o))) {
            const t = l.views,
              e = i.renderState.baseLayer;
            r.bindXRFramebuffer(e.framebuffer);
            let n = !1;
            t.length !== m.cameras.length && (m.cameras.length = 0, n = !0);
            for (let r = 0; r < t.length; r++) {
              const i = t[r],
                s = e.getViewport(i),
                o = d[r];
              o.matrix.fromArray(i.transform.matrix), o.projectionMatrix.fromArray(i.projectionMatrix), o.viewport.set(s.x, s.y, s.width, s.height), 0 === r && m.matrix.copy(o.matrix), !0 === n && m.cameras.push(o)
            }
          }
          const n = i.inputSources;
          for (let r = 0; r < c.length; r++) {
            const t = c[r],
              i = n[r];
            t.update(i, e, o)
          }
          M && M(t, e)
        }), this.setAnimationLoop = function(t) {
          M = t
        }, this.dispose = function() {}
      }
    }

    function qh(t) {
      function e(e, n) {
        e.opacity.value = n.opacity, n.color && e.diffuse.value.copy(n.color), n.emissive && e.emissive.value.copy(n.emissive).multiplyScalar(n.emissiveIntensity), n.map && (e.map.value = n.map), n.alphaMap && (e.alphaMap.value = n.alphaMap), n.specularMap && (e.specularMap.value = n.specularMap);
        const r = t.get(n).envMap;
        if (r) {
          e.envMap.value = r, e.flipEnvMap.value = r.isCubeTexture && r._needsFlipEnvMap ? -1 : 1, e.reflectivity.value = n.reflectivity, e.refractionRatio.value = n.refractionRatio;
          const i = t.get(r).__maxMipLevel;
          void 0 !== i && (e.maxMipLevel.value = i)
        }
        let i, s;
        n.lightMap && (e.lightMap.value = n.lightMap, e.lightMapIntensity.value = n.lightMapIntensity), n.aoMap && (e.aoMap.value = n.aoMap, e.aoMapIntensity.value = n.aoMapIntensity), n.map ? i = n.map : n.specularMap ? i = n.specularMap : n.displacementMap ? i = n.displacementMap : n.normalMap ? i = n.normalMap : n.bumpMap ? i = n.bumpMap : n.roughnessMap ? i = n.roughnessMap : n.metalnessMap ? i = n.metalnessMap : n.alphaMap ? i = n.alphaMap : n.emissiveMap ? i = n.emissiveMap : n.clearcoatMap ? i = n.clearcoatMap : n.clearcoatNormalMap ? i = n.clearcoatNormalMap : n.clearcoatRoughnessMap && (i = n.clearcoatRoughnessMap), void 0 !== i && (i.isWebGLRenderTarget && (i = i.texture), !0 === i.matrixAutoUpdate && i.updateMatrix(), e.uvTransform.value.copy(i.matrix)), n.aoMap ? s = n.aoMap : n.lightMap && (s = n.lightMap), void 0 !== s && (s.isWebGLRenderTarget && (s = s.texture), !0 === s.matrixAutoUpdate && s.updateMatrix(), e.uv2Transform.value.copy(s.matrix))
      }

      function n(e, n) {
        e.roughness.value = n.roughness, e.metalness.value = n.metalness, n.roughnessMap && (e.roughnessMap.value = n.roughnessMap), n.metalnessMap && (e.metalnessMap.value = n.metalnessMap), n.emissiveMap && (e.emissiveMap.value = n.emissiveMap), n.bumpMap && (e.bumpMap.value = n.bumpMap, e.bumpScale.value = n.bumpScale, n.side === p && (e.bumpScale.value *= -1)), n.normalMap && (e.normalMap.value = n.normalMap, e.normalScale.value.copy(n.normalScale), n.side === p && e.normalScale.value.negate()), n.displacementMap && (e.displacementMap.value = n.displacementMap, e.displacementScale.value = n.displacementScale, e.displacementBias.value = n.displacementBias), t.get(n).envMap && (e.envMapIntensity.value = n.envMapIntensity)
      }
      return {
        refreshFogUniforms: function(t, e) {
          t.fogColor.value.copy(e.color), e.isFog ? (t.fogNear.value = e.near, t.fogFar.value = e.far) : e.isFogExp2 && (t.fogDensity.value = e.density)
        },
        refreshMaterialUniforms: function(t, r, i, s) {
          r.isMeshBasicMaterial ? e(t, r) : r.isMeshLambertMaterial ? (e(t, r), function(t, e) {
            e.emissiveMap && (t.emissiveMap.value = e.emissiveMap)
          }(t, r)) : r.isMeshToonMaterial ? (e(t, r), function(t, e) {
            e.gradientMap && (t.gradientMap.value = e.gradientMap), e.emissiveMap && (t.emissiveMap.value = e.emissiveMap), e.bumpMap && (t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale, e.side === p && (t.bumpScale.value *= -1)), e.normalMap && (t.normalMap.value = e.normalMap, t.normalScale.value.copy(e.normalScale), e.side === p && t.normalScale.value.negate()), e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias)
          }(t, r)) : r.isMeshPhongMaterial ? (e(t, r), function(t, e) {
            t.specular.value.copy(e.specular), t.shininess.value = Math.max(e.shininess, 1e-4), e.emissiveMap && (t.emissiveMap.value = e.emissiveMap), e.bumpMap && (t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale, e.side === p && (t.bumpScale.value *= -1)), e.normalMap && (t.normalMap.value = e.normalMap, t.normalScale.value.copy(e.normalScale), e.side === p && t.normalScale.value.negate()), e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias)
          }(t, r)) : r.isMeshStandardMaterial ? (e(t, r), r.isMeshPhysicalMaterial ? function(t, e) {
            n(t, e), t.reflectivity.value = e.reflectivity, t.clearcoat.value = e.clearcoat, t.clearcoatRoughness.value = e.clearcoatRoughness, e.sheen && t.sheen.value.copy(e.sheen), e.clearcoatMap && (t.clearcoatMap.value = e.clearcoatMap), e.clearcoatRoughnessMap && (t.clearcoatRoughnessMap.value = e.clearcoatRoughnessMap), e.clearcoatNormalMap && (t.clearcoatNormalScale.value.copy(e.clearcoatNormalScale), t.clearcoatNormalMap.value = e.clearcoatNormalMap, e.side === p && t.clearcoatNormalScale.value.negate()), t.transmission.value = e.transmission, e.transmissionMap && (t.transmissionMap.value = e.transmissionMap)
          }(t, r) : n(t, r)) : r.isMeshMatcapMaterial ? (e(t, r), function(t, e) {
            e.matcap && (t.matcap.value = e.matcap), e.bumpMap && (t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale, e.side === p && (t.bumpScale.value *= -1)), e.normalMap && (t.normalMap.value = e.normalMap, t.normalScale.value.copy(e.normalScale), e.side === p && t.normalScale.value.negate()), e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias)
          }(t, r)) : r.isMeshDepthMaterial ? (e(t, r), function(t, e) {
            e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias)
          }(t, r)) : r.isMeshDistanceMaterial ? (e(t, r), function(t, e) {
            e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias), t.referencePosition.value.copy(e.referencePosition), t.nearDistance.value = e.nearDistance, t.farDistance.value = e.farDistance
          }(t, r)) : r.isMeshNormalMaterial ? (e(t, r), function(t, e) {
            e.bumpMap && (t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale, e.side === p && (t.bumpScale.value *= -1)), e.normalMap && (t.normalMap.value = e.normalMap, t.normalScale.value.copy(e.normalScale), e.side === p && t.normalScale.value.negate()), e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias)
          }(t, r)) : r.isLineBasicMaterial ? (function(t, e) {
            t.diffuse.value.copy(e.color), t.opacity.value = e.opacity
          }(t, r), r.isLineDashedMaterial && function(t, e) {
            t.dashSize.value = e.dashSize, t.totalSize.value = e.dashSize + e.gapSize, t.scale.value = e.scale
          }(t, r)) : r.isPointsMaterial ? function(t, e, n, r) {
            let i;
            t.diffuse.value.copy(e.color), t.opacity.value = e.opacity, t.size.value = e.size * n, t.scale.value = .5 * r, e.map && (t.map.value = e.map), e.alphaMap && (t.alphaMap.value = e.alphaMap), e.map ? i = e.map : e.alphaMap && (i = e.alphaMap), void 0 !== i && (!0 === i.matrixAutoUpdate && i.updateMatrix(), t.uvTransform.value.copy(i.matrix))
          }(t, r, i, s) : r.isSpriteMaterial ? function(t, e) {
            let n;
            t.diffuse.value.copy(e.color), t.opacity.value = e.opacity, t.rotation.value = e.rotation, e.map && (t.map.value = e.map), e.alphaMap && (t.alphaMap.value = e.alphaMap), e.map ? n = e.map : e.alphaMap && (n = e.alphaMap), void 0 !== n && (!0 === n.matrixAutoUpdate && n.updateMatrix(), t.uvTransform.value.copy(n.matrix))
          }(t, r) : r.isShadowMaterial ? (t.color.value.copy(r.color), t.opacity.value = r.opacity) : r.isShaderMaterial && (r.uniformsNeedUpdate = !1)
        }
      }
    }

    function Xh() {
      const t = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
      return t.style.display = "block", t
    }

    function Yh(t) {
      const e = void 0 !== (t = t || {}).canvas ? t.canvas : Xh(),
        n = void 0 !== t.context ? t.context : null,
        r = void 0 !== t.alpha && t.alpha,
        i = void 0 === t.depth || t.depth,
        s = void 0 === t.stencil || t.stencil,
        o = void 0 !== t.antialias && t.antialias,
        a = void 0 === t.premultipliedAlpha || t.premultipliedAlpha,
        l = void 0 !== t.preserveDrawingBuffer && t.preserveDrawingBuffer,
        c = void 0 !== t.powerPreference ? t.powerPreference : "default",
        h = void 0 !== t.failIfMajorPerformanceCaveat && t.failIfMajorPerformanceCaveat;
      let u = null,
        p = null;
      const d = [],
        m = [];
      this.domElement = e, this.debug = {
        checkShaderErrors: !0
      }, this.autoClear = !0, this.autoClearColor = !0, this.autoClearDepth = !0, this.autoClearStencil = !0, this.sortObjects = !0, this.clippingPlanes = [], this.localClippingEnabled = !1, this.gammaFactor = 2, this.outputEncoding = Xe, this.physicallyCorrectLights = !1, this.toneMapping = Z, this.toneMappingExposure = 1;
      const f = this;
      let g = !1,
        x = 0,
        v = 0,
        y = null,
        _ = -1,
        b = null;
      const w = new pr,
        M = new pr;
      let S = null,
        T = e.width,
        E = e.height,
        A = 1,
        L = null,
        R = null;
      const C = new pr(0, 0, T, E),
        P = new pr(0, 0, T, E);
      let D = !1;
      const I = new Qs;
      let B = !1,
        N = !1;
      const F = new Xr,
        z = new gr,
        G = {
          background: null,
          fog: null,
          environment: null,
          overrideMaterial: null,
          isScene: !0
        };

      function O() {
        return null === y ? A : 1
      }
      let H, U, k, V, W, j, q, X, Y, J, Q, K, $, tt, et, nt, rt, it, st, ot, at, lt, ct = n;

      function ht(t, n) {
        for (let r = 0; r < t.length; r++) {
          const i = t[r],
            s = e.getContext(i, n);
          if (null !== s) return s
        }
        return null
      }
      try {
        const t = {
          alpha: r,
          depth: i,
          stencil: s,
          antialias: o,
          premultipliedAlpha: a,
          preserveDrawingBuffer: l,
          powerPreference: c,
          failIfMajorPerformanceCaveat: h
        };
        if (e.addEventListener("webglcontextlost", dt, !1), e.addEventListener("webglcontextrestored", mt, !1), null === ct) {
          const e = ["webgl2", "webgl", "experimental-webgl"];
          if (!0 === f.isWebGL1Renderer && e.shift(), null === (ct = ht(e, t))) throw ht(e) ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.")
        }
        void 0 === ct.getShaderPrecisionFormat && (ct.getShaderPrecisionFormat = function() {
          return {
            rangeMin: 1,
            rangeMax: 1,
            precision: 1
          }
        })
      } catch (Et) {
        throw console.error("THREE.WebGLRenderer: " + Et.message), Et
      }

      function ut() {
        H = new Dl(ct), U = new Rl(ct, H, t), H.init(U), at = new Hh(ct, H, U), k = new Gh(ct, H, U), V = new Nl(ct), W = new bh, j = new Oh(ct, H, k, W, U, at, V), q = new Pl(f), X = new $s(ct, U), lt = new Al(ct, H, X, U), Y = new Il(ct, X, V, lt), J = new Ol(ct, Y, X, V), it = new Gl(ct), et = new Cl(W), Q = new _h(f, q, H, U, lt, et), K = new qh(W), $ = new Th(W), tt = new Dh(H, U), rt = new El(f, q, k, J, a), nt = new zh(f, J, U), st = new Ll(ct, H, V, U), ot = new Bl(ct, H, V, U), V.programs = Q.programs, f.capabilities = U, f.extensions = H, f.properties = W, f.renderLists = $, f.shadowMap = nt, f.state = k, f.info = V
      }
      ut();
      const pt = new jh(f, ct);

      function dt(t) {
        t.preventDefault(), console.log("THREE.WebGLRenderer: Context Lost."), g = !0
      }

      function mt() {
        console.log("THREE.WebGLRenderer: Context Restored."), g = !1;
        const t = V.autoReset,
          e = nt.enabled,
          n = nt.autoUpdate,
          r = nt.needsUpdate,
          i = nt.type;
        ut(), V.autoReset = t, nt.enabled = e, nt.autoUpdate = n, nt.needsUpdate = r, nt.type = i
      }

      function ft(t) {
        const e = t.target;
        e.removeEventListener("dispose", ft),
          function(t) {
            (function(t) {
              const e = W.get(t).programs;
              void 0 !== e && e.forEach(function(t) {
                Q.releaseProgram(t)
              })
            })(t), W.remove(t)
          }(e)
      }
      this.xr = pt, this.getContext = function() {
        return ct
      }, this.getContextAttributes = function() {
        return ct.getContextAttributes()
      }, this.forceContextLoss = function() {
        const t = H.get("WEBGL_lose_context");
        t && t.loseContext()
      }, this.forceContextRestore = function() {
        const t = H.get("WEBGL_lose_context");
        t && t.restoreContext()
      }, this.getPixelRatio = function() {
        return A
      }, this.setPixelRatio = function(t) {
        void 0 !== t && (A = t, this.setSize(T, E, !1))
      }, this.getSize = function(t) {
        return void 0 === t && (console.warn("WebGLRenderer: .getsize() now requires a Vector2 as an argument"), t = new sr), t.set(T, E)
      }, this.setSize = function(t, n, r) {
        pt.isPresenting ? console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.") : (T = t, E = n, e.width = Math.floor(t * A), e.height = Math.floor(n * A), !1 !== r && (e.style.width = t + "px", e.style.height = n + "px"), this.setViewport(0, 0, t, n))
      }, this.getDrawingBufferSize = function(t) {
        return void 0 === t && (console.warn("WebGLRenderer: .getdrawingBufferSize() now requires a Vector2 as an argument"), t = new sr), t.set(T * A, E * A).floor()
      }, this.setDrawingBufferSize = function(t, n, r) {
        T = t, E = n, A = r, e.width = Math.floor(t * r), e.height = Math.floor(n * r), this.setViewport(0, 0, t, n)
      }, this.getCurrentViewport = function(t) {
        return void 0 === t && (console.warn("WebGLRenderer: .getCurrentViewport() now requires a Vector4 as an argument"), t = new pr), t.copy(w)
      }, this.getViewport = function(t) {
        return t.copy(C)
      }, this.setViewport = function(t, e, n, r) {
        t.isVector4 ? C.set(t.x, t.y, t.z, t.w) : C.set(t, e, n, r), k.viewport(w.copy(C).multiplyScalar(A).floor())
      }, this.getScissor = function(t) {
        return t.copy(P)
      }, this.setScissor = function(t, e, n, r) {
        t.isVector4 ? P.set(t.x, t.y, t.z, t.w) : P.set(t, e, n, r), k.scissor(M.copy(P).multiplyScalar(A).floor())
      }, this.getScissorTest = function() {
        return D
      }, this.setScissorTest = function(t) {
        k.setScissorTest(D = t)
      }, this.setOpaqueSort = function(t) {
        L = t
      }, this.setTransparentSort = function(t) {
        R = t
      }, this.getClearColor = function(t) {
        return void 0 === t && (console.warn("WebGLRenderer: .getClearColor() now requires a Color as an argument"), t = new ki), t.copy(rt.getClearColor())
      }, this.setClearColor = function() {
        rt.setClearColor.apply(rt, arguments)
      }, this.getClearAlpha = function() {
        return rt.getClearAlpha()
      }, this.setClearAlpha = function() {
        rt.setClearAlpha.apply(rt, arguments)
      }, this.clear = function(t, e, n) {
        let r = 0;
        (void 0 === t || t) && (r |= 16384), (void 0 === e || e) && (r |= 256), (void 0 === n || n) && (r |= 1024), ct.clear(r)
      }, this.clearColor = function() {
        this.clear(!0, !1, !1)
      }, this.clearDepth = function() {
        this.clear(!1, !0, !1)
      }, this.clearStencil = function() {
        this.clear(!1, !1, !0)
      }, this.dispose = function() {
        e.removeEventListener("webglcontextlost", dt, !1), e.removeEventListener("webglcontextrestored", mt, !1), $.dispose(), tt.dispose(), W.dispose(), q.dispose(), J.dispose(), lt.dispose(), pt.dispose(), pt.removeEventListener("sessionstart", xt), pt.removeEventListener("sessionend", vt), yt.stop()
      }, this.renderBufferImmediate = function(t, e) {
        lt.initAttributes();
        const n = W.get(t);
        t.hasPositions && !n.position && (n.position = ct.createBuffer()), t.hasNormals && !n.normal && (n.normal = ct.createBuffer()), t.hasUvs && !n.uv && (n.uv = ct.createBuffer()), t.hasColors && !n.color && (n.color = ct.createBuffer());
        const r = e.getAttributes();
        t.hasPositions && (ct.bindBuffer(34962, n.position), ct.bufferData(34962, t.positionArray, 35048), lt.enableAttribute(r.position), ct.vertexAttribPointer(r.position, 3, 5126, !1, 0, 0)), t.hasNormals && (ct.bindBuffer(34962, n.normal), ct.bufferData(34962, t.normalArray, 35048), lt.enableAttribute(r.normal), ct.vertexAttribPointer(r.normal, 3, 5126, !1, 0, 0)), t.hasUvs && (ct.bindBuffer(34962, n.uv), ct.bufferData(34962, t.uvArray, 35048), lt.enableAttribute(r.uv), ct.vertexAttribPointer(r.uv, 2, 5126, !1, 0, 0)), t.hasColors && (ct.bindBuffer(34962, n.color), ct.bufferData(34962, t.colorArray, 35048), lt.enableAttribute(r.color), ct.vertexAttribPointer(r.color, 3, 5126, !1, 0, 0)), lt.disableUnusedAttributes(), ct.drawArrays(4, 0, t.count), t.count = 0
      }, this.renderBufferDirect = function(t, e, n, r, i, s) {
        null === e && (e = G);
        const o = i.isMesh && i.matrixWorld.determinant() < 0,
          a = Tt(t, e, r, i);
        k.setMaterial(r, o);
        let l = n.index;
        const c = n.attributes.position;
        if (null === l) {
          if (void 0 === c || 0 === c.count) return
        } else if (0 === l.count) return;
        let h, u = 1;
        !0 === r.wireframe && (l = Y.getWireframeAttribute(n), u = 2), (r.morphTargets || r.morphNormals) && it.update(i, n, r, a), lt.setup(i, r, a, n, l);
        let p = st;
        null !== l && (h = X.get(l), (p = ot).setIndex(h));
        const d = null !== l ? l.count : c.count,
          m = n.drawRange.start * u,
          f = n.drawRange.count * u,
          g = null !== s ? s.start * u : 0,
          x = null !== s ? s.count * u : 1 / 0,
          v = Math.max(m, g),
          y = Math.min(d, m + f, g + x) - 1,
          _ = Math.max(0, y - v + 1);
        if (0 !== _) {
          if (i.isMesh) !0 === r.wireframe ? (k.setLineWidth(r.wireframeLinewidth * O()), p.setMode(1)) : p.setMode(4);
          else if (i.isLine) {
            let t = r.linewidth;
            void 0 === t && (t = 1), k.setLineWidth(t * O()), i.isLineSegments ? p.setMode(1) : i.isLineLoop ? p.setMode(2) : p.setMode(3)
          } else i.isPoints ? p.setMode(0) : i.isSprite && p.setMode(4);
          if (i.isInstancedMesh) p.renderInstances(v, _, i.count);
          else if (n.isInstancedBufferGeometry) {
            const t = Math.min(n.instanceCount, n._maxInstanceCount);
            p.renderInstances(v, _, t)
          } else p.render(v, _)
        }
      }, this.compile = function(t, e) {
        (p = tt.get(t)).init(), t.traverseVisible(function(t) {
          t.isLight && t.layers.test(e.layers) && (p.pushLight(t), t.castShadow && p.pushShadow(t))
        }), p.setupLights(), t.traverse(function(e) {
          const n = e.material;
          if (n)
            if (Array.isArray(n))
              for (let r = 0; r < n.length; r++) {
                Mt(n[r], t, e)
              } else Mt(n, t, e)
        })
      };
      let gt = null;

      function xt() {
        yt.stop()
      }

      function vt() {
        yt.start()
      }
      const yt = new Ks;

      function _t(t, e, n) {
        const r = !0 === e.isScene ? e.overrideMaterial : null;
        for (let i = 0, s = t.length; i < s; i++) {
          const s = t[i],
            o = s.object,
            a = s.geometry,
            l = null === r ? s.material : r,
            c = s.group;
          if (n.isArrayCamera) {
            const t = n.cameras;
            for (let n = 0, r = t.length; n < r; n++) {
              const r = t[n];
              o.layers.test(r.layers) && (k.viewport(w.copy(r.viewport)), p.setupLightsView(r), wt(o, e, r, a, l, c))
            }
          } else wt(o, e, n, a, l, c)
        }
      }

      function wt(t, e, n, r, i, s) {
        if (t.onBeforeRender(f, e, n, r, i, s), t.modelViewMatrix.multiplyMatrices(n.matrixWorldInverse, t.matrixWorld), t.normalMatrix.getNormalMatrix(t.modelViewMatrix), t.isImmediateRenderObject) {
          const r = Tt(n, e, i, t);
          k.setMaterial(i), lt.reset(),
            function(t, e) {
              t.render(function(t) {
                f.renderBufferImmediate(t, e)
              })
            }(t, r)
        } else f.renderBufferDirect(n, e, r, i, t, s);
        t.onAfterRender(f, e, n, r, i, s)
      }

      function Mt(t, e, n) {
        !0 !== e.isScene && (e = G);
        const r = W.get(t),
          i = p.state.lights,
          s = p.state.shadowsArray,
          o = i.state.version,
          a = Q.getParameters(t, i.state, s, e, n),
          l = Q.getProgramCacheKey(a);
        let c = r.programs;
        r.environment = t.isMeshStandardMaterial ? e.environment : null, r.fog = e.fog, r.envMap = q.get(t.envMap || r.environment), void 0 === c && (t.addEventListener("dispose", ft), c = new Map, r.programs = c);
        let h = c.get(l);
        if (void 0 !== h) {
          if (r.currentProgram === h && r.lightsStateVersion === o) return St(t, a), h
        } else a.uniforms = Q.getUniforms(t), t.onBuild(a, f), t.onBeforeCompile(a, f), h = Q.acquireProgram(a, l), c.set(l, h), r.uniforms = a.uniforms;
        const u = r.uniforms;
        (t.isShaderMaterial || t.isRawShaderMaterial) && !0 !== t.clipping || (u.clippingPlanes = et.uniform), St(t, a), r.needsLights = function(t) {
          return t.isMeshLambertMaterial || t.isMeshToonMaterial || t.isMeshPhongMaterial || t.isMeshStandardMaterial || t.isShadowMaterial || t.isShaderMaterial && !0 === t.lights
        }(t), r.lightsStateVersion = o, r.needsLights && (u.ambientLightColor.value = i.state.ambient, u.lightProbe.value = i.state.probe, u.directionalLights.value = i.state.directional, u.directionalLightShadows.value = i.state.directionalShadow, u.spotLights.value = i.state.spot, u.spotLightShadows.value = i.state.spotShadow, u.rectAreaLights.value = i.state.rectArea, u.ltc_1.value = i.state.rectAreaLTC1, u.ltc_2.value = i.state.rectAreaLTC2, u.pointLights.value = i.state.point, u.pointLightShadows.value = i.state.pointShadow, u.hemisphereLights.value = i.state.hemi, u.directionalShadowMap.value = i.state.directionalShadowMap, u.directionalShadowMatrix.value = i.state.directionalShadowMatrix, u.spotShadowMap.value = i.state.spotShadowMap, u.spotShadowMatrix.value = i.state.spotShadowMatrix, u.pointShadowMap.value = i.state.pointShadowMap, u.pointShadowMatrix.value = i.state.pointShadowMatrix);
        const d = h.getUniforms(),
          m = jc.seqWithValue(d.seq, u);
        return r.currentProgram = h, r.uniformsList = m, h
      }

      function St(t, e) {
        const n = W.get(t);
        n.outputEncoding = e.outputEncoding, n.instancing = e.instancing, n.numClippingPlanes = e.numClippingPlanes, n.numIntersection = e.numClipIntersection, n.vertexAlphas = e.vertexAlphas
      }

      function Tt(t, e, n, r) {
        !0 !== e.isScene && (e = G), j.resetTextureUnits();
        const i = e.fog,
          s = n.isMeshStandardMaterial ? e.environment : null,
          o = null === y ? f.outputEncoding : y.texture.encoding,
          a = q.get(n.envMap || s),
          l = !0 === n.vertexColors && r.geometry && r.geometry.attributes.color && 4 === r.geometry.attributes.color.itemSize,
          c = W.get(n),
          h = p.state.lights;
        if (!0 === B && (!0 === N || t !== b)) {
          const e = t === b && n.id === _;
          et.setState(n, t, e)
        }
        let u = !1;
        n.version === c.__version ? c.needsLights && c.lightsStateVersion !== h.state.version ? u = !0 : c.outputEncoding !== o ? u = !0 : r.isInstancedMesh && !1 === c.instancing ? u = !0 : r.isInstancedMesh || !0 !== c.instancing ? c.envMap !== a ? u = !0 : n.fog && c.fog !== i ? u = !0 : void 0 === c.numClippingPlanes || c.numClippingPlanes === et.numPlanes && c.numIntersection === et.numIntersection ? c.vertexAlphas !== l && (u = !0) : u = !0 : u = !0 : (u = !0, c.__version = n.version);
        let d = c.currentProgram;
        !0 === u && (d = Mt(n, e, r));
        let m = !1,
          g = !1,
          x = !1;
        const v = d.getUniforms(),
          w = c.uniforms;
        if (k.useProgram(d.program) && (m = !0, g = !0, x = !0), n.id !== _ && (_ = n.id, g = !0), m || b !== t) {
          if (v.setValue(ct, "projectionMatrix", t.projectionMatrix), U.logarithmicDepthBuffer && v.setValue(ct, "logDepthBufFC", 2 / (Math.log(t.far + 1) / Math.LN2)), b !== t && (b = t, g = !0, x = !0), n.isShaderMaterial || n.isMeshPhongMaterial || n.isMeshToonMaterial || n.isMeshStandardMaterial || n.envMap) {
            const e = v.map.cameraPosition;
            void 0 !== e && e.setValue(ct, z.setFromMatrixPosition(t.matrixWorld))
          }(n.isMeshPhongMaterial || n.isMeshToonMaterial || n.isMeshLambertMaterial || n.isMeshBasicMaterial || n.isMeshStandardMaterial || n.isShaderMaterial) && v.setValue(ct, "isOrthographic", !0 === t.isOrthographicCamera), (n.isMeshPhongMaterial || n.isMeshToonMaterial || n.isMeshLambertMaterial || n.isMeshBasicMaterial || n.isMeshStandardMaterial || n.isShaderMaterial || n.isShadowMaterial || n.skinning) && v.setValue(ct, "viewMatrix", t.matrixWorldInverse)
        }
        if (n.skinning) {
          v.setOptional(ct, r, "bindMatrix"), v.setOptional(ct, r, "bindMatrixInverse");
          const t = r.skeleton;
          if (t) {
            const e = t.bones;
            if (U.floatVertexTextures) {
              if (null === t.boneTexture) {
                let n = Math.sqrt(4 * e.length);
                n = er(n), n = Math.max(n, 4);
                const r = new Float32Array(n * n * 4);
                r.set(t.boneMatrices);
                const i = new Ys(r, n, n, Nt, At);
                t.boneMatrices = r, t.boneTexture = i, t.boneTextureSize = n
              }
              v.setValue(ct, "boneTexture", t.boneTexture, j), v.setValue(ct, "boneTextureSize", t.boneTextureSize)
            } else v.setOptional(ct, t, "boneMatrices")
          }
        }
        var M, S;
        return (g || c.receiveShadow !== r.receiveShadow) && (c.receiveShadow = r.receiveShadow, v.setValue(ct, "receiveShadow", r.receiveShadow)), g && (v.setValue(ct, "toneMappingExposure", f.toneMappingExposure), c.needsLights && (S = x, (M = w).ambientLightColor.needsUpdate = S, M.lightProbe.needsUpdate = S, M.directionalLights.needsUpdate = S, M.directionalLightShadows.needsUpdate = S, M.pointLights.needsUpdate = S, M.pointLightShadows.needsUpdate = S, M.spotLights.needsUpdate = S, M.spotLightShadows.needsUpdate = S, M.rectAreaLights.needsUpdate = S, M.hemisphereLights.needsUpdate = S), i && n.fog && K.refreshFogUniforms(w, i), K.refreshMaterialUniforms(w, n, A, E), jc.upload(ct, c.uniformsList, w, j)), n.isShaderMaterial && !0 === n.uniformsNeedUpdate && (jc.upload(ct, c.uniformsList, w, j), n.uniformsNeedUpdate = !1), n.isSpriteMaterial && v.setValue(ct, "center", r.center), v.setValue(ct, "modelViewMatrix", r.modelViewMatrix), v.setValue(ct, "normalMatrix", r.normalMatrix), v.setValue(ct, "modelMatrix", r.matrixWorld), d
      }
      yt.setAnimationLoop(function(t) {
        gt && gt(t)
      }), "undefined" != typeof window && yt.setContext(window), this.setAnimationLoop = function(t) {
        gt = t, pt.setAnimationLoop(t), null === t ? yt.stop() : yt.start()
      }, pt.addEventListener("sessionstart", xt), pt.addEventListener("sessionend", vt), this.render = function(t, e) {
        let n, r;
        if (void 0 !== arguments[2] && (console.warn("THREE.WebGLRenderer.render(): the renderTarget argument has been removed. Use .setRenderTarget() instead."), n = arguments[2]), void 0 !== arguments[3] && (console.warn("THREE.WebGLRenderer.render(): the forceClear argument has been removed. Use .clear() instead."), r = arguments[3]), void 0 !== e && !0 !== e.isCamera) return void console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
        if (!0 === g) return;
        !0 === t.autoUpdate && t.updateMatrixWorld(), null === e.parent && e.updateMatrixWorld(), !0 === pt.enabled && !0 === pt.isPresenting && (e = pt.getCamera(e)), !0 === t.isScene && t.onBeforeRender(f, t, e, n || y), (p = tt.get(t, m.length)).init(), m.push(p), F.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse), I.setFromProjectionMatrix(F), N = this.localClippingEnabled, B = et.init(this.clippingPlanes, N, e), (u = $.get(t, d.length)).init(), d.push(u),
          function t(e, n, r, i) {
            if (!1 === e.visible) return;
            const s = e.layers.test(n.layers);
            if (s)
              if (e.isGroup) r = e.renderOrder;
              else if (e.isLOD) !0 === e.autoUpdate && e.update(n);
            else if (e.isLight) p.pushLight(e), e.castShadow && p.pushShadow(e);
            else if (e.isSprite) {
              if (!e.frustumCulled || I.intersectsSprite(e)) {
                i && z.setFromMatrixPosition(e.matrixWorld).applyMatrix4(F);
                const t = J.update(e),
                  n = e.material;
                n.visible && u.push(e, t, n, r, z.z, null)
              }
            } else if (e.isImmediateRenderObject) i && z.setFromMatrixPosition(e.matrixWorld).applyMatrix4(F), u.push(e, null, e.material, r, z.z, null);
            else if ((e.isMesh || e.isLine || e.isPoints) && (e.isSkinnedMesh && e.skeleton.frame !== V.render.frame && (e.skeleton.update(), e.skeleton.frame = V.render.frame), !e.frustumCulled || I.intersectsObject(e))) {
              i && z.setFromMatrixPosition(e.matrixWorld).applyMatrix4(F);
              const t = J.update(e),
                n = e.material;
              if (Array.isArray(n)) {
                const i = t.groups;
                for (let s = 0, o = i.length; s < o; s++) {
                  const o = i[s],
                    a = n[o.materialIndex];
                  a && a.visible && u.push(e, t, a, r, z.z, o)
                }
              } else n.visible && u.push(e, t, n, r, z.z, null)
            }
            const o = e.children;
            for (let a = 0, l = o.length; a < l; a++) t(o[a], n, r, i)
          }(t, e, 0, f.sortObjects), u.finish(), !0 === f.sortObjects && u.sort(L, R), !0 === B && et.beginShadows();
        const i = p.state.shadowsArray;
        nt.render(i, t, e), p.setupLights(), p.setupLightsView(e), !0 === B && et.endShadows(), !0 === this.info.autoReset && this.info.reset(), void 0 !== n && this.setRenderTarget(n), rt.render(u, t, e, r);
        const s = u.opaque,
          o = u.transparent;
        s.length > 0 && _t(s, t, e), o.length > 0 && _t(o, t, e), null !== y && (j.updateRenderTargetMipmap(y), j.updateMultisampleRenderTarget(y)), !0 === t.isScene && t.onAfterRender(f, t, e), k.buffers.depth.setTest(!0), k.buffers.depth.setMask(!0), k.buffers.color.setMask(!0), k.setPolygonOffset(!1), lt.resetDefaultState(), _ = -1, b = null, m.pop(), p = m.length > 0 ? m[m.length - 1] : null, d.pop(), u = d.length > 0 ? d[d.length - 1] : null
      }, this.getActiveCubeFace = function() {
        return x
      }, this.getActiveMipmapLevel = function() {
        return v
      }, this.getRenderTarget = function() {
        return y
      }, this.setRenderTarget = function(t, e = 0, n = 0) {
        y = t, x = e, v = n, t && void 0 === W.get(t).__webglFramebuffer && j.setupRenderTarget(t);
        let r = null,
          i = !1,
          s = !1;
        if (t) {
          const n = t.texture;
          (n.isDataTexture3D || n.isDataTexture2DArray) && (s = !0);
          const o = W.get(t).__webglFramebuffer;
          t.isWebGLCubeRenderTarget ? (r = o[e], i = !0) : r = t.isWebGLMultisampleRenderTarget ? W.get(t).__webglMultisampledFramebuffer : o, w.copy(t.viewport), M.copy(t.scissor), S = t.scissorTest
        } else w.copy(C).multiplyScalar(A).floor(), M.copy(P).multiplyScalar(A).floor(), S = D;
        if (k.bindFramebuffer(36160, r), k.viewport(w), k.scissor(M), k.setScissorTest(S), i) {
          const r = W.get(t.texture);
          ct.framebufferTexture2D(36160, 36064, 34069 + e, r.__webglTexture, n)
        } else if (s) {
          const r = W.get(t.texture),
            i = e || 0;
          ct.framebufferTextureLayer(36160, 36064, r.__webglTexture, n || 0, i)
        }
      }, this.readRenderTargetPixels = function(t, e, n, r, i, s, o) {
        if (!t || !t.isWebGLRenderTarget) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
        let a = W.get(t).__webglFramebuffer;
        if (t.isWebGLCubeRenderTarget && void 0 !== o && (a = a[o]), a) {
          k.bindFramebuffer(36160, a);
          try {
            const o = t.texture,
              a = o.format,
              l = o.type;
            if (a !== Nt && at.convert(a) !== ct.getParameter(35739)) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
            const c = l === Lt && (H.has("EXT_color_buffer_half_float") || U.isWebGL2 && H.has("EXT_color_buffer_float"));
            if (!(l === bt || at.convert(l) === ct.getParameter(35738) || l === At && (U.isWebGL2 || H.has("OES_texture_float") || H.has("WEBGL_color_buffer_float")) || c)) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
            36053 === ct.checkFramebufferStatus(36160) ? e >= 0 && e <= t.width - r && n >= 0 && n <= t.height - i && ct.readPixels(e, n, r, i, at.convert(a), at.convert(l), s) : console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.")
          } finally {
            const t = null !== y ? W.get(y).__webglFramebuffer : null;
            k.bindFramebuffer(36160, t)
          }
        }
      }, this.copyFramebufferToTexture = function(t, e, n = 0) {
        const r = Math.pow(2, -n),
          i = Math.floor(e.image.width * r),
          s = Math.floor(e.image.height * r),
          o = at.convert(e.format);
        j.setTexture2D(e, 0), ct.copyTexImage2D(3553, n, o, t.x, t.y, i, s, 0), k.unbindTexture()
      }, this.copyTextureToTexture = function(t, e, n, r = 0) {
        const i = e.image.width,
          s = e.image.height,
          o = at.convert(n.format),
          a = at.convert(n.type);
        j.setTexture2D(n, 0), ct.pixelStorei(37440, n.flipY), ct.pixelStorei(37441, n.premultiplyAlpha), ct.pixelStorei(3317, n.unpackAlignment), e.isDataTexture ? ct.texSubImage2D(3553, r, t.x, t.y, i, s, o, a, e.image.data) : e.isCompressedTexture ? ct.compressedTexSubImage2D(3553, r, t.x, t.y, e.mipmaps[0].width, e.mipmaps[0].height, o, e.mipmaps[0].data) : ct.texSubImage2D(3553, r, t.x, t.y, o, a, e.image), 0 === r && n.generateMipmaps && ct.generateMipmap(3553), k.unbindTexture()
      }, this.copyTextureToTexture3D = function(t, e, n, r, i = 0) {
        if (f.isWebGL1Renderer) return void console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.");
        const {
          width: s,
          height: o,
          data: a
        } = n.image, l = at.convert(r.format), c = at.convert(r.type);
        let h;
        if (r.isDataTexture3D) j.setTexture3D(r, 0), h = 32879;
        else {
          if (!r.isDataTexture2DArray) return void console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");
          j.setTexture2DArray(r, 0), h = 35866
        }
        ct.pixelStorei(37440, r.flipY), ct.pixelStorei(37441, r.premultiplyAlpha), ct.pixelStorei(3317, r.unpackAlignment);
        const u = ct.getParameter(3314),
          p = ct.getParameter(32878),
          d = ct.getParameter(3316),
          m = ct.getParameter(3315),
          g = ct.getParameter(32877);
        ct.pixelStorei(3314, s), ct.pixelStorei(32878, o), ct.pixelStorei(3316, t.min.x), ct.pixelStorei(3315, t.min.y), ct.pixelStorei(32877, t.min.z), ct.texSubImage3D(h, i, e.x, e.y, e.z, t.max.x - t.min.x + 1, t.max.y - t.min.y + 1, t.max.z - t.min.z + 1, l, c, a), ct.pixelStorei(3314, u), ct.pixelStorei(32878, p), ct.pixelStorei(3316, d), ct.pixelStorei(3315, m), ct.pixelStorei(32877, g), 0 === i && r.generateMipmaps && ct.generateMipmap(h), k.unbindTexture()
      }, this.initTexture = function(t) {
        j.setTexture2D(t, 0), k.unbindTexture()
      }, this.resetState = function() {
        x = 0, v = 0, y = null, k.reset(), lt.reset()
      }, "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {
        detail: this
      }))
    }
    class Zh extends Yh {}
    exports.WebGL1Renderer = Zh, Zh.prototype.isWebGL1Renderer = !0;
    class Jh {
      constructor(t, e = 25e-5) {
        this.name = "", this.color = new ki(t), this.density = e
      }
      clone() {
        return new Jh(this.color, this.density)
      }
      toJSON() {
        return {
          type: "FogExp2",
          color: this.color.getHex(),
          density: this.density
        }
      }
    }
    exports.FogExp2 = Jh, Jh.prototype.isFogExp2 = !0;
    class Qh {
      constructor(t, e = 1, n = 1e3) {
        this.name = "", this.color = new ki(t), this.near = e, this.far = n
      }
      clone() {
        return new Qh(this.color, this.near, this.far)
      }
      toJSON() {
        return {
          type: "Fog",
          color: this.color.getHex(),
          near: this.near,
          far: this.far
        }
      }
    }
    exports.Fog = Qh, Qh.prototype.isFog = !0;
    class Kh extends vi {
      constructor() {
        super(), this.type = "Scene", this.background = null, this.environment = null, this.fog = null, this.overrideMaterial = null, this.autoUpdate = !0, "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {
          detail: this
        }))
      }
      copy(t, e) {
        return super.copy(t, e), null !== t.background && (this.background = t.background.clone()), null !== t.environment && (this.environment = t.environment.clone()), null !== t.fog && (this.fog = t.fog.clone()), null !== t.overrideMaterial && (this.overrideMaterial = t.overrideMaterial.clone()), this.autoUpdate = t.autoUpdate, this.matrixAutoUpdate = t.matrixAutoUpdate, this
      }
      toJSON(t) {
        const e = super.toJSON(t);
        return null !== this.background && (e.object.background = this.background.toJSON(t)), null !== this.environment && (e.object.environment = this.environment.toJSON(t)), null !== this.fog && (e.object.fog = this.fog.toJSON()), e
      }
    }
    exports.Scene = Kh, Kh.prototype.isScene = !0;
    class $h {
      constructor(t, e) {
        this.array = t, this.stride = e, this.count = void 0 !== t ? t.length / e : 0, this.usage = wn, this.updateRange = {
          offset: 0,
          count: -1
        }, this.version = 0, this.uuid = Gn(), this.onUploadCallback = function() {}
      }
      set needsUpdate(t) {
        !0 === t && this.version++
      }
      setUsage(t) {
        return this.usage = t, this
      }
      copy(t) {
        return this.array = new t.array.constructor(t.array), this.count = t.count, this.stride = t.stride, this.usage = t.usage, this
      }
      copyAt(t, e, n) {
        t *= this.stride, n *= e.stride;
        for (let r = 0, i = this.stride; r < i; r++) this.array[t + r] = e.array[n + r];
        return this
      }
      set(t, e = 0) {
        return this.array.set(t, e), this
      }
      clone(t) {
        void 0 === t.arrayBuffers && (t.arrayBuffers = {}), void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = Gn()), void 0 === t.arrayBuffers[this.array.buffer._uuid] && (t.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
        const e = new this.array.constructor(t.arrayBuffers[this.array.buffer._uuid]),
          n = new $h(e, this.stride);
        return n.setUsage(this.usage), n
      }
      onUpload(t) {
        return this.onUploadCallback = t, this
      }
      toJSON(t) {
        return void 0 === t.arrayBuffers && (t.arrayBuffers = {}), void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = Gn()), void 0 === t.arrayBuffers[this.array.buffer._uuid] && (t.arrayBuffers[this.array.buffer._uuid] = Array.prototype.slice.call(new Uint32Array(this.array.buffer))), {
          uuid: this.uuid,
          buffer: this.array.buffer._uuid,
          type: this.array.constructor.name,
          stride: this.stride
        }
      }
    }
    exports.InterleavedBuffer = $h, $h.prototype.isInterleavedBuffer = !0;
    const tu = new gr;
    class eu {
      constructor(t, e, n, r) {
        this.name = "", this.data = t, this.itemSize = e, this.offset = n, this.normalized = !0 === r
      }
      get count() {
        return this.data.count
      }
      get array() {
        return this.data.array
      }
      set needsUpdate(t) {
        this.data.needsUpdate = t
      }
      applyMatrix4(t) {
        for (let e = 0, n = this.data.count; e < n; e++) tu.x = this.getX(e), tu.y = this.getY(e), tu.z = this.getZ(e), tu.applyMatrix4(t), this.setXYZ(e, tu.x, tu.y, tu.z);
        return this
      }
      applyNormalMatrix(t) {
        for (let e = 0, n = this.count; e < n; e++) tu.x = this.getX(e), tu.y = this.getY(e), tu.z = this.getZ(e), tu.applyNormalMatrix(t), this.setXYZ(e, tu.x, tu.y, tu.z);
        return this
      }
      transformDirection(t) {
        for (let e = 0, n = this.count; e < n; e++) tu.x = this.getX(e), tu.y = this.getY(e), tu.z = this.getZ(e), tu.transformDirection(t), this.setXYZ(e, tu.x, tu.y, tu.z);
        return this
      }
      setX(t, e) {
        return this.data.array[t * this.data.stride + this.offset] = e, this
      }
      setY(t, e) {
        return this.data.array[t * this.data.stride + this.offset + 1] = e, this
      }
      setZ(t, e) {
        return this.data.array[t * this.data.stride + this.offset + 2] = e, this
      }
      setW(t, e) {
        return this.data.array[t * this.data.stride + this.offset + 3] = e, this
      }
      getX(t) {
        return this.data.array[t * this.data.stride + this.offset]
      }
      getY(t) {
        return this.data.array[t * this.data.stride + this.offset + 1]
      }
      getZ(t) {
        return this.data.array[t * this.data.stride + this.offset + 2]
      }
      getW(t) {
        return this.data.array[t * this.data.stride + this.offset + 3]
      }
      setXY(t, e, n) {
        return t = t * this.data.stride + this.offset, this.data.array[t + 0] = e, this.data.array[t + 1] = n, this
      }
      setXYZ(t, e, n, r) {
        return t = t * this.data.stride + this.offset, this.data.array[t + 0] = e, this.data.array[t + 1] = n, this.data.array[t + 2] = r, this
      }
      setXYZW(t, e, n, r, i) {
        return t = t * this.data.stride + this.offset, this.data.array[t + 0] = e, this.data.array[t + 1] = n, this.data.array[t + 2] = r, this.data.array[t + 3] = i, this
      }
      clone(t) {
        if (void 0 === t) {
          console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data.");
          const t = [];
          for (let e = 0; e < this.count; e++) {
            const n = e * this.data.stride + this.offset;
            for (let e = 0; e < this.itemSize; e++) t.push(this.data.array[n + e])
          }
          return new qi(new this.array.constructor(t), this.itemSize, this.normalized)
        }
        return void 0 === t.interleavedBuffers && (t.interleavedBuffers = {}), void 0 === t.interleavedBuffers[this.data.uuid] && (t.interleavedBuffers[this.data.uuid] = this.data.clone(t)), new eu(t.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized)
      }
      toJSON(t) {
        if (void 0 === t) {
          console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data.");
          const t = [];
          for (let e = 0; e < this.count; e++) {
            const n = e * this.data.stride + this.offset;
            for (let e = 0; e < this.itemSize; e++) t.push(this.data.array[n + e])
          }
          return {
            itemSize: this.itemSize,
            type: this.array.constructor.name,
            array: t,
            normalized: this.normalized
          }
        }
        return void 0 === t.interleavedBuffers && (t.interleavedBuffers = {}), void 0 === t.interleavedBuffers[this.data.uuid] && (t.interleavedBuffers[this.data.uuid] = this.data.toJSON(t)), {
          isInterleavedBufferAttribute: !0,
          itemSize: this.itemSize,
          data: this.data.uuid,
          offset: this.offset,
          normalized: this.normalized
        }
      }
    }
    exports.InterleavedBufferAttribute = eu, eu.prototype.isInterleavedBufferAttribute = !0;
    class nu extends Ni {
      constructor(t) {
        super(), this.type = "SpriteMaterial", this.color = new ki(16777215), this.map = null, this.alphaMap = null, this.rotation = 0, this.sizeAttenuation = !0, this.transparent = !0, this.setValues(t)
      }
      copy(t) {
        return super.copy(t), this.color.copy(t.color), this.map = t.map, this.alphaMap = t.alphaMap, this.rotation = t.rotation, this.sizeAttenuation = t.sizeAttenuation, this
      }
    }
    let ru;
    exports.SpriteMaterial = nu, nu.prototype.isSpriteMaterial = !0;
    const iu = new gr,
      su = new gr,
      ou = new gr,
      au = new sr,
      lu = new sr,
      cu = new Xr,
      hu = new gr,
      uu = new gr,
      pu = new gr,
      du = new sr,
      mu = new sr,
      fu = new sr;
    class gu extends vi {
      constructor(t) {
        if (super(), this.type = "Sprite", void 0 === ru) {
          ru = new ds;
          const t = new Float32Array([-.5, -.5, 0, 0, 0, .5, -.5, 0, 1, 0, .5, .5, 0, 1, 1, -.5, .5, 0, 0, 1]),
            e = new $h(t, 5);
          ru.setIndex([0, 1, 2, 0, 2, 3]), ru.setAttribute("position", new eu(e, 3, 0, !1)), ru.setAttribute("uv", new eu(e, 2, 3, !1))
        }
        this.geometry = ru, this.material = void 0 !== t ? t : new nu, this.center = new sr(.5, .5)
      }
      raycast(t, e) {
        null === t.camera && console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'), su.setFromMatrixScale(this.matrixWorld), cu.copy(t.camera.matrixWorld), this.modelViewMatrix.multiplyMatrices(t.camera.matrixWorldInverse, this.matrixWorld), ou.setFromMatrixPosition(this.modelViewMatrix), t.camera.isPerspectiveCamera && !1 === this.material.sizeAttenuation && su.multiplyScalar(-ou.z);
        const n = this.material.rotation;
        let r, i;
        0 !== n && (i = Math.cos(n), r = Math.sin(n));
        const s = this.center;
        xu(hu.set(-.5, -.5, 0), ou, s, su, r, i), xu(uu.set(.5, -.5, 0), ou, s, su, r, i), xu(pu.set(.5, .5, 0), ou, s, su, r, i), du.set(0, 0), mu.set(1, 0), fu.set(1, 1);
        let o = t.ray.intersectTriangle(hu, uu, pu, !1, iu);
        if (null === o && (xu(uu.set(-.5, .5, 0), ou, s, su, r, i), mu.set(0, 1), null === (o = t.ray.intersectTriangle(hu, pu, uu, !1, iu)))) return;
        const a = t.ray.origin.distanceTo(iu);
        a < t.near || a > t.far || e.push({
          distance: a,
          point: iu.clone(),
          uv: Ii.getUV(iu, hu, uu, pu, du, mu, fu, new sr),
          face: null,
          object: this
        })
      }
      copy(t) {
        return super.copy(t), void 0 !== t.center && this.center.copy(t.center), this.material = t.material, this
      }
    }

    function xu(t, e, n, r, i, s) {
      au.subVectors(t, n).addScalar(.5).multiply(r), void 0 !== i ? (lu.x = s * au.x - i * au.y, lu.y = i * au.x + s * au.y) : lu.copy(au), t.copy(e), t.x += lu.x, t.y += lu.y, t.applyMatrix4(cu)
    }
    exports.Sprite = gu, gu.prototype.isSprite = !0;
    const vu = new gr,
      yu = new gr;
    class _u extends vi {
      constructor() {
        super(), this._currentLevel = 0, this.type = "LOD", Object.defineProperties(this, {
          levels: {
            enumerable: !0,
            value: []
          },
          isLOD: {
            value: !0
          }
        }), this.autoUpdate = !0
      }
      copy(t) {
        super.copy(t, !1);
        const e = t.levels;
        for (let n = 0, r = e.length; n < r; n++) {
          const t = e[n];
          this.addLevel(t.object.clone(), t.distance)
        }
        return this.autoUpdate = t.autoUpdate, this
      }
      addLevel(t, e = 0) {
        e = Math.abs(e);
        const n = this.levels;
        let r;
        for (r = 0; r < n.length && !(e < n[r].distance); r++);
        return n.splice(r, 0, {
          distance: e,
          object: t
        }), this.add(t), this
      }
      getCurrentLevel() {
        return this._currentLevel
      }
      getObjectForDistance(t) {
        const e = this.levels;
        if (e.length > 0) {
          let n, r;
          for (n = 1, r = e.length; n < r && !(t < e[n].distance); n++);
          return e[n - 1].object
        }
        return null
      }
      raycast(t, e) {
        if (this.levels.length > 0) {
          vu.setFromMatrixPosition(this.matrixWorld);
          const n = t.ray.origin.distanceTo(vu);
          this.getObjectForDistance(n).raycast(t, e)
        }
      }
      update(t) {
        const e = this.levels;
        if (e.length > 1) {
          vu.setFromMatrixPosition(t.matrixWorld), yu.setFromMatrixPosition(this.matrixWorld);
          const n = vu.distanceTo(yu) / t.zoom;
          let r, i;
          for (e[0].object.visible = !0, r = 1, i = e.length; r < i && n >= e[r].distance; r++) e[r - 1].object.visible = !1, e[r].object.visible = !0;
          for (this._currentLevel = r - 1; r < i; r++) e[r].object.visible = !1
        }
      }
      toJSON(t) {
        const e = super.toJSON(t);
        !1 === this.autoUpdate && (e.object.autoUpdate = !1), e.object.levels = [];
        const n = this.levels;
        for (let r = 0, i = n.length; r < i; r++) {
          const t = n[r];
          e.object.levels.push({
            object: t.object.uuid,
            distance: t.distance
          })
        }
        return e
      }
    }
    exports.LOD = _u;
    const bu = new gr,
      wu = new pr,
      Mu = new pr,
      Su = new gr,
      Tu = new Xr;
    class Eu extends Ps {
      constructor(t, e) {
        super(t, e), this.type = "SkinnedMesh", this.bindMode = "attached", this.bindMatrix = new Xr, this.bindMatrixInverse = new Xr
      }
      copy(t) {
        return super.copy(t), this.bindMode = t.bindMode, this.bindMatrix.copy(t.bindMatrix), this.bindMatrixInverse.copy(t.bindMatrixInverse), this.skeleton = t.skeleton, this
      }
      bind(t, e) {
        this.skeleton = t, void 0 === e && (this.updateMatrixWorld(!0), this.skeleton.calculateInverses(), e = this.matrixWorld), this.bindMatrix.copy(e), this.bindMatrixInverse.copy(e).invert()
      }
      pose() {
        this.skeleton.pose()
      }
      normalizeSkinWeights() {
        const t = new pr,
          e = this.geometry.attributes.skinWeight;
        for (let n = 0, r = e.count; n < r; n++) {
          t.x = e.getX(n), t.y = e.getY(n), t.z = e.getZ(n), t.w = e.getW(n);
          const r = 1 / t.manhattanLength();
          r !== 1 / 0 ? t.multiplyScalar(r) : t.set(1, 0, 0, 0), e.setXYZW(n, t.x, t.y, t.z, t.w)
        }
      }
      updateMatrixWorld(t) {
        super.updateMatrixWorld(t), "attached" === this.bindMode ? this.bindMatrixInverse.copy(this.matrixWorld).invert() : "detached" === this.bindMode ? this.bindMatrixInverse.copy(this.bindMatrix).invert() : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode)
      }
      boneTransform(t, e) {
        const n = this.skeleton,
          r = this.geometry;
        wu.fromBufferAttribute(r.attributes.skinIndex, t), Mu.fromBufferAttribute(r.attributes.skinWeight, t), bu.fromBufferAttribute(r.attributes.position, t).applyMatrix4(this.bindMatrix), e.set(0, 0, 0);
        for (let i = 0; i < 4; i++) {
          const t = Mu.getComponent(i);
          if (0 !== t) {
            const r = wu.getComponent(i);
            Tu.multiplyMatrices(n.bones[r].matrixWorld, n.boneInverses[r]), e.addScaledVector(Su.copy(bu).applyMatrix4(Tu), t)
          }
        }
        return e.applyMatrix4(this.bindMatrixInverse)
      }
    }
    exports.SkinnedMesh = Eu, Eu.prototype.isSkinnedMesh = !0;
    class Au extends vi {
      constructor() {
        super(), this.type = "Bone"
      }
    }
    exports.Bone = Au, Au.prototype.isBone = !0;
    const Lu = new Xr,
      Ru = new Xr;
    class Cu {
      constructor(t = [], e = []) {
        this.uuid = Gn(), this.bones = t.slice(0), this.boneInverses = e, this.boneMatrices = null, this.boneTexture = null, this.boneTextureSize = 0, this.frame = -1, this.init()
      }
      init() {
        const t = this.bones,
          e = this.boneInverses;
        if (this.boneMatrices = new Float32Array(16 * t.length), 0 === e.length) this.calculateInverses();
        else if (t.length !== e.length) {
          console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."), this.boneInverses = [];
          for (let t = 0, e = this.bones.length; t < e; t++) this.boneInverses.push(new Xr)
        }
      }
      calculateInverses() {
        this.boneInverses.length = 0;
        for (let t = 0, e = this.bones.length; t < e; t++) {
          const e = new Xr;
          this.bones[t] && e.copy(this.bones[t].matrixWorld).invert(), this.boneInverses.push(e)
        }
      }
      pose() {
        for (let t = 0, e = this.bones.length; t < e; t++) {
          const e = this.bones[t];
          e && e.matrixWorld.copy(this.boneInverses[t]).invert()
        }
        for (let t = 0, e = this.bones.length; t < e; t++) {
          const e = this.bones[t];
          e && (e.parent && e.parent.isBone ? (e.matrix.copy(e.parent.matrixWorld).invert(), e.matrix.multiply(e.matrixWorld)) : e.matrix.copy(e.matrixWorld), e.matrix.decompose(e.position, e.quaternion, e.scale))
        }
      }
      update() {
        const t = this.bones,
          e = this.boneInverses,
          n = this.boneMatrices,
          r = this.boneTexture;
        for (let i = 0, s = t.length; i < s; i++) {
          const r = t[i] ? t[i].matrixWorld : Ru;
          Lu.multiplyMatrices(r, e[i]), Lu.toArray(n, 16 * i)
        }
        null !== r && (r.needsUpdate = !0)
      }
      clone() {
        return new Cu(this.bones, this.boneInverses)
      }
      getBoneByName(t) {
        for (let e = 0, n = this.bones.length; e < n; e++) {
          const n = this.bones[e];
          if (n.name === t) return n
        }
      }
      dispose() {
        null !== this.boneTexture && (this.boneTexture.dispose(), this.boneTexture = null)
      }
      fromJSON(t, e) {
        this.uuid = t.uuid;
        for (let n = 0, r = t.bones.length; n < r; n++) {
          const r = t.bones[n];
          let i = e[r];
          void 0 === i && (console.warn("THREE.Skeleton: No bone found with UUID:", r), i = new Au), this.bones.push(i), this.boneInverses.push((new Xr).fromArray(t.boneInverses[n]))
        }
        return this.init(), this
      }
      toJSON() {
        const t = {
          metadata: {
            version: 4.5,
            type: "Skeleton",
            generator: "Skeleton.toJSON"
          },
          bones: [],
          boneInverses: []
        };
        t.uuid = this.uuid;
        const e = this.bones,
          n = this.boneInverses;
        for (let r = 0, i = e.length; r < i; r++) {
          const i = e[r];
          t.bones.push(i.uuid);
          const s = n[r];
          t.boneInverses.push(s.toArray())
        }
        return t
      }
    }
    exports.Skeleton = Cu;
    const Pu = new Xr,
      Du = new Xr,
      Iu = [],
      Bu = new Ps;
    class Nu extends Ps {
      constructor(t, e, n) {
        super(t, e), this.instanceMatrix = new qi(new Float32Array(16 * n), 16), this.instanceColor = null, this.count = n, this.frustumCulled = !1
      }
      copy(t) {
        return super.copy(t), this.instanceMatrix.copy(t.instanceMatrix), null !== t.instanceColor && (this.instanceColor = t.instanceColor.clone()), this.count = t.count, this
      }
      getColorAt(t, e) {
        e.fromArray(this.instanceColor.array, 3 * t)
      }
      getMatrixAt(t, e) {
        e.fromArray(this.instanceMatrix.array, 16 * t)
      }
      raycast(t, e) {
        const n = this.matrixWorld,
          r = this.count;
        if (Bu.geometry = this.geometry, Bu.material = this.material, void 0 !== Bu.material)
          for (let i = 0; i < r; i++) {
            this.getMatrixAt(i, Pu), Du.multiplyMatrices(n, Pu), Bu.matrixWorld = Du, Bu.raycast(t, Iu);
            for (let t = 0, n = Iu.length; t < n; t++) {
              const n = Iu[t];
              n.instanceId = i, n.object = this, e.push(n)
            }
            Iu.length = 0
          }
      }
      setColorAt(t, e) {
        null === this.instanceColor && (this.instanceColor = new qi(new Float32Array(3 * this.count), 3)), e.toArray(this.instanceColor.array, 3 * t)
      }
      setMatrixAt(t, e) {
        e.toArray(this.instanceMatrix.array, 16 * t)
      }
      updateMorphTargets() {}
      dispose() {
        this.dispatchEvent({
          type: "dispose"
        })
      }
    }
    exports.InstancedMesh = Nu, Nu.prototype.isInstancedMesh = !0;
    class Fu extends Ni {
      constructor(t) {
        super(), this.type = "LineBasicMaterial", this.color = new ki(16777215), this.linewidth = 1, this.linecap = "round", this.linejoin = "round", this.morphTargets = !1, this.setValues(t)
      }
      copy(t) {
        return super.copy(t), this.color.copy(t.color), this.linewidth = t.linewidth, this.linecap = t.linecap, this.linejoin = t.linejoin, this.morphTargets = t.morphTargets, this
      }
    }
    exports.LineBasicMaterial = Fu, Fu.prototype.isLineBasicMaterial = !0;
    const zu = new gr,
      Gu = new gr,
      Ou = new Xr,
      Hu = new qr,
      Uu = new Gr;
    class ku extends vi {
      constructor(t = new ds, e = new Fu) {
        super(), this.type = "Line", this.geometry = t, this.material = e, this.updateMorphTargets()
      }
      copy(t) {
        return super.copy(t), this.material = t.material, this.geometry = t.geometry, this
      }
      computeLineDistances() {
        const t = this.geometry;
        if (t.isBufferGeometry)
          if (null === t.index) {
            const e = t.attributes.position,
              n = [0];
            for (let t = 1, r = e.count; t < r; t++) zu.fromBufferAttribute(e, t - 1), Gu.fromBufferAttribute(e, t), n[t] = n[t - 1], n[t] += zu.distanceTo(Gu);
            t.setAttribute("lineDistance", new es(n, 1))
          } else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
        else t.isGeometry && console.error("THREE.Line.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
        return this
      }
      raycast(t, e) {
        const n = this.geometry,
          r = this.matrixWorld,
          i = t.params.Line.threshold,
          s = n.drawRange;
        if (null === n.boundingSphere && n.computeBoundingSphere(), Uu.copy(n.boundingSphere), Uu.applyMatrix4(r), Uu.radius += i, !1 === t.ray.intersectsSphere(Uu)) return;
        Ou.copy(r).invert(), Hu.copy(t.ray).applyMatrix4(Ou);
        const o = i / ((this.scale.x + this.scale.y + this.scale.z) / 3),
          a = o * o,
          l = new gr,
          c = new gr,
          h = new gr,
          u = new gr,
          p = this.isLineSegments ? 2 : 1;
        if (n.isBufferGeometry) {
          const r = n.index,
            i = n.attributes.position;
          if (null !== r) {
            for (let n = Math.max(0, s.start), o = Math.min(r.count, s.start + s.count) - 1; n < o; n += p) {
              const s = r.getX(n),
                o = r.getX(n + 1);
              if (l.fromBufferAttribute(i, s), c.fromBufferAttribute(i, o), Hu.distanceSqToSegment(l, c, u, h) > a) continue;
              u.applyMatrix4(this.matrixWorld);
              const p = t.ray.origin.distanceTo(u);
              p < t.near || p > t.far || e.push({
                distance: p,
                point: h.clone().applyMatrix4(this.matrixWorld),
                index: n,
                face: null,
                faceIndex: null,
                object: this
              })
            }
          } else {
            for (let n = Math.max(0, s.start), r = Math.min(i.count, s.start + s.count) - 1; n < r; n += p) {
              if (l.fromBufferAttribute(i, n), c.fromBufferAttribute(i, n + 1), Hu.distanceSqToSegment(l, c, u, h) > a) continue;
              u.applyMatrix4(this.matrixWorld);
              const r = t.ray.origin.distanceTo(u);
              r < t.near || r > t.far || e.push({
                distance: r,
                point: h.clone().applyMatrix4(this.matrixWorld),
                index: n,
                face: null,
                faceIndex: null,
                object: this
              })
            }
          }
        } else n.isGeometry && console.error("THREE.Line.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")
      }
      updateMorphTargets() {
        const t = this.geometry;
        if (t.isBufferGeometry) {
          const e = t.morphAttributes,
            n = Object.keys(e);
          if (n.length > 0) {
            const t = e[n[0]];
            if (void 0 !== t) {
              this.morphTargetInfluences = [], this.morphTargetDictionary = {};
              for (let e = 0, n = t.length; e < n; e++) {
                const n = t[e].name || String(e);
                this.morphTargetInfluences.push(0), this.morphTargetDictionary[n] = e
              }
            }
          }
        } else {
          const e = t.morphTargets;
          void 0 !== e && e.length > 0 && console.error("THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.")
        }
      }
    }
    exports.Line = ku, ku.prototype.isLine = !0;
    const Vu = new gr,
      Wu = new gr;
    class ju extends ku {
      constructor(t, e) {
        super(t, e), this.type = "LineSegments"
      }
      computeLineDistances() {
        const t = this.geometry;
        if (t.isBufferGeometry)
          if (null === t.index) {
            const e = t.attributes.position,
              n = [];
            for (let t = 0, r = e.count; t < r; t += 2) Vu.fromBufferAttribute(e, t), Wu.fromBufferAttribute(e, t + 1), n[t] = 0 === t ? 0 : n[t - 1], n[t + 1] = n[t] + Vu.distanceTo(Wu);
            t.setAttribute("lineDistance", new es(n, 1))
          } else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
        else t.isGeometry && console.error("THREE.LineSegments.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
        return this
      }
    }
    exports.LineSegments = ju, ju.prototype.isLineSegments = !0;
    class qu extends ku {
      constructor(t, e) {
        super(t, e), this.type = "LineLoop"
      }
    }
    exports.LineLoop = qu, qu.prototype.isLineLoop = !0;
    class Xu extends Ni {
      constructor(t) {
        super(), this.type = "PointsMaterial", this.color = new ki(16777215), this.map = null, this.alphaMap = null, this.size = 1, this.sizeAttenuation = !0, this.morphTargets = !1, this.setValues(t)
      }
      copy(t) {
        return super.copy(t), this.color.copy(t.color), this.map = t.map, this.alphaMap = t.alphaMap, this.size = t.size, this.sizeAttenuation = t.sizeAttenuation, this.morphTargets = t.morphTargets, this
      }
    }
    exports.PointsMaterial = Xu, Xu.prototype.isPointsMaterial = !0;
    const Yu = new Xr,
      Zu = new qr,
      Ju = new Gr,
      Qu = new gr;
    class Ku extends vi {
      constructor(t = new ds, e = new Xu) {
        super(), this.type = "Points", this.geometry = t, this.material = e, this.updateMorphTargets()
      }
      copy(t) {
        return super.copy(t), this.material = t.material, this.geometry = t.geometry, this
      }
      raycast(t, e) {
        const n = this.geometry,
          r = this.matrixWorld,
          i = t.params.Points.threshold,
          s = n.drawRange;
        if (null === n.boundingSphere && n.computeBoundingSphere(), Ju.copy(n.boundingSphere), Ju.applyMatrix4(r), Ju.radius += i, !1 === t.ray.intersectsSphere(Ju)) return;
        Yu.copy(r).invert(), Zu.copy(t.ray).applyMatrix4(Yu);
        const o = i / ((this.scale.x + this.scale.y + this.scale.z) / 3),
          a = o * o;
        if (n.isBufferGeometry) {
          const i = n.index,
            o = n.attributes.position;
          if (null !== i) {
            for (let n = Math.max(0, s.start), l = Math.min(i.count, s.start + s.count); n < l; n++) {
              const s = i.getX(n);
              Qu.fromBufferAttribute(o, s), $u(Qu, s, a, r, t, e, this)
            }
          } else {
            for (let n = Math.max(0, s.start), i = Math.min(o.count, s.start + s.count); n < i; n++) Qu.fromBufferAttribute(o, n), $u(Qu, n, a, r, t, e, this)
          }
        } else console.error("THREE.Points.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")
      }
      updateMorphTargets() {
        const t = this.geometry;
        if (t.isBufferGeometry) {
          const e = t.morphAttributes,
            n = Object.keys(e);
          if (n.length > 0) {
            const t = e[n[0]];
            if (void 0 !== t) {
              this.morphTargetInfluences = [], this.morphTargetDictionary = {};
              for (let e = 0, n = t.length; e < n; e++) {
                const n = t[e].name || String(e);
                this.morphTargetInfluences.push(0), this.morphTargetDictionary[n] = e
              }
            }
          }
        } else {
          const e = t.morphTargets;
          void 0 !== e && e.length > 0 && console.error("THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.")
        }
      }
    }

    function $u(t, e, n, r, i, s, o) {
      const a = Zu.distanceSqToPoint(t);
      if (a < n) {
        const n = new gr;
        Zu.closestPointToPoint(t, n), n.applyMatrix4(r);
        const l = i.ray.origin.distanceTo(n);
        if (l < i.near || l > i.far) return;
        s.push({
          distance: l,
          distanceToRay: Math.sqrt(a),
          point: n,
          index: e,
          face: null,
          object: o
        })
      }
    }
    exports.Points = Ku, Ku.prototype.isPoints = !0;
    class tp extends hr {
      constructor(t, e, n, r, i, s, o, a, l) {
        super(t, e, n, r, i, s, o, a, l), this.format = void 0 !== o ? o : Bt, this.minFilter = void 0 !== s ? s : gt, this.magFilter = void 0 !== i ? i : gt, this.generateMipmaps = !1;
        const c = this;
        "requestVideoFrameCallback" in t && t.requestVideoFrameCallback(function e() {
          c.needsUpdate = !0, t.requestVideoFrameCallback(e)
        })
      }
      clone() {
        return new this.constructor(this.image).copy(this)
      }
      update() {
        const t = this.image;
        !1 === "requestVideoFrameCallback" in t && t.readyState >= t.HAVE_CURRENT_DATA && (this.needsUpdate = !0)
      }
    }
    exports.VideoTexture = tp, tp.prototype.isVideoTexture = !0;
    class ep extends hr {
      constructor(t, e, n, r, i, s, o, a, l, c, h, u) {
        super(null, s, o, a, l, c, r, i, h, u), this.image = {
          width: e,
          height: n
        }, this.mipmaps = t, this.flipY = !1, this.generateMipmaps = !1
      }
    }
    exports.CompressedTexture = ep, ep.prototype.isCompressedTexture = !0;
    class np extends hr {
      constructor(t, e, n, r, i, s, o, a, l) {
        super(t, e, n, r, i, s, o, a, l), this.needsUpdate = !0
      }
    }
    exports.CanvasTexture = np, np.prototype.isCanvasTexture = !0;
    class rp extends hr {
      constructor(t, e, n, r, i, s, o, a, l, c) {
        if ((c = void 0 !== c ? c : Ot) !== Ot && c !== Ht) throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
        void 0 === n && c === Ot && (n = St), void 0 === n && c === Ht && (n = Dt), super(null, r, i, s, o, a, c, n, l), this.image = {
          width: t,
          height: e
        }, this.magFilter = void 0 !== o ? o : ut, this.minFilter = void 0 !== a ? a : ut, this.flipY = !1, this.generateMipmaps = !1
      }
    }
    exports.DepthTexture = rp, rp.prototype.isDepthTexture = !0;
    class ip extends ds {
      constructor(t = 1, e = 8, n = 0, r = 2 * Math.PI) {
        super(), this.type = "CircleGeometry", this.parameters = {
          radius: t,
          segments: e,
          thetaStart: n,
          thetaLength: r
        }, e = Math.max(3, e);
        const i = [],
          s = [],
          o = [],
          a = [],
          l = new gr,
          c = new sr;
        s.push(0, 0, 0), o.push(0, 0, 1), a.push(.5, .5);
        for (let h = 0, u = 3; h <= e; h++, u += 3) {
          const i = n + h / e * r;
          l.x = t * Math.cos(i), l.y = t * Math.sin(i), s.push(l.x, l.y, l.z), o.push(0, 0, 1), c.x = (s[u] / t + 1) / 2, c.y = (s[u + 1] / t + 1) / 2, a.push(c.x, c.y)
        }
        for (let h = 1; h <= e; h++) i.push(h, h + 1, 0);
        this.setIndex(i), this.setAttribute("position", new es(s, 3)), this.setAttribute("normal", new es(o, 3)), this.setAttribute("uv", new es(a, 2))
      }
    }
    exports.CircleGeometry = exports.CircleBufferGeometry = ip;
    class sp extends ds {
      constructor(t = 1, e = 1, n = 1, r = 8, i = 1, s = !1, o = 0, a = 2 * Math.PI) {
        super(), this.type = "CylinderGeometry", this.parameters = {
          radiusTop: t,
          radiusBottom: e,
          height: n,
          radialSegments: r,
          heightSegments: i,
          openEnded: s,
          thetaStart: o,
          thetaLength: a
        };
        const l = this;
        r = Math.floor(r), i = Math.floor(i);
        const c = [],
          h = [],
          u = [],
          p = [];
        let d = 0;
        const m = [],
          f = n / 2;
        let g = 0;

        function x(n) {
          const i = d,
            s = new sr,
            m = new gr;
          let x = 0;
          const v = !0 === n ? t : e,
            y = !0 === n ? 1 : -1;
          for (let t = 1; t <= r; t++) h.push(0, f * y, 0), u.push(0, y, 0), p.push(.5, .5), d++;
          const _ = d;
          for (let t = 0; t <= r; t++) {
            const e = t / r * a + o,
              n = Math.cos(e),
              i = Math.sin(e);
            m.x = v * i, m.y = f * y, m.z = v * n, h.push(m.x, m.y, m.z), u.push(0, y, 0), s.x = .5 * n + .5, s.y = .5 * i * y + .5, p.push(s.x, s.y), d++
          }
          for (let t = 0; t < r; t++) {
            const e = i + t,
              r = _ + t;
            !0 === n ? c.push(r, r + 1, e) : c.push(r + 1, r, e), x += 3
          }
          l.addGroup(g, x, !0 === n ? 1 : 2), g += x
        }! function() {
          const s = new gr,
            x = new gr;
          let v = 0;
          const y = (e - t) / n;
          for (let l = 0; l <= i; l++) {
            const c = [],
              g = l / i,
              v = g * (e - t) + t;
            for (let t = 0; t <= r; t++) {
              const e = t / r,
                i = e * a + o,
                l = Math.sin(i),
                m = Math.cos(i);
              x.x = v * l, x.y = -g * n + f, x.z = v * m, h.push(x.x, x.y, x.z), s.set(l, y, m).normalize(), u.push(s.x, s.y, s.z), p.push(e, 1 - g), c.push(d++)
            }
            m.push(c)
          }
          for (let t = 0; t < r; t++)
            for (let e = 0; e < i; e++) {
              const n = m[e][t],
                r = m[e + 1][t],
                i = m[e + 1][t + 1],
                s = m[e][t + 1];
              c.push(n, r, s), c.push(r, i, s), v += 6
            }
          l.addGroup(g, v, 0), g += v
        }(), !1 === s && (t > 0 && x(!0), e > 0 && x(!1)), this.setIndex(c), this.setAttribute("position", new es(h, 3)), this.setAttribute("normal", new es(u, 3)), this.setAttribute("uv", new es(p, 2))
      }
    }
    exports.CylinderGeometry = exports.CylinderBufferGeometry = sp;
    class op extends sp {
      constructor(t = 1, e = 1, n = 8, r = 1, i = !1, s = 0, o = 2 * Math.PI) {
        super(0, t, e, n, r, i, s, o), this.type = "ConeGeometry", this.parameters = {
          radius: t,
          height: e,
          radialSegments: n,
          heightSegments: r,
          openEnded: i,
          thetaStart: s,
          thetaLength: o
        }
      }
    }
    exports.ConeGeometry = exports.ConeBufferGeometry = op;
    class ap extends ds {
      constructor(t, e, n = 1, r = 0) {
        super(), this.type = "PolyhedronGeometry", this.parameters = {
          vertices: t,
          indices: e,
          radius: n,
          detail: r
        };
        const i = [],
          s = [];

        function o(t, e, n, r) {
          const i = r + 1,
            s = [];
          for (let o = 0; o <= i; o++) {
            s[o] = [];
            const r = t.clone().lerp(n, o / i),
              a = e.clone().lerp(n, o / i),
              l = i - o;
            for (let t = 0; t <= l; t++) s[o][t] = 0 === t && o === i ? r : r.clone().lerp(a, t / l)
          }
          for (let o = 0; o < i; o++)
            for (let t = 0; t < 2 * (i - o) - 1; t++) {
              const e = Math.floor(t / 2);
              t % 2 == 0 ? (a(s[o][e + 1]), a(s[o + 1][e]), a(s[o][e])) : (a(s[o][e + 1]), a(s[o + 1][e + 1]), a(s[o + 1][e]))
            }
        }

        function a(t) {
          i.push(t.x, t.y, t.z)
        }

        function l(e, n) {
          const r = 3 * e;
          n.x = t[r + 0], n.y = t[r + 1], n.z = t[r + 2]
        }

        function c(t, e, n, r) {
          r < 0 && 1 === t.x && (s[e] = t.x - 1), 0 === n.x && 0 === n.z && (s[e] = r / 2 / Math.PI + .5)
        }

        function h(t) {
          return Math.atan2(t.z, -t.x)
        }! function(t) {
          const n = new gr,
            r = new gr,
            i = new gr;
          for (let s = 0; s < e.length; s += 3) l(e[s + 0], n), l(e[s + 1], r), l(e[s + 2], i), o(n, r, i, t)
        }(r),
        function(t) {
          const e = new gr;
          for (let n = 0; n < i.length; n += 3) e.x = i[n + 0], e.y = i[n + 1], e.z = i[n + 2], e.normalize().multiplyScalar(t), i[n + 0] = e.x, i[n + 1] = e.y, i[n + 2] = e.z
        }(n),
        function() {
          const t = new gr;
          for (let n = 0; n < i.length; n += 3) {
            t.x = i[n + 0], t.y = i[n + 1], t.z = i[n + 2];
            const r = h(t) / 2 / Math.PI + .5,
              o = (e = t, Math.atan2(-e.y, Math.sqrt(e.x * e.x + e.z * e.z)) / Math.PI + .5);
            s.push(r, 1 - o)
          }
          var e;
          (function() {
            const t = new gr,
              e = new gr,
              n = new gr,
              r = new gr,
              o = new sr,
              a = new sr,
              l = new sr;
            for (let u = 0, p = 0; u < i.length; u += 9, p += 6) {
              t.set(i[u + 0], i[u + 1], i[u + 2]), e.set(i[u + 3], i[u + 4], i[u + 5]), n.set(i[u + 6], i[u + 7], i[u + 8]), o.set(s[p + 0], s[p + 1]), a.set(s[p + 2], s[p + 3]), l.set(s[p + 4], s[p + 5]), r.copy(t).add(e).add(n).divideScalar(3);
              const d = h(r);
              c(o, p + 0, t, d), c(a, p + 2, e, d), c(l, p + 4, n, d)
            }
          })(),
          function() {
            for (let t = 0; t < s.length; t += 6) {
              const e = s[t + 0],
                n = s[t + 2],
                r = s[t + 4],
                i = Math.max(e, n, r),
                o = Math.min(e, n, r);
              i > .9 && o < .1 && (e < .2 && (s[t + 0] += 1), n < .2 && (s[t + 2] += 1), r < .2 && (s[t + 4] += 1))
            }
          }()
        }(), this.setAttribute("position", new es(i, 3)), this.setAttribute("normal", new es(i.slice(), 3)), this.setAttribute("uv", new es(s, 2)), 0 === r ? this.computeVertexNormals() : this.normalizeNormals()
      }
    }
    exports.PolyhedronGeometry = exports.PolyhedronBufferGeometry = ap;
    class lp extends ap {
      constructor(t = 1, e = 0) {
        const n = (1 + Math.sqrt(5)) / 2,
          r = 1 / n;
        super([-1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, 1, 1, 1, -1, 1, 1, 1, 0, -r, -n, 0, -r, n, 0, r, -n, 0, r, n, -r, -n, 0, -r, n, 0, r, -n, 0, r, n, 0, -n, 0, -r, n, 0, -r, -n, 0, r, n, 0, r], [3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9], t, e), this.type = "DodecahedronGeometry", this.parameters = {
          radius: t,
          detail: e
        }
      }
    }
    exports.DodecahedronGeometry = exports.DodecahedronBufferGeometry = lp;
    const cp = new gr,
      hp = new gr,
      up = new gr,
      pp = new Ii;
    class dp extends ds {
      constructor(t, e) {
        if (super(), this.type = "EdgesGeometry", this.parameters = {
            thresholdAngle: e
          }, e = void 0 !== e ? e : 1, !0 === t.isGeometry) return void console.error("THREE.EdgesGeometry no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
        const n = Math.pow(10, 4),
          r = Math.cos(Fn * e),
          i = t.getIndex(),
          s = t.getAttribute("position"),
          o = i ? i.count : s.count,
          a = [0, 0, 0],
          l = ["a", "b", "c"],
          c = new Array(3),
          h = {},
          u = [];
        for (let p = 0; p < o; p += 3) {
          i ? (a[0] = i.getX(p), a[1] = i.getX(p + 1), a[2] = i.getX(p + 2)) : (a[0] = p, a[1] = p + 1, a[2] = p + 2);
          const {
            a: t,
            b: e,
            c: o
          } = pp;
          if (t.fromBufferAttribute(s, a[0]), e.fromBufferAttribute(s, a[1]), o.fromBufferAttribute(s, a[2]), pp.getNormal(up), c[0] = `${Math.round(t.x*n)},${Math.round(t.y*n)},${Math.round(t.z*n)}`, c[1] = `${Math.round(e.x*n)},${Math.round(e.y*n)},${Math.round(e.z*n)}`, c[2] = `${Math.round(o.x*n)},${Math.round(o.y*n)},${Math.round(o.z*n)}`, c[0] !== c[1] && c[1] !== c[2] && c[2] !== c[0])
            for (let n = 0; n < 3; n++) {
              const t = (n + 1) % 3,
                e = c[n],
                i = c[t],
                s = pp[l[n]],
                o = pp[l[t]],
                p = `${e}_${i}`,
                d = `${i}_${e}`;
              d in h && h[d] ? (up.dot(h[d].normal) <= r && (u.push(s.x, s.y, s.z), u.push(o.x, o.y, o.z)), h[d] = null) : p in h || (h[p] = {
                index0: a[n],
                index1: a[t],
                normal: up.clone()
              })
            }
        }
        for (const p in h)
          if (h[p]) {
            const {
              index0: t,
              index1: e
            } = h[p];
            cp.fromBufferAttribute(s, t), hp.fromBufferAttribute(s, e), u.push(cp.x, cp.y, cp.z), u.push(hp.x, hp.y, hp.z)
          } this.setAttribute("position", new es(u, 3))
      }
    }
    exports.EdgesGeometry = dp;
    const mp = {
      triangulate: function(t, e, n) {
        n = n || 2;
        const r = e && e.length,
          i = r ? e[0] * n : t.length;
        let s = fp(t, 0, i, n, !0);
        const o = [];
        if (!s || s.next === s.prev) return o;
        let a, l, c, h, u, p, d;
        if (r && (s = wp(t, e, s, n)), t.length > 80 * n) {
          a = c = t[0], l = h = t[1];
          for (let e = n; e < i; e += n)(u = t[e]) < a && (a = u), (p = t[e + 1]) < l && (l = p), u > c && (c = u), p > h && (h = p);
          d = 0 !== (d = Math.max(c - a, h - l)) ? 1 / d : 0
        }
        return xp(s, o, n, a, l, d), o
      }
    };

    function fp(t, e, n, r, i) {
      let s, o;
      if (i === jp(t, e, n, r) > 0)
        for (s = e; s < n; s += r) o = kp(s, t[s], t[s + 1], o);
      else
        for (s = n - r; s >= e; s -= r) o = kp(s, t[s], t[s + 1], o);
      return o && Bp(o, o.next) && (Vp(o), o = o.next), o
    }

    function gp(t, e) {
      if (!t) return t;
      e || (e = t);
      let n, r = t;
      do {
        if (n = !1, r.steiner || !Bp(r, r.next) && 0 !== Ip(r.prev, r, r.next)) r = r.next;
        else {
          if (Vp(r), (r = e = r.prev) === r.next) break;
          n = !0
        }
      } while (n || r !== e);
      return e
    }

    function xp(t, e, n, r, i, s, o) {
      if (!t) return;
      !o && s && Ap(t, r, i, s);
      let a, l, c = t;
      for (; t.prev !== t.next;)
        if (a = t.prev, l = t.next, s ? yp(t, r, i, s) : vp(t)) e.push(a.i / n), e.push(t.i / n), e.push(l.i / n), Vp(t), t = l.next, c = l.next;
        else if ((t = l) === c) {
        o ? 1 === o ? xp(t = _p(gp(t), e, n), e, n, r, i, s, 2) : 2 === o && bp(t, e, n, r, i, s) : xp(gp(t), e, n, r, i, s, 1);
        break
      }
    }

    function vp(t) {
      const e = t.prev,
        n = t,
        r = t.next;
      if (Ip(e, n, r) >= 0) return !1;
      let i = t.next.next;
      for (; i !== t.prev;) {
        if (Pp(e.x, e.y, n.x, n.y, r.x, r.y, i.x, i.y) && Ip(i.prev, i, i.next) >= 0) return !1;
        i = i.next
      }
      return !0
    }

    function yp(t, e, n, r) {
      const i = t.prev,
        s = t,
        o = t.next;
      if (Ip(i, s, o) >= 0) return !1;
      const a = i.x < s.x ? i.x < o.x ? i.x : o.x : s.x < o.x ? s.x : o.x,
        l = i.y < s.y ? i.y < o.y ? i.y : o.y : s.y < o.y ? s.y : o.y,
        c = i.x > s.x ? i.x > o.x ? i.x : o.x : s.x > o.x ? s.x : o.x,
        h = i.y > s.y ? i.y > o.y ? i.y : o.y : s.y > o.y ? s.y : o.y,
        u = Rp(a, l, e, n, r),
        p = Rp(c, h, e, n, r);
      let d = t.prevZ,
        m = t.nextZ;
      for (; d && d.z >= u && m && m.z <= p;) {
        if (d !== t.prev && d !== t.next && Pp(i.x, i.y, s.x, s.y, o.x, o.y, d.x, d.y) && Ip(d.prev, d, d.next) >= 0) return !1;
        if (d = d.prevZ, m !== t.prev && m !== t.next && Pp(i.x, i.y, s.x, s.y, o.x, o.y, m.x, m.y) && Ip(m.prev, m, m.next) >= 0) return !1;
        m = m.nextZ
      }
      for (; d && d.z >= u;) {
        if (d !== t.prev && d !== t.next && Pp(i.x, i.y, s.x, s.y, o.x, o.y, d.x, d.y) && Ip(d.prev, d, d.next) >= 0) return !1;
        d = d.prevZ
      }
      for (; m && m.z <= p;) {
        if (m !== t.prev && m !== t.next && Pp(i.x, i.y, s.x, s.y, o.x, o.y, m.x, m.y) && Ip(m.prev, m, m.next) >= 0) return !1;
        m = m.nextZ
      }
      return !0
    }

    function _p(t, e, n) {
      let r = t;
      do {
        const i = r.prev,
          s = r.next.next;
        !Bp(i, s) && Np(i, r, r.next, s) && Op(i, s) && Op(s, i) && (e.push(i.i / n), e.push(r.i / n), e.push(s.i / n), Vp(r), Vp(r.next), r = t = s), r = r.next
      } while (r !== t);
      return gp(r)
    }

    function bp(t, e, n, r, i, s) {
      let o = t;
      do {
        let t = o.next.next;
        for (; t !== o.prev;) {
          if (o.i !== t.i && Dp(o, t)) {
            let a = Up(o, t);
            return o = gp(o, o.next), a = gp(a, a.next), xp(o, e, n, r, i, s), void xp(a, e, n, r, i, s)
          }
          t = t.next
        }
        o = o.next
      } while (o !== t)
    }

    function wp(t, e, n, r) {
      const i = [];
      let s, o, a, l, c;
      for (s = 0, o = e.length; s < o; s++)(c = fp(t, a = e[s] * r, l = s < o - 1 ? e[s + 1] * r : t.length, r, !1)) === c.next && (c.steiner = !0), i.push(Cp(c));
      for (i.sort(Mp), s = 0; s < i.length; s++) Sp(i[s], n), n = gp(n, n.next);
      return n
    }

    function Mp(t, e) {
      return t.x - e.x
    }

    function Sp(t, e) {
      if (e = Tp(t, e)) {
        const n = Up(e, t);
        gp(e, e.next), gp(n, n.next)
      }
    }

    function Tp(t, e) {
      let n = e;
      const r = t.x,
        i = t.y;
      let s, o = -1 / 0;
      do {
        if (i <= n.y && i >= n.next.y && n.next.y !== n.y) {
          const t = n.x + (i - n.y) * (n.next.x - n.x) / (n.next.y - n.y);
          if (t <= r && t > o) {
            if (o = t, t === r) {
              if (i === n.y) return n;
              if (i === n.next.y) return n.next
            }
            s = n.x < n.next.x ? n : n.next
          }
        }
        n = n.next
      } while (n !== e);
      if (!s) return null;
      if (r === o) return s;
      const a = s,
        l = s.x,
        c = s.y;
      let h, u = 1 / 0;
      n = s;
      do {
        r >= n.x && n.x >= l && r !== n.x && Pp(i < c ? r : o, i, l, c, i < c ? o : r, i, n.x, n.y) && (h = Math.abs(i - n.y) / (r - n.x), Op(n, t) && (h < u || h === u && (n.x > s.x || n.x === s.x && Ep(s, n))) && (s = n, u = h)), n = n.next
      } while (n !== a);
      return s
    }

    function Ep(t, e) {
      return Ip(t.prev, t, e.prev) < 0 && Ip(e.next, t, t.next) < 0
    }

    function Ap(t, e, n, r) {
      let i = t;
      do {
        null === i.z && (i.z = Rp(i.x, i.y, e, n, r)), i.prevZ = i.prev, i.nextZ = i.next, i = i.next
      } while (i !== t);
      i.prevZ.nextZ = null, i.prevZ = null, Lp(i)
    }

    function Lp(t) {
      let e, n, r, i, s, o, a, l, c = 1;
      do {
        for (n = t, t = null, s = null, o = 0; n;) {
          for (o++, r = n, a = 0, e = 0; e < c && (a++, r = r.nextZ); e++);
          for (l = c; a > 0 || l > 0 && r;) 0 !== a && (0 === l || !r || n.z <= r.z) ? (i = n, n = n.nextZ, a--) : (i = r, r = r.nextZ, l--), s ? s.nextZ = i : t = i, i.prevZ = s, s = i;
          n = r
        }
        s.nextZ = null, c *= 2
      } while (o > 1);
      return t
    }

    function Rp(t, e, n, r, i) {
      return (t = 1431655765 & ((t = 858993459 & ((t = 252645135 & ((t = 16711935 & ((t = 32767 * (t - n) * i) | t << 8)) | t << 4)) | t << 2)) | t << 1)) | (e = 1431655765 & ((e = 858993459 & ((e = 252645135 & ((e = 16711935 & ((e = 32767 * (e - r) * i) | e << 8)) | e << 4)) | e << 2)) | e << 1)) << 1
    }

    function Cp(t) {
      let e = t,
        n = t;
      do {
        (e.x < n.x || e.x === n.x && e.y < n.y) && (n = e), e = e.next
      } while (e !== t);
      return n
    }

    function Pp(t, e, n, r, i, s, o, a) {
      return (i - o) * (e - a) - (t - o) * (s - a) >= 0 && (t - o) * (r - a) - (n - o) * (e - a) >= 0 && (n - o) * (s - a) - (i - o) * (r - a) >= 0
    }

    function Dp(t, e) {
      return t.next.i !== e.i && t.prev.i !== e.i && !Gp(t, e) && (Op(t, e) && Op(e, t) && Hp(t, e) && (Ip(t.prev, t, e.prev) || Ip(t, e.prev, e)) || Bp(t, e) && Ip(t.prev, t, t.next) > 0 && Ip(e.prev, e, e.next) > 0)
    }

    function Ip(t, e, n) {
      return (e.y - t.y) * (n.x - e.x) - (e.x - t.x) * (n.y - e.y)
    }

    function Bp(t, e) {
      return t.x === e.x && t.y === e.y
    }

    function Np(t, e, n, r) {
      const i = zp(Ip(t, e, n)),
        s = zp(Ip(t, e, r)),
        o = zp(Ip(n, r, t)),
        a = zp(Ip(n, r, e));
      return i !== s && o !== a || (!(0 !== i || !Fp(t, n, e)) || (!(0 !== s || !Fp(t, r, e)) || (!(0 !== o || !Fp(n, t, r)) || !(0 !== a || !Fp(n, e, r)))))
    }

    function Fp(t, e, n) {
      return e.x <= Math.max(t.x, n.x) && e.x >= Math.min(t.x, n.x) && e.y <= Math.max(t.y, n.y) && e.y >= Math.min(t.y, n.y)
    }

    function zp(t) {
      return t > 0 ? 1 : t < 0 ? -1 : 0
    }

    function Gp(t, e) {
      let n = t;
      do {
        if (n.i !== t.i && n.next.i !== t.i && n.i !== e.i && n.next.i !== e.i && Np(n, n.next, t, e)) return !0;
        n = n.next
      } while (n !== t);
      return !1
    }

    function Op(t, e) {
      return Ip(t.prev, t, t.next) < 0 ? Ip(t, e, t.next) >= 0 && Ip(t, t.prev, e) >= 0 : Ip(t, e, t.prev) < 0 || Ip(t, t.next, e) < 0
    }

    function Hp(t, e) {
      let n = t,
        r = !1;
      const i = (t.x + e.x) / 2,
        s = (t.y + e.y) / 2;
      do {
        n.y > s != n.next.y > s && n.next.y !== n.y && i < (n.next.x - n.x) * (s - n.y) / (n.next.y - n.y) + n.x && (r = !r), n = n.next
      } while (n !== t);
      return r
    }

    function Up(t, e) {
      const n = new Wp(t.i, t.x, t.y),
        r = new Wp(e.i, e.x, e.y),
        i = t.next,
        s = e.prev;
      return t.next = e, e.prev = t, n.next = i, i.prev = n, r.next = n, n.prev = r, s.next = r, r.prev = s, r
    }

    function kp(t, e, n, r) {
      const i = new Wp(t, e, n);
      return r ? (i.next = r.next, i.prev = r, r.next.prev = i, r.next = i) : (i.prev = i, i.next = i), i
    }

    function Vp(t) {
      t.next.prev = t.prev, t.prev.next = t.next, t.prevZ && (t.prevZ.nextZ = t.nextZ), t.nextZ && (t.nextZ.prevZ = t.prevZ)
    }

    function Wp(t, e, n) {
      this.i = t, this.x = e, this.y = n, this.prev = null, this.next = null, this.z = null, this.prevZ = null, this.nextZ = null, this.steiner = !1
    }

    function jp(t, e, n, r) {
      let i = 0;
      for (let s = e, o = n - r; s < n; s += r) i += (t[o] - t[s]) * (t[s + 1] + t[o + 1]), o = s;
      return i
    }
    class qp {
      static area(t) {
        const e = t.length;
        let n = 0;
        for (let r = e - 1, i = 0; i < e; r = i++) n += t[r].x * t[i].y - t[i].x * t[r].y;
        return .5 * n
      }
      static isClockWise(t) {
        return qp.area(t) < 0
      }
      static triangulateShape(t, e) {
        const n = [],
          r = [],
          i = [];
        Xp(t), Yp(n, t);
        let s = t.length;
        e.forEach(Xp);
        for (let a = 0; a < e.length; a++) r.push(s), s += e[a].length, Yp(n, e[a]);
        const o = mp.triangulate(n, r);
        for (let a = 0; a < o.length; a += 3) i.push(o.slice(a, a + 3));
        return i
      }
    }

    function Xp(t) {
      const e = t.length;
      e > 2 && t[e - 1].equals(t[0]) && t.pop()
    }

    function Yp(t, e) {
      for (let n = 0; n < e.length; n++) t.push(e[n].x), t.push(e[n].y)
    }
    exports.ShapeUtils = qp;
    class Zp extends ds {
      constructor(t, e) {
        super(), this.type = "ExtrudeGeometry", this.parameters = {
          shapes: t,
          options: e
        }, t = Array.isArray(t) ? t : [t];
        const n = this,
          r = [],
          i = [];
        for (let o = 0, a = t.length; o < a; o++) {
          s(t[o])
        }

        function s(t) {
          const s = [],
            o = void 0 !== e.curveSegments ? e.curveSegments : 12,
            a = void 0 !== e.steps ? e.steps : 1;
          let l = void 0 !== e.depth ? e.depth : 100,
            c = void 0 === e.bevelEnabled || e.bevelEnabled,
            h = void 0 !== e.bevelThickness ? e.bevelThickness : 6,
            u = void 0 !== e.bevelSize ? e.bevelSize : h - 2,
            p = void 0 !== e.bevelOffset ? e.bevelOffset : 0,
            d = void 0 !== e.bevelSegments ? e.bevelSegments : 3;
          const m = e.extrudePath,
            f = void 0 !== e.UVGenerator ? e.UVGenerator : Jp;
          void 0 !== e.amount && (console.warn("THREE.ExtrudeBufferGeometry: amount has been renamed to depth."), l = e.amount);
          let g, x, v, y, _, b = !1;
          m && (g = m.getSpacedPoints(a), b = !0, c = !1, x = m.computeFrenetFrames(a, !1), v = new gr, y = new gr, _ = new gr), c || (d = 0, h = 0, u = 0, p = 0);
          const w = t.extractPoints(o);
          let M = w.shape;
          const S = w.holes;
          if (!qp.isClockWise(M)) {
            M = M.reverse();
            for (let t = 0, e = S.length; t < e; t++) {
              const e = S[t];
              qp.isClockWise(e) && (S[t] = e.reverse())
            }
          }
          const T = qp.triangulateShape(M, S),
            E = M;
          for (let e = 0, n = S.length; e < n; e++) {
            const t = S[e];
            M = M.concat(t)
          }

          function A(t, e, n) {
            return e || console.error("THREE.ExtrudeGeometry: vec does not exist"), e.clone().multiplyScalar(n).add(t)
          }
          const L = M.length,
            R = T.length;

          function C(t, e, n) {
            let r, i, s;
            const o = t.x - e.x,
              a = t.y - e.y,
              l = n.x - t.x,
              c = n.y - t.y,
              h = o * o + a * a,
              u = o * c - a * l;
            if (Math.abs(u) > Number.EPSILON) {
              const u = Math.sqrt(h),
                p = Math.sqrt(l * l + c * c),
                d = e.x - a / u,
                m = e.y + o / u,
                f = ((n.x - c / p - d) * c - (n.y + l / p - m) * l) / (o * c - a * l),
                g = (r = d + o * f - t.x) * r + (i = m + a * f - t.y) * i;
              if (g <= 2) return new sr(r, i);
              s = Math.sqrt(g / 2)
            } else {
              let t = !1;
              o > Number.EPSILON ? l > Number.EPSILON && (t = !0) : o < -Number.EPSILON ? l < -Number.EPSILON && (t = !0) : Math.sign(a) === Math.sign(c) && (t = !0), t ? (r = -a, i = o, s = Math.sqrt(h)) : (r = o, i = a, s = Math.sqrt(h / 2))
            }
            return new sr(r / s, i / s)
          }
          const P = [];
          for (let e = 0, n = E.length, r = n - 1, i = e + 1; e < n; e++, r++, i++) r === n && (r = 0), i === n && (i = 0), P[e] = C(E[e], E[r], E[i]);
          const D = [];
          let I, B = P.concat();
          for (let e = 0, n = S.length; e < n; e++) {
            const t = S[e];
            I = [];
            for (let e = 0, n = t.length, r = n - 1, i = e + 1; e < n; e++, r++, i++) r === n && (r = 0), i === n && (i = 0), I[e] = C(t[e], t[r], t[i]);
            D.push(I), B = B.concat(I)
          }
          for (let e = 0; e < d; e++) {
            const t = e / d,
              n = h * Math.cos(t * Math.PI / 2),
              r = u * Math.sin(t * Math.PI / 2) + p;
            for (let e = 0, i = E.length; e < i; e++) {
              const t = A(E[e], P[e], r);
              z(t.x, t.y, -n)
            }
            for (let e = 0, i = S.length; e < i; e++) {
              const t = S[e];
              I = D[e];
              for (let e = 0, i = t.length; e < i; e++) {
                const i = A(t[e], I[e], r);
                z(i.x, i.y, -n)
              }
            }
          }
          const N = u + p;
          for (let e = 0; e < L; e++) {
            const t = c ? A(M[e], B[e], N) : M[e];
            b ? (y.copy(x.normals[0]).multiplyScalar(t.x), v.copy(x.binormals[0]).multiplyScalar(t.y), _.copy(g[0]).add(y).add(v), z(_.x, _.y, _.z)) : z(t.x, t.y, 0)
          }
          for (let e = 1; e <= a; e++)
            for (let t = 0; t < L; t++) {
              const n = c ? A(M[t], B[t], N) : M[t];
              b ? (y.copy(x.normals[e]).multiplyScalar(n.x), v.copy(x.binormals[e]).multiplyScalar(n.y), _.copy(g[e]).add(y).add(v), z(_.x, _.y, _.z)) : z(n.x, n.y, l / a * e)
            }
          for (let e = d - 1; e >= 0; e--) {
            const t = e / d,
              n = h * Math.cos(t * Math.PI / 2),
              r = u * Math.sin(t * Math.PI / 2) + p;
            for (let e = 0, i = E.length; e < i; e++) {
              const t = A(E[e], P[e], r);
              z(t.x, t.y, l + n)
            }
            for (let e = 0, i = S.length; e < i; e++) {
              const t = S[e];
              I = D[e];
              for (let e = 0, i = t.length; e < i; e++) {
                const i = A(t[e], I[e], r);
                b ? z(i.x, i.y + g[a - 1].y, g[a - 1].x + n) : z(i.x, i.y, l + n)
              }
            }
          }

          function F(t, e) {
            let n = t.length;
            for (; --n >= 0;) {
              const r = n;
              let i = n - 1;
              i < 0 && (i = t.length - 1);
              for (let t = 0, n = a + 2 * d; t < n; t++) {
                const n = L * t,
                  s = L * (t + 1);
                O(e + r + n, e + i + n, e + i + s, e + r + s)
              }
            }
          }

          function z(t, e, n) {
            s.push(t), s.push(e), s.push(n)
          }

          function G(t, e, i) {
            H(t), H(e), H(i);
            const s = r.length / 3,
              o = f.generateTopUV(n, r, s - 3, s - 2, s - 1);
            U(o[0]), U(o[1]), U(o[2])
          }

          function O(t, e, i, s) {
            H(t), H(e), H(s), H(e), H(i), H(s);
            const o = r.length / 3,
              a = f.generateSideWallUV(n, r, o - 6, o - 3, o - 2, o - 1);
            U(a[0]), U(a[1]), U(a[3]), U(a[1]), U(a[2]), U(a[3])
          }

          function H(t) {
            r.push(s[3 * t + 0]), r.push(s[3 * t + 1]), r.push(s[3 * t + 2])
          }

          function U(t) {
            i.push(t.x), i.push(t.y)
          }! function() {
            const t = r.length / 3;
            if (c) {
              let t = 0,
                e = L * t;
              for (let n = 0; n < R; n++) {
                const t = T[n];
                G(t[2] + e, t[1] + e, t[0] + e)
              }
              e = L * (t = a + 2 * d);
              for (let n = 0; n < R; n++) {
                const t = T[n];
                G(t[0] + e, t[1] + e, t[2] + e)
              }
            } else {
              for (let t = 0; t < R; t++) {
                const e = T[t];
                G(e[2], e[1], e[0])
              }
              for (let t = 0; t < R; t++) {
                const e = T[t];
                G(e[0] + L * a, e[1] + L * a, e[2] + L * a)
              }
            }
            n.addGroup(t, r.length / 3 - t, 0)
          }(),
          function() {
            const t = r.length / 3;
            let e = 0;
            F(E, e), e += E.length;
            for (let n = 0, r = S.length; n < r; n++) {
              const t = S[n];
              F(t, e), e += t.length
            }
            n.addGroup(t, r.length / 3 - t, 1)
          }()
        }
        this.setAttribute("position", new es(r, 3)), this.setAttribute("uv", new es(i, 2)), this.computeVertexNormals()
      }
      toJSON() {
        const t = ds.prototype.toJSON.call(this);
        return Qp(this.parameters.shapes, this.parameters.options, t)
      }
    }
    exports.ExtrudeGeometry = exports.ExtrudeBufferGeometry = Zp;
    const Jp = {
      generateTopUV: function(t, e, n, r, i) {
        const s = e[3 * n],
          o = e[3 * n + 1],
          a = e[3 * r],
          l = e[3 * r + 1],
          c = e[3 * i],
          h = e[3 * i + 1];
        return [new sr(s, o), new sr(a, l), new sr(c, h)]
      },
      generateSideWallUV: function(t, e, n, r, i, s) {
        const o = e[3 * n],
          a = e[3 * n + 1],
          l = e[3 * n + 2],
          c = e[3 * r],
          h = e[3 * r + 1],
          u = e[3 * r + 2],
          p = e[3 * i],
          d = e[3 * i + 1],
          m = e[3 * i + 2],
          f = e[3 * s],
          g = e[3 * s + 1],
          x = e[3 * s + 2];
        return Math.abs(a - h) < .01 ? [new sr(o, 1 - l), new sr(c, 1 - u), new sr(p, 1 - m), new sr(f, 1 - x)] : [new sr(a, 1 - l), new sr(h, 1 - u), new sr(d, 1 - m), new sr(g, 1 - x)]
      }
    };

    function Qp(t, e, n) {
      if (n.shapes = [], Array.isArray(t))
        for (let r = 0, i = t.length; r < i; r++) {
          const e = t[r];
          n.shapes.push(e.uuid)
        } else n.shapes.push(t.uuid);
      return void 0 !== e.extrudePath && (n.options.extrudePath = e.extrudePath.toJSON()), n
    }
    class Kp extends ap {
      constructor(t = 1, e = 0) {
        const n = (1 + Math.sqrt(5)) / 2;
        super([-1, n, 0, 1, n, 0, -1, -n, 0, 1, -n, 0, 0, -1, n, 0, 1, n, 0, -1, -n, 0, 1, -n, n, 0, -1, n, 0, 1, -n, 0, -1, -n, 0, 1], [0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1], t, e), this.type = "IcosahedronGeometry", this.parameters = {
          radius: t,
          detail: e
        }
      }
    }
    exports.IcosahedronGeometry = exports.IcosahedronBufferGeometry = Kp;
    class $p extends ds {
      constructor(t, e = 12, n = 0, r = 2 * Math.PI) {
        super(), this.type = "LatheGeometry", this.parameters = {
          points: t,
          segments: e,
          phiStart: n,
          phiLength: r
        }, e = Math.floor(e), r = On(r, 0, 2 * Math.PI);
        const i = [],
          s = [],
          o = [],
          a = 1 / e,
          l = new gr,
          c = new sr;
        for (let h = 0; h <= e; h++) {
          const i = n + h * a * r,
            u = Math.sin(i),
            p = Math.cos(i);
          for (let n = 0; n <= t.length - 1; n++) l.x = t[n].x * u, l.y = t[n].y, l.z = t[n].x * p, s.push(l.x, l.y, l.z), c.x = h / e, c.y = n / (t.length - 1), o.push(c.x, c.y)
        }
        for (let h = 0; h < e; h++)
          for (let e = 0; e < t.length - 1; e++) {
            const n = e + h * t.length,
              r = n,
              s = n + t.length,
              o = n + t.length + 1,
              a = n + 1;
            i.push(r, s, a), i.push(s, o, a)
          }
        if (this.setIndex(i), this.setAttribute("position", new es(s, 3)), this.setAttribute("uv", new es(o, 2)), this.computeVertexNormals(), r === 2 * Math.PI) {
          const n = this.attributes.normal.array,
            r = new gr,
            i = new gr,
            s = new gr,
            o = e * t.length * 3;
          for (let e = 0, a = 0; e < t.length; e++, a += 3) r.x = n[a + 0], r.y = n[a + 1], r.z = n[a + 2], i.x = n[o + a + 0], i.y = n[o + a + 1], i.z = n[o + a + 2], s.addVectors(r, i).normalize(), n[a + 0] = n[o + a + 0] = s.x, n[a + 1] = n[o + a + 1] = s.y, n[a + 2] = n[o + a + 2] = s.z
        }
      }
    }
    exports.LatheGeometry = exports.LatheBufferGeometry = $p;
    class td extends ap {
      constructor(t = 1, e = 0) {
        super([1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1], [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2], t, e), this.type = "OctahedronGeometry", this.parameters = {
          radius: t,
          detail: e
        }
      }
    }
    exports.OctahedronGeometry = exports.OctahedronBufferGeometry = td;
    class ed extends ds {
      constructor(t, e, n) {
        super(), this.type = "ParametricGeometry", this.parameters = {
          func: t,
          slices: e,
          stacks: n
        };
        const r = [],
          i = [],
          s = [],
          o = [],
          a = new gr,
          l = new gr,
          c = new gr,
          h = new gr,
          u = new gr;
        t.length < 3 && console.error("THREE.ParametricGeometry: Function must now modify a Vector3 as third parameter.");
        const p = e + 1;
        for (let d = 0; d <= n; d++) {
          const r = d / n;
          for (let n = 0; n <= e; n++) {
            const p = n / e;
            t(p, r, l), i.push(l.x, l.y, l.z), p - 1e-5 >= 0 ? (t(p - 1e-5, r, c), h.subVectors(l, c)) : (t(p + 1e-5, r, c), h.subVectors(c, l)), r - 1e-5 >= 0 ? (t(p, r - 1e-5, c), u.subVectors(l, c)) : (t(p, r + 1e-5, c), u.subVectors(c, l)), a.crossVectors(h, u).normalize(), s.push(a.x, a.y, a.z), o.push(p, r)
          }
        }
        for (let d = 0; d < n; d++)
          for (let t = 0; t < e; t++) {
            const e = d * p + t,
              n = d * p + t + 1,
              i = (d + 1) * p + t + 1,
              s = (d + 1) * p + t;
            r.push(e, n, s), r.push(n, i, s)
          }
        this.setIndex(r), this.setAttribute("position", new es(i, 3)), this.setAttribute("normal", new es(s, 3)), this.setAttribute("uv", new es(o, 2))
      }
    }
    exports.ParametricGeometry = exports.ParametricBufferGeometry = ed;
    class nd extends ds {
      constructor(t = .5, e = 1, n = 8, r = 1, i = 0, s = 2 * Math.PI) {
        super(), this.type = "RingGeometry", this.parameters = {
          innerRadius: t,
          outerRadius: e,
          thetaSegments: n,
          phiSegments: r,
          thetaStart: i,
          thetaLength: s
        }, n = Math.max(3, n);
        const o = [],
          a = [],
          l = [],
          c = [];
        let h = t;
        const u = (e - t) / (r = Math.max(1, r)),
          p = new gr,
          d = new sr;
        for (let m = 0; m <= r; m++) {
          for (let t = 0; t <= n; t++) {
            const r = i + t / n * s;
            p.x = h * Math.cos(r), p.y = h * Math.sin(r), a.push(p.x, p.y, p.z), l.push(0, 0, 1), d.x = (p.x / e + 1) / 2, d.y = (p.y / e + 1) / 2, c.push(d.x, d.y)
          }
          h += u
        }
        for (let m = 0; m < r; m++) {
          const t = m * (n + 1);
          for (let e = 0; e < n; e++) {
            const r = e + t,
              i = r,
              s = r + n + 1,
              a = r + n + 2,
              l = r + 1;
            o.push(i, s, l), o.push(s, a, l)
          }
        }
        this.setIndex(o), this.setAttribute("position", new es(a, 3)), this.setAttribute("normal", new es(l, 3)), this.setAttribute("uv", new es(c, 2))
      }
    }
    exports.RingGeometry = exports.RingBufferGeometry = nd;
    class rd extends ds {
      constructor(t, e = 12) {
        super(), this.type = "ShapeGeometry", this.parameters = {
          shapes: t,
          curveSegments: e
        };
        const n = [],
          r = [],
          i = [],
          s = [];
        let o = 0,
          a = 0;
        if (!1 === Array.isArray(t)) l(t);
        else
          for (let c = 0; c < t.length; c++) l(t[c]), this.addGroup(o, a, c), o += a, a = 0;

        function l(t) {
          const o = r.length / 3,
            l = t.extractPoints(e);
          let c = l.shape;
          const h = l.holes;
          !1 === qp.isClockWise(c) && (c = c.reverse());
          for (let e = 0, n = h.length; e < n; e++) {
            const t = h[e];
            !0 === qp.isClockWise(t) && (h[e] = t.reverse())
          }
          const u = qp.triangulateShape(c, h);
          for (let e = 0, n = h.length; e < n; e++) {
            const t = h[e];
            c = c.concat(t)
          }
          for (let e = 0, n = c.length; e < n; e++) {
            const t = c[e];
            r.push(t.x, t.y, 0), i.push(0, 0, 1), s.push(t.x, t.y)
          }
          for (let e = 0, r = u.length; e < r; e++) {
            const t = u[e],
              r = t[0] + o,
              i = t[1] + o,
              s = t[2] + o;
            n.push(r, i, s), a += 3
          }
        }
        this.setIndex(n), this.setAttribute("position", new es(r, 3)), this.setAttribute("normal", new es(i, 3)), this.setAttribute("uv", new es(s, 2))
      }
      toJSON() {
        const t = ds.prototype.toJSON.call(this);
        return id(this.parameters.shapes, t)
      }
    }

    function id(t, e) {
      if (e.shapes = [], Array.isArray(t))
        for (let n = 0, r = t.length; n < r; n++) {
          const r = t[n];
          e.shapes.push(r.uuid)
        } else e.shapes.push(t.uuid);
      return e
    }
    exports.ShapeGeometry = exports.ShapeBufferGeometry = rd;
    class sd extends ds {
      constructor(t = 1, e = 8, n = 6, r = 0, i = 2 * Math.PI, s = 0, o = Math.PI) {
        super(), this.type = "SphereGeometry", this.parameters = {
          radius: t,
          widthSegments: e,
          heightSegments: n,
          phiStart: r,
          phiLength: i,
          thetaStart: s,
          thetaLength: o
        }, e = Math.max(3, Math.floor(e)), n = Math.max(2, Math.floor(n));
        const a = Math.min(s + o, Math.PI);
        let l = 0;
        const c = [],
          h = new gr,
          u = new gr,
          p = [],
          d = [],
          m = [],
          f = [];
        for (let g = 0; g <= n; g++) {
          const p = [],
            x = g / n;
          let v = 0;
          0 == g && 0 == s ? v = .5 / e : g == n && a == Math.PI && (v = -.5 / e);
          for (let n = 0; n <= e; n++) {
            const a = n / e;
            h.x = -t * Math.cos(r + a * i) * Math.sin(s + x * o), h.y = t * Math.cos(s + x * o), h.z = t * Math.sin(r + a * i) * Math.sin(s + x * o), d.push(h.x, h.y, h.z), u.copy(h).normalize(), m.push(u.x, u.y, u.z), f.push(a + v, 1 - x), p.push(l++)
          }
          c.push(p)
        }
        for (let g = 0; g < n; g++)
          for (let t = 0; t < e; t++) {
            const e = c[g][t + 1],
              r = c[g][t],
              i = c[g + 1][t],
              o = c[g + 1][t + 1];
            (0 !== g || s > 0) && p.push(e, r, o), (g !== n - 1 || a < Math.PI) && p.push(r, i, o)
          }
        this.setIndex(p), this.setAttribute("position", new es(d, 3)), this.setAttribute("normal", new es(m, 3)), this.setAttribute("uv", new es(f, 2))
      }
    }
    exports.SphereGeometry = exports.SphereBufferGeometry = sd;
    class od extends ap {
      constructor(t = 1, e = 0) {
        super([1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1], [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1], t, e), this.type = "TetrahedronGeometry", this.parameters = {
          radius: t,
          detail: e
        }
      }
    }
    exports.TetrahedronGeometry = exports.TetrahedronBufferGeometry = od;
    class ad extends Zp {
      constructor(t, e = {}) {
        const n = e.font;
        if (!n || !n.isFont) return console.error("THREE.TextGeometry: font parameter is not an instance of THREE.Font."), new ds;
        const r = n.generateShapes(t, e.size);
        e.depth = void 0 !== e.height ? e.height : 50, void 0 === e.bevelThickness && (e.bevelThickness = 10), void 0 === e.bevelSize && (e.bevelSize = 8), void 0 === e.bevelEnabled && (e.bevelEnabled = !1), super(r, e), this.type = "TextGeometry"
      }
    }
    exports.TextGeometry = exports.TextBufferGeometry = ad;
    class ld extends ds {
      constructor(t = 1, e = .4, n = 8, r = 6, i = 2 * Math.PI) {
        super(), this.type = "TorusGeometry", this.parameters = {
          radius: t,
          tube: e,
          radialSegments: n,
          tubularSegments: r,
          arc: i
        }, n = Math.floor(n), r = Math.floor(r);
        const s = [],
          o = [],
          a = [],
          l = [],
          c = new gr,
          h = new gr,
          u = new gr;
        for (let p = 0; p <= n; p++)
          for (let s = 0; s <= r; s++) {
            const d = s / r * i,
              m = p / n * Math.PI * 2;
            h.x = (t + e * Math.cos(m)) * Math.cos(d), h.y = (t + e * Math.cos(m)) * Math.sin(d), h.z = e * Math.sin(m), o.push(h.x, h.y, h.z), c.x = t * Math.cos(d), c.y = t * Math.sin(d), u.subVectors(h, c).normalize(), a.push(u.x, u.y, u.z), l.push(s / r), l.push(p / n)
          }
        for (let p = 1; p <= n; p++)
          for (let t = 1; t <= r; t++) {
            const e = (r + 1) * p + t - 1,
              n = (r + 1) * (p - 1) + t - 1,
              i = (r + 1) * (p - 1) + t,
              o = (r + 1) * p + t;
            s.push(e, n, o), s.push(n, i, o)
          }
        this.setIndex(s), this.setAttribute("position", new es(o, 3)), this.setAttribute("normal", new es(a, 3)), this.setAttribute("uv", new es(l, 2))
      }
    }
    exports.TorusGeometry = exports.TorusBufferGeometry = ld;
    class cd extends ds {
      constructor(t = 1, e = .4, n = 64, r = 8, i = 2, s = 3) {
        super(), this.type = "TorusKnotGeometry", this.parameters = {
          radius: t,
          tube: e,
          tubularSegments: n,
          radialSegments: r,
          p: i,
          q: s
        }, n = Math.floor(n), r = Math.floor(r);
        const o = [],
          a = [],
          l = [],
          c = [],
          h = new gr,
          u = new gr,
          p = new gr,
          d = new gr,
          m = new gr,
          f = new gr,
          g = new gr;
        for (let v = 0; v <= n; ++v) {
          const o = v / n * i * Math.PI * 2;
          x(o, i, s, t, p), x(o + .01, i, s, t, d), f.subVectors(d, p), g.addVectors(d, p), m.crossVectors(f, g), g.crossVectors(m, f), m.normalize(), g.normalize();
          for (let t = 0; t <= r; ++t) {
            const i = t / r * Math.PI * 2,
              s = -e * Math.cos(i),
              o = e * Math.sin(i);
            h.x = p.x + (s * g.x + o * m.x), h.y = p.y + (s * g.y + o * m.y), h.z = p.z + (s * g.z + o * m.z), a.push(h.x, h.y, h.z), u.subVectors(h, p).normalize(), l.push(u.x, u.y, u.z), c.push(v / n), c.push(t / r)
          }
        }
        for (let v = 1; v <= n; v++)
          for (let t = 1; t <= r; t++) {
            const e = (r + 1) * (v - 1) + (t - 1),
              n = (r + 1) * v + (t - 1),
              i = (r + 1) * v + t,
              s = (r + 1) * (v - 1) + t;
            o.push(e, n, s), o.push(n, i, s)
          }

        function x(t, e, n, r, i) {
          const s = Math.cos(t),
            o = Math.sin(t),
            a = n / e * t,
            l = Math.cos(a);
          i.x = r * (2 + l) * .5 * s, i.y = r * (2 + l) * o * .5, i.z = r * Math.sin(a) * .5
        }
        this.setIndex(o), this.setAttribute("position", new es(a, 3)), this.setAttribute("normal", new es(l, 3)), this.setAttribute("uv", new es(c, 2))
      }
    }
    exports.TorusKnotGeometry = exports.TorusKnotBufferGeometry = cd;
    class hd extends ds {
      constructor(t, e = 64, n = 1, r = 8, i = !1) {
        super(), this.type = "TubeGeometry", this.parameters = {
          path: t,
          tubularSegments: e,
          radius: n,
          radialSegments: r,
          closed: i
        };
        const s = t.computeFrenetFrames(e, i);
        this.tangents = s.tangents, this.normals = s.normals, this.binormals = s.binormals;
        const o = new gr,
          a = new gr,
          l = new sr;
        let c = new gr;
        const h = [],
          u = [],
          p = [],
          d = [];

        function m(i) {
          c = t.getPointAt(i / e, c);
          const l = s.normals[i],
            p = s.binormals[i];
          for (let t = 0; t <= r; t++) {
            const e = t / r * Math.PI * 2,
              i = Math.sin(e),
              s = -Math.cos(e);
            a.x = s * l.x + i * p.x, a.y = s * l.y + i * p.y, a.z = s * l.z + i * p.z, a.normalize(), u.push(a.x, a.y, a.z), o.x = c.x + n * a.x, o.y = c.y + n * a.y, o.z = c.z + n * a.z, h.push(o.x, o.y, o.z)
          }
        }! function() {
          for (let t = 0; t < e; t++) m(t);
          m(!1 === i ? e : 0),
            function() {
              for (let t = 0; t <= e; t++)
                for (let n = 0; n <= r; n++) l.x = t / e, l.y = n / r, p.push(l.x, l.y)
            }(),
            function() {
              for (let t = 1; t <= e; t++)
                for (let e = 1; e <= r; e++) {
                  const n = (r + 1) * (t - 1) + (e - 1),
                    i = (r + 1) * t + (e - 1),
                    s = (r + 1) * t + e,
                    o = (r + 1) * (t - 1) + e;
                  d.push(n, i, o), d.push(i, s, o)
                }
            }()
        }(), this.setIndex(d), this.setAttribute("position", new es(h, 3)), this.setAttribute("normal", new es(u, 3)), this.setAttribute("uv", new es(p, 2))
      }
      toJSON() {
        const t = ds.prototype.toJSON.call(this);
        return t.path = this.parameters.path.toJSON(), t
      }
    }
    exports.TubeGeometry = exports.TubeBufferGeometry = hd;
    class ud extends ds {
      constructor(t) {
        if (super(), this.type = "WireframeGeometry", !0 === t.isGeometry) return void console.error("THREE.WireframeGeometry no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
        const e = [],
          n = [0, 0],
          r = {},
          i = new gr;
        if (null !== t.index) {
          const s = t.attributes.position,
            o = t.index;
          let a = t.groups;
          0 === a.length && (a = [{
            start: 0,
            count: o.count,
            materialIndex: 0
          }]);
          for (let t = 0, e = a.length; t < e; ++t) {
            const e = a[t],
              i = e.start;
            for (let t = i, s = i + e.count; t < s; t += 3)
              for (let e = 0; e < 3; e++) {
                const i = o.getX(t + e),
                  s = o.getX(t + (e + 1) % 3);
                n[0] = Math.min(i, s), n[1] = Math.max(i, s);
                const a = n[0] + "," + n[1];
                void 0 === r[a] && (r[a] = {
                  index1: n[0],
                  index2: n[1]
                })
              }
          }
          for (const t in r) {
            const n = r[t];
            i.fromBufferAttribute(s, n.index1), e.push(i.x, i.y, i.z), i.fromBufferAttribute(s, n.index2), e.push(i.x, i.y, i.z)
          }
        } else {
          const n = t.attributes.position;
          for (let t = 0, r = n.count / 3; t < r; t++)
            for (let s = 0; s < 3; s++) {
              const r = 3 * t + s;
              i.fromBufferAttribute(n, r), e.push(i.x, i.y, i.z);
              const o = 3 * t + (s + 1) % 3;
              i.fromBufferAttribute(n, o), e.push(i.x, i.y, i.z)
            }
        }
        this.setAttribute("position", new es(e, 3))
      }
    }
    exports.WireframeGeometry = ud;
    var pd = Object.freeze({
      __proto__: null,
      BoxGeometry: Bs,
      BoxBufferGeometry: Bs,
      CircleGeometry: ip,
      CircleBufferGeometry: ip,
      ConeGeometry: op,
      ConeBufferGeometry: op,
      CylinderGeometry: sp,
      CylinderBufferGeometry: sp,
      DodecahedronGeometry: lp,
      DodecahedronBufferGeometry: lp,
      EdgesGeometry: dp,
      ExtrudeGeometry: Zp,
      ExtrudeBufferGeometry: Zp,
      IcosahedronGeometry: Kp,
      IcosahedronBufferGeometry: Kp,
      LatheGeometry: $p,
      LatheBufferGeometry: $p,
      OctahedronGeometry: td,
      OctahedronBufferGeometry: td,
      ParametricGeometry: ed,
      ParametricBufferGeometry: ed,
      PlaneGeometry: to,
      PlaneBufferGeometry: to,
      PolyhedronGeometry: ap,
      PolyhedronBufferGeometry: ap,
      RingGeometry: nd,
      RingBufferGeometry: nd,
      ShapeGeometry: rd,
      ShapeBufferGeometry: rd,
      SphereGeometry: sd,
      SphereBufferGeometry: sd,
      TetrahedronGeometry: od,
      TetrahedronBufferGeometry: od,
      TextGeometry: ad,
      TextBufferGeometry: ad,
      TorusGeometry: ld,
      TorusBufferGeometry: ld,
      TorusKnotGeometry: cd,
      TorusKnotBufferGeometry: cd,
      TubeGeometry: hd,
      TubeBufferGeometry: hd,
      WireframeGeometry: ud
    });
    class dd extends Ni {
      constructor(t) {
        super(), this.type = "ShadowMaterial", this.color = new ki(0), this.transparent = !0, this.setValues(t)
      }
      copy(t) {
        return super.copy(t), this.color.copy(t.color), this
      }
    }
    exports.ShadowMaterial = dd, dd.prototype.isShadowMaterial = !0;
    class md extends Hs {
      constructor(t) {
        super(t), this.type = "RawShaderMaterial"
      }
    }
    exports.RawShaderMaterial = md, md.prototype.isRawShaderMaterial = !0;
    class fd extends Ni {
      constructor(t) {
        super(), this.defines = {
          STANDARD: ""
        }, this.type = "MeshStandardMaterial", this.color = new ki(16777215), this.roughness = 1, this.metalness = 0, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new ki(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = rn, this.normalScale = new sr(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.roughnessMap = null, this.metalnessMap = null, this.alphaMap = null, this.envMap = null, this.envMapIntensity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.flatShading = !1, this.vertexTangents = !1, this.setValues(t)
      }
      copy(t) {
        return super.copy(t), this.defines = {
          STANDARD: ""
        }, this.color.copy(t.color), this.roughness = t.roughness, this.metalness = t.metalness, this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.roughnessMap = t.roughnessMap, this.metalnessMap = t.metalnessMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.envMapIntensity = t.envMapIntensity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this.flatShading = t.flatShading, this.vertexTangents = t.vertexTangents, this
      }
    }
    exports.MeshStandardMaterial = fd, fd.prototype.isMeshStandardMaterial = !0;
    class gd extends fd {
      constructor(t) {
        super(), this.defines = {
          STANDARD: "",
          PHYSICAL: ""
        }, this.type = "MeshPhysicalMaterial", this.clearcoat = 0, this.clearcoatMap = null, this.clearcoatRoughness = 0, this.clearcoatRoughnessMap = null, this.clearcoatNormalScale = new sr(1, 1), this.clearcoatNormalMap = null, this.reflectivity = .5, Object.defineProperty(this, "ior", {
          get: function() {
            return (1 + .4 * this.reflectivity) / (1 - .4 * this.reflectivity)
          },
          set: function(t) {
            this.reflectivity = On(2.5 * (t - 1) / (t + 1), 0, 1)
          }
        }), this.sheen = null, this.transmission = 0, this.transmissionMap = null, this.setValues(t)
      }
      copy(t) {
        return super.copy(t), this.defines = {
          STANDARD: "",
          PHYSICAL: ""
        }, this.clearcoat = t.clearcoat, this.clearcoatMap = t.clearcoatMap, this.clearcoatRoughness = t.clearcoatRoughness, this.clearcoatRoughnessMap = t.clearcoatRoughnessMap, this.clearcoatNormalMap = t.clearcoatNormalMap, this.clearcoatNormalScale.copy(t.clearcoatNormalScale), this.reflectivity = t.reflectivity, t.sheen ? this.sheen = (this.sheen || new ki).copy(t.sheen) : this.sheen = null, this.transmission = t.transmission, this.transmissionMap = t.transmissionMap, this
      }
    }
    exports.MeshPhysicalMaterial = gd, gd.prototype.isMeshPhysicalMaterial = !0;
    class xd extends Ni {
      constructor(t) {
        super(), this.type = "MeshPhongMaterial", this.color = new ki(16777215), this.specular = new ki(1118481), this.shininess = 30, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new ki(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = rn, this.normalScale = new sr(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = q, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.flatShading = !1, this.setValues(t)
      }
      copy(t) {
        return super.copy(t), this.color.copy(t.color), this.specular.copy(t.specular), this.shininess = t.shininess, this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.combine = t.combine, this.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this.flatShading = t.flatShading, this
      }
    }
    exports.MeshPhongMaterial = xd, xd.prototype.isMeshPhongMaterial = !0;
    class vd extends Ni {
      constructor(t) {
        super(), this.defines = {
          TOON: ""
        }, this.type = "MeshToonMaterial", this.color = new ki(16777215), this.map = null, this.gradientMap = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new ki(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = rn, this.normalScale = new sr(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(t)
      }
      copy(t) {
        return super.copy(t), this.color.copy(t.color), this.map = t.map, this.gradientMap = t.gradientMap, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.alphaMap = t.alphaMap, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this
      }
    }
    exports.MeshToonMaterial = vd, vd.prototype.isMeshToonMaterial = !0;
    class yd extends Ni {
      constructor(t) {
        super(), this.type = "MeshNormalMaterial", this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = rn, this.normalScale = new sr(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.flatShading = !1, this.setValues(t)
      }
      copy(t) {
        return super.copy(t), this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this.flatShading = t.flatShading, this
      }
    }
    exports.MeshNormalMaterial = yd, yd.prototype.isMeshNormalMaterial = !0;
    class _d extends Ni {
      constructor(t) {
        super(), this.type = "MeshLambertMaterial", this.color = new ki(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new ki(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = q, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(t)
      }
      copy(t) {
        return super.copy(t), this.color.copy(t.color), this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.combine = t.combine, this.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this
      }
    }
    exports.MeshLambertMaterial = _d, _d.prototype.isMeshLambertMaterial = !0;
    class bd extends Ni {
      constructor(t) {
        super(), this.defines = {
          MATCAP: ""
        }, this.type = "MeshMatcapMaterial", this.color = new ki(16777215), this.matcap = null, this.map = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = rn, this.normalScale = new sr(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.flatShading = !1, this.setValues(t)
      }
      copy(t) {
        return super.copy(t), this.defines = {
          MATCAP: ""
        }, this.color.copy(t.color), this.matcap = t.matcap, this.map = t.map, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.alphaMap = t.alphaMap, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this.flatShading = t.flatShading, this
      }
    }
    exports.MeshMatcapMaterial = bd, bd.prototype.isMeshMatcapMaterial = !0;
    class wd extends Fu {
      constructor(t) {
        super(), this.type = "LineDashedMaterial", this.scale = 1, this.dashSize = 3, this.gapSize = 1, this.setValues(t)
      }
      copy(t) {
        return super.copy(t), this.scale = t.scale, this.dashSize = t.dashSize, this.gapSize = t.gapSize, this
      }
    }
    exports.LineDashedMaterial = wd, wd.prototype.isLineDashedMaterial = !0;
    var Md = Object.freeze({
      __proto__: null,
      ShadowMaterial: dd,
      SpriteMaterial: nu,
      RawShaderMaterial: md,
      ShaderMaterial: Hs,
      PointsMaterial: Xu,
      MeshPhysicalMaterial: gd,
      MeshStandardMaterial: fd,
      MeshPhongMaterial: xd,
      MeshToonMaterial: vd,
      MeshNormalMaterial: yd,
      MeshLambertMaterial: _d,
      MeshDepthMaterial: Ih,
      MeshDistanceMaterial: Bh,
      MeshBasicMaterial: Vi,
      MeshMatcapMaterial: bd,
      LineDashedMaterial: wd,
      LineBasicMaterial: Fu,
      Material: Ni
    });
    const Sd = {
      arraySlice: function(t, e, n) {
        return Sd.isTypedArray(t) ? new t.constructor(t.subarray(e, void 0 !== n ? n : t.length)) : t.slice(e, n)
      },
      convertArray: function(t, e, n) {
        return !t || !n && t.constructor === e ? t : "number" == typeof e.BYTES_PER_ELEMENT ? new e(t) : Array.prototype.slice.call(t)
      },
      isTypedArray: function(t) {
        return ArrayBuffer.isView(t) && !(t instanceof DataView)
      },
      getKeyframeOrder: function(t) {
        const e = t.length,
          n = new Array(e);
        for (let r = 0; r !== e; ++r) n[r] = r;
        return n.sort(function(e, n) {
          return t[e] - t[n]
        }), n
      },
      sortedArray: function(t, e, n) {
        const r = t.length,
          i = new t.constructor(r);
        for (let s = 0, o = 0; o !== r; ++s) {
          const r = n[s] * e;
          for (let n = 0; n !== e; ++n) i[o++] = t[r + n]
        }
        return i
      },
      flattenJSON: function(t, e, n, r) {
        let i = 1,
          s = t[0];
        for (; void 0 !== s && void 0 === s[r];) s = t[i++];
        if (void 0 === s) return;
        let o = s[r];
        if (void 0 !== o)
          if (Array.isArray(o))
            do {
              void 0 !== (o = s[r]) && (e.push(s.time), n.push.apply(n, o)), s = t[i++]
            } while (void 0 !== s);
          else if (void 0 !== o.toArray)
          do {
            void 0 !== (o = s[r]) && (e.push(s.time), o.toArray(n, n.length)), s = t[i++]
          } while (void 0 !== s);
        else
          do {
            void 0 !== (o = s[r]) && (e.push(s.time), n.push(o)), s = t[i++]
          } while (void 0 !== s)
      },
      subclip: function(t, e, n, r, i = 30) {
        const s = t.clone();
        s.name = e;
        const o = [];
        for (let l = 0; l < s.tracks.length; ++l) {
          const t = s.tracks[l],
            e = t.getValueSize(),
            a = [],
            c = [];
          for (let s = 0; s < t.times.length; ++s) {
            const o = t.times[s] * i;
            if (!(o < n || o >= r)) {
              a.push(t.times[s]);
              for (let n = 0; n < e; ++n) c.push(t.values[s * e + n])
            }
          }
          0 !== a.length && (t.times = Sd.convertArray(a, t.times.constructor), t.values = Sd.convertArray(c, t.values.constructor), o.push(t))
        }
        s.tracks = o;
        let a = 1 / 0;
        for (let l = 0; l < s.tracks.length; ++l) a > s.tracks[l].times[0] && (a = s.tracks[l].times[0]);
        for (let l = 0; l < s.tracks.length; ++l) s.tracks[l].shift(-1 * a);
        return s.resetDuration(), s
      },
      makeClipAdditive: function(t, e = 0, n = t, r = 30) {
        r <= 0 && (r = 30);
        const i = n.tracks.length,
          s = e / r;
        for (let o = 0; o < i; ++o) {
          const e = n.tracks[o],
            r = e.ValueTypeName;
          if ("bool" === r || "string" === r) continue;
          const i = t.tracks.find(function(t) {
            return t.name === e.name && t.ValueTypeName === r
          });
          if (void 0 === i) continue;
          let a = 0;
          const l = e.getValueSize();
          e.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (a = l / 3);
          let c = 0;
          const h = i.getValueSize();
          i.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (c = h / 3);
          const u = e.times.length - 1;
          let p;
          if (s <= e.times[0]) {
            const t = a,
              n = l - a;
            p = Sd.arraySlice(e.values, t, n)
          } else if (s >= e.times[u]) {
            const t = u * l + a,
              n = t + l - a;
            p = Sd.arraySlice(e.values, t, n)
          } else {
            const t = e.createInterpolant(),
              n = a,
              r = l - a;
            t.evaluate(s), p = Sd.arraySlice(t.resultBuffer, n, r)
          }
          if ("quaternion" === r) {
            (new fr).fromArray(p).normalize().conjugate().toArray(p)
          }
          const d = i.times.length;
          for (let t = 0; t < d; ++t) {
            const e = t * h + c;
            if ("quaternion" === r) fr.multiplyQuaternionsFlat(i.values, e, p, 0, i.values, e);
            else {
              const t = h - 2 * c;
              for (let n = 0; n < t; ++n) i.values[e + n] -= p[n]
            }
          }
        }
        return t.blendMode = Ve, t
      }
    };
    exports.AnimationUtils = Sd;
    class Td {
      constructor(t, e, n, r) {
        this.parameterPositions = t, this._cachedIndex = 0, this.resultBuffer = void 0 !== r ? r : new e.constructor(n), this.sampleValues = e, this.valueSize = n, this.settings = null, this.DefaultSettings_ = {}
      }
      evaluate(t) {
        const e = this.parameterPositions;
        let n = this._cachedIndex,
          r = e[n],
          i = e[n - 1];
        t: {
          e: {
            let s;n: {
              r: if (!(t < r)) {
                for (let s = n + 2;;) {
                  if (void 0 === r) {
                    if (t < i) break r;
                    return n = e.length, this._cachedIndex = n, this.afterEnd_(n - 1, t, i)
                  }
                  if (n === s) break;
                  if (i = r, t < (r = e[++n])) break e
                }
                s = e.length;
                break n
              }if (t >= i) break t; {
                const o = e[1];
                t < o && (n = 2, i = o);
                for (let s = n - 2;;) {
                  if (void 0 === i) return this._cachedIndex = 0, this.beforeStart_(0, t, r);
                  if (n === s) break;
                  if (r = i, t >= (i = e[--n - 1])) break e
                }
                s = n, n = 0
              }
            }
            for (; n < s;) {
              const r = n + s >>> 1;
              t < e[r] ? s = r : n = r + 1
            }
            if (r = e[n], void 0 === (i = e[n - 1])) return this._cachedIndex = 0,
            this.beforeStart_(0, t, r);
            if (void 0 === r) return n = e.length,
            this._cachedIndex = n,
            this.afterEnd_(n - 1, i, t)
          }
          this._cachedIndex = n,
          this.intervalChanged_(n, i, r)
        }
        return this.interpolate_(n, i, t, r)
      }
      getSettings_() {
        return this.settings || this.DefaultSettings_
      }
      copySampleValue_(t) {
        const e = this.resultBuffer,
          n = this.sampleValues,
          r = this.valueSize,
          i = t * r;
        for (let s = 0; s !== r; ++s) e[s] = n[i + s];
        return e
      }
      interpolate_() {
        throw new Error("call to abstract method")
      }
      intervalChanged_() {}
    }
    exports.Interpolant = Td, Td.prototype.beforeStart_ = Td.prototype.copySampleValue_, Td.prototype.afterEnd_ = Td.prototype.copySampleValue_;
    class Ed extends Td {
      constructor(t, e, n, r) {
        super(t, e, n, r), this._weightPrev = -0, this._offsetPrev = -0, this._weightNext = -0, this._offsetNext = -0, this.DefaultSettings_ = {
          endingStart: Oe,
          endingEnd: Oe
        }
      }
      intervalChanged_(t, e, n) {
        const r = this.parameterPositions;
        let i = t - 2,
          s = t + 1,
          o = r[i],
          a = r[s];
        if (void 0 === o) switch (this.getSettings_().endingStart) {
          case He:
            i = t, o = 2 * e - n;
            break;
          case Ue:
            o = e + r[i = r.length - 2] - r[i + 1];
            break;
          default:
            i = t, o = n
        }
        if (void 0 === a) switch (this.getSettings_().endingEnd) {
          case He:
            s = t, a = 2 * n - e;
            break;
          case Ue:
            s = 1, a = n + r[1] - r[0];
            break;
          default:
            s = t - 1, a = e
        }
        const l = .5 * (n - e),
          c = this.valueSize;
        this._weightPrev = l / (e - o), this._weightNext = l / (a - n), this._offsetPrev = i * c, this._offsetNext = s * c
      }
      interpolate_(t, e, n, r) {
        const i = this.resultBuffer,
          s = this.sampleValues,
          o = this.valueSize,
          a = t * o,
          l = a - o,
          c = this._offsetPrev,
          h = this._offsetNext,
          u = this._weightPrev,
          p = this._weightNext,
          d = (n - e) / (r - e),
          m = d * d,
          f = m * d,
          g = -u * f + 2 * u * m - u * d,
          x = (1 + u) * f + (-1.5 - 2 * u) * m + (-.5 + u) * d + 1,
          v = (-1 - p) * f + (1.5 + p) * m + .5 * d,
          y = p * f - p * m;
        for (let _ = 0; _ !== o; ++_) i[_] = g * s[c + _] + x * s[l + _] + v * s[a + _] + y * s[h + _];
        return i
      }
    }
    exports.CubicInterpolant = Ed;
    class Ad extends Td {
      constructor(t, e, n, r) {
        super(t, e, n, r)
      }
      interpolate_(t, e, n, r) {
        const i = this.resultBuffer,
          s = this.sampleValues,
          o = this.valueSize,
          a = t * o,
          l = a - o,
          c = (n - e) / (r - e),
          h = 1 - c;
        for (let u = 0; u !== o; ++u) i[u] = s[l + u] * h + s[a + u] * c;
        return i
      }
    }
    exports.LinearInterpolant = Ad;
    class Ld extends Td {
      constructor(t, e, n, r) {
        super(t, e, n, r)
      }
      interpolate_(t) {
        return this.copySampleValue_(t - 1)
      }
    }
    exports.DiscreteInterpolant = Ld;
    class Rd {
      constructor(t, e, n, r) {
        if (void 0 === t) throw new Error("THREE.KeyframeTrack: track name is undefined");
        if (void 0 === e || 0 === e.length) throw new Error("THREE.KeyframeTrack: no keyframes in track named " + t);
        this.name = t, this.times = Sd.convertArray(e, this.TimeBufferType), this.values = Sd.convertArray(n, this.ValueBufferType), this.setInterpolation(r || this.DefaultInterpolation)
      }
      static toJSON(t) {
        const e = t.constructor;
        let n;
        if (e.toJSON !== this.toJSON) n = e.toJSON(t);
        else {
          n = {
            name: t.name,
            times: Sd.convertArray(t.times, Array),
            values: Sd.convertArray(t.values, Array)
          };
          const e = t.getInterpolation();
          e !== t.DefaultInterpolation && (n.interpolation = e)
        }
        return n.type = t.ValueTypeName, n
      }
      InterpolantFactoryMethodDiscrete(t) {
        return new Ld(this.times, this.values, this.getValueSize(), t)
      }
      InterpolantFactoryMethodLinear(t) {
        return new Ad(this.times, this.values, this.getValueSize(), t)
      }
      InterpolantFactoryMethodSmooth(t) {
        return new Ed(this.times, this.values, this.getValueSize(), t)
      }
      setInterpolation(t) {
        let e;
        switch (t) {
          case Fe:
            e = this.InterpolantFactoryMethodDiscrete;
            break;
          case ze:
            e = this.InterpolantFactoryMethodLinear;
            break;
          case Ge:
            e = this.InterpolantFactoryMethodSmooth
        }
        if (void 0 === e) {
          const e = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
          if (void 0 === this.createInterpolant) {
            if (t === this.DefaultInterpolation) throw new Error(e);
            this.setInterpolation(this.DefaultInterpolation)
          }
          return console.warn("THREE.KeyframeTrack:", e), this
        }
        return this.createInterpolant = e, this
      }
      getInterpolation() {
        switch (this.createInterpolant) {
          case this.InterpolantFactoryMethodDiscrete:
            return Fe;
          case this.InterpolantFactoryMethodLinear:
            return ze;
          case this.InterpolantFactoryMethodSmooth:
            return Ge
        }
      }
      getValueSize() {
        return this.values.length / this.times.length
      }
      shift(t) {
        if (0 !== t) {
          const e = this.times;
          for (let n = 0, r = e.length; n !== r; ++n) e[n] += t
        }
        return this
      }
      scale(t) {
        if (1 !== t) {
          const e = this.times;
          for (let n = 0, r = e.length; n !== r; ++n) e[n] *= t
        }
        return this
      }
      trim(t, e) {
        const n = this.times,
          r = n.length;
        let i = 0,
          s = r - 1;
        for (; i !== r && n[i] < t;) ++i;
        for (; - 1 !== s && n[s] > e;) --s;
        if (++s, 0 !== i || s !== r) {
          i >= s && (i = (s = Math.max(s, 1)) - 1);
          const t = this.getValueSize();
          this.times = Sd.arraySlice(n, i, s), this.values = Sd.arraySlice(this.values, i * t, s * t)
        }
        return this
      }
      validate() {
        let t = !0;
        const e = this.getValueSize();
        e - Math.floor(e) != 0 && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this), t = !1);
        const n = this.times,
          r = this.values,
          i = n.length;
        0 === i && (console.error("THREE.KeyframeTrack: Track is empty.", this), t = !1);
        let s = null;
        for (let o = 0; o !== i; o++) {
          const e = n[o];
          if ("number" == typeof e && isNaN(e)) {
            console.error("THREE.KeyframeTrack: Time is not a valid number.", this, o, e), t = !1;
            break
          }
          if (null !== s && s > e) {
            console.error("THREE.KeyframeTrack: Out of order keys.", this, o, e, s), t = !1;
            break
          }
          s = e
        }
        if (void 0 !== r && Sd.isTypedArray(r))
          for (let o = 0, a = r.length; o !== a; ++o) {
            const e = r[o];
            if (isNaN(e)) {
              console.error("THREE.KeyframeTrack: Value is not a valid number.", this, o, e), t = !1;
              break
            }
          }
        return t
      }
      optimize() {
        const t = Sd.arraySlice(this.times),
          e = Sd.arraySlice(this.values),
          n = this.getValueSize(),
          r = this.getInterpolation() === Ge,
          i = t.length - 1;
        let s = 1;
        for (let o = 1; o < i; ++o) {
          let i = !1;
          const a = t[o];
          if (a !== t[o + 1] && (1 !== o || a !== t[0]))
            if (r) i = !0;
            else {
              const t = o * n,
                r = t - n,
                s = t + n;
              for (let o = 0; o !== n; ++o) {
                const n = e[t + o];
                if (n !== e[r + o] || n !== e[s + o]) {
                  i = !0;
                  break
                }
              }
            } if (i) {
            if (o !== s) {
              t[s] = t[o];
              const r = o * n,
                i = s * n;
              for (let t = 0; t !== n; ++t) e[i + t] = e[r + t]
            }++s
          }
        }
        if (i > 0) {
          t[s] = t[i];
          for (let t = i * n, r = s * n, o = 0; o !== n; ++o) e[r + o] = e[t + o];
          ++s
        }
        return s !== t.length ? (this.times = Sd.arraySlice(t, 0, s), this.values = Sd.arraySlice(e, 0, s * n)) : (this.times = t, this.values = e), this
      }
      clone() {
        const t = Sd.arraySlice(this.times, 0),
          e = Sd.arraySlice(this.values, 0),
          n = new(0, this.constructor)(this.name, t, e);
        return n.createInterpolant = this.createInterpolant, n
      }
    }
    exports.KeyframeTrack = Rd, Rd.prototype.TimeBufferType = Float32Array, Rd.prototype.ValueBufferType = Float32Array, Rd.prototype.DefaultInterpolation = ze;
    class Cd extends Rd {}
    exports.BooleanKeyframeTrack = Cd, Cd.prototype.ValueTypeName = "bool", Cd.prototype.ValueBufferType = Array, Cd.prototype.DefaultInterpolation = Fe, Cd.prototype.InterpolantFactoryMethodLinear = void 0, Cd.prototype.InterpolantFactoryMethodSmooth = void 0;
    class Pd extends Rd {}
    exports.ColorKeyframeTrack = Pd, Pd.prototype.ValueTypeName = "color";
    class Dd extends Rd {}
    exports.NumberKeyframeTrack = Dd, Dd.prototype.ValueTypeName = "number";
    class Id extends Td {
      constructor(t, e, n, r) {
        super(t, e, n, r)
      }
      interpolate_(t, e, n, r) {
        const i = this.resultBuffer,
          s = this.sampleValues,
          o = this.valueSize,
          a = (n - e) / (r - e);
        let l = t * o;
        for (let c = l + o; l !== c; l += 4) fr.slerpFlat(i, 0, s, l - o, s, l, a);
        return i
      }
    }
    exports.QuaternionLinearInterpolant = Id;
    class Bd extends Rd {
      InterpolantFactoryMethodLinear(t) {
        return new Id(this.times, this.values, this.getValueSize(), t)
      }
    }
    exports.QuaternionKeyframeTrack = Bd, Bd.prototype.ValueTypeName = "quaternion", Bd.prototype.DefaultInterpolation = ze, Bd.prototype.InterpolantFactoryMethodSmooth = void 0;
    class Nd extends Rd {}
    exports.StringKeyframeTrack = Nd, Nd.prototype.ValueTypeName = "string", Nd.prototype.ValueBufferType = Array, Nd.prototype.DefaultInterpolation = Fe, Nd.prototype.InterpolantFactoryMethodLinear = void 0, Nd.prototype.InterpolantFactoryMethodSmooth = void 0;
    class Fd extends Rd {}
    exports.VectorKeyframeTrack = Fd, Fd.prototype.ValueTypeName = "vector";
    class zd {
      constructor(t, e = -1, n, r = ke) {
        this.name = t, this.tracks = n, this.duration = e, this.blendMode = r, this.uuid = Gn(), this.duration < 0 && this.resetDuration()
      }
      static parse(t) {
        const e = [],
          n = t.tracks,
          r = 1 / (t.fps || 1);
        for (let s = 0, o = n.length; s !== o; ++s) e.push(Od(n[s]).scale(r));
        const i = new this(t.name, t.duration, e, t.blendMode);
        return i.uuid = t.uuid, i
      }
      static toJSON(t) {
        const e = [],
          n = t.tracks,
          r = {
            name: t.name,
            duration: t.duration,
            tracks: e,
            uuid: t.uuid,
            blendMode: t.blendMode
          };
        for (let i = 0, s = n.length; i !== s; ++i) e.push(Rd.toJSON(n[i]));
        return r
      }
      static CreateFromMorphTargetSequence(t, e, n, r) {
        const i = e.length,
          s = [];
        for (let o = 0; o < i; o++) {
          let t = [],
            a = [];
          t.push((o + i - 1) % i, o, (o + 1) % i), a.push(0, 1, 0);
          const l = Sd.getKeyframeOrder(t);
          t = Sd.sortedArray(t, 1, l), a = Sd.sortedArray(a, 1, l), r || 0 !== t[0] || (t.push(i), a.push(a[0])), s.push(new Dd(".morphTargetInfluences[" + e[o].name + "]", t, a).scale(1 / n))
        }
        return new this(t, -1, s)
      }
      static findByName(t, e) {
        let n = t;
        if (!Array.isArray(t)) {
          const e = t;
          n = e.geometry && e.geometry.animations || e.animations
        }
        for (let r = 0; r < n.length; r++)
          if (n[r].name === e) return n[r];
        return null
      }
      static CreateClipsFromMorphTargetSequences(t, e, n) {
        const r = {},
          i = /^([\w-]*?)([\d]+)$/;
        for (let o = 0, a = t.length; o < a; o++) {
          const e = t[o],
            n = e.name.match(i);
          if (n && n.length > 1) {
            const t = n[1];
            let i = r[t];
            i || (r[t] = i = []), i.push(e)
          }
        }
        const s = [];
        for (const o in r) s.push(this.CreateFromMorphTargetSequence(o, r[o], e, n));
        return s
      }
      static parseAnimation(t, e) {
        if (!t) return console.error("THREE.AnimationClip: No animation in JSONLoader data."), null;
        const n = function(t, e, n, r, i) {
            if (0 !== n.length) {
              const s = [],
                o = [];
              Sd.flattenJSON(n, s, o, r), 0 !== s.length && i.push(new t(e, s, o))
            }
          },
          r = [],
          i = t.name || "default",
          s = t.fps || 30,
          o = t.blendMode;
        let a = t.length || -1;
        const l = t.hierarchy || [];
        for (let c = 0; c < l.length; c++) {
          const t = l[c].keys;
          if (t && 0 !== t.length)
            if (t[0].morphTargets) {
              const e = {};
              let n;
              for (n = 0; n < t.length; n++)
                if (t[n].morphTargets)
                  for (let r = 0; r < t[n].morphTargets.length; r++) e[t[n].morphTargets[r]] = -1;
              for (const i in e) {
                const e = [],
                  s = [];
                for (let r = 0; r !== t[n].morphTargets.length; ++r) {
                  const r = t[n];
                  e.push(r.time), s.push(r.morphTarget === i ? 1 : 0)
                }
                r.push(new Dd(".morphTargetInfluence[" + i + "]", e, s))
              }
              a = e.length * (s || 1)
            } else {
              const i = ".bones[" + e[c].name + "]";
              n(Fd, i + ".position", t, "pos", r), n(Bd, i + ".quaternion", t, "rot", r), n(Fd, i + ".scale", t, "scl", r)
            }
        }
        return 0 === r.length ? null : new this(i, a, r, o)
      }
      resetDuration() {
        let t = 0;
        for (let e = 0, n = this.tracks.length; e !== n; ++e) {
          const n = this.tracks[e];
          t = Math.max(t, n.times[n.times.length - 1])
        }
        return this.duration = t, this
      }
      trim() {
        for (let t = 0; t < this.tracks.length; t++) this.tracks[t].trim(0, this.duration);
        return this
      }
      validate() {
        let t = !0;
        for (let e = 0; e < this.tracks.length; e++) t = t && this.tracks[e].validate();
        return t
      }
      optimize() {
        for (let t = 0; t < this.tracks.length; t++) this.tracks[t].optimize();
        return this
      }
      clone() {
        const t = [];
        for (let e = 0; e < this.tracks.length; e++) t.push(this.tracks[e].clone());
        return new this.constructor(this.name, this.duration, t, this.blendMode)
      }
      toJSON() {
        return this.constructor.toJSON(this)
      }
    }

    function Gd(t) {
      switch (t.toLowerCase()) {
        case "scalar":
        case "double":
        case "float":
        case "number":
        case "integer":
          return Dd;
        case "vector":
        case "vector2":
        case "vector3":
        case "vector4":
          return Fd;
        case "color":
          return Pd;
        case "quaternion":
          return Bd;
        case "bool":
        case "boolean":
          return Cd;
        case "string":
          return Nd
      }
      throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + t)
    }

    function Od(t) {
      if (void 0 === t.type) throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
      const e = Gd(t.type);
      if (void 0 === t.times) {
        const e = [],
          n = [];
        Sd.flattenJSON(t.keys, e, n, "value"), t.times = e, t.values = n
      }
      return void 0 !== e.parse ? e.parse(t) : new e(t.name, t.times, t.values, t.interpolation)
    }
    exports.AnimationClip = zd;
    const Hd = {
      enabled: !1,
      files: {},
      add: function(t, e) {
        !1 !== this.enabled && (this.files[t] = e)
      },
      get: function(t) {
        if (!1 !== this.enabled) return this.files[t]
      },
      remove: function(t) {
        delete this.files[t]
      },
      clear: function() {
        this.files = {}
      }
    };
    exports.Cache = Hd;
    class Ud {
      constructor(t, e, n) {
        const r = this;
        let i = !1,
          s = 0,
          o = 0,
          a = void 0;
        const l = [];
        this.onStart = void 0, this.onLoad = t, this.onProgress = e, this.onError = n, this.itemStart = function(t) {
          o++, !1 === i && void 0 !== r.onStart && r.onStart(t, s, o), i = !0
        }, this.itemEnd = function(t) {
          s++, void 0 !== r.onProgress && r.onProgress(t, s, o), s === o && (i = !1, void 0 !== r.onLoad && r.onLoad())
        }, this.itemError = function(t) {
          void 0 !== r.onError && r.onError(t)
        }, this.resolveURL = function(t) {
          return a ? a(t) : t
        }, this.setURLModifier = function(t) {
          return a = t, this
        }, this.addHandler = function(t, e) {
          return l.push(t, e), this
        }, this.removeHandler = function(t) {
          const e = l.indexOf(t);
          return -1 !== e && l.splice(e, 2), this
        }, this.getHandler = function(t) {
          for (let e = 0, n = l.length; e < n; e += 2) {
            const n = l[e],
              r = l[e + 1];
            if (n.global && (n.lastIndex = 0), n.test(t)) return r
          }
          return null
        }
      }
    }
    exports.LoadingManager = Ud;
    const kd = new Ud;
    exports.DefaultLoadingManager = kd;
    class Vd {
      constructor(t) {
        this.manager = void 0 !== t ? t : kd, this.crossOrigin = "anonymous", this.withCredentials = !1, this.path = "", this.resourcePath = "", this.requestHeader = {}
      }
      load() {}
      loadAsync(t, e) {
        const n = this;
        return new Promise(function(r, i) {
          n.load(t, r, e, i)
        })
      }
      parse() {}
      setCrossOrigin(t) {
        return this.crossOrigin = t, this
      }
      setWithCredentials(t) {
        return this.withCredentials = t, this
      }
      setPath(t) {
        return this.path = t, this
      }
      setResourcePath(t) {
        return this.resourcePath = t, this
      }
      setRequestHeader(t) {
        return this.requestHeader = t, this
      }
    }
    exports.Loader = Vd;
    const Wd = {};
    class jd extends Vd {
      constructor(t) {
        super(t)
      }
      load(t, e, n, r) {
        void 0 === t && (t = ""), void 0 !== this.path && (t = this.path + t), t = this.manager.resolveURL(t);
        const i = this,
          s = Hd.get(t);
        if (void 0 !== s) return i.manager.itemStart(t), setTimeout(function() {
          e && e(s), i.manager.itemEnd(t)
        }, 0), s;
        if (void 0 !== Wd[t]) return void Wd[t].push({
          onLoad: e,
          onProgress: n,
          onError: r
        });
        const o = t.match(/^data:(.*?)(;base64)?,(.*)$/);
        let a;
        if (o) {
          const n = o[1],
            s = !!o[2];
          let a = o[3];
          a = decodeURIComponent(a), s && (a = atob(a));
          try {
            let s;
            const o = (this.responseType || "").toLowerCase();
            switch (o) {
              case "arraybuffer":
              case "blob":
                const t = new Uint8Array(a.length);
                for (let n = 0; n < a.length; n++) t[n] = a.charCodeAt(n);
                s = "blob" === o ? new Blob([t.buffer], {
                  type: n
                }) : t.buffer;
                break;
              case "document":
                const e = new DOMParser;
                s = e.parseFromString(a, n);
                break;
              case "json":
                s = JSON.parse(a);
                break;
              default:
                s = a
            }
            setTimeout(function() {
              e && e(s), i.manager.itemEnd(t)
            }, 0)
          } catch (l) {
            setTimeout(function() {
              r && r(l), i.manager.itemError(t), i.manager.itemEnd(t)
            }, 0)
          }
        } else {
          Wd[t] = [], Wd[t].push({
            onLoad: e,
            onProgress: n,
            onError: r
          }), (a = new XMLHttpRequest).open("GET", t, !0), a.addEventListener("load", function(e) {
            const n = this.response,
              r = Wd[t];
            if (delete Wd[t], 200 === this.status || 0 === this.status) {
              0 === this.status && console.warn("THREE.FileLoader: HTTP Status 0 received."), Hd.add(t, n);
              for (let t = 0, e = r.length; t < e; t++) {
                const e = r[t];
                e.onLoad && e.onLoad(n)
              }
              i.manager.itemEnd(t)
            } else {
              for (let t = 0, n = r.length; t < n; t++) {
                const n = r[t];
                n.onError && n.onError(e)
              }
              i.manager.itemError(t), i.manager.itemEnd(t)
            }
          }, !1), a.addEventListener("progress", function(e) {
            const n = Wd[t];
            for (let t = 0, r = n.length; t < r; t++) {
              const r = n[t];
              r.onProgress && r.onProgress(e)
            }
          }, !1), a.addEventListener("error", function(e) {
            const n = Wd[t];
            delete Wd[t];
            for (let t = 0, r = n.length; t < r; t++) {
              const r = n[t];
              r.onError && r.onError(e)
            }
            i.manager.itemError(t), i.manager.itemEnd(t)
          }, !1), a.addEventListener("abort", function(e) {
            const n = Wd[t];
            delete Wd[t];
            for (let t = 0, r = n.length; t < r; t++) {
              const r = n[t];
              r.onError && r.onError(e)
            }
            i.manager.itemError(t), i.manager.itemEnd(t)
          }, !1), void 0 !== this.responseType && (a.responseType = this.responseType), void 0 !== this.withCredentials && (a.withCredentials = this.withCredentials), a.overrideMimeType && a.overrideMimeType(void 0 !== this.mimeType ? this.mimeType : "text/plain");
          for (const t in this.requestHeader) a.setRequestHeader(t, this.requestHeader[t]);
          a.send(null)
        }
        return i.manager.itemStart(t), a
      }
      setResponseType(t) {
        return this.responseType = t, this
      }
      setMimeType(t) {
        return this.mimeType = t, this
      }
    }
    exports.FileLoader = jd;
    class qd extends Vd {
      constructor(t) {
        super(t)
      }
      load(t, e, n, r) {
        const i = this,
          s = new jd(this.manager);
        s.setPath(this.path), s.setRequestHeader(this.requestHeader), s.setWithCredentials(this.withCredentials), s.load(t, function(n) {
          try {
            e(i.parse(JSON.parse(n)))
          } catch (s) {
            r ? r(s) : console.error(s), i.manager.itemError(t)
          }
        }, n, r)
      }
      parse(t) {
        const e = [];
        for (let n = 0; n < t.length; n++) {
          const r = zd.parse(t[n]);
          e.push(r)
        }
        return e
      }
    }
    exports.AnimationLoader = qd;
    class Xd extends Vd {
      constructor(t) {
        super(t)
      }
      load(t, e, n, r) {
        const i = this,
          s = [],
          o = new ep,
          a = new jd(this.manager);
        a.setPath(this.path), a.setResponseType("arraybuffer"), a.setRequestHeader(this.requestHeader), a.setWithCredentials(i.withCredentials);
        let l = 0;

        function c(c) {
          a.load(t[c], function(t) {
            const n = i.parse(t, !0);
            s[c] = {
              width: n.width,
              height: n.height,
              format: n.format,
              mipmaps: n.mipmaps
            }, 6 === (l += 1) && (1 === n.mipmapCount && (o.minFilter = gt), o.image = s, o.format = n.format, o.needsUpdate = !0, e && e(o))
          }, n, r)
        }
        if (Array.isArray(t))
          for (let h = 0, u = t.length; h < u; ++h) c(h);
        else a.load(t, function(t) {
          const n = i.parse(t, !0);
          if (n.isCubemap) {
            const t = n.mipmaps.length / n.mipmapCount;
            for (let e = 0; e < t; e++) {
              s[e] = {
                mipmaps: []
              };
              for (let t = 0; t < n.mipmapCount; t++) s[e].mipmaps.push(n.mipmaps[e * n.mipmapCount + t]), s[e].format = n.format, s[e].width = n.width, s[e].height = n.height
            }
            o.image = s
          } else o.image.width = n.width, o.image.height = n.height, o.mipmaps = n.mipmaps;
          1 === n.mipmapCount && (o.minFilter = gt), o.format = n.format, o.needsUpdate = !0, e && e(o)
        }, n, r);
        return o
      }
    }
    exports.CompressedTextureLoader = Xd;
    class Yd extends Vd {
      constructor(t) {
        super(t)
      }
      load(t, e, n, r) {
        void 0 !== this.path && (t = this.path + t), t = this.manager.resolveURL(t);
        const i = this,
          s = Hd.get(t);
        if (void 0 !== s) return i.manager.itemStart(t), setTimeout(function() {
          e && e(s), i.manager.itemEnd(t)
        }, 0), s;
        const o = document.createElementNS("http://www.w3.org/1999/xhtml", "img");

        function a() {
          o.removeEventListener("load", a, !1), o.removeEventListener("error", l, !1), Hd.add(t, this), e && e(this), i.manager.itemEnd(t)
        }

        function l(e) {
          o.removeEventListener("load", a, !1), o.removeEventListener("error", l, !1), r && r(e), i.manager.itemError(t), i.manager.itemEnd(t)
        }
        return o.addEventListener("load", a, !1), o.addEventListener("error", l, !1), "data:" !== t.substr(0, 5) && void 0 !== this.crossOrigin && (o.crossOrigin = this.crossOrigin), i.manager.itemStart(t), o.src = t, o
      }
    }
    exports.ImageLoader = Yd;
    class Zd extends Vd {
      constructor(t) {
        super(t)
      }
      load(t, e, n, r) {
        const i = new qs,
          s = new Yd(this.manager);
        s.setCrossOrigin(this.crossOrigin), s.setPath(this.path);
        let o = 0;

        function a(n) {
          s.load(t[n], function(t) {
            i.images[n] = t, 6 === ++o && (i.needsUpdate = !0, e && e(i))
          }, void 0, r)
        }
        for (let l = 0; l < t.length; ++l) a(l);
        return i
      }
    }
    exports.CubeTextureLoader = Zd;
    class Jd extends Vd {
      constructor(t) {
        super(t)
      }
      load(t, e, n, r) {
        const i = this,
          s = new Ys,
          o = new jd(this.manager);
        return o.setResponseType("arraybuffer"), o.setRequestHeader(this.requestHeader), o.setPath(this.path), o.setWithCredentials(i.withCredentials), o.load(t, function(t) {
          const n = i.parse(t);
          n && (void 0 !== n.image ? s.image = n.image : void 0 !== n.data && (s.image.width = n.width, s.image.height = n.height, s.image.data = n.data), s.wrapS = void 0 !== n.wrapS ? n.wrapS : ct, s.wrapT = void 0 !== n.wrapT ? n.wrapT : ct, s.magFilter = void 0 !== n.magFilter ? n.magFilter : gt, s.minFilter = void 0 !== n.minFilter ? n.minFilter : gt, s.anisotropy = void 0 !== n.anisotropy ? n.anisotropy : 1, void 0 !== n.encoding && (s.encoding = n.encoding), void 0 !== n.flipY && (s.flipY = n.flipY), void 0 !== n.format && (s.format = n.format), void 0 !== n.type && (s.type = n.type), void 0 !== n.mipmaps && (s.mipmaps = n.mipmaps, s.minFilter = yt), 1 === n.mipmapCount && (s.minFilter = gt), void 0 !== n.generateMipmaps && (s.generateMipmaps = n.generateMipmaps), s.needsUpdate = !0, e && e(s, n))
        }, n, r), s
      }
    }
    exports.DataTextureLoader = Jd;
    class Qd extends Vd {
      constructor(t) {
        super(t)
      }
      load(t, e, n, r) {
        const i = new hr,
          s = new Yd(this.manager);
        return s.setCrossOrigin(this.crossOrigin), s.setPath(this.path), s.load(t, function(n) {
          i.image = n;
          const r = t.search(/\.jpe?g($|\?)/i) > 0 || 0 === t.search(/^data\:image\/jpeg/);
          i.format = r ? Bt : Nt, i.needsUpdate = !0, void 0 !== e && e(i)
        }, n, r), i
      }
    }
    exports.TextureLoader = Qd;
    class Kd {
      constructor() {
        this.type = "Curve", this.arcLengthDivisions = 200
      }
      getPoint() {
        return console.warn("THREE.Curve: .getPoint() not implemented."), null
      }
      getPointAt(t, e) {
        const n = this.getUtoTmapping(t);
        return this.getPoint(n, e)
      }
      getPoints(t = 5) {
        const e = [];
        for (let n = 0; n <= t; n++) e.push(this.getPoint(n / t));
        return e
      }
      getSpacedPoints(t = 5) {
        const e = [];
        for (let n = 0; n <= t; n++) e.push(this.getPointAt(n / t));
        return e
      }
      getLength() {
        const t = this.getLengths();
        return t[t.length - 1]
      }
      getLengths(t = this.arcLengthDivisions) {
        if (this.cacheArcLengths && this.cacheArcLengths.length === t + 1 && !this.needsUpdate) return this.cacheArcLengths;
        this.needsUpdate = !1;
        const e = [];
        let n, r = this.getPoint(0),
          i = 0;
        e.push(0);
        for (let s = 1; s <= t; s++) i += (n = this.getPoint(s / t)).distanceTo(r), e.push(i), r = n;
        return this.cacheArcLengths = e, e
      }
      updateArcLengths() {
        this.needsUpdate = !0, this.getLengths()
      }
      getUtoTmapping(t, e) {
        const n = this.getLengths();
        let r = 0;
        const i = n.length;
        let s;
        s = e || t * n[i - 1];
        let o, a = 0,
          l = i - 1;
        for (; a <= l;)
          if ((o = n[r = Math.floor(a + (l - a) / 2)] - s) < 0) a = r + 1;
          else {
            if (!(o > 0)) {
              l = r;
              break
            }
            l = r - 1
          } if (n[r = l] === s) return r / (i - 1);
        const c = n[r];
        return (r + (s - c) / (n[r + 1] - c)) / (i - 1)
      }
      getTangent(t, e) {
        let n = t - 1e-4,
          r = t + 1e-4;
        n < 0 && (n = 0), r > 1 && (r = 1);
        const i = this.getPoint(n),
          s = this.getPoint(r),
          o = e || (i.isVector2 ? new sr : new gr);
        return o.copy(s).sub(i).normalize(), o
      }
      getTangentAt(t, e) {
        const n = this.getUtoTmapping(t);
        return this.getTangent(n, e)
      }
      computeFrenetFrames(t, e) {
        const n = new gr,
          r = [],
          i = [],
          s = [],
          o = new gr,
          a = new Xr;
        for (let p = 0; p <= t; p++) {
          const e = p / t;
          r[p] = this.getTangentAt(e, new gr), r[p].normalize()
        }
        i[0] = new gr, s[0] = new gr;
        let l = Number.MAX_VALUE;
        const c = Math.abs(r[0].x),
          h = Math.abs(r[0].y),
          u = Math.abs(r[0].z);
        c <= l && (l = c, n.set(1, 0, 0)), h <= l && (l = h, n.set(0, 1, 0)), u <= l && n.set(0, 0, 1), o.crossVectors(r[0], n).normalize(), i[0].crossVectors(r[0], o), s[0].crossVectors(r[0], i[0]);
        for (let p = 1; p <= t; p++) {
          if (i[p] = i[p - 1].clone(), s[p] = s[p - 1].clone(), o.crossVectors(r[p - 1], r[p]), o.length() > Number.EPSILON) {
            o.normalize();
            const t = Math.acos(On(r[p - 1].dot(r[p]), -1, 1));
            i[p].applyMatrix4(a.makeRotationAxis(o, t))
          }
          s[p].crossVectors(r[p], i[p])
        }
        if (!0 === e) {
          let e = Math.acos(On(i[0].dot(i[t]), -1, 1));
          e /= t, r[0].dot(o.crossVectors(i[0], i[t])) > 0 && (e = -e);
          for (let n = 1; n <= t; n++) i[n].applyMatrix4(a.makeRotationAxis(r[n], e * n)), s[n].crossVectors(r[n], i[n])
        }
        return {
          tangents: r,
          normals: i,
          binormals: s
        }
      }
      clone() {
        return (new this.constructor).copy(this)
      }
      copy(t) {
        return this.arcLengthDivisions = t.arcLengthDivisions, this
      }
      toJSON() {
        const t = {
          metadata: {
            version: 4.5,
            type: "Curve",
            generator: "Curve.toJSON"
          }
        };
        return t.arcLengthDivisions = this.arcLengthDivisions, t.type = this.type, t
      }
      fromJSON(t) {
        return this.arcLengthDivisions = t.arcLengthDivisions, this
      }
    }
    exports.Curve = Kd;
    class $d extends Kd {
      constructor(t = 0, e = 0, n = 1, r = 1, i = 0, s = 2 * Math.PI, o = !1, a = 0) {
        super(), this.type = "EllipseCurve", this.aX = t, this.aY = e, this.xRadius = n, this.yRadius = r, this.aStartAngle = i, this.aEndAngle = s, this.aClockwise = o, this.aRotation = a
      }
      getPoint(t, e) {
        const n = e || new sr,
          r = 2 * Math.PI;
        let i = this.aEndAngle - this.aStartAngle;
        const s = Math.abs(i) < Number.EPSILON;
        for (; i < 0;) i += r;
        for (; i > r;) i -= r;
        i < Number.EPSILON && (i = s ? 0 : r), !0 !== this.aClockwise || s || (i === r ? i = -r : i -= r);
        const o = this.aStartAngle + t * i;
        let a = this.aX + this.xRadius * Math.cos(o),
          l = this.aY + this.yRadius * Math.sin(o);
        if (0 !== this.aRotation) {
          const t = Math.cos(this.aRotation),
            e = Math.sin(this.aRotation),
            n = a - this.aX,
            r = l - this.aY;
          a = n * t - r * e + this.aX, l = n * e + r * t + this.aY
        }
        return n.set(a, l)
      }
      copy(t) {
        return super.copy(t), this.aX = t.aX, this.aY = t.aY, this.xRadius = t.xRadius, this.yRadius = t.yRadius, this.aStartAngle = t.aStartAngle, this.aEndAngle = t.aEndAngle, this.aClockwise = t.aClockwise, this.aRotation = t.aRotation, this
      }
      toJSON() {
        const t = super.toJSON();
        return t.aX = this.aX, t.aY = this.aY, t.xRadius = this.xRadius, t.yRadius = this.yRadius, t.aStartAngle = this.aStartAngle, t.aEndAngle = this.aEndAngle, t.aClockwise = this.aClockwise, t.aRotation = this.aRotation, t
      }
      fromJSON(t) {
        return super.fromJSON(t), this.aX = t.aX, this.aY = t.aY, this.xRadius = t.xRadius, this.yRadius = t.yRadius, this.aStartAngle = t.aStartAngle, this.aEndAngle = t.aEndAngle, this.aClockwise = t.aClockwise, this.aRotation = t.aRotation, this
      }
    }
    exports.EllipseCurve = $d, $d.prototype.isEllipseCurve = !0;
    class tm extends $d {
      constructor(t, e, n, r, i, s) {
        super(t, e, n, n, r, i, s), this.type = "ArcCurve"
      }
    }

    function em() {
      let t = 0,
        e = 0,
        n = 0,
        r = 0;

      function i(i, s, o, a) {
        t = i, e = o, n = -3 * i + 3 * s - 2 * o - a, r = 2 * i - 2 * s + o + a
      }
      return {
        initCatmullRom: function(t, e, n, r, s) {
          i(e, n, s * (n - t), s * (r - e))
        },
        initNonuniformCatmullRom: function(t, e, n, r, s, o, a) {
          let l = (e - t) / s - (n - t) / (s + o) + (n - e) / o,
            c = (n - e) / o - (r - e) / (o + a) + (r - n) / a;
          i(e, n, l *= o, c *= o)
        },
        calc: function(i) {
          const s = i * i;
          return t + e * i + n * s + r * (s * i)
        }
      }
    }
    exports.ArcCurve = tm, tm.prototype.isArcCurve = !0;
    const nm = new gr,
      rm = new em,
      im = new em,
      sm = new em;
    class om extends Kd {
      constructor(t = [], e = !1, n = "centripetal", r = .5) {
        super(), this.type = "CatmullRomCurve3", this.points = t, this.closed = e, this.curveType = n, this.tension = r
      }
      getPoint(t, e = new gr) {
        const n = e,
          r = this.points,
          i = r.length,
          s = (i - (this.closed ? 0 : 1)) * t;
        let o, a, l = Math.floor(s),
          c = s - l;
        this.closed ? l += l > 0 ? 0 : (Math.floor(Math.abs(l) / i) + 1) * i : 0 === c && l === i - 1 && (l = i - 2, c = 1), this.closed || l > 0 ? o = r[(l - 1) % i] : (nm.subVectors(r[0], r[1]).add(r[0]), o = nm);
        const h = r[l % i],
          u = r[(l + 1) % i];
        if (this.closed || l + 2 < i ? a = r[(l + 2) % i] : (nm.subVectors(r[i - 1], r[i - 2]).add(r[i - 1]), a = nm), "centripetal" === this.curveType || "chordal" === this.curveType) {
          const t = "chordal" === this.curveType ? .5 : .25;
          let e = Math.pow(o.distanceToSquared(h), t),
            n = Math.pow(h.distanceToSquared(u), t),
            r = Math.pow(u.distanceToSquared(a), t);
          n < 1e-4 && (n = 1), e < 1e-4 && (e = n), r < 1e-4 && (r = n), rm.initNonuniformCatmullRom(o.x, h.x, u.x, a.x, e, n, r), im.initNonuniformCatmullRom(o.y, h.y, u.y, a.y, e, n, r), sm.initNonuniformCatmullRom(o.z, h.z, u.z, a.z, e, n, r)
        } else "catmullrom" === this.curveType && (rm.initCatmullRom(o.x, h.x, u.x, a.x, this.tension), im.initCatmullRom(o.y, h.y, u.y, a.y, this.tension), sm.initCatmullRom(o.z, h.z, u.z, a.z, this.tension));
        return n.set(rm.calc(c), im.calc(c), sm.calc(c)), n
      }
      copy(t) {
        super.copy(t), this.points = [];
        for (let e = 0, n = t.points.length; e < n; e++) {
          const n = t.points[e];
          this.points.push(n.clone())
        }
        return this.closed = t.closed, this.curveType = t.curveType, this.tension = t.tension, this
      }
      toJSON() {
        const t = super.toJSON();
        t.points = [];
        for (let e = 0, n = this.points.length; e < n; e++) {
          const n = this.points[e];
          t.points.push(n.toArray())
        }
        return t.closed = this.closed, t.curveType = this.curveType, t.tension = this.tension, t
      }
      fromJSON(t) {
        super.fromJSON(t), this.points = [];
        for (let e = 0, n = t.points.length; e < n; e++) {
          const n = t.points[e];
          this.points.push((new gr).fromArray(n))
        }
        return this.closed = t.closed, this.curveType = t.curveType, this.tension = t.tension, this
      }
    }

    function am(t, e, n, r, i) {
      const s = .5 * (r - e),
        o = .5 * (i - n),
        a = t * t;
      return (2 * n - 2 * r + s + o) * (t * a) + (-3 * n + 3 * r - 2 * s - o) * a + s * t + n
    }

    function lm(t, e) {
      const n = 1 - t;
      return n * n * e
    }

    function cm(t, e) {
      return 2 * (1 - t) * t * e
    }

    function hm(t, e) {
      return t * t * e
    }

    function um(t, e, n, r) {
      return lm(t, e) + cm(t, n) + hm(t, r)
    }

    function pm(t, e) {
      const n = 1 - t;
      return n * n * n * e
    }

    function dm(t, e) {
      const n = 1 - t;
      return 3 * n * n * t * e
    }

    function mm(t, e) {
      return 3 * (1 - t) * t * t * e
    }

    function fm(t, e) {
      return t * t * t * e
    }

    function gm(t, e, n, r, i) {
      return pm(t, e) + dm(t, n) + mm(t, r) + fm(t, i)
    }
    exports.CatmullRomCurve3 = om, om.prototype.isCatmullRomCurve3 = !0;
    class xm extends Kd {
      constructor(t = new sr, e = new sr, n = new sr, r = new sr) {
        super(), this.type = "CubicBezierCurve", this.v0 = t, this.v1 = e, this.v2 = n, this.v3 = r
      }
      getPoint(t, e = new sr) {
        const n = e,
          r = this.v0,
          i = this.v1,
          s = this.v2,
          o = this.v3;
        return n.set(gm(t, r.x, i.x, s.x, o.x), gm(t, r.y, i.y, s.y, o.y)), n
      }
      copy(t) {
        return super.copy(t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this.v3.copy(t.v3), this
      }
      toJSON() {
        const t = super.toJSON();
        return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t.v3 = this.v3.toArray(), t
      }
      fromJSON(t) {
        return super.fromJSON(t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this.v3.fromArray(t.v3), this
      }
    }
    exports.CubicBezierCurve = xm, xm.prototype.isCubicBezierCurve = !0;
    class vm extends Kd {
      constructor(t = new gr, e = new gr, n = new gr, r = new gr) {
        super(), this.type = "CubicBezierCurve3", this.v0 = t, this.v1 = e, this.v2 = n, this.v3 = r
      }
      getPoint(t, e = new gr) {
        const n = e,
          r = this.v0,
          i = this.v1,
          s = this.v2,
          o = this.v3;
        return n.set(gm(t, r.x, i.x, s.x, o.x), gm(t, r.y, i.y, s.y, o.y), gm(t, r.z, i.z, s.z, o.z)), n
      }
      copy(t) {
        return super.copy(t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this.v3.copy(t.v3), this
      }
      toJSON() {
        const t = super.toJSON();
        return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t.v3 = this.v3.toArray(), t
      }
      fromJSON(t) {
        return super.fromJSON(t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this.v3.fromArray(t.v3), this
      }
    }
    exports.CubicBezierCurve3 = vm, vm.prototype.isCubicBezierCurve3 = !0;
    class ym extends Kd {
      constructor(t = new sr, e = new sr) {
        super(), this.type = "LineCurve", this.v1 = t, this.v2 = e
      }
      getPoint(t, e = new sr) {
        const n = e;
        return 1 === t ? n.copy(this.v2) : (n.copy(this.v2).sub(this.v1), n.multiplyScalar(t).add(this.v1)), n
      }
      getPointAt(t, e) {
        return this.getPoint(t, e)
      }
      getTangent(t, e) {
        const n = e || new sr;
        return n.copy(this.v2).sub(this.v1).normalize(), n
      }
      copy(t) {
        return super.copy(t), this.v1.copy(t.v1), this.v2.copy(t.v2), this
      }
      toJSON() {
        const t = super.toJSON();
        return t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t
      }
      fromJSON(t) {
        return super.fromJSON(t), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this
      }
    }
    exports.LineCurve = ym, ym.prototype.isLineCurve = !0;
    class _m extends Kd {
      constructor(t = new gr, e = new gr) {
        super(), this.type = "LineCurve3", this.isLineCurve3 = !0, this.v1 = t, this.v2 = e
      }
      getPoint(t, e = new gr) {
        const n = e;
        return 1 === t ? n.copy(this.v2) : (n.copy(this.v2).sub(this.v1), n.multiplyScalar(t).add(this.v1)), n
      }
      getPointAt(t, e) {
        return this.getPoint(t, e)
      }
      copy(t) {
        return super.copy(t), this.v1.copy(t.v1), this.v2.copy(t.v2), this
      }
      toJSON() {
        const t = super.toJSON();
        return t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t
      }
      fromJSON(t) {
        return super.fromJSON(t), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this
      }
    }
    exports.LineCurve3 = _m;
    class bm extends Kd {
      constructor(t = new sr, e = new sr, n = new sr) {
        super(), this.type = "QuadraticBezierCurve", this.v0 = t, this.v1 = e, this.v2 = n
      }
      getPoint(t, e = new sr) {
        const n = e,
          r = this.v0,
          i = this.v1,
          s = this.v2;
        return n.set(um(t, r.x, i.x, s.x), um(t, r.y, i.y, s.y)), n
      }
      copy(t) {
        return super.copy(t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this
      }
      toJSON() {
        const t = super.toJSON();
        return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t
      }
      fromJSON(t) {
        return super.fromJSON(t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this
      }
    }
    exports.QuadraticBezierCurve = bm, bm.prototype.isQuadraticBezierCurve = !0;
    class wm extends Kd {
      constructor(t = new gr, e = new gr, n = new gr) {
        super(), this.type = "QuadraticBezierCurve3", this.v0 = t, this.v1 = e, this.v2 = n
      }
      getPoint(t, e = new gr) {
        const n = e,
          r = this.v0,
          i = this.v1,
          s = this.v2;
        return n.set(um(t, r.x, i.x, s.x), um(t, r.y, i.y, s.y), um(t, r.z, i.z, s.z)), n
      }
      copy(t) {
        return super.copy(t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this
      }
      toJSON() {
        const t = super.toJSON();
        return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t
      }
      fromJSON(t) {
        return super.fromJSON(t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this
      }
    }
    exports.QuadraticBezierCurve3 = wm, wm.prototype.isQuadraticBezierCurve3 = !0;
    class Mm extends Kd {
      constructor(t = []) {
        super(), this.type = "SplineCurve", this.points = t
      }
      getPoint(t, e = new sr) {
        const n = e,
          r = this.points,
          i = (r.length - 1) * t,
          s = Math.floor(i),
          o = i - s,
          a = r[0 === s ? s : s - 1],
          l = r[s],
          c = r[s > r.length - 2 ? r.length - 1 : s + 1],
          h = r[s > r.length - 3 ? r.length - 1 : s + 2];
        return n.set(am(o, a.x, l.x, c.x, h.x), am(o, a.y, l.y, c.y, h.y)), n
      }
      copy(t) {
        super.copy(t), this.points = [];
        for (let e = 0, n = t.points.length; e < n; e++) {
          const n = t.points[e];
          this.points.push(n.clone())
        }
        return this
      }
      toJSON() {
        const t = super.toJSON();
        t.points = [];
        for (let e = 0, n = this.points.length; e < n; e++) {
          const n = this.points[e];
          t.points.push(n.toArray())
        }
        return t
      }
      fromJSON(t) {
        super.fromJSON(t), this.points = [];
        for (let e = 0, n = t.points.length; e < n; e++) {
          const n = t.points[e];
          this.points.push((new sr).fromArray(n))
        }
        return this
      }
    }
    exports.SplineCurve = Mm, Mm.prototype.isSplineCurve = !0;
    var Sm = Object.freeze({
      __proto__: null,
      ArcCurve: tm,
      CatmullRomCurve3: om,
      CubicBezierCurve: xm,
      CubicBezierCurve3: vm,
      EllipseCurve: $d,
      LineCurve: ym,
      LineCurve3: _m,
      QuadraticBezierCurve: bm,
      QuadraticBezierCurve3: wm,
      SplineCurve: Mm
    });
    class Tm extends Kd {
      constructor() {
        super(), this.type = "CurvePath", this.curves = [], this.autoClose = !1
      }
      add(t) {
        this.curves.push(t)
      }
      closePath() {
        const t = this.curves[0].getPoint(0),
          e = this.curves[this.curves.length - 1].getPoint(1);
        t.equals(e) || this.curves.push(new ym(e, t))
      }
      getPoint(t) {
        const e = t * this.getLength(),
          n = this.getCurveLengths();
        let r = 0;
        for (; r < n.length;) {
          if (n[r] >= e) {
            const t = n[r] - e,
              i = this.curves[r],
              s = i.getLength(),
              o = 0 === s ? 0 : 1 - t / s;
            return i.getPointAt(o)
          }
          r++
        }
        return null
      }
      getLength() {
        const t = this.getCurveLengths();
        return t[t.length - 1]
      }
      updateArcLengths() {
        this.needsUpdate = !0, this.cacheLengths = null, this.getCurveLengths()
      }
      getCurveLengths() {
        if (this.cacheLengths && this.cacheLengths.length === this.curves.length) return this.cacheLengths;
        const t = [];
        let e = 0;
        for (let n = 0, r = this.curves.length; n < r; n++) e += this.curves[n].getLength(), t.push(e);
        return this.cacheLengths = t, t
      }
      getSpacedPoints(t = 40) {
        const e = [];
        for (let n = 0; n <= t; n++) e.push(this.getPoint(n / t));
        return this.autoClose && e.push(e[0]), e
      }
      getPoints(t = 12) {
        const e = [];
        let n;
        for (let r = 0, i = this.curves; r < i.length; r++) {
          const s = i[r],
            o = s && s.isEllipseCurve ? 2 * t : s && (s.isLineCurve || s.isLineCurve3) ? 1 : s && s.isSplineCurve ? t * s.points.length : t,
            a = s.getPoints(o);
          for (let t = 0; t < a.length; t++) {
            const r = a[t];
            n && n.equals(r) || (e.push(r), n = r)
          }
        }
        return this.autoClose && e.length > 1 && !e[e.length - 1].equals(e[0]) && e.push(e[0]), e
      }
      copy(t) {
        super.copy(t), this.curves = [];
        for (let e = 0, n = t.curves.length; e < n; e++) {
          const n = t.curves[e];
          this.curves.push(n.clone())
        }
        return this.autoClose = t.autoClose, this
      }
      toJSON() {
        const t = super.toJSON();
        t.autoClose = this.autoClose, t.curves = [];
        for (let e = 0, n = this.curves.length; e < n; e++) {
          const n = this.curves[e];
          t.curves.push(n.toJSON())
        }
        return t
      }
      fromJSON(t) {
        super.fromJSON(t), this.autoClose = t.autoClose, this.curves = [];
        for (let e = 0, n = t.curves.length; e < n; e++) {
          const n = t.curves[e];
          this.curves.push((new Sm[n.type]).fromJSON(n))
        }
        return this
      }
    }
    exports.CurvePath = Tm;
    class Em extends Tm {
      constructor(t) {
        super(), this.type = "Path", this.currentPoint = new sr, t && this.setFromPoints(t)
      }
      setFromPoints(t) {
        this.moveTo(t[0].x, t[0].y);
        for (let e = 1, n = t.length; e < n; e++) this.lineTo(t[e].x, t[e].y);
        return this
      }
      moveTo(t, e) {
        return this.currentPoint.set(t, e), this
      }
      lineTo(t, e) {
        const n = new ym(this.currentPoint.clone(), new sr(t, e));
        return this.curves.push(n), this.currentPoint.set(t, e), this
      }
      quadraticCurveTo(t, e, n, r) {
        const i = new bm(this.currentPoint.clone(), new sr(t, e), new sr(n, r));
        return this.curves.push(i), this.currentPoint.set(n, r), this
      }
      bezierCurveTo(t, e, n, r, i, s) {
        const o = new xm(this.currentPoint.clone(), new sr(t, e), new sr(n, r), new sr(i, s));
        return this.curves.push(o), this.currentPoint.set(i, s), this
      }
      splineThru(t) {
        const e = [this.currentPoint.clone()].concat(t),
          n = new Mm(e);
        return this.curves.push(n), this.currentPoint.copy(t[t.length - 1]), this
      }
      arc(t, e, n, r, i, s) {
        const o = this.currentPoint.x,
          a = this.currentPoint.y;
        return this.absarc(t + o, e + a, n, r, i, s), this
      }
      absarc(t, e, n, r, i, s) {
        return this.absellipse(t, e, n, n, r, i, s), this
      }
      ellipse(t, e, n, r, i, s, o, a) {
        const l = this.currentPoint.x,
          c = this.currentPoint.y;
        return this.absellipse(t + l, e + c, n, r, i, s, o, a), this
      }
      absellipse(t, e, n, r, i, s, o, a) {
        const l = new $d(t, e, n, r, i, s, o, a);
        if (this.curves.length > 0) {
          const t = l.getPoint(0);
          t.equals(this.currentPoint) || this.lineTo(t.x, t.y)
        }
        this.curves.push(l);
        const c = l.getPoint(1);
        return this.currentPoint.copy(c), this
      }
      copy(t) {
        return super.copy(t), this.currentPoint.copy(t.currentPoint), this
      }
      toJSON() {
        const t = super.toJSON();
        return t.currentPoint = this.currentPoint.toArray(), t
      }
      fromJSON(t) {
        return super.fromJSON(t), this.currentPoint.fromArray(t.currentPoint), this
      }
    }
    exports.Path = Em;
    class Am extends Em {
      constructor(t) {
        super(t), this.uuid = Gn(), this.type = "Shape", this.holes = []
      }
      getPointsHoles(t) {
        const e = [];
        for (let n = 0, r = this.holes.length; n < r; n++) e[n] = this.holes[n].getPoints(t);
        return e
      }
      extractPoints(t) {
        return {
          shape: this.getPoints(t),
          holes: this.getPointsHoles(t)
        }
      }
      copy(t) {
        super.copy(t), this.holes = [];
        for (let e = 0, n = t.holes.length; e < n; e++) {
          const n = t.holes[e];
          this.holes.push(n.clone())
        }
        return this
      }
      toJSON() {
        const t = super.toJSON();
        t.uuid = this.uuid, t.holes = [];
        for (let e = 0, n = this.holes.length; e < n; e++) {
          const n = this.holes[e];
          t.holes.push(n.toJSON())
        }
        return t
      }
      fromJSON(t) {
        super.fromJSON(t), this.uuid = t.uuid, this.holes = [];
        for (let e = 0, n = t.holes.length; e < n; e++) {
          const n = t.holes[e];
          this.holes.push((new Em).fromJSON(n))
        }
        return this
      }
    }
    exports.Shape = Am;
    class Lm extends vi {
      constructor(t, e = 1) {
        super(), this.type = "Light", this.color = new ki(t), this.intensity = e
      }
      dispose() {}
      copy(t) {
        return super.copy(t), this.color.copy(t.color), this.intensity = t.intensity, this
      }
      toJSON(t) {
        const e = super.toJSON(t);
        return e.object.color = this.color.getHex(), e.object.intensity = this.intensity, void 0 !== this.groundColor && (e.object.groundColor = this.groundColor.getHex()), void 0 !== this.distance && (e.object.distance = this.distance), void 0 !== this.angle && (e.object.angle = this.angle), void 0 !== this.decay && (e.object.decay = this.decay), void 0 !== this.penumbra && (e.object.penumbra = this.penumbra), void 0 !== this.shadow && (e.object.shadow = this.shadow.toJSON()), e
      }
    }
    exports.Light = Lm, Lm.prototype.isLight = !0;
    class Rm extends Lm {
      constructor(t, e, n) {
        super(t, n), this.type = "HemisphereLight", this.position.copy(vi.DefaultUp), this.updateMatrix(), this.groundColor = new ki(e)
      }
      copy(t) {
        return Lm.prototype.copy.call(this, t), this.groundColor.copy(t.groundColor), this
      }
    }
    exports.HemisphereLight = Rm, Rm.prototype.isHemisphereLight = !0;
    const Cm = new Xr,
      Pm = new gr,
      Dm = new gr;
    class Im {
      constructor(t) {
        this.camera = t, this.bias = 0, this.normalBias = 0, this.radius = 1, this.mapSize = new sr(512, 512), this.map = null, this.mapPass = null, this.matrix = new Xr, this.autoUpdate = !0, this.needsUpdate = !1, this._frustum = new Qs, this._frameExtents = new sr(1, 1), this._viewportCount = 1, this._viewports = [new pr(0, 0, 1, 1)]
      }
      getViewportCount() {
        return this._viewportCount
      }
      getFrustum() {
        return this._frustum
      }
      updateMatrices(t) {
        const e = this.camera,
          n = this.matrix;
        Pm.setFromMatrixPosition(t.matrixWorld), e.position.copy(Pm), Dm.setFromMatrixPosition(t.target.matrixWorld), e.lookAt(Dm), e.updateMatrixWorld(), Cm.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse), this._frustum.setFromProjectionMatrix(Cm), n.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1), n.multiply(e.projectionMatrix), n.multiply(e.matrixWorldInverse)
      }
      getViewport(t) {
        return this._viewports[t]
      }
      getFrameExtents() {
        return this._frameExtents
      }
      dispose() {
        this.map && this.map.dispose(), this.mapPass && this.mapPass.dispose()
      }
      copy(t) {
        return this.camera = t.camera.clone(), this.bias = t.bias, this.radius = t.radius, this.mapSize.copy(t.mapSize), this
      }
      clone() {
        return (new this.constructor).copy(this)
      }
      toJSON() {
        const t = {};
        return 0 !== this.bias && (t.bias = this.bias), 0 !== this.normalBias && (t.normalBias = this.normalBias), 1 !== this.radius && (t.radius = this.radius), 512 === this.mapSize.x && 512 === this.mapSize.y || (t.mapSize = this.mapSize.toArray()), t.camera = this.camera.toJSON(!1).object, delete t.camera.matrix, t
      }
    }
    class Bm extends Im {
      constructor() {
        super(new ks(50, 1, .5, 500)), this.focus = 1
      }
      updateMatrices(t) {
        const e = this.camera,
          n = 2 * zn * t.angle * this.focus,
          r = this.mapSize.width / this.mapSize.height,
          i = t.distance || e.far;
        n === e.fov && r === e.aspect && i === e.far || (e.fov = n, e.aspect = r, e.far = i, e.updateProjectionMatrix()), super.updateMatrices(t)
      }
      copy(t) {
        return super.copy(t), this.focus = t.focus, this
      }
    }
    Bm.prototype.isSpotLightShadow = !0;
    class Nm extends Lm {
      constructor(t, e, n = 0, r = Math.PI / 3, i = 0, s = 1) {
        super(t, e), this.type = "SpotLight", this.position.copy(vi.DefaultUp), this.updateMatrix(), this.target = new vi, this.distance = n, this.angle = r, this.penumbra = i, this.decay = s, this.shadow = new Bm
      }
      get power() {
        return this.intensity * Math.PI
      }
      set power(t) {
        this.intensity = t / Math.PI
      }
      dispose() {
        this.shadow.dispose()
      }
      copy(t) {
        return super.copy(t), this.distance = t.distance, this.angle = t.angle, this.penumbra = t.penumbra, this.decay = t.decay, this.target = t.target.clone(), this.shadow = t.shadow.clone(), this
      }
    }
    exports.SpotLight = Nm, Nm.prototype.isSpotLight = !0;
    const Fm = new Xr,
      zm = new gr,
      Gm = new gr;
    class Om extends Im {
      constructor() {
        super(new ks(90, 1, .5, 500)), this._frameExtents = new sr(4, 2), this._viewportCount = 6, this._viewports = [new pr(2, 1, 1, 1), new pr(0, 1, 1, 1), new pr(3, 1, 1, 1), new pr(1, 1, 1, 1), new pr(3, 0, 1, 1), new pr(1, 0, 1, 1)], this._cubeDirections = [new gr(1, 0, 0), new gr(-1, 0, 0), new gr(0, 0, 1), new gr(0, 0, -1), new gr(0, 1, 0), new gr(0, -1, 0)], this._cubeUps = [new gr(0, 1, 0), new gr(0, 1, 0), new gr(0, 1, 0), new gr(0, 1, 0), new gr(0, 0, 1), new gr(0, 0, -1)]
      }
      updateMatrices(t, e = 0) {
        const n = this.camera,
          r = this.matrix,
          i = t.distance || n.far;
        i !== n.far && (n.far = i, n.updateProjectionMatrix()), zm.setFromMatrixPosition(t.matrixWorld), n.position.copy(zm), Gm.copy(n.position), Gm.add(this._cubeDirections[e]), n.up.copy(this._cubeUps[e]), n.lookAt(Gm), n.updateMatrixWorld(), r.makeTranslation(-zm.x, -zm.y, -zm.z), Fm.multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse), this._frustum.setFromProjectionMatrix(Fm)
      }
    }
    Om.prototype.isPointLightShadow = !0;
    class Hm extends Lm {
      constructor(t, e, n = 0, r = 1) {
        super(t, e), this.type = "PointLight", this.distance = n, this.decay = r, this.shadow = new Om
      }
      get power() {
        return 4 * this.intensity * Math.PI
      }
      set power(t) {
        this.intensity = t / (4 * Math.PI)
      }
      dispose() {
        this.shadow.dispose()
      }
      copy(t) {
        return super.copy(t), this.distance = t.distance, this.decay = t.decay, this.shadow = t.shadow.clone(), this
      }
    }
    exports.PointLight = Hm, Hm.prototype.isPointLight = !0;
    class Um extends Us {
      constructor(t = -1, e = 1, n = 1, r = -1, i = .1, s = 2e3) {
        super(), this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = t, this.right = e, this.top = n, this.bottom = r, this.near = i, this.far = s, this.updateProjectionMatrix()
      }
      copy(t, e) {
        return super.copy(t, e), this.left = t.left, this.right = t.right, this.top = t.top, this.bottom = t.bottom, this.near = t.near, this.far = t.far, this.zoom = t.zoom, this.view = null === t.view ? null : Object.assign({}, t.view), this
      }
      setViewOffset(t, e, n, r, i, s) {
        null === this.view && (this.view = {
          enabled: !0,
          fullWidth: 1,
          fullHeight: 1,
          offsetX: 0,
          offsetY: 0,
          width: 1,
          height: 1
        }), this.view.enabled = !0, this.view.fullWidth = t, this.view.fullHeight = e, this.view.offsetX = n, this.view.offsetY = r, this.view.width = i, this.view.height = s, this.updateProjectionMatrix()
      }
      clearViewOffset() {
        null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix()
      }
      updateProjectionMatrix() {
        const t = (this.right - this.left) / (2 * this.zoom),
          e = (this.top - this.bottom) / (2 * this.zoom),
          n = (this.right + this.left) / 2,
          r = (this.top + this.bottom) / 2;
        let i = n - t,
          s = n + t,
          o = r + e,
          a = r - e;
        if (null !== this.view && this.view.enabled) {
          const t = (this.right - this.left) / this.view.fullWidth / this.zoom,
            e = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
          s = (i += t * this.view.offsetX) + t * this.view.width, a = (o -= e * this.view.offsetY) - e * this.view.height
        }
        this.projectionMatrix.makeOrthographic(i, s, o, a, this.near, this.far), this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
      }
      toJSON(t) {
        const e = super.toJSON(t);
        return e.object.zoom = this.zoom, e.object.left = this.left, e.object.right = this.right, e.object.top = this.top, e.object.bottom = this.bottom, e.object.near = this.near, e.object.far = this.far, null !== this.view && (e.object.view = Object.assign({}, this.view)), e
      }
    }
    exports.OrthographicCamera = Um, Um.prototype.isOrthographicCamera = !0;
    class km extends Im {
      constructor() {
        super(new Um(-5, 5, 5, -5, .5, 500))
      }
    }
    km.prototype.isDirectionalLightShadow = !0;
    class Vm extends Lm {
      constructor(t, e) {
        super(t, e), this.type = "DirectionalLight", this.position.copy(vi.DefaultUp), this.updateMatrix(), this.target = new vi, this.shadow = new km
      }
      dispose() {
        this.shadow.dispose()
      }
      copy(t) {
        return super.copy(t), this.target = t.target.clone(), this.shadow = t.shadow.clone(), this
      }
    }
    exports.DirectionalLight = Vm, Vm.prototype.isDirectionalLight = !0;
    class Wm extends Lm {
      constructor(t, e) {
        super(t, e), this.type = "AmbientLight"
      }
    }
    exports.AmbientLight = Wm, Wm.prototype.isAmbientLight = !0;
    class jm extends Lm {
      constructor(t, e, n = 10, r = 10) {
        super(t, e), this.type = "RectAreaLight", this.width = n, this.height = r
      }
      copy(t) {
        return super.copy(t), this.width = t.width, this.height = t.height, this
      }
      toJSON(t) {
        const e = super.toJSON(t);
        return e.object.width = this.width, e.object.height = this.height, e
      }
    }
    exports.RectAreaLight = jm, jm.prototype.isRectAreaLight = !0;
    class qm {
      constructor() {
        this.coefficients = [];
        for (let t = 0; t < 9; t++) this.coefficients.push(new gr)
      }
      set(t) {
        for (let e = 0; e < 9; e++) this.coefficients[e].copy(t[e]);
        return this
      }
      zero() {
        for (let t = 0; t < 9; t++) this.coefficients[t].set(0, 0, 0);
        return this
      }
      getAt(t, e) {
        const n = t.x,
          r = t.y,
          i = t.z,
          s = this.coefficients;
        return e.copy(s[0]).multiplyScalar(.282095), e.addScaledVector(s[1], .488603 * r), e.addScaledVector(s[2], .488603 * i), e.addScaledVector(s[3], .488603 * n), e.addScaledVector(s[4], n * r * 1.092548), e.addScaledVector(s[5], r * i * 1.092548), e.addScaledVector(s[6], .315392 * (3 * i * i - 1)), e.addScaledVector(s[7], n * i * 1.092548), e.addScaledVector(s[8], .546274 * (n * n - r * r)), e
      }
      getIrradianceAt(t, e) {
        const n = t.x,
          r = t.y,
          i = t.z,
          s = this.coefficients;
        return e.copy(s[0]).multiplyScalar(.886227), e.addScaledVector(s[1], 1.023328 * r), e.addScaledVector(s[2], 1.023328 * i), e.addScaledVector(s[3], 1.023328 * n), e.addScaledVector(s[4], .858086 * n * r), e.addScaledVector(s[5], .858086 * r * i), e.addScaledVector(s[6], .743125 * i * i - .247708), e.addScaledVector(s[7], .858086 * n * i), e.addScaledVector(s[8], .429043 * (n * n - r * r)), e
      }
      add(t) {
        for (let e = 0; e < 9; e++) this.coefficients[e].add(t.coefficients[e]);
        return this
      }
      addScaledSH(t, e) {
        for (let n = 0; n < 9; n++) this.coefficients[n].addScaledVector(t.coefficients[n], e);
        return this
      }
      scale(t) {
        for (let e = 0; e < 9; e++) this.coefficients[e].multiplyScalar(t);
        return this
      }
      lerp(t, e) {
        for (let n = 0; n < 9; n++) this.coefficients[n].lerp(t.coefficients[n], e);
        return this
      }
      equals(t) {
        for (let e = 0; e < 9; e++)
          if (!this.coefficients[e].equals(t.coefficients[e])) return !1;
        return !0
      }
      copy(t) {
        return this.set(t.coefficients)
      }
      clone() {
        return (new this.constructor).copy(this)
      }
      fromArray(t, e = 0) {
        const n = this.coefficients;
        for (let r = 0; r < 9; r++) n[r].fromArray(t, e + 3 * r);
        return this
      }
      toArray(t = [], e = 0) {
        const n = this.coefficients;
        for (let r = 0; r < 9; r++) n[r].toArray(t, e + 3 * r);
        return t
      }
      static getBasisAt(t, e) {
        const n = t.x,
          r = t.y,
          i = t.z;
        e[0] = .282095, e[1] = .488603 * r, e[2] = .488603 * i, e[3] = .488603 * n, e[4] = 1.092548 * n * r, e[5] = 1.092548 * r * i, e[6] = .315392 * (3 * i * i - 1), e[7] = 1.092548 * n * i, e[8] = .546274 * (n * n - r * r)
      }
    }
    exports.SphericalHarmonics3 = qm, qm.prototype.isSphericalHarmonics3 = !0;
    class Xm extends Lm {
      constructor(t = new qm, e = 1) {
        super(void 0, e), this.sh = t
      }
      copy(t) {
        return super.copy(t), this.sh.copy(t.sh), this
      }
      fromJSON(t) {
        return this.intensity = t.intensity, this.sh.fromArray(t.sh), this
      }
      toJSON(t) {
        const e = super.toJSON(t);
        return e.object.sh = this.sh.toArray(), e
      }
    }
    exports.LightProbe = Xm, Xm.prototype.isLightProbe = !0;
    class Ym extends Vd {
      constructor(t) {
        super(t), this.textures = {}
      }
      load(t, e, n, r) {
        const i = this,
          s = new jd(i.manager);
        s.setPath(i.path), s.setRequestHeader(i.requestHeader), s.setWithCredentials(i.withCredentials), s.load(t, function(n) {
          try {
            e(i.parse(JSON.parse(n)))
          } catch (s) {
            r ? r(s) : console.error(s), i.manager.itemError(t)
          }
        }, n, r)
      }
      parse(t) {
        const e = this.textures;

        function n(t) {
          return void 0 === e[t] && console.warn("THREE.MaterialLoader: Undefined texture", t), e[t]
        }
        const r = new Md[t.type];
        if (void 0 !== t.uuid && (r.uuid = t.uuid), void 0 !== t.name && (r.name = t.name), void 0 !== t.color && void 0 !== r.color && r.color.setHex(t.color), void 0 !== t.roughness && (r.roughness = t.roughness), void 0 !== t.metalness && (r.metalness = t.metalness), void 0 !== t.sheen && (r.sheen = (new ki).setHex(t.sheen)), void 0 !== t.emissive && void 0 !== r.emissive && r.emissive.setHex(t.emissive), void 0 !== t.specular && void 0 !== r.specular && r.specular.setHex(t.specular), void 0 !== t.shininess && (r.shininess = t.shininess), void 0 !== t.clearcoat && (r.clearcoat = t.clearcoat), void 0 !== t.clearcoatRoughness && (r.clearcoatRoughness = t.clearcoatRoughness), void 0 !== t.fog && (r.fog = t.fog), void 0 !== t.flatShading && (r.flatShading = t.flatShading), void 0 !== t.blending && (r.blending = t.blending), void 0 !== t.combine && (r.combine = t.combine), void 0 !== t.side && (r.side = t.side), void 0 !== t.shadowSide && (r.shadowSide = t.shadowSide), void 0 !== t.opacity && (r.opacity = t.opacity), void 0 !== t.transparent && (r.transparent = t.transparent), void 0 !== t.alphaTest && (r.alphaTest = t.alphaTest), void 0 !== t.depthTest && (r.depthTest = t.depthTest), void 0 !== t.depthWrite && (r.depthWrite = t.depthWrite), void 0 !== t.colorWrite && (r.colorWrite = t.colorWrite), void 0 !== t.stencilWrite && (r.stencilWrite = t.stencilWrite), void 0 !== t.stencilWriteMask && (r.stencilWriteMask = t.stencilWriteMask), void 0 !== t.stencilFunc && (r.stencilFunc = t.stencilFunc), void 0 !== t.stencilRef && (r.stencilRef = t.stencilRef), void 0 !== t.stencilFuncMask && (r.stencilFuncMask = t.stencilFuncMask), void 0 !== t.stencilFail && (r.stencilFail = t.stencilFail), void 0 !== t.stencilZFail && (r.stencilZFail = t.stencilZFail), void 0 !== t.stencilZPass && (r.stencilZPass = t.stencilZPass), void 0 !== t.wireframe && (r.wireframe = t.wireframe), void 0 !== t.wireframeLinewidth && (r.wireframeLinewidth = t.wireframeLinewidth), void 0 !== t.wireframeLinecap && (r.wireframeLinecap = t.wireframeLinecap), void 0 !== t.wireframeLinejoin && (r.wireframeLinejoin = t.wireframeLinejoin), void 0 !== t.rotation && (r.rotation = t.rotation), 1 !== t.linewidth && (r.linewidth = t.linewidth), void 0 !== t.dashSize && (r.dashSize = t.dashSize), void 0 !== t.gapSize && (r.gapSize = t.gapSize), void 0 !== t.scale && (r.scale = t.scale), void 0 !== t.polygonOffset && (r.polygonOffset = t.polygonOffset), void 0 !== t.polygonOffsetFactor && (r.polygonOffsetFactor = t.polygonOffsetFactor), void 0 !== t.polygonOffsetUnits && (r.polygonOffsetUnits = t.polygonOffsetUnits), void 0 !== t.skinning && (r.skinning = t.skinning), void 0 !== t.morphTargets && (r.morphTargets = t.morphTargets), void 0 !== t.morphNormals && (r.morphNormals = t.morphNormals), void 0 !== t.dithering && (r.dithering = t.dithering), void 0 !== t.alphaToCoverage && (r.alphaToCoverage = t.alphaToCoverage), void 0 !== t.premultipliedAlpha && (r.premultipliedAlpha = t.premultipliedAlpha), void 0 !== t.vertexTangents && (r.vertexTangents = t.vertexTangents), void 0 !== t.visible && (r.visible = t.visible), void 0 !== t.toneMapped && (r.toneMapped = t.toneMapped), void 0 !== t.userData && (r.userData = t.userData), void 0 !== t.vertexColors && ("number" == typeof t.vertexColors ? r.vertexColors = t.vertexColors > 0 : r.vertexColors = t.vertexColors), void 0 !== t.uniforms)
          for (const i in t.uniforms) {
            const e = t.uniforms[i];
            switch (r.uniforms[i] = {}, e.type) {
              case "t":
                r.uniforms[i].value = n(e.value);
                break;
              case "c":
                r.uniforms[i].value = (new ki).setHex(e.value);
                break;
              case "v2":
                r.uniforms[i].value = (new sr).fromArray(e.value);
                break;
              case "v3":
                r.uniforms[i].value = (new gr).fromArray(e.value);
                break;
              case "v4":
                r.uniforms[i].value = (new pr).fromArray(e.value);
                break;
              case "m3":
                r.uniforms[i].value = (new or).fromArray(e.value);
                break;
              case "m4":
                r.uniforms[i].value = (new Xr).fromArray(e.value);
                break;
              default:
                r.uniforms[i].value = e.value
            }
          }
        if (void 0 !== t.defines && (r.defines = t.defines), void 0 !== t.vertexShader && (r.vertexShader = t.vertexShader), void 0 !== t.fragmentShader && (r.fragmentShader = t.fragmentShader), void 0 !== t.extensions)
          for (const i in t.extensions) r.extensions[i] = t.extensions[i];
        if (void 0 !== t.shading && (r.flatShading = 1 === t.shading), void 0 !== t.size && (r.size = t.size), void 0 !== t.sizeAttenuation && (r.sizeAttenuation = t.sizeAttenuation), void 0 !== t.map && (r.map = n(t.map)), void 0 !== t.matcap && (r.matcap = n(t.matcap)), void 0 !== t.alphaMap && (r.alphaMap = n(t.alphaMap)), void 0 !== t.bumpMap && (r.bumpMap = n(t.bumpMap)), void 0 !== t.bumpScale && (r.bumpScale = t.bumpScale), void 0 !== t.normalMap && (r.normalMap = n(t.normalMap)), void 0 !== t.normalMapType && (r.normalMapType = t.normalMapType), void 0 !== t.normalScale) {
          let e = t.normalScale;
          !1 === Array.isArray(e) && (e = [e, e]), r.normalScale = (new sr).fromArray(e)
        }
        return void 0 !== t.displacementMap && (r.displacementMap = n(t.displacementMap)), void 0 !== t.displacementScale && (r.displacementScale = t.displacementScale), void 0 !== t.displacementBias && (r.displacementBias = t.displacementBias), void 0 !== t.roughnessMap && (r.roughnessMap = n(t.roughnessMap)), void 0 !== t.metalnessMap && (r.metalnessMap = n(t.metalnessMap)), void 0 !== t.emissiveMap && (r.emissiveMap = n(t.emissiveMap)), void 0 !== t.emissiveIntensity && (r.emissiveIntensity = t.emissiveIntensity), void 0 !== t.specularMap && (r.specularMap = n(t.specularMap)), void 0 !== t.envMap && (r.envMap = n(t.envMap)), void 0 !== t.envMapIntensity && (r.envMapIntensity = t.envMapIntensity), void 0 !== t.reflectivity && (r.reflectivity = t.reflectivity), void 0 !== t.refractionRatio && (r.refractionRatio = t.refractionRatio), void 0 !== t.lightMap && (r.lightMap = n(t.lightMap)), void 0 !== t.lightMapIntensity && (r.lightMapIntensity = t.lightMapIntensity), void 0 !== t.aoMap && (r.aoMap = n(t.aoMap)), void 0 !== t.aoMapIntensity && (r.aoMapIntensity = t.aoMapIntensity), void 0 !== t.gradientMap && (r.gradientMap = n(t.gradientMap)), void 0 !== t.clearcoatMap && (r.clearcoatMap = n(t.clearcoatMap)), void 0 !== t.clearcoatRoughnessMap && (r.clearcoatRoughnessMap = n(t.clearcoatRoughnessMap)), void 0 !== t.clearcoatNormalMap && (r.clearcoatNormalMap = n(t.clearcoatNormalMap)), void 0 !== t.clearcoatNormalScale && (r.clearcoatNormalScale = (new sr).fromArray(t.clearcoatNormalScale)), void 0 !== t.transmission && (r.transmission = t.transmission), void 0 !== t.transmissionMap && (r.transmissionMap = n(t.transmissionMap)), r
      }
      setTextures(t) {
        return this.textures = t, this
      }
    }
    exports.MaterialLoader = Ym;
    class Zm {
      static decodeText(t) {
        if ("undefined" != typeof TextDecoder) return (new TextDecoder).decode(t);
        let e = "";
        for (let r = 0, i = t.length; r < i; r++) e += String.fromCharCode(t[r]);
        try {
          return decodeURIComponent(escape(e))
        } catch (n) {
          return e
        }
      }
      static extractUrlBase(t) {
        const e = t.lastIndexOf("/");
        return -1 === e ? "./" : t.substr(0, e + 1)
      }
    }
    exports.LoaderUtils = Zm;
    class Jm extends ds {
      constructor() {
        super(), this.type = "InstancedBufferGeometry", this.instanceCount = 1 / 0
      }
      copy(t) {
        return super.copy(t), this.instanceCount = t.instanceCount, this
      }
      clone() {
        return (new this.constructor).copy(this)
      }
      toJSON() {
        const t = super.toJSON(this);
        return t.instanceCount = this.instanceCount, t.isInstancedBufferGeometry = !0, t
      }
    }
    exports.InstancedBufferGeometry = Jm, Jm.prototype.isInstancedBufferGeometry = !0;
    class Qm extends qi {
      constructor(t, e, n, r) {
        "number" == typeof n && (r = n, n = !1, console.error("THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.")), super(t, e, n), this.meshPerAttribute = r || 1
      }
      copy(t) {
        return super.copy(t), this.meshPerAttribute = t.meshPerAttribute, this
      }
      toJSON() {
        const t = super.toJSON();
        return t.meshPerAttribute = this.meshPerAttribute, t.isInstancedBufferAttribute = !0, t
      }
    }
    exports.InstancedBufferAttribute = Qm, Qm.prototype.isInstancedBufferAttribute = !0;
    class Km extends Vd {
      constructor(t) {
        super(t)
      }
      load(t, e, n, r) {
        const i = this,
          s = new jd(i.manager);
        s.setPath(i.path), s.setRequestHeader(i.requestHeader), s.setWithCredentials(i.withCredentials), s.load(t, function(n) {
          try {
            e(i.parse(JSON.parse(n)))
          } catch (s) {
            r ? r(s) : console.error(s), i.manager.itemError(t)
          }
        }, n, r)
      }
      parse(t) {
        const e = {},
          n = {};

        function r(t, r) {
          if (void 0 !== e[r]) return e[r];
          const i = t.interleavedBuffers[r],
            s = function(t, e) {
              if (void 0 !== n[e]) return n[e];
              const r = t.arrayBuffers[e],
                i = new Uint32Array(r).buffer;
              return n[e] = i, i
            }(t, i.buffer),
            o = ss(i.type, s),
            a = new $h(o, i.stride);
          return a.uuid = i.uuid, e[r] = a, a
        }
        const i = t.isInstancedBufferGeometry ? new Jm : new ds,
          s = t.data.index;
        if (void 0 !== s) {
          const t = ss(s.type, s.array);
          i.setIndex(new qi(t, 1))
        }
        const o = t.data.attributes;
        for (const h in o) {
          const e = o[h];
          let n;
          if (e.isInterleavedBufferAttribute) {
            const i = r(t.data, e.data);
            n = new eu(i, e.itemSize, e.offset, e.normalized)
          } else {
            const t = ss(e.type, e.array);
            n = new(e.isInstancedBufferAttribute ? Qm : qi)(t, e.itemSize, e.normalized)
          }
          void 0 !== e.name && (n.name = e.name), void 0 !== e.usage && n.setUsage(e.usage), void 0 !== e.updateRange && (n.updateRange.offset = e.updateRange.offset, n.updateRange.count = e.updateRange.count), i.setAttribute(h, n)
        }
        const a = t.data.morphAttributes;
        if (a)
          for (const h in a) {
            const e = a[h],
              n = [];
            for (let i = 0, s = e.length; i < s; i++) {
              const s = e[i];
              let o;
              if (s.isInterleavedBufferAttribute) {
                const e = r(t.data, s.data);
                o = new eu(e, s.itemSize, s.offset, s.normalized)
              } else {
                const t = ss(s.type, s.array);
                o = new qi(t, s.itemSize, s.normalized)
              }
              void 0 !== s.name && (o.name = s.name), n.push(o)
            }
            i.morphAttributes[h] = n
          }
        t.data.morphTargetsRelative && (i.morphTargetsRelative = !0);
        const l = t.data.groups || t.data.drawcalls || t.data.offsets;
        if (void 0 !== l)
          for (let h = 0, u = l.length; h !== u; ++h) {
            const t = l[h];
            i.addGroup(t.start, t.count, t.materialIndex)
          }
        const c = t.data.boundingSphere;
        if (void 0 !== c) {
          const t = new gr;
          void 0 !== c.center && t.fromArray(c.center), i.boundingSphere = new Gr(t, c.radius)
        }
        return t.name && (i.name = t.name), t.userData && (i.userData = t.userData), i
      }
    }
    exports.BufferGeometryLoader = Km;
    class $m extends Vd {
      constructor(t) {
        super(t)
      }
      load(t, e, n, r) {
        const i = this,
          s = "" === this.path ? Zm.extractUrlBase(t) : this.path;
        this.resourcePath = this.resourcePath || s;
        const o = new jd(this.manager);
        o.setPath(this.path), o.setRequestHeader(this.requestHeader), o.setWithCredentials(this.withCredentials), o.load(t, function(n) {
          let s = null;
          try {
            s = JSON.parse(n)
          } catch (a) {
            return void 0 !== r && r(a), void console.error("THREE:ObjectLoader: Can't parse " + t + ".", a.message)
          }
          const o = s.metadata;
          void 0 !== o && void 0 !== o.type && "geometry" !== o.type.toLowerCase() ? i.parse(s, e) : console.error("THREE.ObjectLoader: Can't load " + t)
        }, n, r)
      }
      parse(t, e) {
        const n = this.parseAnimations(t.animations),
          r = this.parseShapes(t.shapes),
          i = this.parseGeometries(t.geometries, r),
          s = this.parseImages(t.images, function() {
            void 0 !== e && e(l)
          }),
          o = this.parseTextures(t.textures, s),
          a = this.parseMaterials(t.materials, o),
          l = this.parseObject(t.object, i, a, n),
          c = this.parseSkeletons(t.skeletons, l);
        if (this.bindSkeletons(l, c), void 0 !== e) {
          let t = !1;
          for (const e in s)
            if (s[e] instanceof HTMLImageElement) {
              t = !0;
              break
            }! 1 === t && e(l)
        }
        return l
      }
      parseShapes(t) {
        const e = {};
        if (void 0 !== t)
          for (let n = 0, r = t.length; n < r; n++) {
            const r = (new Am).fromJSON(t[n]);
            e[r.uuid] = r
          }
        return e
      }
      parseSkeletons(t, e) {
        const n = {},
          r = {};
        if (e.traverse(function(t) {
            t.isBone && (r[t.uuid] = t)
          }), void 0 !== t)
          for (let i = 0, s = t.length; i < s; i++) {
            const e = (new Cu).fromJSON(t[i], r);
            n[e.uuid] = e
          }
        return n
      }
      parseGeometries(t, e) {
        const n = {};
        let r;
        if (void 0 !== t) {
          const i = new Km;
          for (let s = 0, o = t.length; s < o; s++) {
            let o;
            const a = t[s];
            switch (a.type) {
              case "PlaneGeometry":
              case "PlaneBufferGeometry":
                o = new pd[a.type](a.width, a.height, a.widthSegments, a.heightSegments);
                break;
              case "BoxGeometry":
              case "BoxBufferGeometry":
                o = new pd[a.type](a.width, a.height, a.depth, a.widthSegments, a.heightSegments, a.depthSegments);
                break;
              case "CircleGeometry":
              case "CircleBufferGeometry":
                o = new pd[a.type](a.radius, a.segments, a.thetaStart, a.thetaLength);
                break;
              case "CylinderGeometry":
              case "CylinderBufferGeometry":
                o = new pd[a.type](a.radiusTop, a.radiusBottom, a.height, a.radialSegments, a.heightSegments, a.openEnded, a.thetaStart, a.thetaLength);
                break;
              case "ConeGeometry":
              case "ConeBufferGeometry":
                o = new pd[a.type](a.radius, a.height, a.radialSegments, a.heightSegments, a.openEnded, a.thetaStart, a.thetaLength);
                break;
              case "SphereGeometry":
              case "SphereBufferGeometry":
                o = new pd[a.type](a.radius, a.widthSegments, a.heightSegments, a.phiStart, a.phiLength, a.thetaStart, a.thetaLength);
                break;
              case "DodecahedronGeometry":
              case "DodecahedronBufferGeometry":
              case "IcosahedronGeometry":
              case "IcosahedronBufferGeometry":
              case "OctahedronGeometry":
              case "OctahedronBufferGeometry":
              case "TetrahedronGeometry":
              case "TetrahedronBufferGeometry":
                o = new pd[a.type](a.radius, a.detail);
                break;
              case "RingGeometry":
              case "RingBufferGeometry":
                o = new pd[a.type](a.innerRadius, a.outerRadius, a.thetaSegments, a.phiSegments, a.thetaStart, a.thetaLength);
                break;
              case "TorusGeometry":
              case "TorusBufferGeometry":
                o = new pd[a.type](a.radius, a.tube, a.radialSegments, a.tubularSegments, a.arc);
                break;
              case "TorusKnotGeometry":
              case "TorusKnotBufferGeometry":
                o = new pd[a.type](a.radius, a.tube, a.tubularSegments, a.radialSegments, a.p, a.q);
                break;
              case "TubeGeometry":
              case "TubeBufferGeometry":
                o = new pd[a.type]((new Sm[a.path.type]).fromJSON(a.path), a.tubularSegments, a.radius, a.radialSegments, a.closed);
                break;
              case "LatheGeometry":
              case "LatheBufferGeometry":
                o = new pd[a.type](a.points, a.segments, a.phiStart, a.phiLength);
                break;
              case "PolyhedronGeometry":
              case "PolyhedronBufferGeometry":
                o = new pd[a.type](a.vertices, a.indices, a.radius, a.details);
                break;
              case "ShapeGeometry":
              case "ShapeBufferGeometry":
                r = [];
                for (let n = 0, i = a.shapes.length; n < i; n++) {
                  const t = e[a.shapes[n]];
                  r.push(t)
                }
                o = new pd[a.type](r, a.curveSegments);
                break;
              case "ExtrudeGeometry":
              case "ExtrudeBufferGeometry":
                r = [];
                for (let n = 0, i = a.shapes.length; n < i; n++) {
                  const t = e[a.shapes[n]];
                  r.push(t)
                }
                const t = a.options.extrudePath;
                void 0 !== t && (a.options.extrudePath = (new Sm[t.type]).fromJSON(t)), o = new pd[a.type](r, a.options);
                break;
              case "BufferGeometry":
              case "InstancedBufferGeometry":
                o = i.parse(a);
                break;
              case "Geometry":
                console.error('THREE.ObjectLoader: Loading "Geometry" is not supported anymore.');
                break;
              default:
                console.warn('THREE.ObjectLoader: Unsupported geometry type "' + a.type + '"');
                continue
            }
            o.uuid = a.uuid, void 0 !== a.name && (o.name = a.name), !0 === o.isBufferGeometry && void 0 !== a.userData && (o.userData = a.userData), n[a.uuid] = o
          }
        }
        return n
      }
      parseMaterials(t, e) {
        const n = {},
          r = {};
        if (void 0 !== t) {
          const i = new Ym;
          i.setTextures(e);
          for (let e = 0, s = t.length; e < s; e++) {
            const s = t[e];
            if ("MultiMaterial" === s.type) {
              const t = [];
              for (let e = 0; e < s.materials.length; e++) {
                const r = s.materials[e];
                void 0 === n[r.uuid] && (n[r.uuid] = i.parse(r)), t.push(n[r.uuid])
              }
              r[s.uuid] = t
            } else void 0 === n[s.uuid] && (n[s.uuid] = i.parse(s)), r[s.uuid] = n[s.uuid]
          }
        }
        return r
      }
      parseAnimations(t) {
        const e = {};
        if (void 0 !== t)
          for (let n = 0; n < t.length; n++) {
            const r = t[n],
              i = zd.parse(r);
            e[i.uuid] = i
          }
        return e
      }
      parseImages(t, e) {
        const n = this,
          r = {};
        let i;

        function s(t) {
          if ("string" == typeof t) {
            const e = t;
            return function(t) {
              return n.manager.itemStart(t), i.load(t, function() {
                n.manager.itemEnd(t)
              }, void 0, function() {
                n.manager.itemError(t), n.manager.itemEnd(t)
              })
            }(/^(\/\/)|([a-z]+:(\/\/)?)/i.test(e) ? e : n.resourcePath + e)
          }
          return t.data ? {
            data: ss(t.type, t.data),
            width: t.width,
            height: t.height
          } : null
        }
        if (void 0 !== t && t.length > 0) {
          const n = new Ud(e);
          (i = new Yd(n)).setCrossOrigin(this.crossOrigin);
          for (let e = 0, i = t.length; e < i; e++) {
            const n = t[e],
              i = n.url;
            if (Array.isArray(i)) {
              r[n.uuid] = [];
              for (let t = 0, e = i.length; t < e; t++) {
                const e = s(i[t]);
                null !== e && (e instanceof HTMLImageElement ? r[n.uuid].push(e) : r[n.uuid].push(new Ys(e.data, e.width, e.height)))
              }
            } else {
              const t = s(n.url);
              null !== t && (r[n.uuid] = t)
            }
          }
        }
        return r
      }
      parseTextures(t, e) {
        function n(t, e) {
          return "number" == typeof t ? t : (console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.", t), e[t])
        }
        const r = {};
        if (void 0 !== t)
          for (let i = 0, s = t.length; i < s; i++) {
            const s = t[i];
            let o;
            void 0 === s.image && console.warn('THREE.ObjectLoader: No "image" specified for', s.uuid), void 0 === e[s.image] && console.warn("THREE.ObjectLoader: Undefined image", s.image);
            const a = e[s.image];
            Array.isArray(a) ? (o = new qs(a), 6 === a.length && (o.needsUpdate = !0)) : (o = a && a.data ? new Ys(a.data, a.width, a.height) : new hr(a), a && (o.needsUpdate = !0)), o.uuid = s.uuid, void 0 !== s.name && (o.name = s.name), void 0 !== s.mapping && (o.mapping = n(s.mapping, tf)), void 0 !== s.offset && o.offset.fromArray(s.offset), void 0 !== s.repeat && o.repeat.fromArray(s.repeat), void 0 !== s.center && o.center.fromArray(s.center), void 0 !== s.rotation && (o.rotation = s.rotation), void 0 !== s.wrap && (o.wrapS = n(s.wrap[0], ef), o.wrapT = n(s.wrap[1], ef)), void 0 !== s.format && (o.format = s.format), void 0 !== s.type && (o.type = s.type), void 0 !== s.encoding && (o.encoding = s.encoding), void 0 !== s.minFilter && (o.minFilter = n(s.minFilter, nf)), void 0 !== s.magFilter && (o.magFilter = n(s.magFilter, nf)), void 0 !== s.anisotropy && (o.anisotropy = s.anisotropy), void 0 !== s.flipY && (o.flipY = s.flipY), void 0 !== s.premultiplyAlpha && (o.premultiplyAlpha = s.premultiplyAlpha), void 0 !== s.unpackAlignment && (o.unpackAlignment = s.unpackAlignment), r[s.uuid] = o
          }
        return r
      }
      parseObject(t, e, n, r) {
        let i, s, o;

        function a(t) {
          return void 0 === e[t] && console.warn("THREE.ObjectLoader: Undefined geometry", t), e[t]
        }

        function l(t) {
          if (void 0 !== t) {
            if (Array.isArray(t)) {
              const e = [];
              for (let r = 0, i = t.length; r < i; r++) {
                const i = t[r];
                void 0 === n[i] && console.warn("THREE.ObjectLoader: Undefined material", i), e.push(n[i])
              }
              return e
            }
            return void 0 === n[t] && console.warn("THREE.ObjectLoader: Undefined material", t), n[t]
          }
        }
        switch (t.type) {
          case "Scene":
            i = new Kh, void 0 !== t.background && Number.isInteger(t.background) && (i.background = new ki(t.background)), void 0 !== t.fog && ("Fog" === t.fog.type ? i.fog = new Qh(t.fog.color, t.fog.near, t.fog.far) : "FogExp2" === t.fog.type && (i.fog = new Jh(t.fog.color, t.fog.density)));
            break;
          case "PerspectiveCamera":
            i = new ks(t.fov, t.aspect, t.near, t.far), void 0 !== t.focus && (i.focus = t.focus), void 0 !== t.zoom && (i.zoom = t.zoom), void 0 !== t.filmGauge && (i.filmGauge = t.filmGauge), void 0 !== t.filmOffset && (i.filmOffset = t.filmOffset), void 0 !== t.view && (i.view = Object.assign({}, t.view));
            break;
          case "OrthographicCamera":
            i = new Um(t.left, t.right, t.top, t.bottom, t.near, t.far), void 0 !== t.zoom && (i.zoom = t.zoom), void 0 !== t.view && (i.view = Object.assign({}, t.view));
            break;
          case "AmbientLight":
            i = new Wm(t.color, t.intensity);
            break;
          case "DirectionalLight":
            i = new Vm(t.color, t.intensity);
            break;
          case "PointLight":
            i = new Hm(t.color, t.intensity, t.distance, t.decay);
            break;
          case "RectAreaLight":
            i = new jm(t.color, t.intensity, t.width, t.height);
            break;
          case "SpotLight":
            i = new Nm(t.color, t.intensity, t.distance, t.angle, t.penumbra, t.decay);
            break;
          case "HemisphereLight":
            i = new Rm(t.color, t.groundColor, t.intensity);
            break;
          case "LightProbe":
            i = (new Xm).fromJSON(t);
            break;
          case "SkinnedMesh":
            s = a(t.geometry), o = l(t.material), i = new Eu(s, o), void 0 !== t.bindMode && (i.bindMode = t.bindMode), void 0 !== t.bindMatrix && i.bindMatrix.fromArray(t.bindMatrix), void 0 !== t.skeleton && (i.skeleton = t.skeleton);
            break;
          case "Mesh":
            s = a(t.geometry), o = l(t.material), i = new Ps(s, o);
            break;
          case "InstancedMesh":
            s = a(t.geometry), o = l(t.material);
            const e = t.count,
              n = t.instanceMatrix,
              r = t.instanceColor;
            (i = new Nu(s, o, e)).instanceMatrix = new qi(new Float32Array(n.array), 16), void 0 !== r && (i.instanceColor = new qi(new Float32Array(r.array), r.itemSize));
            break;
          case "LOD":
            i = new _u;
            break;
          case "Line":
            i = new ku(a(t.geometry), l(t.material));
            break;
          case "LineLoop":
            i = new qu(a(t.geometry), l(t.material));
            break;
          case "LineSegments":
            i = new ju(a(t.geometry), l(t.material));
            break;
          case "PointCloud":
          case "Points":
            i = new Ku(a(t.geometry), l(t.material));
            break;
          case "Sprite":
            i = new gu(l(t.material));
            break;
          case "Group":
            i = new kh;
            break;
          case "Bone":
            i = new Au;
            break;
          default:
            i = new vi
        }
        if (i.uuid = t.uuid, void 0 !== t.name && (i.name = t.name), void 0 !== t.matrix ? (i.matrix.fromArray(t.matrix), void 0 !== t.matrixAutoUpdate && (i.matrixAutoUpdate = t.matrixAutoUpdate), i.matrixAutoUpdate && i.matrix.decompose(i.position, i.quaternion, i.scale)) : (void 0 !== t.position && i.position.fromArray(t.position), void 0 !== t.rotation && i.rotation.fromArray(t.rotation), void 0 !== t.quaternion && i.quaternion.fromArray(t.quaternion), void 0 !== t.scale && i.scale.fromArray(t.scale)), void 0 !== t.castShadow && (i.castShadow = t.castShadow), void 0 !== t.receiveShadow && (i.receiveShadow = t.receiveShadow), t.shadow && (void 0 !== t.shadow.bias && (i.shadow.bias = t.shadow.bias), void 0 !== t.shadow.normalBias && (i.shadow.normalBias = t.shadow.normalBias), void 0 !== t.shadow.radius && (i.shadow.radius = t.shadow.radius), void 0 !== t.shadow.mapSize && i.shadow.mapSize.fromArray(t.shadow.mapSize), void 0 !== t.shadow.camera && (i.shadow.camera = this.parseObject(t.shadow.camera))), void 0 !== t.visible && (i.visible = t.visible), void 0 !== t.frustumCulled && (i.frustumCulled = t.frustumCulled), void 0 !== t.renderOrder && (i.renderOrder = t.renderOrder), void 0 !== t.userData && (i.userData = t.userData), void 0 !== t.layers && (i.layers.mask = t.layers), void 0 !== t.children) {
          const s = t.children;
          for (let t = 0; t < s.length; t++) i.add(this.parseObject(s[t], e, n, r))
        }
        if (void 0 !== t.animations) {
          const e = t.animations;
          for (let t = 0; t < e.length; t++) {
            const n = e[t];
            i.animations.push(r[n])
          }
        }
        if ("LOD" === t.type) {
          void 0 !== t.autoUpdate && (i.autoUpdate = t.autoUpdate);
          const e = t.levels;
          for (let t = 0; t < e.length; t++) {
            const n = e[t],
              r = i.getObjectByProperty("uuid", n.object);
            void 0 !== r && i.addLevel(r, n.distance)
          }
        }
        return i
      }
      bindSkeletons(t, e) {
        0 !== Object.keys(e).length && t.traverse(function(t) {
          if (!0 === t.isSkinnedMesh && void 0 !== t.skeleton) {
            const n = e[t.skeleton];
            void 0 === n ? console.warn("THREE.ObjectLoader: No skeleton found with UUID:", t.skeleton) : t.bind(n, t.bindMatrix)
          }
        })
      }
      setTexturePath(t) {
        return console.warn("THREE.ObjectLoader: .setTexturePath() has been renamed to .setResourcePath()."), this.setResourcePath(t)
      }
    }
    exports.ObjectLoader = $m;
    const tf = {
        UVMapping: et,
        CubeReflectionMapping: nt,
        CubeRefractionMapping: rt,
        EquirectangularReflectionMapping: it,
        EquirectangularRefractionMapping: st,
        CubeUVReflectionMapping: ot,
        CubeUVRefractionMapping: at
      },
      ef = {
        RepeatWrapping: lt,
        ClampToEdgeWrapping: ct,
        MirroredRepeatWrapping: ht
      },
      nf = {
        NearestFilter: ut,
        NearestMipmapNearestFilter: pt,
        NearestMipmapLinearFilter: mt,
        LinearFilter: gt,
        LinearMipmapNearestFilter: xt,
        LinearMipmapLinearFilter: yt
      };
    class rf extends Vd {
      constructor(t) {
        super(t), "undefined" == typeof createImageBitmap && console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."), "undefined" == typeof fetch && console.warn("THREE.ImageBitmapLoader: fetch() not supported."), this.options = {
          premultiplyAlpha: "none"
        }
      }
      setOptions(t) {
        return this.options = t, this
      }
      load(t, e, n, r) {
        void 0 === t && (t = ""), void 0 !== this.path && (t = this.path + t), t = this.manager.resolveURL(t);
        const i = this,
          s = Hd.get(t);
        if (void 0 !== s) return i.manager.itemStart(t), setTimeout(function() {
          e && e(s), i.manager.itemEnd(t)
        }, 0), s;
        const o = {};
        o.credentials = "anonymous" === this.crossOrigin ? "same-origin" : "include", o.headers = this.requestHeader, fetch(t, o).then(function(t) {
          return t.blob()
        }).then(function(t) {
          return createImageBitmap(t, Object.assign(i.options, {
            colorSpaceConversion: "none"
          }))
        }).then(function(n) {
          Hd.add(t, n), e && e(n), i.manager.itemEnd(t)
        }).catch(function(e) {
          r && r(e), i.manager.itemError(t), i.manager.itemEnd(t)
        }), i.manager.itemStart(t)
      }
    }
    exports.ImageBitmapLoader = rf, rf.prototype.isImageBitmapLoader = !0;
    class sf {
      constructor() {
        this.type = "ShapePath", this.color = new ki, this.subPaths = [], this.currentPath = null
      }
      moveTo(t, e) {
        return this.currentPath = new Em, this.subPaths.push(this.currentPath), this.currentPath.moveTo(t, e), this
      }
      lineTo(t, e) {
        return this.currentPath.lineTo(t, e), this
      }
      quadraticCurveTo(t, e, n, r) {
        return this.currentPath.quadraticCurveTo(t, e, n, r), this
      }
      bezierCurveTo(t, e, n, r, i, s) {
        return this.currentPath.bezierCurveTo(t, e, n, r, i, s), this
      }
      splineThru(t) {
        return this.currentPath.splineThru(t), this
      }
      toShapes(t, e) {
        function n(t) {
          const e = [];
          for (let n = 0, r = t.length; n < r; n++) {
            const r = t[n],
              i = new Am;
            i.curves = r.curves, e.push(i)
          }
          return e
        }

        function r(t, e) {
          const n = e.length;
          let r = !1;
          for (let i = n - 1, s = 0; s < n; i = s++) {
            let n = e[i],
              o = e[s],
              a = o.x - n.x,
              l = o.y - n.y;
            if (Math.abs(l) > Number.EPSILON) {
              if (l < 0 && (n = e[s], a = -a, o = e[i], l = -l), t.y < n.y || t.y > o.y) continue;
              if (t.y === n.y) {
                if (t.x === n.x) return !0
              } else {
                const e = l * (t.x - n.x) - a * (t.y - n.y);
                if (0 === e) return !0;
                if (e < 0) continue;
                r = !r
              }
            } else {
              if (t.y !== n.y) continue;
              if (o.x <= t.x && t.x <= n.x || n.x <= t.x && t.x <= o.x) return !0
            }
          }
          return r
        }
        const i = qp.isClockWise,
          s = this.subPaths;
        if (0 === s.length) return [];
        if (!0 === e) return n(s);
        let o, a, l;
        const c = [];
        if (1 === s.length) return a = s[0], (l = new Am).curves = a.curves, c.push(l), c;
        let h = !i(s[0].getPoints());
        h = t ? !h : h;
        const u = [],
          p = [];
        let d, m, f = [],
          g = 0;
        p[g] = void 0, f[g] = [];
        for (let x = 0, v = s.length; x < v; x++) o = i(d = (a = s[x]).getPoints()), (o = t ? !o : o) ? (!h && p[g] && g++, p[g] = {
          s: new Am,
          p: d
        }, p[g].s.curves = a.curves, h && g++, f[g] = []) : f[g].push({
          h: a,
          p: d[0]
        });
        if (!p[0]) return n(s);
        if (p.length > 1) {
          let t = !1;
          const e = [];
          for (let n = 0, r = p.length; n < r; n++) u[n] = [];
          for (let n = 0, i = p.length; n < i; n++) {
            const i = f[n];
            for (let s = 0; s < i.length; s++) {
              const o = i[s];
              let a = !0;
              for (let i = 0; i < p.length; i++) r(o.p, p[i].p) && (n !== i && e.push({
                froms: n,
                tos: i,
                hole: s
              }), a ? (a = !1, u[i].push(o)) : t = !0);
              a && u[n].push(o)
            }
          }
          e.length > 0 && (t || (f = u))
        }
        for (let x = 0, v = p.length; x < v; x++) {
          l = p[x].s, c.push(l);
          for (let t = 0, e = (m = f[x]).length; t < e; t++) l.holes.push(m[t].h)
        }
        return c
      }
    }
    exports.ShapePath = sf;
    class of {
      constructor(t) {
        this.type = "Font", this.data = t
      }
      generateShapes(t, e = 100) {
        const n = [],
          r = af(t, e, this.data);
        for (let i = 0, s = r.length; i < s; i++) Array.prototype.push.apply(n, r[i].toShapes());
        return n
      }
    }

    function af(t, e, n) {
      const r = Array.from(t),
        i = e / n.resolution,
        s = (n.boundingBox.yMax - n.boundingBox.yMin + n.underlineThickness) * i,
        o = [];
      let a = 0,
        l = 0;
      for (let c = 0; c < r.length; c++) {
        const t = r[c];
        if ("\n" === t) a = 0, l -= s;
        else {
          const e = lf(t, i, a, l, n);
          a += e.offsetX, o.push(e.path)
        }
      }
      return o
    }

    function lf(t, e, n, r, i) {
      const s = i.glyphs[t] || i.glyphs["?"];
      if (!s) return void console.error('THREE.Font: character "' + t + '" does not exists in font family ' + i.familyName + ".");
      const o = new sf;
      let a, l, c, h, u, p, d, m;
      if (s.o) {
        const t = s._cachedOutline || (s._cachedOutline = s.o.split(" "));
        for (let i = 0, s = t.length; i < s;) {
          switch (t[i++]) {
            case "m":
              a = t[i++] * e + n, l = t[i++] * e + r, o.moveTo(a, l);
              break;
            case "l":
              a = t[i++] * e + n, l = t[i++] * e + r, o.lineTo(a, l);
              break;
            case "q":
              c = t[i++] * e + n, h = t[i++] * e + r, u = t[i++] * e + n, p = t[i++] * e + r, o.quadraticCurveTo(u, p, c, h);
              break;
            case "b":
              c = t[i++] * e + n, h = t[i++] * e + r, u = t[i++] * e + n, p = t[i++] * e + r, d = t[i++] * e + n, m = t[i++] * e + r, o.bezierCurveTo(u, p, d, m, c, h)
          }
        }
      }
      return {
        offsetX: s.ha * e,
        path: o
      }
    }
    exports.Font = of , of .prototype.isFont = !0;
    class cf extends Vd {
      constructor(t) {
        super(t)
      }
      load(t, e, n, r) {
        const i = this,
          s = new jd(this.manager);
        s.setPath(this.path), s.setRequestHeader(this.requestHeader), s.setWithCredentials(i.withCredentials), s.load(t, function(t) {
          let n;
          try {
            n = JSON.parse(t)
          } catch (s) {
            console.warn("THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead."), n = JSON.parse(t.substring(65, t.length - 2))
          }
          const r = i.parse(n);
          e && e(r)
        }, n, r)
      }
      parse(t) {
        return new of (t)
      }
    }
    let hf;
    exports.FontLoader = cf;
    const uf = {
      getContext: function() {
        return void 0 === hf && (hf = new(window.AudioContext || window.webkitAudioContext)), hf
      },
      setContext: function(t) {
        hf = t
      }
    };
    exports.AudioContext = uf;
    class pf extends Vd {
      constructor(t) {
        super(t)
      }
      load(t, e, n, r) {
        const i = this,
          s = new jd(this.manager);
        s.setResponseType("arraybuffer"), s.setPath(this.path), s.setRequestHeader(this.requestHeader), s.setWithCredentials(this.withCredentials), s.load(t, function(n) {
          try {
            const o = n.slice(0);
            uf.getContext().decodeAudioData(o, function(t) {
              e(t)
            })
          } catch (s) {
            r ? r(s) : console.error(s), i.manager.itemError(t)
          }
        }, n, r)
      }
    }
    exports.AudioLoader = pf;
    class df extends Xm {
      constructor(t, e, n = 1) {
        super(void 0, n);
        const r = (new ki).set(t),
          i = (new ki).set(e),
          s = new gr(r.r, r.g, r.b),
          o = new gr(i.r, i.g, i.b),
          a = Math.sqrt(Math.PI),
          l = a * Math.sqrt(.75);
        this.sh.coefficients[0].copy(s).add(o).multiplyScalar(a), this.sh.coefficients[1].copy(s).sub(o).multiplyScalar(l)
      }
    }
    exports.HemisphereLightProbe = df, df.prototype.isHemisphereLightProbe = !0;
    class mf extends Xm {
      constructor(t, e = 1) {
        super(void 0, e);
        const n = (new ki).set(t);
        this.sh.coefficients[0].set(n.r, n.g, n.b).multiplyScalar(2 * Math.sqrt(Math.PI))
      }
    }
    exports.AmbientLightProbe = mf, mf.prototype.isAmbientLightProbe = !0;
    const ff = new Xr,
      gf = new Xr;
    class xf {
      constructor() {
        this.type = "StereoCamera", this.aspect = 1, this.eyeSep = .064, this.cameraL = new ks, this.cameraL.layers.enable(1), this.cameraL.matrixAutoUpdate = !1, this.cameraR = new ks, this.cameraR.layers.enable(2), this.cameraR.matrixAutoUpdate = !1, this._cache = {
          focus: null,
          fov: null,
          aspect: null,
          near: null,
          far: null,
          zoom: null,
          eyeSep: null
        }
      }
      update(t) {
        const e = this._cache;
        if (e.focus !== t.focus || e.fov !== t.fov || e.aspect !== t.aspect * this.aspect || e.near !== t.near || e.far !== t.far || e.zoom !== t.zoom || e.eyeSep !== this.eyeSep) {
          e.focus = t.focus, e.fov = t.fov, e.aspect = t.aspect * this.aspect, e.near = t.near, e.far = t.far, e.zoom = t.zoom, e.eyeSep = this.eyeSep;
          const n = t.projectionMatrix.clone(),
            r = e.eyeSep / 2,
            i = r * e.near / e.focus,
            s = e.near * Math.tan(Fn * e.fov * .5) / e.zoom;
          let o, a;
          gf.elements[12] = -r, ff.elements[12] = r, o = -s * e.aspect + i, a = s * e.aspect + i, n.elements[0] = 2 * e.near / (a - o), n.elements[8] = (a + o) / (a - o), this.cameraL.projectionMatrix.copy(n), o = -s * e.aspect - i, a = s * e.aspect - i, n.elements[0] = 2 * e.near / (a - o), n.elements[8] = (a + o) / (a - o), this.cameraR.projectionMatrix.copy(n)
        }
        this.cameraL.matrixWorld.copy(t.matrixWorld).multiply(gf), this.cameraR.matrixWorld.copy(t.matrixWorld).multiply(ff)
      }
    }
    exports.StereoCamera = xf;
    class vf {
      constructor(t = !0) {
        this.autoStart = t, this.startTime = 0, this.oldTime = 0, this.elapsedTime = 0, this.running = !1
      }
      start() {
        this.startTime = yf(), this.oldTime = this.startTime, this.elapsedTime = 0, this.running = !0
      }
      stop() {
        this.getElapsedTime(), this.running = !1, this.autoStart = !1
      }
      getElapsedTime() {
        return this.getDelta(), this.elapsedTime
      }
      getDelta() {
        let t = 0;
        if (this.autoStart && !this.running) return this.start(), 0;
        if (this.running) {
          const e = yf();
          t = (e - this.oldTime) / 1e3, this.oldTime = e, this.elapsedTime += t
        }
        return t
      }
    }

    function yf() {
      return ("undefined" == typeof performance ? Date : performance).now()
    }
    exports.Clock = vf;
    const _f = new gr,
      bf = new fr,
      wf = new gr,
      Mf = new gr;
    class Sf extends vi {
      constructor() {
        super(), this.type = "AudioListener", this.context = uf.getContext(), this.gain = this.context.createGain(), this.gain.connect(this.context.destination), this.filter = null, this.timeDelta = 0, this._clock = new vf
      }
      getInput() {
        return this.gain
      }
      removeFilter() {
        return null !== this.filter && (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination), this.gain.connect(this.context.destination), this.filter = null), this
      }
      getFilter() {
        return this.filter
      }
      setFilter(t) {
        return null !== this.filter ? (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination)) : this.gain.disconnect(this.context.destination), this.filter = t, this.gain.connect(this.filter), this.filter.connect(this.context.destination), this
      }
      getMasterVolume() {
        return this.gain.gain.value
      }
      setMasterVolume(t) {
        return this.gain.gain.setTargetAtTime(t, this.context.currentTime, .01), this
      }
      updateMatrixWorld(t) {
        super.updateMatrixWorld(t);
        const e = this.context.listener,
          n = this.up;
        if (this.timeDelta = this._clock.getDelta(), this.matrixWorld.decompose(_f, bf, wf), Mf.set(0, 0, -1).applyQuaternion(bf), e.positionX) {
          const t = this.context.currentTime + this.timeDelta;
          e.positionX.linearRampToValueAtTime(_f.x, t), e.positionY.linearRampToValueAtTime(_f.y, t), e.positionZ.linearRampToValueAtTime(_f.z, t), e.forwardX.linearRampToValueAtTime(Mf.x, t), e.forwardY.linearRampToValueAtTime(Mf.y, t), e.forwardZ.linearRampToValueAtTime(Mf.z, t), e.upX.linearRampToValueAtTime(n.x, t), e.upY.linearRampToValueAtTime(n.y, t), e.upZ.linearRampToValueAtTime(n.z, t)
        } else e.setPosition(_f.x, _f.y, _f.z), e.setOrientation(Mf.x, Mf.y, Mf.z, n.x, n.y, n.z)
      }
    }
    exports.AudioListener = Sf;
    class Tf extends vi {
      constructor(t) {
        super(), this.type = "Audio", this.listener = t, this.context = t.context, this.gain = this.context.createGain(), this.gain.connect(t.getInput()), this.autoplay = !1, this.buffer = null, this.detune = 0, this.loop = !1, this.loopStart = 0, this.loopEnd = 0, this.offset = 0, this.duration = void 0, this.playbackRate = 1, this.isPlaying = !1, this.hasPlaybackControl = !0, this.source = null, this.sourceType = "empty", this._startedAt = 0, this._progress = 0, this._connected = !1, this.filters = []
      }
      getOutput() {
        return this.gain
      }
      setNodeSource(t) {
        return this.hasPlaybackControl = !1, this.sourceType = "audioNode", this.source = t, this.connect(), this
      }
      setMediaElementSource(t) {
        return this.hasPlaybackControl = !1, this.sourceType = "mediaNode", this.source = this.context.createMediaElementSource(t), this.connect(), this
      }
      setMediaStreamSource(t) {
        return this.hasPlaybackControl = !1, this.sourceType = "mediaStreamNode", this.source = this.context.createMediaStreamSource(t), this.connect(), this
      }
      setBuffer(t) {
        return this.buffer = t, this.sourceType = "buffer", this.autoplay && this.play(), this
      }
      play(t = 0) {
        if (!0 === this.isPlaying) return void console.warn("THREE.Audio: Audio is already playing.");
        if (!1 === this.hasPlaybackControl) return void console.warn("THREE.Audio: this Audio has no playback control.");
        this._startedAt = this.context.currentTime + t;
        const e = this.context.createBufferSource();
        return e.buffer = this.buffer, e.loop = this.loop, e.loopStart = this.loopStart, e.loopEnd = this.loopEnd, e.onended = this.onEnded.bind(this), e.start(this._startedAt, this._progress + this.offset, this.duration), this.isPlaying = !0, this.source = e, this.setDetune(this.detune), this.setPlaybackRate(this.playbackRate), this.connect()
      }
      pause() {
        if (!1 !== this.hasPlaybackControl) return !0 === this.isPlaying && (this._progress += Math.max(this.context.currentTime - this._startedAt, 0) * this.playbackRate, !0 === this.loop && (this._progress = this._progress % (this.duration || this.buffer.duration)), this.source.stop(), this.source.onended = null, this.isPlaying = !1), this;
        console.warn("THREE.Audio: this Audio has no playback control.")
      }
      stop() {
        if (!1 !== this.hasPlaybackControl) return this._progress = 0, this.source.stop(), this.source.onended = null, this.isPlaying = !1, this;
        console.warn("THREE.Audio: this Audio has no playback control.")
      }
      connect() {
        if (this.filters.length > 0) {
          this.source.connect(this.filters[0]);
          for (let t = 1, e = this.filters.length; t < e; t++) this.filters[t - 1].connect(this.filters[t]);
          this.filters[this.filters.length - 1].connect(this.getOutput())
        } else this.source.connect(this.getOutput());
        return this._connected = !0, this
      }
      disconnect() {
        if (this.filters.length > 0) {
          this.source.disconnect(this.filters[0]);
          for (let t = 1, e = this.filters.length; t < e; t++) this.filters[t - 1].disconnect(this.filters[t]);
          this.filters[this.filters.length - 1].disconnect(this.getOutput())
        } else this.source.disconnect(this.getOutput());
        return this._connected = !1, this
      }
      getFilters() {
        return this.filters
      }
      setFilters(t) {
        return t || (t = []), !0 === this._connected ? (this.disconnect(), this.filters = t.slice(), this.connect()) : this.filters = t.slice(), this
      }
      setDetune(t) {
        if (this.detune = t, void 0 !== this.source.detune) return !0 === this.isPlaying && this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, .01), this
      }
      getDetune() {
        return this.detune
      }
      getFilter() {
        return this.getFilters()[0]
      }
      setFilter(t) {
        return this.setFilters(t ? [t] : [])
      }
      setPlaybackRate(t) {
        if (!1 !== this.hasPlaybackControl) return this.playbackRate = t, !0 === this.isPlaying && this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, .01), this;
        console.warn("THREE.Audio: this Audio has no playback control.")
      }
      getPlaybackRate() {
        return this.playbackRate
      }
      onEnded() {
        this.isPlaying = !1
      }
      getLoop() {
        return !1 === this.hasPlaybackControl ? (console.warn("THREE.Audio: this Audio has no playback control."), !1) : this.loop
      }
      setLoop(t) {
        if (!1 !== this.hasPlaybackControl) return this.loop = t, !0 === this.isPlaying && (this.source.loop = this.loop), this;
        console.warn("THREE.Audio: this Audio has no playback control.")
      }
      setLoopStart(t) {
        return this.loopStart = t, this
      }
      setLoopEnd(t) {
        return this.loopEnd = t, this
      }
      getVolume() {
        return this.gain.gain.value
      }
      setVolume(t) {
        return this.gain.gain.setTargetAtTime(t, this.context.currentTime, .01), this
      }
    }
    exports.Audio = Tf;
    const Ef = new gr,
      Af = new fr,
      Lf = new gr,
      Rf = new gr;
    class Cf extends Tf {
      constructor(t) {
        super(t), this.panner = this.context.createPanner(), this.panner.panningModel = "HRTF", this.panner.connect(this.gain)
      }
      getOutput() {
        return this.panner
      }
      getRefDistance() {
        return this.panner.refDistance
      }
      setRefDistance(t) {
        return this.panner.refDistance = t, this
      }
      getRolloffFactor() {
        return this.panner.rolloffFactor
      }
      setRolloffFactor(t) {
        return this.panner.rolloffFactor = t, this
      }
      getDistanceModel() {
        return this.panner.distanceModel
      }
      setDistanceModel(t) {
        return this.panner.distanceModel = t, this
      }
      getMaxDistance() {
        return this.panner.maxDistance
      }
      setMaxDistance(t) {
        return this.panner.maxDistance = t, this
      }
      setDirectionalCone(t, e, n) {
        return this.panner.coneInnerAngle = t, this.panner.coneOuterAngle = e, this.panner.coneOuterGain = n, this
      }
      updateMatrixWorld(t) {
        if (super.updateMatrixWorld(t), !0 === this.hasPlaybackControl && !1 === this.isPlaying) return;
        this.matrixWorld.decompose(Ef, Af, Lf), Rf.set(0, 0, 1).applyQuaternion(Af);
        const e = this.panner;
        if (e.positionX) {
          const t = this.context.currentTime + this.listener.timeDelta;
          e.positionX.linearRampToValueAtTime(Ef.x, t), e.positionY.linearRampToValueAtTime(Ef.y, t), e.positionZ.linearRampToValueAtTime(Ef.z, t), e.orientationX.linearRampToValueAtTime(Rf.x, t), e.orientationY.linearRampToValueAtTime(Rf.y, t), e.orientationZ.linearRampToValueAtTime(Rf.z, t)
        } else e.setPosition(Ef.x, Ef.y, Ef.z), e.setOrientation(Rf.x, Rf.y, Rf.z)
      }
    }
    exports.PositionalAudio = Cf;
    class Pf {
      constructor(t, e = 2048) {
        this.analyser = t.context.createAnalyser(), this.analyser.fftSize = e, this.data = new Uint8Array(this.analyser.frequencyBinCount), t.getOutput().connect(this.analyser)
      }
      getFrequencyData() {
        return this.analyser.getByteFrequencyData(this.data), this.data
      }
      getAverageFrequency() {
        let t = 0;
        const e = this.getFrequencyData();
        for (let n = 0; n < e.length; n++) t += e[n];
        return t / e.length
      }
    }
    exports.AudioAnalyser = Pf;
    class Df {
      constructor(t, e, n) {
        let r, i, s;
        switch (this.binding = t, this.valueSize = n, e) {
          case "quaternion":
            r = this._slerp, i = this._slerpAdditive, s = this._setAdditiveIdentityQuaternion, this.buffer = new Float64Array(6 * n), this._workIndex = 5;
            break;
          case "string":
          case "bool":
            r = this._select, i = this._select, s = this._setAdditiveIdentityOther, this.buffer = new Array(5 * n);
            break;
          default:
            r = this._lerp, i = this._lerpAdditive, s = this._setAdditiveIdentityNumeric, this.buffer = new Float64Array(5 * n)
        }
        this._mixBufferRegion = r, this._mixBufferRegionAdditive = i, this._setIdentity = s, this._origIndex = 3, this._addIndex = 4, this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, this.useCount = 0, this.referenceCount = 0
      }
      accumulate(t, e) {
        const n = this.buffer,
          r = this.valueSize,
          i = t * r + r;
        let s = this.cumulativeWeight;
        if (0 === s) {
          for (let t = 0; t !== r; ++t) n[i + t] = n[t];
          s = e
        } else {
          const t = e / (s += e);
          this._mixBufferRegion(n, i, 0, t, r)
        }
        this.cumulativeWeight = s
      }
      accumulateAdditive(t) {
        const e = this.buffer,
          n = this.valueSize,
          r = n * this._addIndex;
        0 === this.cumulativeWeightAdditive && this._setIdentity(), this._mixBufferRegionAdditive(e, r, 0, t, n), this.cumulativeWeightAdditive += t
      }
      apply(t) {
        const e = this.valueSize,
          n = this.buffer,
          r = t * e + e,
          i = this.cumulativeWeight,
          s = this.cumulativeWeightAdditive,
          o = this.binding;
        if (this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, i < 1) {
          const t = e * this._origIndex;
          this._mixBufferRegion(n, r, t, 1 - i, e)
        }
        s > 0 && this._mixBufferRegionAdditive(n, r, this._addIndex * e, 1, e);
        for (let a = e, l = e + e; a !== l; ++a)
          if (n[a] !== n[a + e]) {
            o.setValue(n, r);
            break
          }
      }
      saveOriginalState() {
        const t = this.binding,
          e = this.buffer,
          n = this.valueSize,
          r = n * this._origIndex;
        t.getValue(e, r);
        for (let i = n, s = r; i !== s; ++i) e[i] = e[r + i % n];
        this._setIdentity(), this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0
      }
      restoreOriginalState() {
        const t = 3 * this.valueSize;
        this.binding.setValue(this.buffer, t)
      }
      _setAdditiveIdentityNumeric() {
        const t = this._addIndex * this.valueSize,
          e = t + this.valueSize;
        for (let n = t; n < e; n++) this.buffer[n] = 0
      }
      _setAdditiveIdentityQuaternion() {
        this._setAdditiveIdentityNumeric(), this.buffer[this._addIndex * this.valueSize + 3] = 1
      }
      _setAdditiveIdentityOther() {
        const t = this._origIndex * this.valueSize,
          e = this._addIndex * this.valueSize;
        for (let n = 0; n < this.valueSize; n++) this.buffer[e + n] = this.buffer[t + n]
      }
      _select(t, e, n, r, i) {
        if (r >= .5)
          for (let s = 0; s !== i; ++s) t[e + s] = t[n + s]
      }
      _slerp(t, e, n, r) {
        fr.slerpFlat(t, e, t, e, t, n, r)
      }
      _slerpAdditive(t, e, n, r, i) {
        const s = this._workIndex * i;
        fr.multiplyQuaternionsFlat(t, s, t, e, t, n), fr.slerpFlat(t, e, t, e, t, s, r)
      }
      _lerp(t, e, n, r, i) {
        const s = 1 - r;
        for (let o = 0; o !== i; ++o) {
          const i = e + o;
          t[i] = t[i] * s + t[n + o] * r
        }
      }
      _lerpAdditive(t, e, n, r, i) {
        for (let s = 0; s !== i; ++s) {
          const i = e + s;
          t[i] = t[i] + t[n + s] * r
        }
      }
    }
    exports.PropertyMixer = Df;
    const If = "\\[\\]\\.:\\/",
      Bf = new RegExp("[\\[\\]\\.:\\/]", "g"),
      Nf = "[^\\[\\]\\.:\\/]",
      Ff = "[^" + "\\[\\]\\.:\\/".replace("\\.", "") + "]",
      zf = /((?:WC+[\/:])*)/.source.replace("WC", Nf),
      Gf = /(WCOD+)?/.source.replace("WCOD", Ff),
      Of = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", Nf),
      Hf = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", Nf),
      Uf = new RegExp("^" + zf + Gf + Of + Hf + "$"),
      kf = ["material", "materials", "bones"];
    class Vf {
      constructor(t, e, n) {
        const r = n || Wf.parseTrackName(e);
        this._targetGroup = t, this._bindings = t.subscribe_(e, r)
      }
      getValue(t, e) {
        this.bind();
        const n = this._targetGroup.nCachedObjects_,
          r = this._bindings[n];
        void 0 !== r && r.getValue(t, e)
      }
      setValue(t, e) {
        const n = this._bindings;
        for (let r = this._targetGroup.nCachedObjects_, i = n.length; r !== i; ++r) n[r].setValue(t, e)
      }
      bind() {
        const t = this._bindings;
        for (let e = this._targetGroup.nCachedObjects_, n = t.length; e !== n; ++e) t[e].bind()
      }
      unbind() {
        const t = this._bindings;
        for (let e = this._targetGroup.nCachedObjects_, n = t.length; e !== n; ++e) t[e].unbind()
      }
    }
    class Wf {
      constructor(t, e, n) {
        this.path = e, this.parsedPath = n || Wf.parseTrackName(e), this.node = Wf.findNode(t, this.parsedPath.nodeName) || t, this.rootNode = t, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound
      }
      static create(t, e, n) {
        return t && t.isAnimationObjectGroup ? new Wf.Composite(t, e, n) : new Wf(t, e, n)
      }
      static sanitizeNodeName(t) {
        return t.replace(/\s/g, "_").replace(Bf, "")
      }
      static parseTrackName(t) {
        const e = Uf.exec(t);
        if (!e) throw new Error("PropertyBinding: Cannot parse trackName: " + t);
        const n = {
            nodeName: e[2],
            objectName: e[3],
            objectIndex: e[4],
            propertyName: e[5],
            propertyIndex: e[6]
          },
          r = n.nodeName && n.nodeName.lastIndexOf(".");
        if (void 0 !== r && -1 !== r) {
          const t = n.nodeName.substring(r + 1); - 1 !== kf.indexOf(t) && (n.nodeName = n.nodeName.substring(0, r), n.objectName = t)
        }
        if (null === n.propertyName || 0 === n.propertyName.length) throw new Error("PropertyBinding: can not parse propertyName from trackName: " + t);
        return n
      }
      static findNode(t, e) {
        if (!e || "" === e || "." === e || -1 === e || e === t.name || e === t.uuid) return t;
        if (t.skeleton) {
          const n = t.skeleton.getBoneByName(e);
          if (void 0 !== n) return n
        }
        if (t.children) {
          const n = function(t) {
              for (let r = 0; r < t.length; r++) {
                const i = t[r];
                if (i.name === e || i.uuid === e) return i;
                const s = n(i.children);
                if (s) return s
              }
              return null
            },
            r = n(t.children);
          if (r) return r
        }
        return null
      }
      _getValue_unavailable() {}
      _setValue_unavailable() {}
      _getValue_direct(t, e) {
        t[e] = this.node[this.propertyName]
      }
      _getValue_array(t, e) {
        const n = this.resolvedProperty;
        for (let r = 0, i = n.length; r !== i; ++r) t[e++] = n[r]
      }
      _getValue_arrayElement(t, e) {
        t[e] = this.resolvedProperty[this.propertyIndex]
      }
      _getValue_toArray(t, e) {
        this.resolvedProperty.toArray(t, e)
      }
      _setValue_direct(t, e) {
        this.targetObject[this.propertyName] = t[e]
      }
      _setValue_direct_setNeedsUpdate(t, e) {
        this.targetObject[this.propertyName] = t[e], this.targetObject.needsUpdate = !0
      }
      _setValue_direct_setMatrixWorldNeedsUpdate(t, e) {
        this.targetObject[this.propertyName] = t[e], this.targetObject.matrixWorldNeedsUpdate = !0
      }
      _setValue_array(t, e) {
        const n = this.resolvedProperty;
        for (let r = 0, i = n.length; r !== i; ++r) n[r] = t[e++]
      }
      _setValue_array_setNeedsUpdate(t, e) {
        const n = this.resolvedProperty;
        for (let r = 0, i = n.length; r !== i; ++r) n[r] = t[e++];
        this.targetObject.needsUpdate = !0
      }
      _setValue_array_setMatrixWorldNeedsUpdate(t, e) {
        const n = this.resolvedProperty;
        for (let r = 0, i = n.length; r !== i; ++r) n[r] = t[e++];
        this.targetObject.matrixWorldNeedsUpdate = !0
      }
      _setValue_arrayElement(t, e) {
        this.resolvedProperty[this.propertyIndex] = t[e]
      }
      _setValue_arrayElement_setNeedsUpdate(t, e) {
        this.resolvedProperty[this.propertyIndex] = t[e], this.targetObject.needsUpdate = !0
      }
      _setValue_arrayElement_setMatrixWorldNeedsUpdate(t, e) {
        this.resolvedProperty[this.propertyIndex] = t[e], this.targetObject.matrixWorldNeedsUpdate = !0
      }
      _setValue_fromArray(t, e) {
        this.resolvedProperty.fromArray(t, e)
      }
      _setValue_fromArray_setNeedsUpdate(t, e) {
        this.resolvedProperty.fromArray(t, e), this.targetObject.needsUpdate = !0
      }
      _setValue_fromArray_setMatrixWorldNeedsUpdate(t, e) {
        this.resolvedProperty.fromArray(t, e), this.targetObject.matrixWorldNeedsUpdate = !0
      }
      _getValue_unbound(t, e) {
        this.bind(), this.getValue(t, e)
      }
      _setValue_unbound(t, e) {
        this.bind(), this.setValue(t, e)
      }
      bind() {
        let t = this.node;
        const e = this.parsedPath,
          n = e.objectName,
          r = e.propertyName;
        let i = e.propertyIndex;
        if (t || (t = Wf.findNode(this.rootNode, e.nodeName) || this.rootNode, this.node = t), this.getValue = this._getValue_unavailable, this.setValue = this._setValue_unavailable, !t) return void console.error("THREE.PropertyBinding: Trying to update node for track: " + this.path + " but it wasn't found.");
        if (n) {
          let r = e.objectIndex;
          switch (n) {
            case "materials":
              if (!t.material) return void console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
              if (!t.material.materials) return void console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
              t = t.material.materials;
              break;
            case "bones":
              if (!t.skeleton) return void console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
              t = t.skeleton.bones;
              for (let e = 0; e < t.length; e++)
                if (t[e].name === r) {
                  r = e;
                  break
                } break;
            default:
              if (void 0 === t[n]) return void console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
              t = t[n]
          }
          if (void 0 !== r) {
            if (void 0 === t[r]) return void console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, t);
            t = t[r]
          }
        }
        const s = t[r];
        if (void 0 === s) {
          const n = e.nodeName;
          return void console.error("THREE.PropertyBinding: Trying to update property for track: " + n + "." + r + " but it wasn't found.", t)
        }
        let o = this.Versioning.None;
        this.targetObject = t, void 0 !== t.needsUpdate ? o = this.Versioning.NeedsUpdate : void 0 !== t.matrixWorldNeedsUpdate && (o = this.Versioning.MatrixWorldNeedsUpdate);
        let a = this.BindingType.Direct;
        if (void 0 !== i) {
          if ("morphTargetInfluences" === r) {
            if (!t.geometry) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
            if (!t.geometry.isBufferGeometry) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences on THREE.Geometry. Use THREE.BufferGeometry instead.", this);
            if (!t.geometry.morphAttributes) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
            void 0 !== t.morphTargetDictionary[i] && (i = t.morphTargetDictionary[i])
          }
          a = this.BindingType.ArrayElement, this.resolvedProperty = s, this.propertyIndex = i
        } else void 0 !== s.fromArray && void 0 !== s.toArray ? (a = this.BindingType.HasFromToArray, this.resolvedProperty = s) : Array.isArray(s) ? (a = this.BindingType.EntireArray, this.resolvedProperty = s) : this.propertyName = r;
        this.getValue = this.GetterByBindingType[a], this.setValue = this.SetterByBindingTypeAndVersioning[a][o]
      }
      unbind() {
        this.node = null, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound
      }
    }
    exports.PropertyBinding = Wf, Wf.Composite = Vf, Wf.prototype.BindingType = {
      Direct: 0,
      EntireArray: 1,
      ArrayElement: 2,
      HasFromToArray: 3
    }, Wf.prototype.Versioning = {
      None: 0,
      NeedsUpdate: 1,
      MatrixWorldNeedsUpdate: 2
    }, Wf.prototype.GetterByBindingType = [Wf.prototype._getValue_direct, Wf.prototype._getValue_array, Wf.prototype._getValue_arrayElement, Wf.prototype._getValue_toArray], Wf.prototype.SetterByBindingTypeAndVersioning = [
      [Wf.prototype._setValue_direct, Wf.prototype._setValue_direct_setNeedsUpdate, Wf.prototype._setValue_direct_setMatrixWorldNeedsUpdate],
      [Wf.prototype._setValue_array, Wf.prototype._setValue_array_setNeedsUpdate, Wf.prototype._setValue_array_setMatrixWorldNeedsUpdate],
      [Wf.prototype._setValue_arrayElement, Wf.prototype._setValue_arrayElement_setNeedsUpdate, Wf.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate],
      [Wf.prototype._setValue_fromArray, Wf.prototype._setValue_fromArray_setNeedsUpdate, Wf.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]
    ];
    class jf {
      constructor() {
        this.uuid = Gn(), this._objects = Array.prototype.slice.call(arguments), this.nCachedObjects_ = 0;
        const t = {};
        this._indicesByUUID = t;
        for (let n = 0, r = arguments.length; n !== r; ++n) t[arguments[n].uuid] = n;
        this._paths = [], this._parsedPaths = [], this._bindings = [], this._bindingsIndicesByPath = {};
        const e = this;
        this.stats = {
          objects: {
            get total() {
              return e._objects.length
            },
            get inUse() {
              return this.total - e.nCachedObjects_
            }
          },
          get bindingsPerObject() {
            return e._bindings.length
          }
        }
      }
      add() {
        const t = this._objects,
          e = this._indicesByUUID,
          n = this._paths,
          r = this._parsedPaths,
          i = this._bindings,
          s = i.length;
        let o = void 0,
          a = t.length,
          l = this.nCachedObjects_;
        for (let c = 0, h = arguments.length; c !== h; ++c) {
          const h = arguments[c],
            u = h.uuid;
          let p = e[u];
          if (void 0 === p) {
            p = a++, e[u] = p, t.push(h);
            for (let t = 0, e = s; t !== e; ++t) i[t].push(new Wf(h, n[t], r[t]))
          } else if (p < l) {
            o = t[p];
            const a = --l,
              c = t[a];
            e[c.uuid] = p, t[p] = c, e[u] = a, t[a] = h;
            for (let t = 0, e = s; t !== e; ++t) {
              const e = i[t],
                s = e[a];
              let o = e[p];
              e[p] = s, void 0 === o && (o = new Wf(h, n[t], r[t])), e[a] = o
            }
          } else t[p] !== o && console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.")
        }
        this.nCachedObjects_ = l
      }
      remove() {
        const t = this._objects,
          e = this._indicesByUUID,
          n = this._bindings,
          r = n.length;
        let i = this.nCachedObjects_;
        for (let s = 0, o = arguments.length; s !== o; ++s) {
          const o = arguments[s],
            a = o.uuid,
            l = e[a];
          if (void 0 !== l && l >= i) {
            const s = i++,
              c = t[s];
            e[c.uuid] = l, t[l] = c, e[a] = s, t[s] = o;
            for (let t = 0, e = r; t !== e; ++t) {
              const e = n[t],
                r = e[s],
                i = e[l];
              e[l] = r, e[s] = i
            }
          }
        }
        this.nCachedObjects_ = i
      }
      uncache() {
        const t = this._objects,
          e = this._indicesByUUID,
          n = this._bindings,
          r = n.length;
        let i = this.nCachedObjects_,
          s = t.length;
        for (let o = 0, a = arguments.length; o !== a; ++o) {
          const a = arguments[o].uuid,
            l = e[a];
          if (void 0 !== l)
            if (delete e[a], l < i) {
              const o = --i,
                a = t[o],
                c = --s,
                h = t[c];
              e[a.uuid] = l, t[l] = a, e[h.uuid] = o, t[o] = h, t.pop();
              for (let t = 0, e = r; t !== e; ++t) {
                const e = n[t],
                  r = e[o],
                  i = e[c];
                e[l] = r, e[o] = i, e.pop()
              }
            } else {
              const i = --s,
                o = t[i];
              i > 0 && (e[o.uuid] = l), t[l] = o, t.pop();
              for (let t = 0, e = r; t !== e; ++t) {
                const e = n[t];
                e[l] = e[i], e.pop()
              }
            }
        }
        this.nCachedObjects_ = i
      }
      subscribe_(t, e) {
        const n = this._bindingsIndicesByPath;
        let r = n[t];
        const i = this._bindings;
        if (void 0 !== r) return i[r];
        const s = this._paths,
          o = this._parsedPaths,
          a = this._objects,
          l = a.length,
          c = this.nCachedObjects_,
          h = new Array(l);
        r = i.length, n[t] = r, s.push(t), o.push(e), i.push(h);
        for (let u = c, p = a.length; u !== p; ++u) {
          const n = a[u];
          h[u] = new Wf(n, t, e)
        }
        return h
      }
      unsubscribe_(t) {
        const e = this._bindingsIndicesByPath,
          n = e[t];
        if (void 0 !== n) {
          const r = this._paths,
            i = this._parsedPaths,
            s = this._bindings,
            o = s.length - 1,
            a = s[o];
          e[t[o]] = n, s[n] = a, s.pop(), i[n] = i[o], i.pop(), r[n] = r[o], r.pop()
        }
      }
    }
    exports.AnimationObjectGroup = jf, jf.prototype.isAnimationObjectGroup = !0;
    class qf {
      constructor(t, e, n = null, r = e.blendMode) {
        this._mixer = t, this._clip = e, this._localRoot = n, this.blendMode = r;
        const i = e.tracks,
          s = i.length,
          o = new Array(s),
          a = {
            endingStart: Oe,
            endingEnd: Oe
          };
        for (let l = 0; l !== s; ++l) {
          const t = i[l].createInterpolant(null);
          o[l] = t, t.settings = a
        }
        this._interpolantSettings = a, this._interpolants = o, this._propertyBindings = new Array(s), this._cacheIndex = null, this._byClipCacheIndex = null, this._timeScaleInterpolant = null, this._weightInterpolant = null, this.loop = Be, this._loopCount = -1, this._startTime = null, this.time = 0, this.timeScale = 1, this._effectiveTimeScale = 1, this.weight = 1, this._effectiveWeight = 1, this.repetitions = 1 / 0, this.paused = !1, this.enabled = !0, this.clampWhenFinished = !1, this.zeroSlopeAtStart = !0, this.zeroSlopeAtEnd = !0
      }
      play() {
        return this._mixer._activateAction(this), this
      }
      stop() {
        return this._mixer._deactivateAction(this), this.reset()
      }
      reset() {
        return this.paused = !1, this.enabled = !0, this.time = 0, this._loopCount = -1, this._startTime = null, this.stopFading().stopWarping()
      }
      isRunning() {
        return this.enabled && !this.paused && 0 !== this.timeScale && null === this._startTime && this._mixer._isActiveAction(this)
      }
      isScheduled() {
        return this._mixer._isActiveAction(this)
      }
      startAt(t) {
        return this._startTime = t, this
      }
      setLoop(t, e) {
        return this.loop = t, this.repetitions = e, this
      }
      setEffectiveWeight(t) {
        return this.weight = t, this._effectiveWeight = this.enabled ? t : 0, this.stopFading()
      }
      getEffectiveWeight() {
        return this._effectiveWeight
      }
      fadeIn(t) {
        return this._scheduleFading(t, 0, 1)
      }
      fadeOut(t) {
        return this._scheduleFading(t, 1, 0)
      }
      crossFadeFrom(t, e, n) {
        if (t.fadeOut(e), this.fadeIn(e), n) {
          const n = this._clip.duration,
            r = t._clip.duration,
            i = r / n,
            s = n / r;
          t.warp(1, i, e), this.warp(s, 1, e)
        }
        return this
      }
      crossFadeTo(t, e, n) {
        return t.crossFadeFrom(this, e, n)
      }
      stopFading() {
        const t = this._weightInterpolant;
        return null !== t && (this._weightInterpolant = null, this._mixer._takeBackControlInterpolant(t)), this
      }
      setEffectiveTimeScale(t) {
        return this.timeScale = t, this._effectiveTimeScale = this.paused ? 0 : t, this.stopWarping()
      }
      getEffectiveTimeScale() {
        return this._effectiveTimeScale
      }
      setDuration(t) {
        return this.timeScale = this._clip.duration / t, this.stopWarping()
      }
      syncWith(t) {
        return this.time = t.time, this.timeScale = t.timeScale, this.stopWarping()
      }
      halt(t) {
        return this.warp(this._effectiveTimeScale, 0, t)
      }
      warp(t, e, n) {
        const r = this._mixer,
          i = r.time,
          s = this.timeScale;
        let o = this._timeScaleInterpolant;
        null === o && (o = r._lendControlInterpolant(), this._timeScaleInterpolant = o);
        const a = o.parameterPositions,
          l = o.sampleValues;
        return a[0] = i, a[1] = i + n, l[0] = t / s, l[1] = e / s, this
      }
      stopWarping() {
        const t = this._timeScaleInterpolant;
        return null !== t && (this._timeScaleInterpolant = null, this._mixer._takeBackControlInterpolant(t)), this
      }
      getMixer() {
        return this._mixer
      }
      getClip() {
        return this._clip
      }
      getRoot() {
        return this._localRoot || this._mixer._root
      }
      _update(t, e, n, r) {
        if (!this.enabled) return void this._updateWeight(t);
        const i = this._startTime;
        if (null !== i) {
          const r = (t - i) * n;
          if (r < 0 || 0 === n) return;
          this._startTime = null, e = n * r
        }
        e *= this._updateTimeScale(t);
        const s = this._updateTime(e),
          o = this._updateWeight(t);
        if (o > 0) {
          const t = this._interpolants,
            e = this._propertyBindings;
          switch (this.blendMode) {
            case Ve:
              for (let n = 0, r = t.length; n !== r; ++n) t[n].evaluate(s), e[n].accumulateAdditive(o);
              break;
            case ke:
            default:
              for (let n = 0, i = t.length; n !== i; ++n) t[n].evaluate(s), e[n].accumulate(r, o)
          }
        }
      }
      _updateWeight(t) {
        let e = 0;
        if (this.enabled) {
          e = this.weight;
          const n = this._weightInterpolant;
          if (null !== n) {
            const r = n.evaluate(t)[0];
            e *= r, t > n.parameterPositions[1] && (this.stopFading(), 0 === r && (this.enabled = !1))
          }
        }
        return this._effectiveWeight = e, e
      }
      _updateTimeScale(t) {
        let e = 0;
        if (!this.paused) {
          e = this.timeScale;
          const n = this._timeScaleInterpolant;
          if (null !== n) {
            e *= n.evaluate(t)[0], t > n.parameterPositions[1] && (this.stopWarping(), 0 === e ? this.paused = !0 : this.timeScale = e)
          }
        }
        return this._effectiveTimeScale = e, e
      }
      _updateTime(t) {
        const e = this._clip.duration,
          n = this.loop;
        let r = this.time + t,
          i = this._loopCount;
        const s = n === Ne;
        if (0 === t) return -1 === i ? r : s && 1 == (1 & i) ? e - r : r;
        if (n === Ie) {
          -1 === i && (this._loopCount = 0, this._setEndings(!0, !0, !1));
          t: {
            if (r >= e) r = e;
            else {
              if (!(r < 0)) {
                this.time = r;
                break t
              }
              r = 0
            }
            this.clampWhenFinished ? this.paused = !0 : this.enabled = !1,
            this.time = r,
            this._mixer.dispatchEvent({
              type: "finished",
              action: this,
              direction: t < 0 ? -1 : 1
            })
          }
        } else {
          if (-1 === i && (t >= 0 ? (i = 0, this._setEndings(!0, 0 === this.repetitions, s)) : this._setEndings(0 === this.repetitions, !0, s)), r >= e || r < 0) {
            const n = Math.floor(r / e);
            r -= e * n, i += Math.abs(n);
            const o = this.repetitions - i;
            if (o <= 0) this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, r = t > 0 ? e : 0, this.time = r, this._mixer.dispatchEvent({
              type: "finished",
              action: this,
              direction: t > 0 ? 1 : -1
            });
            else {
              if (1 === o) {
                const e = t < 0;
                this._setEndings(e, !e, s)
              } else this._setEndings(!1, !1, s);
              this._loopCount = i, this.time = r, this._mixer.dispatchEvent({
                type: "loop",
                action: this,
                loopDelta: n
              })
            }
          } else this.time = r;
          if (s && 1 == (1 & i)) return e - r
        }
        return r
      }
      _setEndings(t, e, n) {
        const r = this._interpolantSettings;
        n ? (r.endingStart = He, r.endingEnd = He) : (r.endingStart = t ? this.zeroSlopeAtStart ? He : Oe : Ue, r.endingEnd = e ? this.zeroSlopeAtEnd ? He : Oe : Ue)
      }
      _scheduleFading(t, e, n) {
        const r = this._mixer,
          i = r.time;
        let s = this._weightInterpolant;
        null === s && (s = r._lendControlInterpolant(), this._weightInterpolant = s);
        const o = s.parameterPositions,
          a = s.sampleValues;
        return o[0] = i, a[0] = e, o[1] = i + t, a[1] = n, this
      }
    }
    class Xf extends In {
      constructor(t) {
        super(), this._root = t, this._initMemoryManager(), this._accuIndex = 0, this.time = 0, this.timeScale = 1
      }
      _bindAction(t, e) {
        const n = t._localRoot || this._root,
          r = t._clip.tracks,
          i = r.length,
          s = t._propertyBindings,
          o = t._interpolants,
          a = n.uuid,
          l = this._bindingsByRootAndName;
        let c = l[a];
        void 0 === c && (c = {}, l[a] = c);
        for (let h = 0; h !== i; ++h) {
          const t = r[h],
            i = t.name;
          let l = c[i];
          if (void 0 !== l) s[h] = l;
          else {
            if (void 0 !== (l = s[h])) {
              null === l._cacheIndex && (++l.referenceCount, this._addInactiveBinding(l, a, i));
              continue
            }
            const r = e && e._propertyBindings[h].binding.parsedPath;
            ++(l = new Df(Wf.create(n, i, r), t.ValueTypeName, t.getValueSize())).referenceCount, this._addInactiveBinding(l, a, i), s[h] = l
          }
          o[h].resultBuffer = l.buffer
        }
      }
      _activateAction(t) {
        if (!this._isActiveAction(t)) {
          if (null === t._cacheIndex) {
            const e = (t._localRoot || this._root).uuid,
              n = t._clip.uuid,
              r = this._actionsByClip[n];
            this._bindAction(t, r && r.knownActions[0]), this._addInactiveAction(t, n, e)
          }
          const e = t._propertyBindings;
          for (let t = 0, n = e.length; t !== n; ++t) {
            const n = e[t];
            0 == n.useCount++ && (this._lendBinding(n), n.saveOriginalState())
          }
          this._lendAction(t)
        }
      }
      _deactivateAction(t) {
        if (this._isActiveAction(t)) {
          const e = t._propertyBindings;
          for (let t = 0, n = e.length; t !== n; ++t) {
            const n = e[t];
            0 == --n.useCount && (n.restoreOriginalState(), this._takeBackBinding(n))
          }
          this._takeBackAction(t)
        }
      }
      _initMemoryManager() {
        this._actions = [], this._nActiveActions = 0, this._actionsByClip = {}, this._bindings = [], this._nActiveBindings = 0, this._bindingsByRootAndName = {}, this._controlInterpolants = [], this._nActiveControlInterpolants = 0;
        const t = this;
        this.stats = {
          actions: {
            get total() {
              return t._actions.length
            },
            get inUse() {
              return t._nActiveActions
            }
          },
          bindings: {
            get total() {
              return t._bindings.length
            },
            get inUse() {
              return t._nActiveBindings
            }
          },
          controlInterpolants: {
            get total() {
              return t._controlInterpolants.length
            },
            get inUse() {
              return t._nActiveControlInterpolants
            }
          }
        }
      }
      _isActiveAction(t) {
        const e = t._cacheIndex;
        return null !== e && e < this._nActiveActions
      }
      _addInactiveAction(t, e, n) {
        const r = this._actions,
          i = this._actionsByClip;
        let s = i[e];
        if (void 0 === s) s = {
          knownActions: [t],
          actionByRoot: {}
        }, t._byClipCacheIndex = 0, i[e] = s;
        else {
          const e = s.knownActions;
          t._byClipCacheIndex = e.length, e.push(t)
        }
        t._cacheIndex = r.length, r.push(t), s.actionByRoot[n] = t
      }
      _removeInactiveAction(t) {
        const e = this._actions,
          n = e[e.length - 1],
          r = t._cacheIndex;
        n._cacheIndex = r, e[r] = n, e.pop(), t._cacheIndex = null;
        const i = t._clip.uuid,
          s = this._actionsByClip,
          o = s[i],
          a = o.knownActions,
          l = a[a.length - 1],
          c = t._byClipCacheIndex;
        l._byClipCacheIndex = c, a[c] = l, a.pop(), t._byClipCacheIndex = null, delete o.actionByRoot[(t._localRoot || this._root).uuid], 0 === a.length && delete s[i], this._removeInactiveBindingsForAction(t)
      }
      _removeInactiveBindingsForAction(t) {
        const e = t._propertyBindings;
        for (let n = 0, r = e.length; n !== r; ++n) {
          const t = e[n];
          0 == --t.referenceCount && this._removeInactiveBinding(t)
        }
      }
      _lendAction(t) {
        const e = this._actions,
          n = t._cacheIndex,
          r = this._nActiveActions++,
          i = e[r];
        t._cacheIndex = r, e[r] = t, i._cacheIndex = n, e[n] = i
      }
      _takeBackAction(t) {
        const e = this._actions,
          n = t._cacheIndex,
          r = --this._nActiveActions,
          i = e[r];
        t._cacheIndex = r, e[r] = t, i._cacheIndex = n, e[n] = i
      }
      _addInactiveBinding(t, e, n) {
        const r = this._bindingsByRootAndName,
          i = this._bindings;
        let s = r[e];
        void 0 === s && (s = {}, r[e] = s), s[n] = t, t._cacheIndex = i.length, i.push(t)
      }
      _removeInactiveBinding(t) {
        const e = this._bindings,
          n = t.binding,
          r = n.rootNode.uuid,
          i = n.path,
          s = this._bindingsByRootAndName,
          o = s[r],
          a = e[e.length - 1],
          l = t._cacheIndex;
        a._cacheIndex = l, e[l] = a, e.pop(), delete o[i], 0 === Object.keys(o).length && delete s[r]
      }
      _lendBinding(t) {
        const e = this._bindings,
          n = t._cacheIndex,
          r = this._nActiveBindings++,
          i = e[r];
        t._cacheIndex = r, e[r] = t, i._cacheIndex = n, e[n] = i
      }
      _takeBackBinding(t) {
        const e = this._bindings,
          n = t._cacheIndex,
          r = --this._nActiveBindings,
          i = e[r];
        t._cacheIndex = r, e[r] = t, i._cacheIndex = n, e[n] = i
      }
      _lendControlInterpolant() {
        const t = this._controlInterpolants,
          e = this._nActiveControlInterpolants++;
        let n = t[e];
        return void 0 === n && ((n = new Ad(new Float32Array(2), new Float32Array(2), 1, this._controlInterpolantsResultBuffer)).__cacheIndex = e, t[e] = n), n
      }
      _takeBackControlInterpolant(t) {
        const e = this._controlInterpolants,
          n = t.__cacheIndex,
          r = --this._nActiveControlInterpolants,
          i = e[r];
        t.__cacheIndex = r, e[r] = t, i.__cacheIndex = n, e[n] = i
      }
      clipAction(t, e, n) {
        const r = e || this._root,
          i = r.uuid;
        let s = "string" == typeof t ? zd.findByName(r, t) : t;
        const o = null !== s ? s.uuid : t,
          a = this._actionsByClip[o];
        let l = null;
        if (void 0 === n && (n = null !== s ? s.blendMode : ke), void 0 !== a) {
          const t = a.actionByRoot[i];
          if (void 0 !== t && t.blendMode === n) return t;
          l = a.knownActions[0], null === s && (s = l._clip)
        }
        if (null === s) return null;
        const c = new qf(this, s, e, n);
        return this._bindAction(c, l), this._addInactiveAction(c, o, i), c
      }
      existingAction(t, e) {
        const n = e || this._root,
          r = n.uuid,
          i = "string" == typeof t ? zd.findByName(n, t) : t,
          s = i ? i.uuid : t,
          o = this._actionsByClip[s];
        return void 0 !== o && o.actionByRoot[r] || null
      }
      stopAllAction() {
        const t = this._actions;
        for (let e = this._nActiveActions - 1; e >= 0; --e) t[e].stop();
        return this
      }
      update(t) {
        t *= this.timeScale;
        const e = this._actions,
          n = this._nActiveActions,
          r = this.time += t,
          i = Math.sign(t),
          s = this._accuIndex ^= 1;
        for (let l = 0; l !== n; ++l) {
          e[l]._update(r, t, i, s)
        }
        const o = this._bindings,
          a = this._nActiveBindings;
        for (let l = 0; l !== a; ++l) o[l].apply(s);
        return this
      }
      setTime(t) {
        this.time = 0;
        for (let e = 0; e < this._actions.length; e++) this._actions[e].time = 0;
        return this.update(t)
      }
      getRoot() {
        return this._root
      }
      uncacheClip(t) {
        const e = this._actions,
          n = t.uuid,
          r = this._actionsByClip,
          i = r[n];
        if (void 0 !== i) {
          const t = i.knownActions;
          for (let n = 0, r = t.length; n !== r; ++n) {
            const r = t[n];
            this._deactivateAction(r);
            const i = r._cacheIndex,
              s = e[e.length - 1];
            r._cacheIndex = null, r._byClipCacheIndex = null, s._cacheIndex = i, e[i] = s, e.pop(), this._removeInactiveBindingsForAction(r)
          }
          delete r[n]
        }
      }
      uncacheRoot(t) {
        const e = t.uuid,
          n = this._actionsByClip;
        for (const i in n) {
          const t = n[i].actionByRoot[e];
          void 0 !== t && (this._deactivateAction(t), this._removeInactiveAction(t))
        }
        const r = this._bindingsByRootAndName[e];
        if (void 0 !== r)
          for (const i in r) {
            const t = r[i];
            t.restoreOriginalState(), this._removeInactiveBinding(t)
          }
      }
      uncacheAction(t, e) {
        const n = this.existingAction(t, e);
        null !== n && (this._deactivateAction(n), this._removeInactiveAction(n))
      }
    }
    exports.AnimationMixer = Xf, Xf.prototype._controlInterpolantsResultBuffer = new Float32Array(1);
    class Yf {
      constructor(t) {
        "string" == typeof t && (console.warn("THREE.Uniform: Type parameter is no longer needed."), t = arguments[1]), this.value = t
      }
      clone() {
        return new Yf(void 0 === this.value.clone ? this.value : this.value.clone())
      }
    }
    exports.Uniform = Yf;
    class Zf extends $h {
      constructor(t, e, n = 1) {
        super(t, e), this.meshPerAttribute = n || 1
      }
      copy(t) {
        return super.copy(t), this.meshPerAttribute = t.meshPerAttribute, this
      }
      clone(t) {
        const e = super.clone(t);
        return e.meshPerAttribute = this.meshPerAttribute, e
      }
      toJSON(t) {
        const e = super.toJSON(t);
        return e.isInstancedInterleavedBuffer = !0, e.meshPerAttribute = this.meshPerAttribute, e
      }
    }
    exports.InstancedInterleavedBuffer = Zf, Zf.prototype.isInstancedInterleavedBuffer = !0;
    class Jf {
      constructor(t, e, n, r, i) {
        this.buffer = t, this.type = e, this.itemSize = n, this.elementSize = r, this.count = i, this.version = 0
      }
      set needsUpdate(t) {
        !0 === t && this.version++
      }
      setBuffer(t) {
        return this.buffer = t, this
      }
      setType(t, e) {
        return this.type = t, this.elementSize = e, this
      }
      setItemSize(t) {
        return this.itemSize = t, this
      }
      setCount(t) {
        return this.count = t, this
      }
    }
    exports.GLBufferAttribute = Jf, Jf.prototype.isGLBufferAttribute = !0;
    class Qf {
      constructor(t, e, n = 0, r = 1 / 0) {
        this.ray = new qr(t, e), this.near = n, this.far = r, this.camera = null, this.layers = new ii, this.params = {
          Mesh: {},
          Line: {
            threshold: 1
          },
          LOD: {},
          Points: {
            threshold: 1
          },
          Sprite: {}
        }
      }
      set(t, e) {
        this.ray.set(t, e)
      }
      setFromCamera(t, e) {
        e && e.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(e.matrixWorld), this.ray.direction.set(t.x, t.y, .5).unproject(e).sub(this.ray.origin).normalize(), this.camera = e) : e && e.isOrthographicCamera ? (this.ray.origin.set(t.x, t.y, (e.near + e.far) / (e.near - e.far)).unproject(e), this.ray.direction.set(0, 0, -1).transformDirection(e.matrixWorld), this.camera = e) : console.error("THREE.Raycaster: Unsupported camera type: " + e.type)
      }
      intersectObject(t, e = !1, n = []) {
        return $f(t, this, n, e), n.sort(Kf), n
      }
      intersectObjects(t, e = !1, n = []) {
        for (let r = 0, i = t.length; r < i; r++) $f(t[r], this, n, e);
        return n.sort(Kf), n
      }
    }

    function Kf(t, e) {
      return t.distance - e.distance
    }

    function $f(t, e, n, r) {
      if (t.layers.test(e.layers) && t.raycast(e, n), !0 === r) {
        const r = t.children;
        for (let t = 0, i = r.length; t < i; t++) $f(r[t], e, n, !0)
      }
    }
    exports.Raycaster = Qf;
    class tg {
      constructor(t = 1, e = 0, n = 0) {
        return this.radius = t, this.phi = e, this.theta = n, this
      }
      set(t, e, n) {
        return this.radius = t, this.phi = e, this.theta = n, this
      }
      copy(t) {
        return this.radius = t.radius, this.phi = t.phi, this.theta = t.theta, this
      }
      makeSafe() {
        return this.phi = Math.max(1e-6, Math.min(Math.PI - 1e-6, this.phi)), this
      }
      setFromVector3(t) {
        return this.setFromCartesianCoords(t.x, t.y, t.z)
      }
      setFromCartesianCoords(t, e, n) {
        return this.radius = Math.sqrt(t * t + e * e + n * n), 0 === this.radius ? (this.theta = 0, this.phi = 0) : (this.theta = Math.atan2(t, n), this.phi = Math.acos(On(e / this.radius, -1, 1))), this
      }
      clone() {
        return (new this.constructor).copy(this)
      }
    }
    exports.Spherical = tg;
    class eg {
      constructor(t = 1, e = 0, n = 0) {
        return this.radius = t, this.theta = e, this.y = n, this
      }
      set(t, e, n) {
        return this.radius = t, this.theta = e, this.y = n, this
      }
      copy(t) {
        return this.radius = t.radius, this.theta = t.theta, this.y = t.y, this
      }
      setFromVector3(t) {
        return this.setFromCartesianCoords(t.x, t.y, t.z)
      }
      setFromCartesianCoords(t, e, n) {
        return this.radius = Math.sqrt(t * t + n * n), this.theta = Math.atan2(t, n), this.y = e, this
      }
      clone() {
        return (new this.constructor).copy(this)
      }
    }
    exports.Cylindrical = eg;
    const ng = new sr;
    class rg {
      constructor(t = new sr(1 / 0, 1 / 0), e = new sr(-1 / 0, -1 / 0)) {
        this.min = t, this.max = e
      }
      set(t, e) {
        return this.min.copy(t), this.max.copy(e), this
      }
      setFromPoints(t) {
        this.makeEmpty();
        for (let e = 0, n = t.length; e < n; e++) this.expandByPoint(t[e]);
        return this
      }
      setFromCenterAndSize(t, e) {
        const n = ng.copy(e).multiplyScalar(.5);
        return this.min.copy(t).sub(n), this.max.copy(t).add(n), this
      }
      clone() {
        return (new this.constructor).copy(this)
      }
      copy(t) {
        return this.min.copy(t.min), this.max.copy(t.max), this
      }
      makeEmpty() {
        return this.min.x = this.min.y = 1 / 0, this.max.x = this.max.y = -1 / 0, this
      }
      isEmpty() {
        return this.max.x < this.min.x || this.max.y < this.min.y
      }
      getCenter(t) {
        return void 0 === t && (console.warn("THREE.Box2: .getCenter() target is now required"), t = new sr), this.isEmpty() ? t.set(0, 0) : t.addVectors(this.min, this.max).multiplyScalar(.5)
      }
      getSize(t) {
        return void 0 === t && (console.warn("THREE.Box2: .getSize() target is now required"), t = new sr), this.isEmpty() ? t.set(0, 0) : t.subVectors(this.max, this.min)
      }
      expandByPoint(t) {
        return this.min.min(t), this.max.max(t), this
      }
      expandByVector(t) {
        return this.min.sub(t), this.max.add(t), this
      }
      expandByScalar(t) {
        return this.min.addScalar(-t), this.max.addScalar(t), this
      }
      containsPoint(t) {
        return !(t.x < this.min.x || t.x > this.max.x || t.y < this.min.y || t.y > this.max.y)
      }
      containsBox(t) {
        return this.min.x <= t.min.x && t.max.x <= this.max.x && this.min.y <= t.min.y && t.max.y <= this.max.y
      }
      getParameter(t, e) {
        return void 0 === e && (console.warn("THREE.Box2: .getParameter() target is now required"), e = new sr), e.set((t.x - this.min.x) / (this.max.x - this.min.x), (t.y - this.min.y) / (this.max.y - this.min.y))
      }
      intersectsBox(t) {
        return !(t.max.x < this.min.x || t.min.x > this.max.x || t.max.y < this.min.y || t.min.y > this.max.y)
      }
      clampPoint(t, e) {
        return void 0 === e && (console.warn("THREE.Box2: .clampPoint() target is now required"), e = new sr), e.copy(t).clamp(this.min, this.max)
      }
      distanceToPoint(t) {
        return ng.copy(t).clamp(this.min, this.max).sub(t).length()
      }
      intersect(t) {
        return this.min.max(t.min), this.max.min(t.max), this
      }
      union(t) {
        return this.min.min(t.min), this.max.max(t.max), this
      }
      translate(t) {
        return this.min.add(t), this.max.add(t), this
      }
      equals(t) {
        return t.min.equals(this.min) && t.max.equals(this.max)
      }
    }
    exports.Box2 = rg, rg.prototype.isBox2 = !0;
    const ig = new gr,
      sg = new gr;
    class og {
      constructor(t = new gr, e = new gr) {
        this.start = t, this.end = e
      }
      set(t, e) {
        return this.start.copy(t), this.end.copy(e), this
      }
      copy(t) {
        return this.start.copy(t.start), this.end.copy(t.end), this
      }
      getCenter(t) {
        return void 0 === t && (console.warn("THREE.Line3: .getCenter() target is now required"), t = new gr), t.addVectors(this.start, this.end).multiplyScalar(.5)
      }
      delta(t) {
        return void 0 === t && (console.warn("THREE.Line3: .delta() target is now required"), t = new gr), t.subVectors(this.end, this.start)
      }
      distanceSq() {
        return this.start.distanceToSquared(this.end)
      }
      distance() {
        return this.start.distanceTo(this.end)
      }
      at(t, e) {
        return void 0 === e && (console.warn("THREE.Line3: .at() target is now required"), e = new gr), this.delta(e).multiplyScalar(t).add(this.start)
      }
      closestPointToPointParameter(t, e) {
        ig.subVectors(t, this.start), sg.subVectors(this.end, this.start);
        const n = sg.dot(sg);
        let r = sg.dot(ig) / n;
        return e && (r = On(r, 0, 1)), r
      }
      closestPointToPoint(t, e, n) {
        const r = this.closestPointToPointParameter(t, e);
        return void 0 === n && (console.warn("THREE.Line3: .closestPointToPoint() target is now required"), n = new gr), this.delta(n).multiplyScalar(r).add(this.start)
      }
      applyMatrix4(t) {
        return this.start.applyMatrix4(t), this.end.applyMatrix4(t), this
      }
      equals(t) {
        return t.start.equals(this.start) && t.end.equals(this.end)
      }
      clone() {
        return (new this.constructor).copy(this)
      }
    }
    exports.Line3 = og;
    class ag extends vi {
      constructor(t) {
        super(), this.material = t, this.render = function() {}, this.hasPositions = !1, this.hasNormals = !1, this.hasColors = !1, this.hasUvs = !1, this.positionArray = null, this.normalArray = null, this.colorArray = null, this.uvArray = null, this.count = 0
      }
    }
    exports.ImmediateRenderObject = ag, ag.prototype.isImmediateRenderObject = !0;
    const lg = new gr;
    class cg extends vi {
      constructor(t, e) {
        super(), this.light = t, this.light.updateMatrixWorld(), this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1, this.color = e;
        const n = new ds,
          r = [0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, -1, 1];
        for (let s = 0, o = 1, a = 32; s < a; s++, o++) {
          const t = s / a * Math.PI * 2,
            e = o / a * Math.PI * 2;
          r.push(Math.cos(t), Math.sin(t), 1, Math.cos(e), Math.sin(e), 1)
        }
        n.setAttribute("position", new es(r, 3));
        const i = new Fu({
          fog: !1,
          toneMapped: !1
        });
        this.cone = new ju(n, i), this.add(this.cone), this.update()
      }
      dispose() {
        this.cone.geometry.dispose(), this.cone.material.dispose()
      }
      update() {
        this.light.updateMatrixWorld();
        const t = this.light.distance ? this.light.distance : 1e3,
          e = t * Math.tan(this.light.angle);
        this.cone.scale.set(e, e, t), lg.setFromMatrixPosition(this.light.target.matrixWorld), this.cone.lookAt(lg), void 0 !== this.color ? this.cone.material.color.set(this.color) : this.cone.material.color.copy(this.light.color)
      }
    }
    exports.SpotLightHelper = cg;
    const hg = new gr,
      ug = new Xr,
      pg = new Xr;
    class dg extends ju {
      constructor(t) {
        const e = mg(t),
          n = new ds,
          r = [],
          i = [],
          s = new ki(0, 0, 1),
          o = new ki(0, 1, 0);
        for (let a = 0; a < e.length; a++) {
          const t = e[a];
          t.parent && t.parent.isBone && (r.push(0, 0, 0), r.push(0, 0, 0), i.push(s.r, s.g, s.b), i.push(o.r, o.g, o.b))
        }
        n.setAttribute("position", new es(r, 3)), n.setAttribute("color", new es(i, 3)), super(n, new Fu({
          vertexColors: !0,
          depthTest: !1,
          depthWrite: !1,
          toneMapped: !1,
          transparent: !0
        })), this.type = "SkeletonHelper", this.isSkeletonHelper = !0, this.root = t, this.bones = e, this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1
      }
      updateMatrixWorld(t) {
        const e = this.bones,
          n = this.geometry,
          r = n.getAttribute("position");
        pg.copy(this.root.matrixWorld).invert();
        for (let i = 0, s = 0; i < e.length; i++) {
          const t = e[i];
          t.parent && t.parent.isBone && (ug.multiplyMatrices(pg, t.matrixWorld), hg.setFromMatrixPosition(ug), r.setXYZ(s, hg.x, hg.y, hg.z), ug.multiplyMatrices(pg, t.parent.matrixWorld), hg.setFromMatrixPosition(ug), r.setXYZ(s + 1, hg.x, hg.y, hg.z), s += 2)
        }
        n.getAttribute("position").needsUpdate = !0, super.updateMatrixWorld(t)
      }
    }

    function mg(t) {
      const e = [];
      t && t.isBone && e.push(t);
      for (let n = 0; n < t.children.length; n++) e.push.apply(e, mg(t.children[n]));
      return e
    }
    exports.SkeletonHelper = dg;
    class fg extends Ps {
      constructor(t, e, n) {
        super(new sd(e, 4, 2), new Vi({
          wireframe: !0,
          fog: !1,
          toneMapped: !1
        })), this.light = t, this.light.updateMatrixWorld(), this.color = n, this.type = "PointLightHelper", this.matrix = this.light.matrixWorld, this.matrixAutoUpdate = !1, this.update()
      }
      dispose() {
        this.geometry.dispose(), this.material.dispose()
      }
      update() {
        void 0 !== this.color ? this.material.color.set(this.color) : this.material.color.copy(this.light.color)
      }
    }
    exports.PointLightHelper = fg;
    const gg = new gr,
      xg = new ki,
      vg = new ki;
    class yg extends vi {
      constructor(t, e, n) {
        super(), this.light = t, this.light.updateMatrixWorld(), this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1, this.color = n;
        const r = new td(e);
        r.rotateY(.5 * Math.PI), this.material = new Vi({
          wireframe: !0,
          fog: !1,
          toneMapped: !1
        }), void 0 === this.color && (this.material.vertexColors = !0);
        const i = r.getAttribute("position"),
          s = new Float32Array(3 * i.count);
        r.setAttribute("color", new qi(s, 3)), this.add(new Ps(r, this.material)), this.update()
      }
      dispose() {
        this.children[0].geometry.dispose(), this.children[0].material.dispose()
      }
      update() {
        const t = this.children[0];
        if (void 0 !== this.color) this.material.color.set(this.color);
        else {
          const e = t.geometry.getAttribute("color");
          xg.copy(this.light.color), vg.copy(this.light.groundColor);
          for (let t = 0, n = e.count; t < n; t++) {
            const r = t < n / 2 ? xg : vg;
            e.setXYZ(t, r.r, r.g, r.b)
          }
          e.needsUpdate = !0
        }
        t.lookAt(gg.setFromMatrixPosition(this.light.matrixWorld).negate())
      }
    }
    exports.HemisphereLightHelper = yg;
    class _g extends ju {
      constructor(t = 10, e = 10, n = 4473924, r = 8947848) {
        n = new ki(n), r = new ki(r);
        const i = e / 2,
          s = t / e,
          o = t / 2,
          a = [],
          l = [];
        for (let h = 0, u = 0, p = -o; h <= e; h++, p += s) {
          a.push(-o, 0, p, o, 0, p), a.push(p, 0, -o, p, 0, o);
          const t = h === i ? n : r;
          t.toArray(l, u), u += 3, t.toArray(l, u), u += 3, t.toArray(l, u), u += 3, t.toArray(l, u), u += 3
        }
        const c = new ds;
        c.setAttribute("position", new es(a, 3)), c.setAttribute("color", new es(l, 3)), super(c, new Fu({
          vertexColors: !0,
          toneMapped: !1
        })), this.type = "GridHelper"
      }
    }
    exports.GridHelper = _g;
    class bg extends ju {
      constructor(t = 10, e = 16, n = 8, r = 64, i = 4473924, s = 8947848) {
        i = new ki(i), s = new ki(s);
        const o = [],
          a = [];
        for (let c = 0; c <= e; c++) {
          const n = c / e * (2 * Math.PI),
            r = Math.sin(n) * t,
            l = Math.cos(n) * t;
          o.push(0, 0, 0), o.push(r, 0, l);
          const h = 1 & c ? i : s;
          a.push(h.r, h.g, h.b), a.push(h.r, h.g, h.b)
        }
        for (let c = 0; c <= n; c++) {
          const e = 1 & c ? i : s,
            l = t - t / n * c;
          for (let t = 0; t < r; t++) {
            let n = t / r * (2 * Math.PI),
              i = Math.sin(n) * l,
              s = Math.cos(n) * l;
            o.push(i, 0, s), a.push(e.r, e.g, e.b), n = (t + 1) / r * (2 * Math.PI), i = Math.sin(n) * l, s = Math.cos(n) * l, o.push(i, 0, s), a.push(e.r, e.g, e.b)
          }
        }
        const l = new ds;
        l.setAttribute("position", new es(o, 3)), l.setAttribute("color", new es(a, 3)), super(l, new Fu({
          vertexColors: !0,
          toneMapped: !1
        })), this.type = "PolarGridHelper"
      }
    }
    exports.PolarGridHelper = bg;
    const wg = new gr,
      Mg = new gr,
      Sg = new gr;
    class Tg extends vi {
      constructor(t, e, n) {
        super(), this.light = t, this.light.updateMatrixWorld(), this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1, this.color = n, void 0 === e && (e = 1);
        let r = new ds;
        r.setAttribute("position", new es([-e, e, 0, e, e, 0, e, -e, 0, -e, -e, 0, -e, e, 0], 3));
        const i = new Fu({
          fog: !1,
          toneMapped: !1
        });
        this.lightPlane = new ku(r, i), this.add(this.lightPlane), (r = new ds).setAttribute("position", new es([0, 0, 0, 0, 0, 1], 3)), this.targetLine = new ku(r, i), this.add(this.targetLine), this.update()
      }
      dispose() {
        this.lightPlane.geometry.dispose(), this.lightPlane.material.dispose(), this.targetLine.geometry.dispose(), this.targetLine.material.dispose()
      }
      update() {
        wg.setFromMatrixPosition(this.light.matrixWorld), Mg.setFromMatrixPosition(this.light.target.matrixWorld), Sg.subVectors(Mg, wg), this.lightPlane.lookAt(Mg), void 0 !== this.color ? (this.lightPlane.material.color.set(this.color), this.targetLine.material.color.set(this.color)) : (this.lightPlane.material.color.copy(this.light.color), this.targetLine.material.color.copy(this.light.color)), this.targetLine.lookAt(Mg), this.targetLine.scale.z = Sg.length()
      }
    }
    exports.DirectionalLightHelper = Tg;
    const Eg = new gr,
      Ag = new Us;
    class Lg extends ju {
      constructor(t) {
        const e = new ds,
          n = new Fu({
            color: 16777215,
            vertexColors: !0,
            toneMapped: !1
          }),
          r = [],
          i = [],
          s = {},
          o = new ki(16755200),
          a = new ki(16711680),
          l = new ki(43775),
          c = new ki(16777215),
          h = new ki(3355443);

        function u(t, e, n) {
          p(t, n), p(e, n)
        }

        function p(t, e) {
          r.push(0, 0, 0), i.push(e.r, e.g, e.b), void 0 === s[t] && (s[t] = []), s[t].push(r.length / 3 - 1)
        }
        u("n1", "n2", o), u("n2", "n4", o), u("n4", "n3", o), u("n3", "n1", o), u("f1", "f2", o), u("f2", "f4", o), u("f4", "f3", o), u("f3", "f1", o), u("n1", "f1", o), u("n2", "f2", o), u("n3", "f3", o), u("n4", "f4", o), u("p", "n1", a), u("p", "n2", a), u("p", "n3", a), u("p", "n4", a), u("u1", "u2", l), u("u2", "u3", l), u("u3", "u1", l), u("c", "t", c), u("p", "c", h), u("cn1", "cn2", h), u("cn3", "cn4", h), u("cf1", "cf2", h), u("cf3", "cf4", h), e.setAttribute("position", new es(r, 3)), e.setAttribute("color", new es(i, 3)), super(e, n), this.type = "CameraHelper", this.camera = t, this.camera.updateProjectionMatrix && this.camera.updateProjectionMatrix(), this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1, this.pointMap = s, this.update()
      }
      update() {
        const t = this.geometry,
          e = this.pointMap;
        Ag.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse), Rg("c", e, t, Ag, 0, 0, -1), Rg("t", e, t, Ag, 0, 0, 1), Rg("n1", e, t, Ag, -1, -1, -1), Rg("n2", e, t, Ag, 1, -1, -1), Rg("n3", e, t, Ag, -1, 1, -1), Rg("n4", e, t, Ag, 1, 1, -1), Rg("f1", e, t, Ag, -1, -1, 1), Rg("f2", e, t, Ag, 1, -1, 1), Rg("f3", e, t, Ag, -1, 1, 1), Rg("f4", e, t, Ag, 1, 1, 1), Rg("u1", e, t, Ag, .7, 1.1, -1), Rg("u2", e, t, Ag, -.7, 1.1, -1), Rg("u3", e, t, Ag, 0, 2, -1), Rg("cf1", e, t, Ag, -1, 0, 1), Rg("cf2", e, t, Ag, 1, 0, 1), Rg("cf3", e, t, Ag, 0, -1, 1), Rg("cf4", e, t, Ag, 0, 1, 1), Rg("cn1", e, t, Ag, -1, 0, -1), Rg("cn2", e, t, Ag, 1, 0, -1), Rg("cn3", e, t, Ag, 0, -1, -1), Rg("cn4", e, t, Ag, 0, 1, -1), t.getAttribute("position").needsUpdate = !0
      }
      dispose() {
        this.geometry.dispose(), this.material.dispose()
      }
    }

    function Rg(t, e, n, r, i, s, o) {
      Eg.set(i, s, o).unproject(r);
      const a = e[t];
      if (void 0 !== a) {
        const t = n.getAttribute("position");
        for (let e = 0, n = a.length; e < n; e++) t.setXYZ(a[e], Eg.x, Eg.y, Eg.z)
      }
    }
    exports.CameraHelper = Lg;
    const Cg = new yr;
    class Pg extends ju {
      constructor(t, e = 16776960) {
        const n = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]),
          r = new Float32Array(24),
          i = new ds;
        i.setIndex(new qi(n, 1)), i.setAttribute("position", new qi(r, 3)), super(i, new Fu({
          color: e,
          toneMapped: !1
        })), this.object = t, this.type = "BoxHelper", this.matrixAutoUpdate = !1, this.update()
      }
      update(t) {
        if (void 0 !== t && console.warn("THREE.BoxHelper: .update() has no longer arguments."), void 0 !== this.object && Cg.setFromObject(this.object), Cg.isEmpty()) return;
        const e = Cg.min,
          n = Cg.max,
          r = this.geometry.attributes.position,
          i = r.array;
        i[0] = n.x, i[1] = n.y, i[2] = n.z, i[3] = e.x, i[4] = n.y, i[5] = n.z, i[6] = e.x, i[7] = e.y, i[8] = n.z, i[9] = n.x, i[10] = e.y, i[11] = n.z, i[12] = n.x, i[13] = n.y, i[14] = e.z, i[15] = e.x, i[16] = n.y, i[17] = e.z, i[18] = e.x, i[19] = e.y, i[20] = e.z, i[21] = n.x, i[22] = e.y, i[23] = e.z, r.needsUpdate = !0, this.geometry.computeBoundingSphere()
      }
      setFromObject(t) {
        return this.object = t, this.update(), this
      }
      copy(t) {
        return ju.prototype.copy.call(this, t), this.object = t.object, this
      }
    }
    exports.BoxHelper = Pg;
    class Dg extends ju {
      constructor(t, e = 16776960) {
        const n = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]),
          r = new ds;
        r.setIndex(new qi(n, 1)), r.setAttribute("position", new es([1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1], 3)), super(r, new Fu({
          color: e,
          toneMapped: !1
        })), this.box = t, this.type = "Box3Helper", this.geometry.computeBoundingSphere()
      }
      updateMatrixWorld(t) {
        const e = this.box;
        e.isEmpty() || (e.getCenter(this.position), e.getSize(this.scale), this.scale.multiplyScalar(.5), super.updateMatrixWorld(t))
      }
    }
    exports.Box3Helper = Dg;
    class Ig extends ku {
      constructor(t, e = 1, n = 16776960) {
        const r = n,
          i = new ds;
        i.setAttribute("position", new es([1, -1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0], 3)), i.computeBoundingSphere(), super(i, new Fu({
          color: r,
          toneMapped: !1
        })), this.type = "PlaneHelper", this.plane = t, this.size = e;
        const s = new ds;
        s.setAttribute("position", new es([1, 1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, -1, 1, 1, -1, 1], 3)), s.computeBoundingSphere(), this.add(new Ps(s, new Vi({
          color: r,
          opacity: .2,
          transparent: !0,
          depthWrite: !1,
          toneMapped: !1
        })))
      }
      updateMatrixWorld(t) {
        let e = -this.plane.constant;
        Math.abs(e) < 1e-8 && (e = 1e-8), this.scale.set(.5 * this.size, .5 * this.size, e), this.children[0].material.side = e < 0 ? p : u, this.lookAt(this.plane.normal), super.updateMatrixWorld(t)
      }
    }
    exports.PlaneHelper = Ig;
    const Bg = new gr;
    let Ng, Fg;
    class zg extends vi {
      constructor(t = new gr(0, 0, 1), e = new gr(0, 0, 0), n = 1, r = 16776960, i = .2 * n, s = .2 * i) {
        super(), this.type = "ArrowHelper", void 0 === Ng && ((Ng = new ds).setAttribute("position", new es([0, 0, 0, 0, 1, 0], 3)), (Fg = new sp(0, .5, 1, 5, 1)).translate(0, -.5, 0)), this.position.copy(e), this.line = new ku(Ng, new Fu({
          color: r,
          toneMapped: !1
        })), this.line.matrixAutoUpdate = !1, this.add(this.line), this.cone = new Ps(Fg, new Vi({
          color: r,
          toneMapped: !1
        })), this.cone.matrixAutoUpdate = !1, this.add(this.cone), this.setDirection(t), this.setLength(n, i, s)
      }
      setDirection(t) {
        if (t.y > .99999) this.quaternion.set(0, 0, 0, 1);
        else if (t.y < -.99999) this.quaternion.set(1, 0, 0, 0);
        else {
          Bg.set(t.z, 0, -t.x).normalize();
          const e = Math.acos(t.y);
          this.quaternion.setFromAxisAngle(Bg, e)
        }
      }
      setLength(t, e = .2 * t, n = .2 * e) {
        this.line.scale.set(1, Math.max(1e-4, t - e), 1), this.line.updateMatrix(), this.cone.scale.set(n, e, n), this.cone.position.y = t, this.cone.updateMatrix()
      }
      setColor(t) {
        this.line.material.color.set(t), this.cone.material.color.set(t)
      }
      copy(t) {
        return super.copy(t, !1), this.line.copy(t.line), this.cone.copy(t.cone), this
      }
    }
    exports.ArrowHelper = zg;
    class Gg extends ju {
      constructor(t = 1) {
        const e = [0, 0, 0, t, 0, 0, 0, 0, 0, 0, t, 0, 0, 0, 0, 0, 0, t],
          n = new ds;
        n.setAttribute("position", new es(e, 3)), n.setAttribute("color", new es([1, 0, 0, 1, .6, 0, 0, 1, 0, .6, 1, 0, 0, 0, 1, 0, .6, 1], 3)), super(n, new Fu({
          vertexColors: !0,
          toneMapped: !1
        })), this.type = "AxesHelper"
      }
      dispose() {
        this.geometry.dispose(), this.material.dispose()
      }
    }
    exports.AxesHelper = Gg;
    const Og = new Float32Array(1),
      Hg = new Int32Array(Og.buffer);
    class Ug {
      static toHalfFloat(t) {
        Og[0] = t;
        const e = Hg[0];
        let n = e >> 16 & 32768,
          r = e >> 12 & 2047;
        const i = e >> 23 & 255;
        return i < 103 ? n : i > 142 ? (n |= 31744, n |= (255 == i ? 0 : 1) && 8388607 & e) : i < 113 ? n |= ((r |= 2048) >> 114 - i) + (r >> 113 - i & 1) : (n |= i - 112 << 10 | r >> 1, n += 1 & r)
      }
    }
    exports.DataUtils = Ug;
    const kg = 4,
      Vg = 8,
      Wg = Math.pow(2, Vg),
      jg = [.125, .215, .35, .446, .526, .582],
      qg = Vg - kg + 1 + jg.length,
      Xg = 20,
      Yg = {
        [Xe]: 0,
        [Ye]: 1,
        [Je]: 2,
        [Ke]: 3,
        [$e]: 4,
        [tn]: 5,
        [Ze]: 6
      },
      Zg = new Vi({
        side: p,
        depthWrite: !1,
        depthTest: !1
      }),
      Jg = new Ps(new Bs, Zg),
      Qg = new Um,
      {
        _lodPlanes: Kg,
        _sizeLods: $g,
        _sigmas: tx
      } = cx(),
      ex = new ki;
    let nx = null;
    const rx = (1 + Math.sqrt(5)) / 2,
      ix = 1 / rx,
      sx = [new gr(1, 1, 1), new gr(-1, 1, 1), new gr(1, 1, -1), new gr(-1, 1, -1), new gr(0, rx, ix), new gr(0, rx, -ix), new gr(ix, 0, rx), new gr(-ix, 0, rx), new gr(rx, ix, 0), new gr(-rx, ix, 0)];

    function ox(t) {
      const e = Math.max(t.r, t.g, t.b),
        n = Math.min(Math.max(Math.ceil(Math.log2(e)), -128), 127);
      return t.multiplyScalar(Math.pow(2, -n)), (n + 128) / 255
    }
    class ax {
      constructor(t) {
        this._renderer = t, this._pingPongRenderTarget = null, this._blurMaterial = px(Xg), this._equirectShader = null, this._cubemapShader = null, this._compileMaterial(this._blurMaterial)
      }
      fromScene(t, e = 0, n = .1, r = 100) {
        nx = this._renderer.getRenderTarget();
        const i = this._allocateTargets();
        return this._sceneToCubeUV(t, n, r, i), e > 0 && this._blur(i, 0, 0, e), this._applyPMREM(i), this._cleanup(i), i
      }
      fromEquirectangular(t) {
        return this._fromTexture(t)
      }
      fromCubemap(t) {
        return this._fromTexture(t)
      }
      compileCubemapShader() {
        null === this._cubemapShader && (this._cubemapShader = mx(), this._compileMaterial(this._cubemapShader))
      }
      compileEquirectangularShader() {
        null === this._equirectShader && (this._equirectShader = dx(), this._compileMaterial(this._equirectShader))
      }
      dispose() {
        this._blurMaterial.dispose(), null !== this._cubemapShader && this._cubemapShader.dispose(), null !== this._equirectShader && this._equirectShader.dispose();
        for (let t = 0; t < Kg.length; t++) Kg[t].dispose()
      }
      _cleanup(t) {
        this._pingPongRenderTarget.dispose(), this._renderer.setRenderTarget(nx), t.scissorTest = !1, ux(t, 0, 0, t.width, t.height)
      }
      _fromTexture(t) {
        nx = this._renderer.getRenderTarget();
        const e = this._allocateTargets(t);
        return this._textureToCubeUV(t, e), this._applyPMREM(e), this._cleanup(e), e
      }
      _allocateTargets(t) {
        const e = {
            magFilter: ut,
            minFilter: ut,
            generateMipmaps: !1,
            type: bt,
            format: Gt,
            encoding: lx(t) ? t.encoding : Je,
            depthBuffer: !1
          },
          n = hx(e);
        return n.depthBuffer = !t, this._pingPongRenderTarget = hx(e), n
      }
      _compileMaterial(t) {
        const e = new Ps(Kg[0], t);
        this._renderer.compile(e, Qg)
      }
      _sceneToCubeUV(t, e, n, r) {
        const i = new ks(90, 1, e, n),
          s = [1, -1, 1, 1, 1, 1],
          o = [1, 1, 1, -1, -1, -1],
          a = this._renderer,
          l = a.autoClear,
          c = a.outputEncoding,
          h = a.toneMapping;
        a.getClearColor(ex), a.toneMapping = Z, a.outputEncoding = Xe, a.autoClear = !1;
        let u = !1;
        const p = t.background;
        if (p) {
          if (p.isColor) {
            Zg.color.copy(p).convertSRGBToLinear(), t.background = null;
            const e = ox(Zg.color);
            Zg.opacity = e, u = !0
          }
        } else {
          Zg.color.copy(ex).convertSRGBToLinear();
          const t = ox(Zg.color);
          Zg.opacity = t, u = !0
        }
        for (let d = 0; d < 6; d++) {
          const e = d % 3;
          0 == e ? (i.up.set(0, s[d], 0), i.lookAt(o[d], 0, 0)) : 1 == e ? (i.up.set(0, 0, s[d]), i.lookAt(0, o[d], 0)) : (i.up.set(0, s[d], 0), i.lookAt(0, 0, o[d])), ux(r, e * Wg, d > 2 ? Wg : 0, Wg, Wg), a.setRenderTarget(r), u && a.render(Jg, i), a.render(t, i)
        }
        a.toneMapping = h, a.outputEncoding = c, a.autoClear = l
      }
      _textureToCubeUV(t, e) {
        const n = this._renderer;
        t.isCubeTexture ? null == this._cubemapShader && (this._cubemapShader = mx()) : null == this._equirectShader && (this._equirectShader = dx());
        const r = t.isCubeTexture ? this._cubemapShader : this._equirectShader,
          i = new Ps(Kg[0], r),
          s = r.uniforms;
        s.envMap.value = t, t.isCubeTexture || s.texelSize.value.set(1 / t.image.width, 1 / t.image.height), s.inputEncoding.value = Yg[t.encoding], s.outputEncoding.value = Yg[e.texture.encoding], ux(e, 0, 0, 3 * Wg, 2 * Wg), n.setRenderTarget(e), n.render(i, Qg)
      }
      _applyPMREM(t) {
        const e = this._renderer,
          n = e.autoClear;
        e.autoClear = !1;
        for (let r = 1; r < qg; r++) {
          const e = Math.sqrt(tx[r] * tx[r] - tx[r - 1] * tx[r - 1]),
            n = sx[(r - 1) % sx.length];
          this._blur(t, r - 1, r, e, n)
        }
        e.autoClear = n
      }
      _blur(t, e, n, r, i) {
        const s = this._pingPongRenderTarget;
        this._halfBlur(t, s, e, n, r, "latitudinal", i), this._halfBlur(s, t, n, n, r, "longitudinal", i)
      }
      _halfBlur(t, e, n, r, i, s, o) {
        const a = this._renderer,
          l = this._blurMaterial;
        "latitudinal" !== s && "longitudinal" !== s && console.error("blur direction must be either latitudinal or longitudinal!");
        const c = new Ps(Kg[r], l),
          h = l.uniforms,
          u = $g[n] - 1,
          p = isFinite(i) ? Math.PI / (2 * u) : 2 * Math.PI / (2 * Xg - 1),
          d = i / p,
          m = isFinite(i) ? 1 + Math.floor(3 * d) : Xg;
        m > Xg && console.warn(`sigmaRadians, ${i}, is too large and will clip, as it requested ${m} samples when the maximum is set to ${Xg}`);
        const f = [];
        let g = 0;
        for (let v = 0; v < Xg; ++v) {
          const t = v / d,
            e = Math.exp(-t * t / 2);
          f.push(e), 0 == v ? g += e : v < m && (g += 2 * e)
        }
        for (let v = 0; v < f.length; v++) f[v] = f[v] / g;
        h.envMap.value = t.texture, h.samples.value = m, h.weights.value = f, h.latitudinal.value = "latitudinal" === s, o && (h.poleAxis.value = o), h.dTheta.value = p, h.mipInt.value = Vg - n, h.inputEncoding.value = Yg[t.texture.encoding], h.outputEncoding.value = Yg[t.texture.encoding];
        const x = $g[r];
        ux(e, 3 * Math.max(0, Wg - 2 * x), (0 === r ? 0 : 2 * Wg) + 2 * x * (r > Vg - kg ? r - Vg + kg : 0), 3 * x, 2 * x), a.setRenderTarget(e), a.render(c, Qg)
      }
    }

    function lx(t) {
      return void 0 !== t && t.type === bt && (t.encoding === Xe || t.encoding === Ye || t.encoding === Ze)
    }

    function cx() {
      const t = [],
        e = [],
        n = [];
      let r = Vg;
      for (let i = 0; i < qg; i++) {
        const s = Math.pow(2, r);
        e.push(s);
        let o = 1 / s;
        i > Vg - kg ? o = jg[i - Vg + kg - 1] : 0 == i && (o = 0), n.push(o);
        const a = 1 / (s - 1),
          l = -a / 2,
          c = 1 + a / 2,
          h = [l, l, c, l, c, c, l, l, c, c, l, c],
          u = 6,
          p = 6,
          d = 3,
          m = 2,
          f = 1,
          g = new Float32Array(d * p * u),
          x = new Float32Array(m * p * u),
          v = new Float32Array(f * p * u);
        for (let t = 0; t < u; t++) {
          const e = t % 3 * 2 / 3 - 1,
            n = t > 2 ? 0 : -1,
            r = [e, n, 0, e + 2 / 3, n, 0, e + 2 / 3, n + 1, 0, e, n, 0, e + 2 / 3, n + 1, 0, e, n + 1, 0];
          g.set(r, d * p * t), x.set(h, m * p * t);
          const i = [t, t, t, t, t, t];
          v.set(i, f * p * t)
        }
        const y = new ds;
        y.setAttribute("position", new qi(g, d)), y.setAttribute("uv", new qi(x, m)), y.setAttribute("faceIndex", new qi(v, f)), t.push(y), r > kg && r--
      }
      return {
        _lodPlanes: t,
        _sizeLods: e,
        _sigmas: n
      }
    }

    function hx(t) {
      const e = new dr(3 * Wg, 3 * Wg, t);
      return e.texture.mapping = ot, e.texture.name = "PMREM.cubeUv", e.scissorTest = !0, e
    }

    function ux(t, e, n, r, i) {
      t.viewport.set(e, n, r, i), t.scissor.set(e, n, r, i)
    }

    function px(t) {
      const e = new Float32Array(t),
        n = new gr(0, 1, 0);
      return new md({
        name: "SphericalGaussianBlur",
        defines: {
          n: t
        },
        uniforms: {
          envMap: {
            value: null
          },
          samples: {
            value: 1
          },
          weights: {
            value: e
          },
          latitudinal: {
            value: !1
          },
          dTheta: {
            value: 0
          },
          mipInt: {
            value: 0
          },
          poleAxis: {
            value: n
          },
          inputEncoding: {
            value: Yg[Xe]
          },
          outputEncoding: {
            value: Yg[Xe]
          }
        },
        vertexShader: fx(),
        fragmentShader: `\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform int samples;\n\t\t\tuniform float weights[ n ];\n\t\t\tuniform bool latitudinal;\n\t\t\tuniform float dTheta;\n\t\t\tuniform float mipInt;\n\t\t\tuniform vec3 poleAxis;\n\n\t\t\t${gx()}\n\n\t\t\t#define ENVMAP_TYPE_CUBE_UV\n\t\t\t#include <cube_uv_reflection_fragment>\n\n\t\t\tvec3 getSample( float theta, vec3 axis ) {\n\n\t\t\t\tfloat cosTheta = cos( theta );\n\t\t\t\t// Rodrigues' axis-angle rotation\n\t\t\t\tvec3 sampleDirection = vOutputDirection * cosTheta\n\t\t\t\t\t+ cross( axis, vOutputDirection ) * sin( theta )\n\t\t\t\t\t+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );\n\n\t\t\t\treturn bilinearCubeUV( envMap, sampleDirection, mipInt );\n\n\t\t\t}\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );\n\n\t\t\t\tif ( all( equal( axis, vec3( 0.0 ) ) ) ) {\n\n\t\t\t\t\taxis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );\n\n\t\t\t\t}\n\n\t\t\t\taxis = normalize( axis );\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );\n\n\t\t\t\tfor ( int i = 1; i < n; i++ ) {\n\n\t\t\t\t\tif ( i >= samples ) {\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfloat theta = dTheta * float( i );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( theta, axis );\n\n\t\t\t\t}\n\n\t\t\t\tgl_FragColor = linearToOutputTexel( gl_FragColor );\n\n\t\t\t}\n\t\t`,
        blending: g,
        depthTest: !1,
        depthWrite: !1
      })
    }

    function dx() {
      const t = new sr(1, 1);
      return new md({
        name: "EquirectangularToCubeUV",
        uniforms: {
          envMap: {
            value: null
          },
          texelSize: {
            value: t
          },
          inputEncoding: {
            value: Yg[Xe]
          },
          outputEncoding: {
            value: Yg[Xe]
          }
        },
        vertexShader: fx(),
        fragmentShader: `\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform vec2 texelSize;\n\n\t\t\t${gx()}\n\n\t\t\t#include <common>\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\n\t\t\t\tvec3 outputDirection = normalize( vOutputDirection );\n\t\t\t\tvec2 uv = equirectUv( outputDirection );\n\n\t\t\t\tvec2 f = fract( uv / texelSize - 0.5 );\n\t\t\t\tuv -= f * texelSize;\n\t\t\t\tvec3 tl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\t\t\t\tuv.x += texelSize.x;\n\t\t\t\tvec3 tr = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\t\t\t\tuv.y += texelSize.y;\n\t\t\t\tvec3 br = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\t\t\t\tuv.x -= texelSize.x;\n\t\t\t\tvec3 bl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\n\t\t\t\tvec3 tm = mix( tl, tr, f.x );\n\t\t\t\tvec3 bm = mix( bl, br, f.x );\n\t\t\t\tgl_FragColor.rgb = mix( tm, bm, f.y );\n\n\t\t\t\tgl_FragColor = linearToOutputTexel( gl_FragColor );\n\n\t\t\t}\n\t\t`,
        blending: g,
        depthTest: !1,
        depthWrite: !1
      })
    }

    function mx() {
      return new md({
        name: "CubemapToCubeUV",
        uniforms: {
          envMap: {
            value: null
          },
          inputEncoding: {
            value: Yg[Xe]
          },
          outputEncoding: {
            value: Yg[Xe]
          }
        },
        vertexShader: fx(),
        fragmentShader: `\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform samplerCube envMap;\n\n\t\t\t${gx()}\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb = envMapTexelToLinear( textureCube( envMap, vec3( - vOutputDirection.x, vOutputDirection.yz ) ) ).rgb;\n\t\t\t\tgl_FragColor = linearToOutputTexel( gl_FragColor );\n\n\t\t\t}\n\t\t`,
        blending: g,
        depthTest: !1,
        depthWrite: !1
      })
    }

    function fx() {
      return "\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute vec3 position;\n\t\tattribute vec2 uv;\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t"
    }

    function gx() {
      return "\n\n\t\tuniform int inputEncoding;\n\t\tuniform int outputEncoding;\n\n\t\t#include <encodings_pars_fragment>\n\n\t\tvec4 inputTexelToLinear( vec4 value ) {\n\n\t\t\tif ( inputEncoding == 0 ) {\n\n\t\t\t\treturn value;\n\n\t\t\t} else if ( inputEncoding == 1 ) {\n\n\t\t\t\treturn sRGBToLinear( value );\n\n\t\t\t} else if ( inputEncoding == 2 ) {\n\n\t\t\t\treturn RGBEToLinear( value );\n\n\t\t\t} else if ( inputEncoding == 3 ) {\n\n\t\t\t\treturn RGBMToLinear( value, 7.0 );\n\n\t\t\t} else if ( inputEncoding == 4 ) {\n\n\t\t\t\treturn RGBMToLinear( value, 16.0 );\n\n\t\t\t} else if ( inputEncoding == 5 ) {\n\n\t\t\t\treturn RGBDToLinear( value, 256.0 );\n\n\t\t\t} else {\n\n\t\t\t\treturn GammaToLinear( value, 2.2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvec4 linearToOutputTexel( vec4 value ) {\n\n\t\t\tif ( outputEncoding == 0 ) {\n\n\t\t\t\treturn value;\n\n\t\t\t} else if ( outputEncoding == 1 ) {\n\n\t\t\t\treturn LinearTosRGB( value );\n\n\t\t\t} else if ( outputEncoding == 2 ) {\n\n\t\t\t\treturn LinearToRGBE( value );\n\n\t\t\t} else if ( outputEncoding == 3 ) {\n\n\t\t\t\treturn LinearToRGBM( value, 7.0 );\n\n\t\t\t} else if ( outputEncoding == 4 ) {\n\n\t\t\t\treturn LinearToRGBM( value, 16.0 );\n\n\t\t\t} else if ( outputEncoding == 5 ) {\n\n\t\t\t\treturn LinearToRGBD( value, 256.0 );\n\n\t\t\t} else {\n\n\t\t\t\treturn LinearToGamma( value, 2.2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvec4 envMapTexelToLinear( vec4 color ) {\n\n\t\t\treturn inputTexelToLinear( color );\n\n\t\t}\n\t"
    }
    exports.PMREMGenerator = ax;
    const xx = 0;
    exports.LineStrip = 0;
    const vx = 1;
    exports.LinePieces = 1;
    const yx = 0;
    exports.NoColors = 0;
    const _x = 1;
    exports.FaceColors = 1;
    const bx = 2;

    function wx(t) {
      return console.warn("THREE.MeshFaceMaterial has been removed. Use an Array instead."), t
    }

    function Mx(t = []) {
      return console.warn("THREE.MultiMaterial has been removed. Use an Array instead."), t.isMultiMaterial = !0, t.materials = t, t.clone = function() {
        return t.slice()
      }, t
    }

    function Sx(t, e) {
      return console.warn("THREE.PointCloud has been renamed to THREE.Points."), new Ku(t, e)
    }

    function Tx(t) {
      return console.warn("THREE.Particle has been renamed to THREE.Sprite."), new gu(t)
    }

    function Ex(t, e) {
      return console.warn("THREE.ParticleSystem has been renamed to THREE.Points."), new Ku(t, e)
    }

    function Ax(t) {
      return console.warn("THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial."), new Xu(t)
    }

    function Lx(t) {
      return console.warn("THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial."), new Xu(t)
    }

    function Rx(t) {
      return console.warn("THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial."), new Xu(t)
    }

    function Cx(t, e, n) {
      return console.warn("THREE.Vertex has been removed. Use THREE.Vector3 instead."), new gr(t, e, n)
    }

    function Px(t, e) {
      return console.warn("THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setUsage( THREE.DynamicDrawUsage ) instead."), new qi(t, e).setUsage(Mn)
    }

    function Dx(t, e) {
      return console.warn("THREE.Int8Attribute has been removed. Use new THREE.Int8BufferAttribute() instead."), new Xi(t, e)
    }

    function Ix(t, e) {
      return console.warn("THREE.Uint8Attribute has been removed. Use new THREE.Uint8BufferAttribute() instead."), new Yi(t, e)
    }

    function Bx(t, e) {
      return console.warn("THREE.Uint8ClampedAttribute has been removed. Use new THREE.Uint8ClampedBufferAttribute() instead."), new Zi(t, e)
    }

    function Nx(t, e) {
      return console.warn("THREE.Int16Attribute has been removed. Use new THREE.Int16BufferAttribute() instead."), new Ji(t, e)
    }

    function Fx(t, e) {
      return console.warn("THREE.Uint16Attribute has been removed. Use new THREE.Uint16BufferAttribute() instead."), new Qi(t, e)
    }

    function zx(t, e) {
      return console.warn("THREE.Int32Attribute has been removed. Use new THREE.Int32BufferAttribute() instead."), new Ki(t, e)
    }

    function Gx(t, e) {
      return console.warn("THREE.Uint32Attribute has been removed. Use new THREE.Uint32BufferAttribute() instead."), new $i(t, e)
    }

    function Ox(t, e) {
      return console.warn("THREE.Float32Attribute has been removed. Use new THREE.Float32BufferAttribute() instead."), new es(t, e)
    }

    function Hx(t, e) {
      return console.warn("THREE.Float64Attribute has been removed. Use new THREE.Float64BufferAttribute() instead."), new ns(t, e)
    }

    function Ux(t) {
      return console.warn("THREE.AxisHelper has been renamed to THREE.AxesHelper."), new Gg(t)
    }

    function kx(t, e) {
      return console.warn("THREE.BoundingBoxHelper has been deprecated. Creating a THREE.BoxHelper instead."), new Pg(t, e)
    }

    function Vx(t, e) {
      return console.warn("THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead."), new ju(new dp(t.geometry), new Fu({
        color: void 0 !== e ? e : 16777215
      }))
    }

    function Wx(t, e) {
      return console.warn("THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead."), new ju(new ud(t.geometry), new Fu({
        color: void 0 !== e ? e : 16777215
      }))
    }

    function jx(t) {
      return console.warn("THREE.XHRLoader has been renamed to THREE.FileLoader."), new jd(t)
    }

    function qx(t) {
      return console.warn("THREE.BinaryTextureLoader has been renamed to THREE.DataTextureLoader."), new Jd(t)
    }

    function Xx(t, e, n) {
      return console.warn("THREE.WebGLRenderTargetCube( width, height, options ) is now WebGLCubeRenderTarget( size, options )."), new Xs(t, n)
    }

    function Yx() {
      console.error("THREE.CanvasRenderer has been removed")
    }

    function Zx() {
      console.error("THREE.JSONLoader has been removed.")
    }
    exports.VertexColors = 2, Kd.create = function(t, e) {
      return console.log("THREE.Curve.create() has been deprecated"), t.prototype = Object.create(Kd.prototype), t.prototype.constructor = t, t.prototype.getPoint = e, t
    }, Em.prototype.fromPoints = function(t) {
      return console.warn("THREE.Path: .fromPoints() has been renamed to .setFromPoints()."), this.setFromPoints(t)
    }, _g.prototype.setColors = function() {
      console.error("THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.")
    }, dg.prototype.update = function() {
      console.error("THREE.SkeletonHelper: update() no longer needs to be called.")
    }, Vd.prototype.extractUrlBase = function(t) {
      return console.warn("THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead."), Zm.extractUrlBase(t)
    }, Vd.Handlers = {
      add: function() {
        console.error("THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead.")
      },
      get: function() {
        console.error("THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead.")
      }
    }, rg.prototype.center = function(t) {
      return console.warn("THREE.Box2: .center() has been renamed to .getCenter()."), this.getCenter(t)
    }, rg.prototype.empty = function() {
      return console.warn("THREE.Box2: .empty() has been renamed to .isEmpty()."), this.isEmpty()
    }, rg.prototype.isIntersectionBox = function(t) {
      return console.warn("THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(t)
    }, rg.prototype.size = function(t) {
      return console.warn("THREE.Box2: .size() has been renamed to .getSize()."), this.getSize(t)
    }, yr.prototype.center = function(t) {
      return console.warn("THREE.Box3: .center() has been renamed to .getCenter()."), this.getCenter(t)
    }, yr.prototype.empty = function() {
      return console.warn("THREE.Box3: .empty() has been renamed to .isEmpty()."), this.isEmpty()
    }, yr.prototype.isIntersectionBox = function(t) {
      return console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(t)
    }, yr.prototype.isIntersectionSphere = function(t) {
      return console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere()."), this.intersectsSphere(t)
    }, yr.prototype.size = function(t) {
      return console.warn("THREE.Box3: .size() has been renamed to .getSize()."), this.getSize(t)
    }, Gr.prototype.empty = function() {
      return console.warn("THREE.Sphere: .empty() has been renamed to .isEmpty()."), this.isEmpty()
    }, Qs.prototype.setFromMatrix = function(t) {
      return console.warn("THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix()."), this.setFromProjectionMatrix(t)
    }, og.prototype.center = function(t) {
      return console.warn("THREE.Line3: .center() has been renamed to .getCenter()."), this.getCenter(t)
    }, or.prototype.flattenToArrayOffset = function(t, e) {
      return console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."), this.toArray(t, e)
    }, or.prototype.multiplyVector3 = function(t) {
      return console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."), t.applyMatrix3(this)
    }, or.prototype.multiplyVector3Array = function() {
      console.error("THREE.Matrix3: .multiplyVector3Array() has been removed.")
    }, or.prototype.applyToBufferAttribute = function(t) {
      return console.warn("THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead."), t.applyMatrix3(this)
    }, or.prototype.applyToVector3Array = function() {
      console.error("THREE.Matrix3: .applyToVector3Array() has been removed.")
    }, or.prototype.getInverse = function(t) {
      return console.warn("THREE.Matrix3: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."), this.copy(t).invert()
    }, Xr.prototype.extractPosition = function(t) {
      return console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."), this.copyPosition(t)
    }, Xr.prototype.flattenToArrayOffset = function(t, e) {
      return console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."), this.toArray(t, e)
    }, Xr.prototype.getPosition = function() {
      return console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead."), (new gr).setFromMatrixColumn(this, 3)
    }, Xr.prototype.setRotationFromQuaternion = function(t) {
      return console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."), this.makeRotationFromQuaternion(t)
    }, Xr.prototype.multiplyToArray = function() {
      console.warn("THREE.Matrix4: .multiplyToArray() has been removed.")
    }, Xr.prototype.multiplyVector3 = function(t) {
      return console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead."), t.applyMatrix4(this)
    }, Xr.prototype.multiplyVector4 = function(t) {
      return console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."), t.applyMatrix4(this)
    }, Xr.prototype.multiplyVector3Array = function() {
      console.error("THREE.Matrix4: .multiplyVector3Array() has been removed.")
    }, Xr.prototype.rotateAxis = function(t) {
      console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."), t.transformDirection(this)
    }, Xr.prototype.crossVector = function(t) {
      return console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."), t.applyMatrix4(this)
    }, Xr.prototype.translate = function() {
      console.error("THREE.Matrix4: .translate() has been removed.")
    }, Xr.prototype.rotateX = function() {
      console.error("THREE.Matrix4: .rotateX() has been removed.")
    }, Xr.prototype.rotateY = function() {
      console.error("THREE.Matrix4: .rotateY() has been removed.")
    }, Xr.prototype.rotateZ = function() {
      console.error("THREE.Matrix4: .rotateZ() has been removed.")
    }, Xr.prototype.rotateByAxis = function() {
      console.error("THREE.Matrix4: .rotateByAxis() has been removed.")
    }, Xr.prototype.applyToBufferAttribute = function(t) {
      return console.warn("THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead."), t.applyMatrix4(this)
    }, Xr.prototype.applyToVector3Array = function() {
      console.error("THREE.Matrix4: .applyToVector3Array() has been removed.")
    }, Xr.prototype.makeFrustum = function(t, e, n, r, i, s) {
      return console.warn("THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead."), this.makePerspective(t, e, r, n, i, s)
    }, Xr.prototype.getInverse = function(t) {
      return console.warn("THREE.Matrix4: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."), this.copy(t).invert()
    }, wi.prototype.isIntersectionLine = function(t) {
      return console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine()."), this.intersectsLine(t)
    }, fr.prototype.multiplyVector3 = function(t) {
      return console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."), t.applyQuaternion(this)
    }, fr.prototype.inverse = function() {
      return console.warn("THREE.Quaternion: .inverse() has been renamed to invert()."), this.invert()
    }, qr.prototype.isIntersectionBox = function(t) {
      return console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(t)
    }, qr.prototype.isIntersectionPlane = function(t) {
      return console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane()."), this.intersectsPlane(t)
    }, qr.prototype.isIntersectionSphere = function(t) {
      return console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere()."), this.intersectsSphere(t)
    }, Ii.prototype.area = function() {
      return console.warn("THREE.Triangle: .area() has been renamed to .getArea()."), this.getArea()
    }, Ii.prototype.barycoordFromPoint = function(t, e) {
      return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."), this.getBarycoord(t, e)
    }, Ii.prototype.midpoint = function(t) {
      return console.warn("THREE.Triangle: .midpoint() has been renamed to .getMidpoint()."), this.getMidpoint(t)
    }, Ii.prototypenormal = function(t) {
      return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."), this.getNormal(t)
    }, Ii.prototype.plane = function(t) {
      return console.warn("THREE.Triangle: .plane() has been renamed to .getPlane()."), this.getPlane(t)
    }, Ii.barycoordFromPoint = function(t, e, n, r, i) {
      return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."), Ii.getBarycoord(t, e, n, r, i)
    }, Ii.normal = function(t, e, n, r) {
      return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."), Ii.getNormal(t, e, n, r)
    }, Am.prototype.extractAllPoints = function(t) {
      return console.warn("THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead."), this.extractPoints(t)
    }, Am.prototype.extrude = function(t) {
      return console.warn("THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead."), new Zp(this, t)
    }, Am.prototype.makeGeometry = function(t) {
      return console.warn("THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead."), new rd(this, t)
    }, sr.prototype.fromAttribute = function(t, e, n) {
      return console.warn("THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(t, e, n)
    }, sr.prototype.distanceToManhattan = function(t) {
      return console.warn("THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."), this.manhattanDistanceTo(t)
    }, sr.prototype.lengthManhattan = function() {
      return console.warn("THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength()
    }, gr.prototype.setEulerFromRotationMatrix = function() {
      console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.")
    }, gr.prototype.setEulerFromQuaternion = function() {
      console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.")
    }, gr.prototype.getPositionFromMatrix = function(t) {
      return console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."), this.setFromMatrixPosition(t)
    }, gr.prototype.getScaleFromMatrix = function(t) {
      return console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."), this.setFromMatrixScale(t)
    }, gr.prototype.getColumnFromMatrix = function(t, e) {
      return console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."), this.setFromMatrixColumn(e, t)
    }, gr.prototype.applyProjection = function(t) {
      return console.warn("THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead."), this.applyMatrix4(t)
    }, gr.prototype.fromAttribute = function(t, e, n) {
      return console.warn("THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(t, e, n)
    }, gr.prototype.distanceToManhattan = function(t) {
      return console.warn("THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."), this.manhattanDistanceTo(t)
    }, gr.prototype.lengthManhattan = function() {
      return console.warn("THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength()
    }, pr.prototype.fromAttribute = function(t, e, n) {
      return console.warn("THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(t, e, n)
    }, pr.prototype.lengthManhattan = function() {
      return console.warn("THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength()
    }, vi.prototype.getChildByName = function(t) {
      return console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."), this.getObjectByName(t)
    }, vi.prototype.renderDepth = function() {
      console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.")
    }, vi.prototype.translate = function(t, e) {
      return console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."), this.translateOnAxis(e, t)
    }, vi.prototype.getWorldRotation = function() {
      console.error("THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.")
    }, vi.prototype.applyMatrix = function(t) {
      return console.warn("THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4()."), this.applyMatrix4(t)
    }, Object.defineProperties(vi.prototype, {
      eulerOrder: {
        get: function() {
          return console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order
        },
        set: function(t) {
          console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order = t
        }
      },
      useQuaternion: {
        get: function() {
          console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")
        },
        set: function() {
          console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")
        }
      }
    }), Ps.prototype.setDrawMode = function() {
      console.error("THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.")
    }, Object.defineProperties(Ps.prototype, {
      drawMode: {
        get: function() {
          return console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode."), 0
        },
        set: function() {
          console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.")
        }
      }
    }), Eu.prototype.initBones = function() {
      console.error("THREE.SkinnedMesh: initBones() has been removed.")
    }, ks.prototype.setLens = function(t, e) {
      console.warn("THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup."), void 0 !== e && (this.filmGauge = e), this.setFocalLength(t)
    }, Object.defineProperties(Lm.prototype, {
      onlyShadow: {
        set: function() {
          console.warn("THREE.Light: .onlyShadow has been removed.")
        }
      },
      shadowCameraFov: {
        set: function(t) {
          console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov."), this.shadow.camera.fov = t
        }
      },
      shadowCameraLeft: {
        set: function(t) {
          console.warn("THREE.Light: .shadowCameraLeft is now .shadow.camera.left."), this.shadow.camera.left = t
        }
      },
      shadowCameraRight: {
        set: function(t) {
          console.warn("THREE.Light: .shadowCameraRight is now .shadow.camera.right."), this.shadow.camera.right = t
        }
      },
      shadowCameraTop: {
        set: function(t) {
          console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top."), this.shadow.camera.top = t
        }
      },
      shadowCameraBottom: {
        set: function(t) {
          console.warn("THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom."), this.shadow.camera.bottom = t
        }
      },
      shadowCameraNear: {
        set: function(t) {
          console.warn("THREE.Light: .shadowCameraNear is now .shadow.camera.near."), this.shadow.camera.near = t
        }
      },
      shadowCameraFar: {
        set: function(t) {
          console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far."), this.shadow.camera.far = t
        }
      },
      shadowCameraVisible: {
        set: function() {
          console.warn("THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.")
        }
      },
      shadowBias: {
        set: function(t) {
          console.warn("THREE.Light: .shadowBias is now .shadow.bias."), this.shadow.bias = t
        }
      },
      shadowDarkness: {
        set: function() {
          console.warn("THREE.Light: .shadowDarkness has been removed.")
        }
      },
      shadowMapWidth: {
        set: function(t) {
          console.warn("THREE.Light: .shadowMapWidth is now .shadow.mapSize.width."), this.shadow.mapSize.width = t
        }
      },
      shadowMapHeight: {
        set: function(t) {
          console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height."), this.shadow.mapSize.height = t
        }
      }
    }), Object.defineProperties(qi.prototype, {
      length: {
        get: function() {
          return console.warn("THREE.BufferAttribute: .length has been deprecated. Use .count instead."), this.array.length
        }
      },
      dynamic: {
        get: function() {
          return console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."), this.usage === Mn
        },
        set: function() {
          console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."), this.setUsage(Mn)
        }
      }
    }), qi.prototype.setDynamic = function(t) {
      return console.warn("THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead."), this.setUsage(!0 === t ? Mn : wn), this
    }, qi.prototype.copyIndicesArray = function() {
      console.error("THREE.BufferAttribute: .copyIndicesArray() has been removed.")
    }, qi.prototype.setArray = function() {
      console.error("THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers")
    }, ds.prototype.addIndex = function(t) {
      console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex()."), this.setIndex(t)
    }, ds.prototype.addAttribute = function(t, e) {
      return console.warn("THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute()."), e && e.isBufferAttribute || e && e.isInterleavedBufferAttribute ? "index" === t ? (console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."), this.setIndex(e), this) : this.setAttribute(t, e) : (console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."), this.setAttribute(t, new qi(arguments[1], arguments[2])))
    }, ds.prototype.addDrawCall = function(t, e, n) {
      void 0 !== n && console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset."), console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup()."), this.addGroup(t, e)
    }, ds.prototype.clearDrawCalls = function() {
      console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups()."), this.clearGroups()
    }, ds.prototype.computeOffsets = function() {
      console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.")
    }, ds.prototype.removeAttribute = function(t) {
      return console.warn("THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute()."), this.deleteAttribute(t)
    }, ds.prototype.applyMatrix = function(t) {
      return console.warn("THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4()."), this.applyMatrix4(t)
    }, Object.defineProperties(ds.prototype, {
      drawcalls: {
        get: function() {
          return console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups."), this.groups
        }
      },
      offsets: {
        get: function() {
          return console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups."), this.groups
        }
      }
    }), $h.prototype.setDynamic = function(t) {
      return console.warn("THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead."), this.setUsage(!0 === t ? Mn : wn), this
    }, $h.prototype.setArray = function() {
      console.error("THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers")
    }, Zp.prototype.getArrays = function() {
      console.error("THREE.ExtrudeGeometry: .getArrays() has been removed.")
    }, Zp.prototype.addShapeList = function() {
      console.error("THREE.ExtrudeGeometry: .addShapeList() has been removed.")
    }, Zp.prototype.addShape = function() {
      console.error("THREE.ExtrudeGeometry: .addShape() has been removed.")
    }, Kh.prototype.dispose = function() {
      console.error("THREE.Scene: .dispose() has been removed.")
    }, Yf.prototype.onUpdate = function() {
      return console.warn("THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead."), this
    }, Object.defineProperties(Ni.prototype, {
      wrapAround: {
        get: function() {
          console.warn("THREE.Material: .wrapAround has been removed.")
        },
        set: function() {
          console.warn("THREE.Material: .wrapAround has been removed.")
        }
      },
      overdraw: {
        get: function() {
          console.warn("THREE.Material: .overdraw has been removed.")
        },
        set: function() {
          console.warn("THREE.Material: .overdraw has been removed.")
        }
      },
      wrapRGB: {
        get: function() {
          return console.warn("THREE.Material: .wrapRGB has been removed."), new ki
        }
      },
      shading: {
        get: function() {
          console.error("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead.")
        },
        set: function(t) {
          console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."), this.flatShading = 1 === t
        }
      },
      stencilMask: {
        get: function() {
          return console.warn("THREE." + this.type + ": .stencilMask has been removed. Use .stencilFuncMask instead."), this.stencilFuncMask
        },
        set: function(t) {
          console.warn("THREE." + this.type + ": .stencilMask has been removed. Use .stencilFuncMask instead."), this.stencilFuncMask = t
        }
      }
    }), Object.defineProperties(Hs.prototype, {
      derivatives: {
        get: function() {
          return console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives."), this.extensions.derivatives
        },
        set: function(t) {
          console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives."), this.extensions.derivatives = t
        }
      }
    }), Yh.prototype.clearTarget = function(t, e, n, r) {
      console.warn("THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead."), this.setRenderTarget(t), this.clear(e, n, r)
    }, Yh.prototype.animate = function(t) {
      console.warn("THREE.WebGLRenderer: .animate() is now .setAnimationLoop()."), this.setAnimationLoop(t)
    }, Yh.prototype.getCurrentRenderTarget = function() {
      return console.warn("THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget()."), this.getRenderTarget()
    }, Yh.prototype.getMaxAnisotropy = function() {
      return console.warn("THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy()."), this.capabilities.getMaxAnisotropy()
    }, Yh.prototype.getPrecision = function() {
      return console.warn("THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision."), this.capabilities.precision
    }, Yh.prototype.resetGLState = function() {
      return console.warn("THREE.WebGLRenderer: .resetGLState() is now .state.reset()."), this.state.reset()
    }, Yh.prototype.supportsFloatTextures = function() {
      return console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."), this.extensions.get("OES_texture_float")
    }, Yh.prototype.supportsHalfFloatTextures = function() {
      return console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."), this.extensions.get("OES_texture_half_float")
    }, Yh.prototype.supportsStandardDerivatives = function() {
      return console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."), this.extensions.get("OES_standard_derivatives")
    }, Yh.prototype.supportsCompressedTextureS3TC = function() {
      return console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."), this.extensions.get("WEBGL_compressed_texture_s3tc")
    }, Yh.prototype.supportsCompressedTexturePVRTC = function() {
      return console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."), this.extensions.get("WEBGL_compressed_texture_pvrtc")
    }, Yh.prototype.supportsBlendMinMax = function() {
      return console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."), this.extensions.get("EXT_blend_minmax")
    }, Yh.prototype.supportsVertexTextures = function() {
      return console.warn("THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures."), this.capabilities.vertexTextures
    }, Yh.prototype.supportsInstancedArrays = function() {
      return console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."), this.extensions.get("ANGLE_instanced_arrays")
    }, Yh.prototype.enableScissorTest = function(t) {
      console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest()."), this.setScissorTest(t)
    }, Yh.prototype.initMaterial = function() {
      console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.")
    }, Yh.prototype.addPrePlugin = function() {
      console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.")
    }, Yh.prototype.addPostPlugin = function() {
      console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.")
    }, Yh.prototype.updateShadowMap = function() {
      console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.")
    }, Yh.prototype.setFaceCulling = function() {
      console.warn("THREE.WebGLRenderer: .setFaceCulling() has been removed.")
    }, Yh.prototype.allocTextureUnit = function() {
      console.warn("THREE.WebGLRenderer: .allocTextureUnit() has been removed.")
    }, Yh.prototype.setTexture = function() {
      console.warn("THREE.WebGLRenderer: .setTexture() has been removed.")
    }, Yh.prototype.setTexture2D = function() {
      console.warn("THREE.WebGLRenderer: .setTexture2D() has been removed.")
    }, Yh.prototype.setTextureCube = function() {
      console.warn("THREE.WebGLRenderer: .setTextureCube() has been removed.")
    }, Yh.prototype.getActiveMipMapLevel = function() {
      return console.warn("THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel()."), this.getActiveMipmapLevel()
    }, Object.defineProperties(Yh.prototype, {
      shadowMapEnabled: {
        get: function() {
          return this.shadowMap.enabled
        },
        set: function(t) {
          console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled."), this.shadowMap.enabled = t
        }
      },
      shadowMapType: {
        get: function() {
          return this.shadowMap.type
        },
        set: function(t) {
          console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type."), this.shadowMap.type = t
        }
      },
      shadowMapCullFace: {
        get: function() {
          console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")
        },
        set: function() {
          console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")
        }
      },
      context: {
        get: function() {
          return console.warn("THREE.WebGLRenderer: .context has been removed. Use .getContext() instead."), this.getContext()
        }
      },
      vr: {
        get: function() {
          return console.warn("THREE.WebGLRenderer: .vr has been renamed to .xr"), this.xr
        }
      },
      gammaInput: {
        get: function() {
          return console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead."), !1
        },
        set: function() {
          console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.")
        }
      },
      gammaOutput: {
        get: function() {
          return console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."), !1
        },
        set: function(t) {
          console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."), this.outputEncoding = !0 === t ? Ye : Xe
        }
      },
      toneMappingWhitePoint: {
        get: function() {
          return console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed."), 1
        },
        set: function() {
          console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.")
        }
      }
    }), Object.defineProperties(zh.prototype, {
      cullFace: {
        get: function() {
          console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")
        },
        set: function() {
          console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")
        }
      },
      renderReverseSided: {
        get: function() {
          console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")
        },
        set: function() {
          console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")
        }
      },
      renderSingleSided: {
        get: function() {
          console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")
        },
        set: function() {
          console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")
        }
      }
    }), Object.defineProperties(dr.prototype, {
      wrapS: {
        get: function() {
          return console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS
        },
        set: function(t) {
          console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS = t
        }
      },
      wrapT: {
        get: function() {
          return console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."), this.texture.wrapT
        },
        set: function(t) {
          console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."), this.texture.wrapT = t
        }
      },
      magFilter: {
        get: function() {
          return console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."), this.texture.magFilter
        },
        set: function(t) {
          console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."), this.texture.magFilter = t
        }
      },
      minFilter: {
        get: function() {
          return console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."), this.texture.minFilter
        },
        set: function(t) {
          console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."), this.texture.minFilter = t
        }
      },
      anisotropy: {
        get: function() {
          return console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."), this.texture.anisotropy
        },
        set: function(t) {
          console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."), this.texture.anisotropy = t
        }
      },
      offset: {
        get: function() {
          return console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."), this.texture.offset
        },
        set: function(t) {
          console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."), this.texture.offset = t
        }
      },
      repeat: {
        get: function() {
          return console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."), this.texture.repeat
        },
        set: function(t) {
          console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."), this.texture.repeat = t
        }
      },
      format: {
        get: function() {
          return console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."), this.texture.format
        },
        set: function(t) {
          console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."), this.texture.format = t
        }
      },
      type: {
        get: function() {
          return console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."), this.texture.type
        },
        set: function(t) {
          console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."), this.texture.type = t
        }
      },
      generateMipmaps: {
        get: function() {
          return console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."), this.texture.generateMipmaps
        },
        set: function(t) {
          console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."), this.texture.generateMipmaps = t
        }
      }
    }), Tf.prototype.load = function(t) {
      console.warn("THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.");
      const e = this;
      return (new pf).load(t, function(t) {
        e.setBuffer(t)
      }), this
    }, Pf.prototype.getData = function() {
      return console.warn("THREE.AudioAnalyser: .getData() is now .getFrequencyData()."), this.getFrequencyData()
    }, js.prototype.updateCubeMap = function(t, e) {
      return console.warn("THREE.CubeCamera: .updateCubeMap() is now .update()."), this.update(t, e)
    }, js.prototype.clear = function(t, e, n, r) {
      return console.warn("THREE.CubeCamera: .clear() is now .renderTarget.clear()."), this.renderTarget.clear(t, e, n, r)
    }, lr.crossOrigin = void 0, lr.loadTexture = function(t, e, n, r) {
      console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.");
      const i = new Qd;
      i.setCrossOrigin(this.crossOrigin);
      const s = i.load(t, n, void 0, r);
      return e && (s.mapping = e), s
    }, lr.loadTextureCube = function(t, e, n, r) {
      console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.");
      const i = new Zd;
      i.setCrossOrigin(this.crossOrigin);
      const s = i.load(t, n, void 0, r);
      return e && (s.mapping = e), s
    }, lr.loadCompressedTexture = function() {
      console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.")
    }, lr.loadCompressedTextureCube = function() {
      console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.")
    };
    const Jx = {
      createMultiMaterialObject: function() {
        console.error("THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js")
      },
      detach: function() {
        console.error("THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js")
      },
      attach: function() {
        console.error("THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js")
      }
    };

    function Qx() {
      console.error("THREE.LensFlare has been moved to /examples/jsm/objects/Lensflare.js")
    }
    exports.SceneUtils = Jx, "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", {
      detail: {
        revision: "128"
      }
    })), "undefined" != typeof window && (window.__THREE__ ? console.warn("WARNING: Multiple instances of Three.js being imported.") : window.__THREE__ = "128");
  }, {}],
  "MSNG": [function(require, module, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    }), exports.VERTEX_SHADER = void 0, exports.VERTEX_SHADER = "attribute float scale;\n      attribute vec4 colors;\n      varying vec4 vColor;\n      void main() {\n\n      \tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n       vColor = colors;\n        gl_PointSize = clamp(scale, 0.0, 1000.0) ; \n          gl_Position = projectionMatrix * mvPosition;\n      }\n    ";
  }, {}],
  "TYFO": [function(require, module, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    }), exports.FRAGMENT_SHADER = void 0, exports.FRAGMENT_SHADER = "\n       uniform sampler2D spriteTexture;\n       varying vec4 vColor;\n\n             void main() {\nif ( length( gl_PointCoord - vec2( 0.5, 0.5 ) ) > 0.475 ) discard;\n\n      \tgl_FragColor = vColor;\n               \n\n             }\n             \n    ";
  }, {}],
  "BESp": [function(require, module, exports) {
    "use strict";
    var t = this && this.__createBinding || (Object.create ? function(t, e, i, s) {
        void 0 === s && (s = i), Object.defineProperty(t, s, {
          enumerable: !0,
          get: function() {
            return e[i]
          }
        })
      } : function(t, e, i, s) {
        void 0 === s && (s = i), t[s] = e[i]
      }),
      e = this && this.__setModuleDefault || (Object.create ? function(t, e) {
        Object.defineProperty(t, "default", {
          enumerable: !0,
          value: e
        })
      } : function(t, e) {
        t.default = e
      }),
      i = this && this.__importStar || function(i) {
        if (i && i.__esModule) return i;
        var s = {};
        if (null != i)
          for (var r in i) "default" !== r && Object.prototype.hasOwnProperty.call(i, r) && t(s, i, r);
        return e(s, i), s
      };
    Object.defineProperty(exports, "__esModule", {
      value: !0
    }), exports.Hero = void 0;
    var s = i(require("three")),
      r = require("./vertexShader"),
      h = require("./fragmentShader"),
      n = function() {
        function t() {
          this.time = 0, this.SPACING = 30, this.AMOUNTX = 60, this.AMOUNTY = 60, this.MAX_POINT_SIZE = 70 * window.devicePixelRatio, this.MIN_POINT_SIZE = .1, this.RIPPLE_SPEED = 4, this.COLOR_ONE = {
            r: 220 / 255,
            g: 81 / 255,
            b: 1
          }, this.COLOR_TWO = {
            r: 39 / 255,
            g: 100 / 255,
            b: 217 / 255
          }, this.MAX_OPACITY = .2, this.init(), this.animate()
        }
        return t.prototype.init = function() {
          this.heroCont = document.querySelector(".hero"), this.canvas = document.querySelector(".hero-threejs"), this.renderer = new s.WebGLRenderer({
            canvas: this.canvas,
            antialias: !0,
            alpha: !0
          }), this.renderer.setPixelRatio(window.devicePixelRatio), this.renderer.setSize(this.heroCont.clientWidth, this.heroCont.clientHeight), this.camera = new s.PerspectiveCamera(75, this.heroCont.clientWidth / this.heroCont.clientHeight, 1, 1e4), this.camera.position.z = 1e3, this.scene = new s.Scene, this.clock = new s.Clock;
          var t = this.createParticleValues(),
            e = t.positions,
            i = t.scales,
            n = t.colors,
            a = new s.BufferGeometry;
          a.setAttribute("position", new s.BufferAttribute(e, 3)), a.setAttribute("scale", new s.BufferAttribute(i, 1)), a.setAttribute("colors", new s.BufferAttribute(n, 4));
          var o = new s.ShaderMaterial({
            vertexShader: r.VERTEX_SHADER,
            fragmentShader: h.FRAGMENT_SHADER,
            transparent: !0
          });
          this.particles = new s.Points(a, o), this.OFFSET_Y_HEIGHT = this.heroCont.clientWidth <= 550 ? 300 : 200, this.particles.geometry.translate(-(this.AMOUNTX - 1) * this.SPACING * .5, this.AMOUNTY * this.SPACING * .5 + this.OFFSET_Y_HEIGHT, 0), this.scene.add(this.particles)
        }, t.prototype.createParticleValues = function() {
          this.numParticles = this.AMOUNTX * this.AMOUNTY, this.sizeOffsets = new Float32Array(this.numParticles);
          for (var t = new Float32Array(3 * this.numParticles), e = new Float32Array(this.numParticles), i = new Float32Array(4 * this.numParticles), s = 0, r = 0, h = this.SPACING * ((this.AMOUNTX - 1) / 2), n = 0; n < this.numParticles; n++) {
            t[s] = this.SPACING * (n % this.AMOUNTX), t[s + 1] = -this.SPACING * ~~(n / this.AMOUNTX), t[s + 2] = 0;
            var a = Math.hypot(this.SPACING * ((this.AMOUNTX - 1) / 2) - t[s], -this.SPACING * ((this.AMOUNTY - 1) / 2) - t[s + 1]);
            this.sizeOffsets[n] = Math.PI / (a + .001) * 500, i[r] = this.numMap(a, 0, h, this.COLOR_ONE.r, this.COLOR_TWO.r), i[r + 1] = this.numMap(a, 0, h, this.COLOR_ONE.g, this.COLOR_TWO.g), i[r + 2] = this.numMap(a, 0, h, this.COLOR_ONE.b, this.COLOR_TWO.b), i[r + 3] = this.numMap(a - 5 * this.SPACING, 0, h, this.MAX_OPACITY, 0), e[s] = 0, s += 3, r += 4
          }
          return {
            positions: t,
            scales: e,
            colors: i
          }
        }, t.prototype.animate = function() {
          requestAnimationFrame(this.animate.bind(this)), this.checkResize() && this.resize();
          for (var t = this.clock.getDelta(), e = this.particles.geometry.attributes.scale.array, i = this.particles.geometry.attributes.colors.array, s = 0; s < this.numParticles; s++) e[s] = Math.sin(this.sizeOffsets[s] + this.time) * i[4 * s + 3] * this.MAX_POINT_SIZE + this.MIN_POINT_SIZE;
          this.particles.geometry.attributes.scale.needsUpdate = !0, this.renderer.render(this.scene, this.camera), this.time += t * this.RIPPLE_SPEED
        }, t.prototype.resize = function() {
          this.camera.aspect = this.heroCont.clientWidth / this.heroCont.clientHeight, this.camera.updateProjectionMatrix(), this.renderer.setSize(this.heroCont.clientWidth, this.heroCont.clientHeight), this.heroCont.clientWidth > 550 && 300 === this.OFFSET_Y_HEIGHT ? (this.OFFSET_Y_HEIGHT = 200, this.particles.geometry.translate(0, -100, 0)) : this.heroCont.clientWidth <= 550 && 200 === this.OFFSET_Y_HEIGHT && (this.OFFSET_Y_HEIGHT = 300, this.particles.geometry.translate(0, 100, 0))
        }, t.prototype.checkResize = function() {
          return this.canvas.width !== this.canvas.clientWidth || this.canvas.height !== this.canvas.clientHeight
        }, t.prototype.numMap = function(t, e, i, s, r) {
          return (t - e) / (i - e) * (r - s) + s
        }, t
      }();
    exports.Hero = n;
  }, {
    "three": "dKqR",
    "./vertexShader": "MSNG",
    "./fragmentShader": "TYFO"
  }],
  "JuNv": [function(require, module, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    }), exports.ONE_TOKEN_ABI = exports.PANCAKE_ABI = exports.BEP20PairABI = void 0, exports.BEP20PairABI = [{
      inputs: [],
      payable: !1,
      stateMutability: "nonpayable",
      type: "constructor"
    }, {
      anonymous: !1,
      inputs: [{
        indexed: !0,
        internalType: "address",
        name: "owner",
        type: "address"
      }, {
        indexed: !0,
        internalType: "address",
        name: "spender",
        type: "address"
      }, {
        indexed: !1,
        internalType: "uint256",
        name: "value",
        type: "uint256"
      }],
      name: "Approval",
      type: "event"
    }, {
      anonymous: !1,
      inputs: [{
        indexed: !0,
        internalType: "address",
        name: "sender",
        type: "address"
      }, {
        indexed: !1,
        internalType: "uint256",
        name: "amount0",
        type: "uint256"
      }, {
        indexed: !1,
        internalType: "uint256",
        name: "amount1",
        type: "uint256"
      }, {
        indexed: !0,
        internalType: "address",
        name: "to",
        type: "address"
      }],
      name: "Burn",
      type: "event"
    }, {
      anonymous: !1,
      inputs: [{
        indexed: !0,
        internalType: "address",
        name: "sender",
        type: "address"
      }, {
        indexed: !1,
        internalType: "uint256",
        name: "amount0",
        type: "uint256"
      }, {
        indexed: !1,
        internalType: "uint256",
        name: "amount1",
        type: "uint256"
      }],
      name: "Mint",
      type: "event"
    }, {
      anonymous: !1,
      inputs: [{
        indexed: !0,
        internalType: "address",
        name: "sender",
        type: "address"
      }, {
        indexed: !1,
        internalType: "uint256",
        name: "amount0In",
        type: "uint256"
      }, {
        indexed: !1,
        internalType: "uint256",
        name: "amount1In",
        type: "uint256"
      }, {
        indexed: !1,
        internalType: "uint256",
        name: "amount0Out",
        type: "uint256"
      }, {
        indexed: !1,
        internalType: "uint256",
        name: "amount1Out",
        type: "uint256"
      }, {
        indexed: !0,
        internalType: "address",
        name: "to",
        type: "address"
      }],
      name: "Swap",
      type: "event"
    }, {
      anonymous: !1,
      inputs: [{
        indexed: !1,
        internalType: "uint112",
        name: "reserve0",
        type: "uint112"
      }, {
        indexed: !1,
        internalType: "uint112",
        name: "reserve1",
        type: "uint112"
      }],
      name: "Sync",
      type: "event"
    }, {
      anonymous: !1,
      inputs: [{
        indexed: !0,
        internalType: "address",
        name: "from",
        type: "address"
      }, {
        indexed: !0,
        internalType: "address",
        name: "to",
        type: "address"
      }, {
        indexed: !1,
        internalType: "uint256",
        name: "value",
        type: "uint256"
      }],
      name: "Transfer",
      type: "event"
    }, {
      constant: !0,
      inputs: [],
      name: "DOMAIN_SEPARATOR",
      outputs: [{
        internalType: "bytes32",
        name: "",
        type: "bytes32"
      }],
      payable: !1,
      stateMutability: "view",
      type: "function"
    }, {
      constant: !0,
      inputs: [],
      name: "MINIMUM_LIQUIDITY",
      outputs: [{
        internalType: "uint256",
        name: "",
        type: "uint256"
      }],
      payable: !1,
      stateMutability: "view",
      type: "function"
    }, {
      constant: !0,
      inputs: [],
      name: "PERMIT_TYPEHASH",
      outputs: [{
        internalType: "bytes32",
        name: "",
        type: "bytes32"
      }],
      payable: !1,
      stateMutability: "view",
      type: "function"
    }, {
      constant: !0,
      inputs: [{
        internalType: "address",
        name: "",
        type: "address"
      }, {
        internalType: "address",
        name: "",
        type: "address"
      }],
      name: "allowance",
      outputs: [{
        internalType: "uint256",
        name: "",
        type: "uint256"
      }],
      payable: !1,
      stateMutability: "view",
      type: "function"
    }, {
      constant: !1,
      inputs: [{
        internalType: "address",
        name: "spender",
        type: "address"
      }, {
        internalType: "uint256",
        name: "value",
        type: "uint256"
      }],
      name: "approve",
      outputs: [{
        internalType: "bool",
        name: "",
        type: "bool"
      }],
      payable: !1,
      stateMutability: "nonpayable",
      type: "function"
    }, {
      constant: !0,
      inputs: [{
        internalType: "address",
        name: "",
        type: "address"
      }],
      name: "balanceOf",
      outputs: [{
        internalType: "uint256",
        name: "",
        type: "uint256"
      }],
      payable: !1,
      stateMutability: "view",
      type: "function"
    }, {
      constant: !1,
      inputs: [{
        internalType: "address",
        name: "to",
        type: "address"
      }],
      name: "burn",
      outputs: [{
        internalType: "uint256",
        name: "amount0",
        type: "uint256"
      }, {
        internalType: "uint256",
        name: "amount1",
        type: "uint256"
      }],
      payable: !1,
      stateMutability: "nonpayable",
      type: "function"
    }, {
      constant: !0,
      inputs: [],
      name: "decimals",
      outputs: [{
        internalType: "uint8",
        name: "",
        type: "uint8"
      }],
      payable: !1,
      stateMutability: "view",
      type: "function"
    }, {
      constant: !0,
      inputs: [],
      name: "factory",
      outputs: [{
        internalType: "address",
        name: "",
        type: "address"
      }],
      payable: !1,
      stateMutability: "view",
      type: "function"
    }, {
      constant: !0,
      inputs: [],
      name: "getReserves",
      outputs: [{
        internalType: "uint112",
        name: "_reserve0",
        type: "uint112"
      }, {
        internalType: "uint112",
        name: "_reserve1",
        type: "uint112"
      }, {
        internalType: "uint32",
        name: "_blockTimestampLast",
        type: "uint32"
      }],
      payable: !1,
      stateMutability: "view",
      type: "function"
    }, {
      constant: !1,
      inputs: [{
        internalType: "address",
        name: "_token0",
        type: "address"
      }, {
        internalType: "address",
        name: "_token1",
        type: "address"
      }],
      name: "initialize",
      outputs: [],
      payable: !1,
      stateMutability: "nonpayable",
      type: "function"
    }, {
      constant: !0,
      inputs: [],
      name: "kLast",
      outputs: [{
        internalType: "uint256",
        name: "",
        type: "uint256"
      }],
      payable: !1,
      stateMutability: "view",
      type: "function"
    }, {
      constant: !1,
      inputs: [{
        internalType: "address",
        name: "to",
        type: "address"
      }],
      name: "mint",
      outputs: [{
        internalType: "uint256",
        name: "liquidity",
        type: "uint256"
      }],
      payable: !1,
      stateMutability: "nonpayable",
      type: "function"
    }, {
      constant: !0,
      inputs: [],
      name: "name",
      outputs: [{
        internalType: "string",
        name: "",
        type: "string"
      }],
      payable: !1,
      stateMutability: "view",
      type: "function"
    }, {
      constant: !0,
      inputs: [{
        internalType: "address",
        name: "",
        type: "address"
      }],
      name: "nonces",
      outputs: [{
        internalType: "uint256",
        name: "",
        type: "uint256"
      }],
      payable: !1,
      stateMutability: "view",
      type: "function"
    }, {
      constant: !1,
      inputs: [{
        internalType: "address",
        name: "owner",
        type: "address"
      }, {
        internalType: "address",
        name: "spender",
        type: "address"
      }, {
        internalType: "uint256",
        name: "value",
        type: "uint256"
      }, {
        internalType: "uint256",
        name: "deadline",
        type: "uint256"
      }, {
        internalType: "uint8",
        name: "v",
        type: "uint8"
      }, {
        internalType: "bytes32",
        name: "r",
        type: "bytes32"
      }, {
        internalType: "bytes32",
        name: "s",
        type: "bytes32"
      }],
      name: "permit",
      outputs: [],
      payable: !1,
      stateMutability: "nonpayable",
      type: "function"
    }, {
      constant: !0,
      inputs: [],
      name: "price0CumulativeLast",
      outputs: [{
        internalType: "uint256",
        name: "",
        type: "uint256"
      }],
      payable: !1,
      stateMutability: "view",
      type: "function"
    }, {
      constant: !0,
      inputs: [],
      name: "price1CumulativeLast",
      outputs: [{
        internalType: "uint256",
        name: "",
        type: "uint256"
      }],
      payable: !1,
      stateMutability: "view",
      type: "function"
    }, {
      constant: !1,
      inputs: [{
        internalType: "address",
        name: "to",
        type: "address"
      }],
      name: "skim",
      outputs: [],
      payable: !1,
      stateMutability: "nonpayable",
      type: "function"
    }, {
      constant: !1,
      inputs: [{
        internalType: "uint256",
        name: "amount0Out",
        type: "uint256"
      }, {
        internalType: "uint256",
        name: "amount1Out",
        type: "uint256"
      }, {
        internalType: "address",
        name: "to",
        type: "address"
      }, {
        internalType: "bytes",
        name: "data",
        type: "bytes"
      }],
      name: "swap",
      outputs: [],
      payable: !1,
      stateMutability: "nonpayable",
      type: "function"
    }, {
      constant: !0,
      inputs: [],
      name: "symbol",
      outputs: [{
        internalType: "string",
        name: "",
        type: "string"
      }],
      payable: !1,
      stateMutability: "view",
      type: "function"
    }, {
      constant: !1,
      inputs: [],
      name: "sync",
      outputs: [],
      payable: !1,
      stateMutability: "nonpayable",
      type: "function"
    }, {
      constant: !0,
      inputs: [],
      name: "token0",
      outputs: [{
        internalType: "address",
        name: "",
        type: "address"
      }],
      payable: !1,
      stateMutability: "view",
      type: "function"
    }, {
      constant: !0,
      inputs: [],
      name: "token1",
      outputs: [{
        internalType: "address",
        name: "",
        type: "address"
      }],
      payable: !1,
      stateMutability: "view",
      type: "function"
    }, {
      constant: !0,
      inputs: [],
      name: "totalSupply",
      outputs: [{
        internalType: "uint256",
        name: "",
        type: "uint256"
      }],
      payable: !1,
      stateMutability: "view",
      type: "function"
    }, {
      constant: !1,
      inputs: [{
        internalType: "address",
        name: "to",
        type: "address"
      }, {
        internalType: "uint256",
        name: "value",
        type: "uint256"
      }],
      name: "transfer",
      outputs: [{
        internalType: "bool",
        name: "",
        type: "bool"
      }],
      payable: !1,
      stateMutability: "nonpayable",
      type: "function"
    }, {
      constant: !1,
      inputs: [{
        internalType: "address",
        name: "from",
        type: "address"
      }, {
        internalType: "address",
        name: "to",
        type: "address"
      }, {
        internalType: "uint256",
        name: "value",
        type: "uint256"
      }],
      name: "transferFrom",
      outputs: [{
        internalType: "bool",
        name: "",
        type: "bool"
      }],
      payable: !1,
      stateMutability: "nonpayable",
      type: "function"
    }], exports.PANCAKE_ABI = [{
      inputs: [{
        internalType: "address",
        name: "_feeToSetter",
        type: "address"
      }],
      stateMutability: "nonpayable",
      type: "constructor"
    }, {
      anonymous: !1,
      inputs: [{
        indexed: !0,
        internalType: "address",
        name: "token0",
        type: "address"
      }, {
        indexed: !0,
        internalType: "address",
        name: "token1",
        type: "address"
      }, {
        indexed: !1,
        internalType: "address",
        name: "pair",
        type: "address"
      }, {
        indexed: !1,
        internalType: "uint256",
        name: "",
        type: "uint256"
      }],
      name: "PairCreated",
      type: "event"
    }, {
      inputs: [{
        internalType: "uint256",
        name: "",
        type: "uint256"
      }],
      name: "allPairs",
      outputs: [{
        internalType: "address",
        name: "",
        type: "address"
      }],
      stateMutability: "view",
      type: "function"
    }, {
      inputs: [],
      name: "allPairsLength",
      outputs: [{
        internalType: "uint256",
        name: "",
        type: "uint256"
      }],
      stateMutability: "view",
      type: "function"
    }, {
      inputs: [{
        internalType: "address",
        name: "tokenA",
        type: "address"
      }, {
        internalType: "address",
        name: "tokenB",
        type: "address"
      }],
      name: "createPair",
      outputs: [{
        internalType: "address",
        name: "pair",
        type: "address"
      }],
      stateMutability: "nonpayable",
      type: "function"
    }, {
      inputs: [],
      name: "feeTo",
      outputs: [{
        internalType: "address",
        name: "",
        type: "address"
      }],
      stateMutability: "view",
      type: "function"
    }, {
      inputs: [],
      name: "feeToSetter",
      outputs: [{
        internalType: "address",
        name: "",
        type: "address"
      }],
      stateMutability: "view",
      type: "function"
    }, {
      inputs: [{
        internalType: "address",
        name: "",
        type: "address"
      }, {
        internalType: "address",
        name: "",
        type: "address"
      }],
      name: "getPair",
      outputs: [{
        internalType: "address",
        name: "",
        type: "address"
      }],
      stateMutability: "view",
      type: "function"
    }, {
      inputs: [],
      name: "pairCodeHash",
      outputs: [{
        internalType: "bytes32",
        name: "",
        type: "bytes32"
      }],
      stateMutability: "pure",
      type: "function"
    }, {
      inputs: [{
        internalType: "address",
        name: "_feeTo",
        type: "address"
      }],
      name: "setFeeTo",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    }, {
      inputs: [{
        internalType: "address",
        name: "_feeToSetter",
        type: "address"
      }],
      name: "setFeeToSetter",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    }], exports.ONE_TOKEN_ABI = [{
  "inputs": [],
  "stateMutability": "nonpayable",
  "type": "constructor"
}, {
  "anonymous": !1,
  "inputs": [{
    "indexed": !0,
    "internalType": "address",
    "name": "owner",
    "type": "address"
  }, {
    "indexed": !0,
    "internalType": "address",
    "name": "spender",
    "type": "address"
  }, {
    "indexed": !1,
    "internalType": "uint256",
    "name": "value",
    "type": "uint256"
  }],
  "name": "Approval",
  "type": "event"
}, {
  "anonymous": !1,
  "inputs": [{
    "indexed": !0,
    "internalType": "address",
    "name": "account",
    "type": "address"
  }, {
    "indexed": !1,
    "internalType": "bool",
    "name": "isExcluded",
    "type": "bool"
  }],
  "name": "ExcludeFromFees",
  "type": "event"
}, {
  "anonymous": !1,
  "inputs": [{
    "indexed": !1,
    "internalType": "address[]",
    "name": "accounts",
    "type": "address[]"
  }, {
    "indexed": !1,
    "internalType": "bool",
    "name": "isExcluded",
    "type": "bool"
  }],
  "name": "ExcludeMultipleAccountsFromFees",
  "type": "event"
}, {
  "anonymous": !1,
  "inputs": [{
    "indexed": !0,
    "internalType": "address",
    "name": "account",
    "type": "address"
  }, {
    "indexed": !1,
    "internalType": "bool",
    "name": "isExcluded",
    "type": "bool"
  }],
  "name": "ExcludedMaxSellTransactionAmount",
  "type": "event"
}, {
  "anonymous": !1,
  "inputs": [{
    "indexed": !0,
    "internalType": "address",
    "name": "account",
    "type": "address"
  }, {
    "indexed": !0,
    "internalType": "uint256",
    "name": "amount",
    "type": "uint256"
  }, {
    "indexed": !0,
    "internalType": "bool",
    "name": "earlyParticipant",
    "type": "bool"
  }, {
    "indexed": !1,
    "internalType": "uint256",
    "name": "numberOfBuyers",
    "type": "uint256"
  }],
  "name": "FixedSaleBuy",
  "type": "event"
}, {
  "anonymous": !1,
  "inputs": [{
    "indexed": !0,
    "internalType": "uint256",
    "name": "newValue",
    "type": "uint256"
  }, {
    "indexed": !0,
    "internalType": "uint256",
    "name": "oldValue",
    "type": "uint256"
  }],
  "name": "GasForProcessingUpdated",
  "type": "event"
}, {
  "anonymous": !1,
  "inputs": [{
    "indexed": !0,
    "internalType": "address",
    "name": "newLiquidityWallet",
    "type": "address"
  }, {
    "indexed": !0,
    "internalType": "address",
    "name": "oldLiquidityWallet",
    "type": "address"
  }],
  "name": "LiquidityWalletUpdated",
  "type": "event"
}, {
  "anonymous": !1,
  "inputs": [{
    "indexed": !0,
    "internalType": "address",
    "name": "previousOwner",
    "type": "address"
  }, {
    "indexed": !0,
    "internalType": "address",
    "name": "newOwner",
    "type": "address"
  }],
  "name": "OwnershipTransferred",
  "type": "event"
}, {
  "anonymous": !1,
  "inputs": [{
    "indexed": !1,
    "internalType": "uint256",
    "name": "iterations",
    "type": "uint256"
  }, {
    "indexed": !1,
    "internalType": "uint256",
    "name": "claims",
    "type": "uint256"
  }, {
    "indexed": !1,
    "internalType": "uint256",
    "name": "lastProcessedIndex",
    "type": "uint256"
  }, {
    "indexed": !0,
    "internalType": "bool",
    "name": "automatic",
    "type": "bool"
  }, {
    "indexed": !1,
    "internalType": "uint256",
    "name": "gas",
    "type": "uint256"
  }, {
    "indexed": !0,
    "internalType": "address",
    "name": "processor",
    "type": "address"
  }],
  "name": "ProcessedDividendTracker",
  "type": "event"
}, {
  "anonymous": !1,
  "inputs": [{
    "indexed": !1,
    "internalType": "uint256",
    "name": "tokensSwapped",
    "type": "uint256"
  }, {
    "indexed": !1,
    "internalType": "uint256",
    "name": "amount",
    "type": "uint256"
  }],
  "name": "SendDividends",
  "type": "event"
}, {
  "anonymous": !1,
  "inputs": [{
    "indexed": !0,
    "internalType": "address",
    "name": "pair",
    "type": "address"
  }, {
    "indexed": !0,
    "internalType": "bool",
    "name": "value",
    "type": "bool"
  }],
  "name": "SetAutomatedMarketMakerPair",
  "type": "event"
}, {
  "anonymous": !1,
  "inputs": [{
    "indexed": !1,
    "internalType": "uint256",
    "name": "tokensSwapped",
    "type": "uint256"
  }, {
    "indexed": !1,
    "internalType": "uint256",
    "name": "ethReceived",
    "type": "uint256"
  }, {
    "indexed": !1,
    "internalType": "uint256",
    "name": "tokensIntoLiqudity",
    "type": "uint256"
  }],
  "name": "SwapAndLiquify",
  "type": "event"
}, {
  "anonymous": !1,
  "inputs": [{
    "indexed": !0,
    "internalType": "address",
    "name": "from",
    "type": "address"
  }, {
    "indexed": !0,
    "internalType": "address",
    "name": "to",
    "type": "address"
  }, {
    "indexed": !1,
    "internalType": "uint256",
    "name": "value",
    "type": "uint256"
  }],
  "name": "Transfer",
  "type": "event"
}, {
  "anonymous": !1,
  "inputs": [{
    "indexed": !0,
    "internalType": "address",
    "name": "newAddress",
    "type": "address"
  }, {
    "indexed": !0,
    "internalType": "address",
    "name": "oldAddress",
    "type": "address"
  }],
  "name": "UpdateDividendTracker",
  "type": "event"
}, {
  "anonymous": !1,
  "inputs": [{
    "indexed": !0,
    "internalType": "address",
    "name": "newAddress",
    "type": "address"
  }, {
    "indexed": !0,
    "internalType": "address",
    "name": "oldAddress",
    "type": "address"
  }],
  "name": "UpdateUniswapV2Router",
  "type": "event"
}, {
  "anonymous": !1,
  "inputs": [{
    "indexed": !0,
    "internalType": "address",
    "name": "newMarketingWallet",
    "type": "address"
  }, {
    "indexed": !0,
    "internalType": "address",
    "name": "oldMarketingWallet",
    "type": "address"
  }],
  "name": "marketingWalletUpdated",
  "type": "event"
}, {
  "inputs": [],
  "name": "BNBRewardsFee",
  "outputs": [{
    "internalType": "uint256",
    "name": "",
    "type": "uint256"
  }],
  "stateMutability": "view",
  "type": "function"
}, {
  "inputs": [],
  "name": "EnableTrading",
  "outputs": [],
  "stateMutability": "nonpayable",
  "type": "function"
}, {
  "inputs": [],
  "name": "LiteCoin",
  "outputs": [{
    "internalType": "address",
    "name": "",
    "type": "address"
  }],
  "stateMutability": "view",
  "type": "function"
}, {
  "inputs": [{
    "internalType": "address",
    "name": "",
    "type": "address"
  }],
  "name": "_isExcludedMaxSellTransactionAmount",
  "outputs": [{
    "internalType": "bool",
    "name": "",
    "type": "bool"
  }],
  "stateMutability": "view",
  "type": "function"
}, {
  "inputs": [],
  "name": "_maxWalletToken",
  "outputs": [{
    "internalType": "uint256",
    "name": "",
    "type": "uint256"
  }],
  "stateMutability": "view",
  "type": "function"
}, {
  "inputs": [],
  "name": "_minimumTokenBalanceForDividends",
  "outputs": [{
    "internalType": "uint256",
    "name": "",
    "type": "uint256"
  }],
  "stateMutability": "view",
  "type": "function"
}, {
  "inputs": [{
    "internalType": "address",
    "name": "owner",
    "type": "address"
  }, {
    "internalType": "address",
    "name": "spender",
    "type": "address"
  }],
  "name": "allowance",
  "outputs": [{
    "internalType": "uint256",
    "name": "",
    "type": "uint256"
  }],
  "stateMutability": "view",
  "type": "function"
}, {
  "inputs": [{
    "internalType": "address",
    "name": "spender",
    "type": "address"
  }, {
    "internalType": "uint256",
    "name": "amount",
    "type": "uint256"
  }],
  "name": "approve",
  "outputs": [{
    "internalType": "bool",
    "name": "",
    "type": "bool"
  }],
  "stateMutability": "nonpayable",
  "type": "function"
}, {
  "inputs": [{
    "internalType": "address",
    "name": "",
    "type": "address"
  }],
  "name": "automatedMarketMakerPairs",
  "outputs": [{
    "internalType": "bool",
    "name": "",
    "type": "bool"
  }],
  "stateMutability": "view",
  "type": "function"
}, {
  "inputs": [{
    "internalType": "address",
    "name": "account",
    "type": "address"
  }],
  "name": "balanceOf",
  "outputs": [{
    "internalType": "uint256",
    "name": "",
    "type": "uint256"
  }],
  "stateMutability": "view",
  "type": "function"
}, {
  "inputs": [],
  "name": "claim",
  "outputs": [],
  "stateMutability": "nonpayable",
  "type": "function"
}, {
  "inputs": [],
  "name": "deadWallet",
  "outputs": [{
    "internalType": "address",
    "name": "",
    "type": "address"
  }],
  "stateMutability": "view",
  "type": "function"
}, {
  "inputs": [],
  "name": "decimals",
  "outputs": [{
    "internalType": "uint8",
    "name": "",
    "type": "uint8"
  }],
  "stateMutability": "view",
  "type": "function"
}, {
  "inputs": [{
    "internalType": "address",
    "name": "spender",
    "type": "address"
  }, {
    "internalType": "uint256",
    "name": "subtractedValue",
    "type": "uint256"
  }],
  "name": "decreaseAllowance",
  "outputs": [{
    "internalType": "bool",
    "name": "",
    "type": "bool"
  }],
  "stateMutability": "nonpayable",
  "type": "function"
}, {
  "inputs": [{
    "internalType": "address",
    "name": "account",
    "type": "address"
  }],
  "name": "dividendTokenBalanceOf",
  "outputs": [{
    "internalType": "uint256",
    "name": "",
    "type": "uint256"
  }],
  "stateMutability": "view",
  "type": "function"
}, {
  "inputs": [],
  "name": "dividendTracker",
  "outputs": [{
    "internalType": "contract LiteHouseDividendTracker",
    "name": "",
    "type": "address"
  }],
  "stateMutability": "view",
  "type": "function"
}, {
  "inputs": [{
    "internalType": "address",
    "name": "account",
    "type": "address"
  }, {
    "internalType": "bool",
    "name": "excluded",
    "type": "bool"
  }],
  "name": "excludeFromFees",
  "outputs": [],
  "stateMutability": "nonpayable",
  "type": "function"
}, {
  "inputs": [{
    "internalType": "address[]",
    "name": "accounts",
    "type": "address[]"
  }, {
    "internalType": "bool",
    "name": "excluded",
    "type": "bool"
  }],
  "name": "excludeMultipleAccountsFromFees",
  "outputs": [],
  "stateMutability": "nonpayable",
  "type": "function"
}, {
  "inputs": [],
  "name": "gasForProcessing",
  "outputs": [{
    "internalType": "uint256",
    "name": "",
    "type": "uint256"
  }],
  "stateMutability": "view",
  "type": "function"
}, {
  "inputs": [{
    "internalType": "address",
    "name": "account",
    "type": "address"
  }],
  "name": "getAccountDividendsInfo",
  "outputs": [{
    "internalType": "address",
    "name": "",
    "type": "address"
  }, {
    "internalType": "int256",
    "name": "",
    "type": "int256"
  }, {
    "internalType": "int256",
    "name": "",
    "type": "int256"
  }, {
    "internalType": "uint256",
    "name": "",
    "type": "uint256"
  }, {
    "internalType": "uint256",
    "name": "",
    "type": "uint256"
  }, {
    "internalType": "uint256",
    "name": "",
    "type": "uint256"
  }, {
    "internalType": "uint256",
    "name": "",
    "type": "uint256"
  }, {
    "internalType": "uint256",
    "name": "",
    "type": "uint256"
  }],
  "stateMutability": "view",
  "type": "function"
}, {
  "inputs": [{
    "internalType": "uint256",
    "name": "index",
    "type": "uint256"
  }],
  "name": "getAccountDividendsInfoAtIndex",
  "outputs": [{
    "internalType": "address",
    "name": "",
    "type": "address"
  }, {
    "internalType": "int256",
    "name": "",
    "type": "int256"
  }, {
    "internalType": "int256",
    "name": "",
    "type": "int256"
  }, {
    "internalType": "uint256",
    "name": "",
    "type": "uint256"
  }, {
    "internalType": "uint256",
    "name": "",
    "type": "uint256"
  }, {
    "internalType": "uint256",
    "name": "",
    "type": "uint256"
  }, {
    "internalType": "uint256",
    "name": "",
    "type": "uint256"
  }, {
    "internalType": "uint256",
    "name": "",
    "type": "uint256"
  }],
  "stateMutability": "view",
  "type": "function"
}, {
  "inputs": [],
  "name": "getClaimWait",
  "outputs": [{
    "internalType": "uint256",
    "name": "",
    "type": "uint256"
  }],
  "stateMutability": "view",
  "type": "function"
}, {
  "inputs": [],
  "name": "getLastProcessedIndex",
  "outputs": [{
    "internalType": "uint256",
    "name": "",
    "type": "uint256"
  }],
  "stateMutability": "view",
  "type": "function"
}, {
  "inputs": [],
  "name": "getNumberOfDividendTokenHolders",
  "outputs": [{
    "internalType": "uint256",
    "name": "",
    "type": "uint256"
  }],
  "stateMutability": "view",
  "type": "function"
}, {
  "inputs": [],
  "name": "getTotalDividendsDistributed",
  "outputs": [{
    "internalType": "uint256",
    "name": "",
    "type": "uint256"
  }],
  "stateMutability": "view",
  "type": "function"
}, {
  "inputs": [{
    "internalType": "address",
    "name": "spender",
    "type": "address"
  }, {
    "internalType": "uint256",
    "name": "addedValue",
    "type": "uint256"
  }],
  "name": "increaseAllowance",
  "outputs": [{
    "internalType": "bool",
    "name": "",
    "type": "bool"
  }],
  "stateMutability": "nonpayable",
  "type": "function"
}, {
  "inputs": [{
    "internalType": "address",
    "name": "account",
    "type": "address"
  }],
  "name": "isExcludedFromFees",
  "outputs": [{
    "internalType": "bool",
    "name": "",
    "type": "bool"
  }],
  "stateMutability": "view",
  "type": "function"
}, {
  "inputs": [],
  "name": "liquidityFee",
  "outputs": [{
    "internalType": "uint256",
    "name": "",
    "type": "uint256"
  }],
  "stateMutability": "view",
  "type": "function"
}, {
  "inputs": [],
  "name": "liquidityWallet",
  "outputs": [{
    "internalType": "address",
    "name": "",
    "type": "address"
  }],
  "stateMutability": "view",
  "type": "function"
}, {
  "inputs": [],
  "name": "marketingFee",
  "outputs": [{
    "internalType": "uint256",
    "name": "",
    "type": "uint256"
  }],
  "stateMutability": "view",
  "type": "function"
}, {
  "inputs": [],
  "name": "marketingWallet",
  "outputs": [{
    "internalType": "address",
    "name": "",
    "type": "address"
  }],
  "stateMutability": "view",
  "type": "function"
}, {
  "inputs": [],
  "name": "maxBuyTranscationAmount",
  "outputs": [{
    "internalType": "uint256",
    "name": "",
    "type": "uint256"
  }],
  "stateMutability": "view",
  "type": "function"
}, {
  "inputs": [],
  "name": "maxSellTransactionAmount",
  "outputs": [{
    "internalType": "uint256",
    "name": "",
    "type": "uint256"
  }],
  "stateMutability": "view",
  "type": "function"
}, {
  "inputs": [],
  "name": "name",
  "outputs": [{
    "internalType": "string",
    "name": "",
    "type": "string"
  }],
  "stateMutability": "view",
  "type": "function"
}, {
  "inputs": [],
  "name": "owner",
  "outputs": [{
    "internalType": "address",
    "name": "",
    "type": "address"
  }],
  "stateMutability": "view",
  "type": "function"
}, {
  "inputs": [],
  "name": "presaleAddress",
  "outputs": [{
    "internalType": "address",
    "name": "",
    "type": "address"
  }],
  "stateMutability": "view",
  "type": "function"
}, {
  "inputs": [{
    "internalType": "uint256",
    "name": "gas",
    "type": "uint256"
  }],
  "name": "processDividendTracker",
  "outputs": [],
  "stateMutability": "nonpayable",
  "type": "function"
}, {
  "inputs": [],
  "name": "renounceOwnership",
  "outputs": [],
  "stateMutability": "nonpayable",
  "type": "function"
}, {
  "inputs": [{
    "internalType": "address",
    "name": "pair",
    "type": "address"
  }, {
    "internalType": "bool",
    "name": "value",
    "type": "bool"
  }],
  "name": "setAutomatedMarketMakerPair",
  "outputs": [],
  "stateMutability": "nonpayable",
  "type": "function"
}, {
  "inputs": [],
  "name": "swapTokensAtAmount",
  "outputs": [{
    "internalType": "uint256",
    "name": "",
    "type": "uint256"
  }],
  "stateMutability": "view",
  "type": "function"
}, {
  "inputs": [],
  "name": "symbol",
  "outputs": [{
    "internalType": "string",
    "name": "",
    "type": "string"
  }],
  "stateMutability": "view",
  "type": "function"
}, {
  "inputs": [],
  "name": "totalFees",
  "outputs": [{
    "internalType": "uint256",
    "name": "",
    "type": "uint256"
  }],
  "stateMutability": "view",
  "type": "function"
}, {
  "inputs": [],
  "name": "totalSupply",
  "outputs": [{
    "internalType": "uint256",
    "name": "",
    "type": "uint256"
  }],
  "stateMutability": "view",
  "type": "function"
}, {
  "inputs": [],
  "name": "tradingIsEnabled",
  "outputs": [{
    "internalType": "bool",
    "name": "",
    "type": "bool"
  }],
  "stateMutability": "view",
  "type": "function"
}, {
  "inputs": [{
    "internalType": "address",
    "name": "recipient",
    "type": "address"
  }, {
    "internalType": "uint256",
    "name": "amount",
    "type": "uint256"
  }],
  "name": "transfer",
  "outputs": [{
    "internalType": "bool",
    "name": "",
    "type": "bool"
  }],
  "stateMutability": "nonpayable",
  "type": "function"
}, {
  "inputs": [{
    "internalType": "address",
    "name": "sender",
    "type": "address"
  }, {
    "internalType": "address",
    "name": "recipient",
    "type": "address"
  }, {
    "internalType": "uint256",
    "name": "amount",
    "type": "uint256"
  }],
  "name": "transferFrom",
  "outputs": [{
    "internalType": "bool",
    "name": "",
    "type": "bool"
  }],
  "stateMutability": "nonpayable",
  "type": "function"
}, {
  "inputs": [{
    "internalType": "address",
    "name": "newOwner",
    "type": "address"
  }],
  "name": "transferOwnership",
  "outputs": [],
  "stateMutability": "nonpayable",
  "type": "function"
}, {
  "inputs": [],
  "name": "uniswapV2Pair",
  "outputs": [{
    "internalType": "address",
    "name": "",
    "type": "address"
  }],
  "stateMutability": "view",
  "type": "function"
}, {
  "inputs": [],
  "name": "uniswapV2Router",
  "outputs": [{
    "internalType": "contract IUniswapV2Router02",
    "name": "",
    "type": "address"
  }],
  "stateMutability": "view",
  "type": "function"
}, {
  "inputs": [{
    "internalType": "uint256",
    "name": "claimWait",
    "type": "uint256"
  }],
  "name": "updateClaimWait",
  "outputs": [],
  "stateMutability": "nonpayable",
  "type": "function"
}, {
  "inputs": [{
    "internalType": "address",
    "name": "newAddress",
    "type": "address"
  }],
  "name": "updateDividendTracker",
  "outputs": [],
  "stateMutability": "nonpayable",
  "type": "function"
}, {
  "inputs": [{
    "internalType": "uint256",
    "name": "newValue",
    "type": "uint256"
  }],
  "name": "updateGasForProcessing",
  "outputs": [],
  "stateMutability": "nonpayable",
  "type": "function"
}, {
  "inputs": [{
    "internalType": "address",
    "name": "newLiquidityWallet",
    "type": "address"
  }],
  "name": "updateLiquidityWallet",
  "outputs": [],
  "stateMutability": "nonpayable",
  "type": "function"
}, {
  "inputs": [{
    "internalType": "address",
    "name": "newMarketingWallet",
    "type": "address"
  }],
  "name": "updateMarketingWallet",
  "outputs": [],
  "stateMutability": "nonpayable",
  "type": "function"
}, {
  "inputs": [{
    "internalType": "uint256",
    "name": "minTokens",
    "type": "uint256"
  }],
  "name": "updateMinTokenBalance",
  "outputs": [],
  "stateMutability": "nonpayable",
  "type": "function"
}, {
  "inputs": [{
    "internalType": "address",
    "name": "newAddress",
    "type": "address"
  }],
  "name": "updateUniswapV2Router",
  "outputs": [],
  "stateMutability": "nonpayable",
  "type": "function"
}, {
  "inputs": [{
    "internalType": "address",
    "name": "_presaleAddress",
    "type": "address"
  }],
  "name": "whitelistDxSale",
  "outputs": [],
  "stateMutability": "nonpayable",
  "type": "function"
}, {
  "inputs": [{
    "internalType": "address",
    "name": "_routerAddress",
    "type": "address"
  }],
  "name": "whitelistRouter",
  "outputs": [],
  "stateMutability": "nonpayable",
  "type": "function"
}, {
  "inputs": [{
    "internalType": "address",
    "name": "account",
    "type": "address"
  }],
  "name": "withdrawableDividendOf",
  "outputs": [{
    "internalType": "uint256",
    "name": "",
    "type": "uint256"
  }],
  "stateMutability": "view",
  "type": "function"
}, {
  "stateMutability": "payable",
  "type": "receive"
}];
  }, {}],
  "u7YK": [function(require, module, exports) {
    "use strict";
    var e = this && this.__awaiter || function(e, t, n, r) {
        return new(n || (n = Promise))(function(i, l) {
          function a(e) {
            try {
              s(r.next(e))
            } catch (t) {
              l(t)
            }
          }

          function o(e) {
            try {
              s(r.throw(e))
            } catch (t) {
              l(t)
            }
          }

          function s(e) {
            var t;
            e.done ? i(e.value) : (t = e.value, t instanceof n ? t : new n(function(e) {
              e(t)
            })).then(a, o)
          }
          s((r = r.apply(e, t || [])).next())
        })
      },
      t = this && this.__generator || function(e, t) {
        var n, r, i, l, a = {
          label: 0,
          sent: function() {
            if (1 & i[0]) throw i[1];
            return i[1]
          },
          trys: [],
          ops: []
        };
        return l = {
          next: o(0),
          throw: o(1),
          return: o(2)
        }, "function" == typeof Symbol && (l[Symbol.iterator] = function() {
          return this
        }), l;

        function o(l) {
          return function(o) {
            return function(l) {
              if (n) throw new TypeError("Generator is already executing.");
              for (; a;) try {
                if (n = 1, r && (i = 2 & l[0] ? r.return : l[0] ? r.throw || ((i = r.return) && i.call(r), 0) : r.next) && !(i = i.call(r, l[1])).done) return i;
                switch (r = 0, i && (l = [2 & l[0], i.value]), l[0]) {
                  case 0:
                  case 1:
                    i = l;
                    break;
                  case 4:
                    return a.label++, {
                      value: l[1],
                      done: !1
                    };
                  case 5:
                    a.label++, r = l[1], l = [0];
                    continue;
                  case 7:
                    l = a.ops.pop(), a.trys.pop();
                    continue;
                  default:
                    if (!(i = (i = a.trys).length > 0 && i[i.length - 1]) && (6 === l[0] || 2 === l[0])) {
                      a = 0;
                      continue
                    }
                    if (3 === l[0] && (!i || l[1] > i[0] && l[1] < i[3])) {
                      a.label = l[1];
                      break
                    }
                    if (6 === l[0] && a.label < i[1]) {
                      a.label = i[1], i = l;
                      break
                    }
                    if (i && a.label < i[2]) {
                      a.label = i[2], a.ops.push(l);
                      break
                    }
                    i[2] && a.ops.pop(), a.trys.pop();
                    continue
                }
                l = t.call(e, a)
              } catch (o) {
                l = [6, o], r = 0
              } finally {
                n = i = 0
              }
              if (5 & l[0]) throw l[1];
              return {
                value: l[0] ? l[1] : void 0,
                done: !0
              }
            }([l, o])
          }
        }
      };
    Object.defineProperty(exports, "__esModule", {
      value: !0
    }), exports.GetBNBPrice = exports.RoundPrice = void 0;
    var n = require("./stats/abi"),
      r = {
        1: {
          symbol: "",
          digits: 1,
          decimalPlace: null
        },
        2: {
          symbol: "",
          digits: 2,
          decimalPlace: null
        },
        3: {
          symbol: "",
          digits: 3,
          decimalPlace: null
        },
        4: {
          symbol: "K",
          digits: 3,
          decimalPlace: 1
        },
        5: {
          symbol: "K",
          digits: 3,
          decimalPlace: 2
        },
        6: {
          symbol: "K",
          digits: 3,
          decimalPlace: null
        },
        7: {
          symbol: "M",
          digits: 3,
          decimalPlace: 1
        },
        8: {
          symbol: "M",
          digits: 3,
          decimalPlace: 2
        },
        9: {
          symbol: "M",
          digits: 3,
          decimalPlace: null
        },
        10: {
          symbol: "B",
          digits: 3,
          decimalPlace: 1
        },
        11: {
          symbol: "B",
          digits: 3,
          decimalPlace: 2
        }
      };

    function i(e) {
      var t = Math.round(e).toString(),
        n = r[t.length].digits,
        i = t.slice(0, n),
        l = r[t.length].decimalPlace;
      return l && (i = i.substring(0, l) + "." + i.substring(l)), i += r[t.length].symbol
    }

    function l(r) {
      return e(this, void 0, void 0, function() {
        var e;
        return t(this, function(t) {
          switch (t.label) {
            case 0:
              return "0x1B96B92314C44b159149f7E0303511fB2Fc4774f", [4, new r.eth.Contract(n.BEP20PairABI, "0x1B96B92314C44b159149f7E0303511fB2Fc4774f")];
            case 1:
              return [4, t.sent().methods.getReserves().call()];
            case 2:
              return e = t.sent(), [2, parseFloat(e._reserve1) / parseFloat(e._reserve0)]
          }
        })
      })
    }
    exports.RoundPrice = i, exports.GetBNBPrice = l;
  }, {
    "./stats/abi": "JuNv"
  }],
  "FE3g": [function(require, module, exports) {
    "use strict";
    var t = this && this.__awaiter || function(t, e, r, n) {
        return new(r || (r = Promise))(function(i, o) {
          function s(t) {
            try {
              c(n.next(t))
            } catch (e) {
              o(e)
            }
          }

          function a(t) {
            try {
              c(n.throw(t))
            } catch (e) {
              o(e)
            }
          }

          function c(t) {
            var e;
            t.done ? i(t.value) : (e = t.value, e instanceof r ? e : new r(function(t) {
              t(e)
            })).then(s, a)
          }
          c((n = n.apply(t, e || [])).next())
        })
      },
      e = this && this.__generator || function(t, e) {
        var r, n, i, o, s = {
          label: 0,
          sent: function() {
            if (1 & i[0]) throw i[1];
            return i[1]
          },
          trys: [],
          ops: []
        };
        return o = {
          next: a(0),
          throw: a(1),
          return: a(2)
        }, "function" == typeof Symbol && (o[Symbol.iterator] = function() {
          return this
        }), o;

        function a(o) {
          return function(a) {
            return function(o) {
              if (r) throw new TypeError("Generator is already executing.");
              for (; s;) try {
                if (r = 1, n && (i = 2 & o[0] ? n.return : o[0] ? n.throw || ((i = n.return) && i.call(n), 0) : n.next) && !(i = i.call(n, o[1])).done) return i;
                switch (n = 0, i && (o = [2 & o[0], i.value]), o[0]) {
                  case 0:
                  case 1:
                    i = o;
                    break;
                  case 4:
                    return s.label++, {
                      value: o[1],
                      done: !1
                    };
                  case 5:
                    s.label++, n = o[1], o = [0];
                    continue;
                  case 7:
                    o = s.ops.pop(), s.trys.pop();
                    continue;
                  default:
                    if (!(i = (i = s.trys).length > 0 && i[i.length - 1]) && (6 === o[0] || 2 === o[0])) {
                      s = 0;
                      continue
                    }
                    if (3 === o[0] && (!i || o[1] > i[0] && o[1] < i[3])) {
                      s.label = o[1];
                      break
                    }
                    if (6 === o[0] && s.label < i[1]) {
                      s.label = i[1], i = o;
                      break
                    }
                    if (i && s.label < i[2]) {
                      s.label = i[2], s.ops.push(o);
                      break
                    }
                    i[2] && s.ops.pop(), s.trys.pop();
                    continue
                }
                o = e.call(t, s)
              } catch (a) {
                o = [6, a], n = 0
              } finally {
                r = i = 0
              }
              if (5 & o[0]) throw o[1];
              return {
                value: o[0] ? o[1] : void 0,
                done: !0
              }
            }([o, a])
          }
        }
      };
    Object.defineProperty(exports, "__esModule", {
      value: !0
    }), exports.Stats = void 0;
    var r = require("./abi"),
      n = require("../utils"),
      i = "0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c",
      o = function() {
        function i(t, e) {
          this.web3 = t, this.BNBPrice = e, this.ONE_TOKEN_ADDRESS = "0xE7e527D2A7A15FBA976966065C8FA1f741FAc237", this.ONE_TOKEN_BNB_PairAddress = "0xd24e6435432a3e89fb8aaf98baa266b195b87cea", this.init()
        }
        return i.prototype.init = function() {
          return t(this, void 0, void 0, function() {
            var t;
            return e(this, function(e) {
              switch (e.label) {
                case 0:
                  return this.daysElem = document.querySelector(".coinStats-item-text-days"), this.priceElem = document.querySelector(".coinStats-item-text-price"), this.rewardsElem = document.querySelector(".coinStats-item-text-rewards"), t = this, [4, new this.web3.eth.Contract(r.ONE_TOKEN_ABI, this.ONE_TOKEN_ADDRESS)];
                case 1:
                  return t.tokenContract = e.sent(), this.updateDaysText(), this.getRewards(), [2]
              }
            })
          })
        }, i.prototype.getRewards = function() {
          return t(this, void 0, void 0, function() {
            var t, r, n;
            return e(this, function(e) {
              switch (e.label) {
                case 0:
                  return [4, this.tokenContract.methods.getTotalDividendsDistributed().call()];
                case 1:
                  return t = e.sent(), r = t * Math.pow(10, -18), .00, n = .00 + r, this.rewardsElem.textContent = n.toString().substring(0, 5), [2]
              }
            })
          })
        }, i.prototype.getO1TPrice = function() {
          return t(this, void 0, void 0, function() {
            var t, n;
            return e(this, function(e) {
              switch (e.label) {
                case 0:
                  return [4, new this.web3.eth.Contract(r.BEP20PairABI, this.ONE_TOKEN_BNB_PairAddress)];
                case 1:
                  return [4, e.sent().methods.getReserves().call()];
                case 2:
                  return t = e.sent(), n = parseFloat(t._reserve0) / parseFloat(t._reserve1) * this.BNBPrice * 599000000, this.updatePriceText(n), [2, n]
              }
            })
          })
        }, i.prototype.updatePriceText = function(t) {
          var e = n.RoundPrice(t);
          this.priceElem.textContent = "$" + e
        }, i.prototype.updateDaysText = function() {
          var t = new Date(2021, 6, 30).setHours(0, 0, 0),
            e = (new Date).setHours(0, 0, 0),
            r = Math.round(Math.abs((t - e) / 864e5));
          this.daysElem.textContent = r.toString()
        }, i
      }();
    exports.Stats = o;
  }, {
    "./abi": "JuNv",
    "../utils": "u7YK"
  }],
  "GTgq": [function(require, module, exports) {
    "use strict";
    var e = this && this.__awaiter || function(e, t, i, n) {
        return new(i || (i = Promise))(function(r, s) {
          function o(e) {
            try {
              c(n.next(e))
            } catch (t) {
              s(t)
            }
          }

          function l(e) {
            try {
              c(n.throw(e))
            } catch (t) {
              s(t)
            }
          }

          function c(e) {
            var t;
            e.done ? r(e.value) : (t = e.value, t instanceof i ? t : new i(function(e) {
              e(t)
            })).then(o, l)
          }
          c((n = n.apply(e, t || [])).next())
        })
      },
      t = this && this.__generator || function(e, t) {
        var i, n, r, s, o = {
          label: 0,
          sent: function() {
            if (1 & r[0]) throw r[1];
            return r[1]
          },
          trys: [],
          ops: []
        };
        return s = {
          next: l(0),
          throw: l(1),
          return: l(2)
        }, "function" == typeof Symbol && (s[Symbol.iterator] = function() {
          return this
        }), s;

        function l(s) {
          return function(l) {
            return function(s) {
              if (i) throw new TypeError("Generator is already executing.");
              for (; o;) try {
                if (i = 1, n && (r = 2 & s[0] ? n.return : s[0] ? n.throw || ((r = n.return) && r.call(n), 0) : n.next) && !(r = r.call(n, s[1])).done) return r;
                switch (n = 0, r && (s = [2 & s[0], r.value]), s[0]) {
                  case 0:
                  case 1:
                    r = s;
                    break;
                  case 4:
                    return o.label++, {
                      value: s[1],
                      done: !1
                    };
                  case 5:
                    o.label++, n = s[1], s = [0];
                    continue;
                  case 7:
                    s = o.ops.pop(), o.trys.pop();
                    continue;
                  default:
                    if (!(r = (r = o.trys).length > 0 && r[r.length - 1]) && (6 === s[0] || 2 === s[0])) {
                      o = 0;
                      continue
                    }
                    if (3 === s[0] && (!r || s[1] > r[0] && s[1] < r[3])) {
                      o.label = s[1];
                      break
                    }
                    if (6 === s[0] && o.label < r[1]) {
                      o.label = r[1], r = s;
                      break
                    }
                    if (r && o.label < r[2]) {
                      o.label = r[2], o.ops.push(s);
                      break
                    }
                    r[2] && o.ops.pop(), o.trys.pop();
                    continue
                }
                s = t.call(e, o)
              } catch (l) {
                s = [6, l], n = 0
              } finally {
                i = r = 0
              }
              if (5 & s[0]) throw s[1];
              return {
                value: s[0] ? s[1] : void 0,
                done: !0
              }
            }([s, l])
          }
        }
      };
    Object.defineProperty(exports, "__esModule", {
      value: !0
    }), exports.Milestones = void 0;
    var i = require("./stats/abi"),
      n = require("./utils"),
      r = function() {
        function r(e, t, i) {
          this.price = e, this.web3 = t, this.BNBPrice = i, this.itemValues = [], this.BITCOIN_PAIR_ADDRESS = "0x7561EEe90e24F3b348E1087A005F78B4c8453524", this.init()
        }
        return r.prototype.init = function() {
          return e(this, void 0, void 0, function() {
            var e, i, r, s, o, l, c, a, u, h = this;
            return t(this, function(t) {
              switch (t.label) {
                case 0:
                  return [4, this.getBitcoinPrice()];
                case 1:
                  return e = t.sent(), this.bitcoinPriceItem = document.querySelector(".milestones-item-1"), this.bitcoinPriceText = this.bitcoinPriceItem.querySelector(".milestones-item-price-bitcoin"), this.bitcoinPriceItem.dataset.value = e.toString(), i = n.RoundPrice(e), this.bitcoinPriceText.textContent = "$" + i, this.milesstonesScrollElem = document.querySelector(".milestones-scroll"), this.itemHtmlElements = document.querySelectorAll(".milestones-item"), this.itemHtmlElements.forEach(function(e, t) {
                    var i = parseInt(e.dataset.value.replace(/,/g, ""));
                    h.itemValues.push(i), i <= h.price && e.classList.add("active")
                  }), r = this.milesstonesScrollElem.scrollWidth, s = this.milesstonesScrollElem.clientWidth, -1 === (o = this.itemValues.findIndex(function(e) {
                    return e > h.price
                  })) && (o = this.itemValues.length - 1), l = o - 1 >= 0 ? o - 1 : 0, 0 === o && 0 === l ? c = 0 : (a = l / (this.itemValues.length - 1), u = this.price / (this.itemValues[o] - this.itemValues[l]) / (this.itemValues.length - 1), c = Math.min(a + u, 1)), this.milesstonesScrollElem.style.setProperty("--barFilledPercent", 85 * c + "%"), this.milesstonesScrollElem.scrollLeft = .85 * c * r - s / 2 + 40, [2]
              }
            })
          })
        }, r.prototype.getBitcoinPrice = function() {
          return e(this, void 0, void 0, function() {
            var e;
            return t(this, function(t) {
              switch (t.label) {
                case 0:
                  return [4, new this.web3.eth.Contract(i.BEP20PairABI, this.BITCOIN_PAIR_ADDRESS)];
                case 1:
                  return [4, t.sent().methods.getReserves().call()];
                case 2:
                  return e = t.sent(), [2, parseFloat(e._reserve1) / parseFloat(e._reserve0) * this.BNBPrice]
              }
            })
          })
        }, r
      }();
    exports.Milestones = r;
  }, {
    "./stats/abi": "JuNv",
    "./utils": "u7YK"
  }],
  "CZUP": [function(require, module, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    }), exports.Buy = void 0;
    var e = function() {
      function e() {
        this.init()
      }
      return e.prototype.init = function() {
        var e = this;
        this.popupOpenBtn = document.querySelector(".buy-grid-help-buttons-details"), this.popupCloseBtn = document.querySelector(".buy-grid-help-popup-modal-close"), this.popup = document.querySelector(".buy-grid-help-popup"), this.modal = this.popup.querySelector(".buy-grid-help-popup-modal"), this.copyAddressBtn = document.querySelector(".buy-grid-item-description-copyAddress"), this.tokenAddress = this.copyAddressBtn.querySelector(".token-address"), this.popupOpenBtn.addEventListener("click", function() {
          e.togglePopup(!0), setTimeout(function() {
            e.outsideClickListener = function(t) {
              e.modal.contains(t.target) || (document.removeEventListener("click", e.outsideClickListener), e.togglePopup(!1))
            }.bind(e), document.addEventListener("click", e.outsideClickListener)
          }, 0)
        }), this.popupCloseBtn.addEventListener("click", function() {
          e.togglePopup(!1), document.removeEventListener("click", e.outsideClickListener)
        }), this.copyAddressBtn.addEventListener("click", function() {
          e.copyAddressBtn.classList.remove("copySuccess"), e.copyAddressBtn.style.animation = "none", e.copyAddressBtn.offsetHeight, e.copyAddressBtn.style.animation = null, e.copyAddressBtn.classList.add("copySuccess"), e.copyToClipboard(e.tokenAddress.textContent)
        })
      }, e.prototype.togglePopup = function(e) {
        e ? (document.body.style.overflowY = "hidden", this.popup.classList.toggle("active", !0)) : (document.body.style.overflowY = "auto", this.popup.classList.toggle("active", !1))
      }, e.prototype.copyToClipboard = function(e) {
        var t = document.createElement("textarea");
        t.value = e, document.body.appendChild(t), t.select(), document.execCommand("copy"), document.body.removeChild(t)
      }, e
    }();
    exports.Buy = e;
  }, {}],
  "f6lU": [function(require, module, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    }), exports.News = void 0;
    var t = function() {
      function t() {
        this.init()
      }
      return t.prototype.init = function() {
        var t = this;
        this.dataFrame = document.querySelector(".news-dataFrame"), this.twitterBtn = document.querySelector(".news-selectors-twitter"), this.mediumBtn = document.querySelector(".news-selectors-medium"), this.twitterFrame = document.querySelector(".news-dataFrame-twitter"), this.mediumFrame = document.querySelector(".news-dataFrame-medium"), this.twitterBtn.addEventListener("click", function() {
          t.setActive("twitter")
        }), this.mediumBtn.addEventListener("click", function() {
          t.setActive("medium")
        }), this.setActive("twitter"), this.initMedium()
      }, t.prototype.setActive = function(t) {
        "twitter" === t ? (this.mediumBtn.classList.toggle("active", !1), this.mediumFrame.classList.toggle("hide", !0), this.twitterBtn.classList.toggle("active", !0), this.twitterFrame.classList.toggle("hide", !1)) : (this.twitterBtn.classList.toggle("active", !1), this.twitterFrame.classList.toggle("hide", !0), this.mediumBtn.classList.toggle("active", !0), this.mediumFrame.classList.toggle("hide", !1)), this.dataFrame.scrollTop = 0
      }, t.prototype.initMedium = function() {
        MediumWidget.Init({
          renderTo: "#medium-widget",
          params: {
            resource: "https://medium.com/@only1token",
            postsPerLine: 1,
            limit: 3,
            picture: "big",
            fields: ["description", "author", "claps", "publishAt"],
            ratio: "landscape"
          }
        })
      }, t
    }();
    exports.News = t;
  }, {}],
  "hh6X": [function(require, module, exports) {
    module.exports = {
      _args: [
        ["web3@1.3.5", "C:\\Users\\jesh\\Desktop\\o1t site\\new site"]
      ],
      _from: "web3@1.3.5",
      _id: "web3@1.3.5",
      _inBundle: !1,
      _integrity: "sha512-UyQW/MT5EIGBrXPCh/FDIaD7RtJTn5/rJUNw2FOglp0qoXnCQHNKvntiR1ylztk05fYxIF6UgsC76IrazlKJjw==",
      _location: "/web3",
      _phantomChildren: {},
      _requested: {
        type: "version",
        registry: !0,
        raw: "web3@1.3.5",
        name: "web3",
        escapedName: "web3",
        rawSpec: "1.3.5",
        saveSpec: null,
        fetchSpec: "1.3.5"
      },
      _requiredBy: ["/"],
      _resolved: "https://registry.npmjs.org/web3/-/web3-1.3.5.tgz",
      _spec: "1.3.5",
      _where: "C:\\Users\\jesh\\Desktop\\o1t site\\new site",
      author: {
        name: "ethereum.org"
      },
      authors: [{
        name: "Fabian Vogelsteller",
        email: "fabian@ethereum.org",
        homepage: "http://frozeman.de"
      }, {
        name: "Marek Kotewicz",
        email: "marek@parity.io",
        url: "https://github.com/debris"
      }, {
        name: "Marian Oancea",
        url: "https://github.com/cubedro"
      }, {
        name: "Gav Wood",
        email: "g@parity.io",
        homepage: "http://gavwood.com"
      }, {
        name: "Jeffery Wilcke",
        email: "jeffrey.wilcke@ethereum.org",
        url: "https://github.com/obscuren"
      }],
      bugs: {
        url: "https://github.com/ethereum/web3.js/issues"
      },
      dependencies: {
        "web3-bzz": "1.3.5",
        "web3-core": "1.3.5",
        "web3-eth": "1.3.5",
        "web3-eth-personal": "1.3.5",
        "web3-net": "1.3.5",
        "web3-shh": "1.3.5",
        "web3-utils": "1.3.5"
      },
      description: "Ethereum JavaScript API",
      devDependencies: {
        "@types/node": "^12.12.6",
        dtslint: "^3.4.1",
        typescript: "^3.9.5"
      },
      engines: {
        node: ">=8.0.0"
      },
      gitHead: "6674ea5d39fa33677a1547e23ef8c1b86031a4d0",
      homepage: "https://github.com/ethereum/web3.js#readme",
      keywords: ["Ethereum", "JavaScript", "API"],
      license: "LGPL-3.0",
      main: "lib/index.js",
      name: "web3",
      repository: {
        type: "git",
        url: "git+https://github.com/ethereum/web3.js.git"
      },
      scripts: {
        compile: "tsc -b tsconfig.json",
        dtslint: "dtslint --localTs ../../node_modules/typescript/lib types",
        postinstall: 'echo "WARNING: the web3-shh and web3-bzz api will be deprecated in the next version"'
      },
      types: "types/index.d.ts",
      version: "1.3.5"
    };
  }, {}],
  "vexR": [function(require, module, exports) {
    module.exports = function(o) {
      return o && "object" == typeof o && "function" == typeof o.copy && "function" == typeof o.fill && "function" == typeof o.readUInt8
    };
  }, {}],
  "tcrG": [function(require, module, exports) {
    "function" == typeof Object.create ? module.exports = function(t, e) {
      t.super_ = e, t.prototype = Object.create(e.prototype, {
        constructor: {
          value: t,
          enumerable: !1,
          writable: !0,
          configurable: !0
        }
      })
    } : module.exports = function(t, e) {
      t.super_ = e;
      var o = function() {};
      o.prototype = e.prototype, t.prototype = new o, t.prototype.constructor = t
    };
  }, {}],
  "pBGv": [function(require, module, exports) {

    var t, e, n = module.exports = {};

    function r() {
      throw new Error("setTimeout has not been defined")
    }

    function o() {
      throw new Error("clearTimeout has not been defined")
    }

    function i(e) {
      if (t === setTimeout) return setTimeout(e, 0);
      if ((t === r || !t) && setTimeout) return t = setTimeout, setTimeout(e, 0);
      try {
        return t(e, 0)
      } catch (n) {
        try {
          return t.call(null, e, 0)
        } catch (n) {
          return t.call(this, e, 0)
        }
      }
    }

    function u(t) {
      if (e === clearTimeout) return clearTimeout(t);
      if ((e === o || !e) && clearTimeout) return e = clearTimeout, clearTimeout(t);
      try {
        return e(t)
      } catch (n) {
        try {
          return e.call(null, t)
        } catch (n) {
          return e.call(this, t)
        }
      }
    }! function() {
      try {
        t = "function" == typeof setTimeout ? setTimeout : r
      } catch (n) {
        t = r
      }
      try {
        e = "function" == typeof clearTimeout ? clearTimeout : o
      } catch (n) {
        e = o
      }
    }();
    var c, s = [],
      l = !1,
      a = -1;

    function f() {
      l && c && (l = !1, c.length ? s = c.concat(s) : a = -1, s.length && h())
    }

    function h() {
      if (!l) {
        var t = i(f);
        l = !0;
        for (var e = s.length; e;) {
          for (c = s, s = []; ++a < e;) c && c[a].run();
          a = -1, e = s.length
        }
        c = null, l = !1, u(t)
      }
    }

    function m(t, e) {
      this.fun = t, this.array = e
    }

    function p() {}
    n.nextTick = function(t) {
      var e = new Array(arguments.length - 1);
      if (arguments.length > 1)
        for (var n = 1; n < arguments.length; n++) e[n - 1] = arguments[n];
      s.push(new m(t, e)), 1 !== s.length || l || i(h)
    }, m.prototype.run = function() {
      this.fun.apply(null, this.array)
    }, n.title = "browser", n.env = {}, n.argv = [], n.version = "", n.versions = {}, n.on = p, n.addListener = p, n.once = p, n.off = p, n.removeListener = p, n.removeAllListeners = p, n.emit = p, n.prependListener = p, n.prependOnceListener = p, n.listeners = function(t) {
      return []
    }, n.binding = function(t) {
      throw new Error("process.binding is not supported")
    }, n.cwd = function() {
      return "/"
    }, n.chdir = function(t) {
      throw new Error("process.chdir is not supported")
    }, n.umask = function() {
      return 0
    };
  }, {}],
  "gfUn": [function(require, module, exports) {
    var process = require("process");
    var e = require("process"),
      t = Object.getOwnPropertyDescriptors || function(e) {
        for (var t = Object.keys(e), r = {}, n = 0; n < t.length; n++) r[t[n]] = Object.getOwnPropertyDescriptor(e, t[n]);
        return r
      },
      r = /%[sdj%]/g;
    exports.format = function(e) {
      if (!v(e)) {
        for (var t = [], n = 0; n < arguments.length; n++) t.push(i(arguments[n]));
        return t.join(" ")
      }
      n = 1;
      for (var o = arguments, u = o.length, s = String(e).replace(r, function(e) {
          if ("%%" === e) return "%";
          if (n >= u) return e;
          switch (e) {
            case "%s":
              return String(o[n++]);
            case "%d":
              return Number(o[n++]);
            case "%j":
              try {
                return JSON.stringify(o[n++])
              } catch (t) {
                return "[Circular]"
              }
              default:
                return e
          }
        }), c = o[n]; n < u; c = o[++n]) h(c) || !S(c) ? s += " " + c : s += " " + i(c);
      return s
    }, exports.deprecate = function(t, r) {
      if (void 0 !== e && !0 === e.noDeprecation) return t;
      if (void 0 === e) return function() {
        return exports.deprecate(t, r).apply(this, arguments)
      };
      var n = !1;
      return function() {
        if (!n) {
          if (e.throwDeprecation) throw new Error(r);
          e.traceDeprecation ? console.trace(r) : console.error(r), n = !0
        }
        return t.apply(this, arguments)
      }
    };
    var n, o = {};

    function i(e, t) {
      var r = {
        seen: [],
        stylize: s
      };
      return arguments.length >= 3 && (r.depth = arguments[2]), arguments.length >= 4 && (r.colors = arguments[3]), b(t) ? r.showHidden = t : t && exports._extend(r, t), j(r.showHidden) && (r.showHidden = !1), j(r.depth) && (r.depth = 2), j(r.colors) && (r.colors = !1), j(r.customInspect) && (r.customInspect = !0), r.colors && (r.stylize = u), p(r, e, r.depth)
    }

    function u(e, t) {
      var r = i.styles[t];
      return r ? "[" + i.colors[r][0] + "m" + e + "[" + i.colors[r][1] + "m" : e
    }

    function s(e, t) {
      return e
    }

    function c(e) {
      var t = {};
      return e.forEach(function(e, r) {
        t[e] = !0
      }), t
    }

    function p(e, t, r) {
      if (e.customInspect && t && P(t.inspect) && t.inspect !== exports.inspect && (!t.constructor || t.constructor.prototype !== t)) {
        var n = t.inspect(r, e);
        return v(n) || (n = p(e, n, r)), n
      }
      var o = l(e, t);
      if (o) return o;
      var i = Object.keys(t),
        u = c(i);
      if (e.showHidden && (i = Object.getOwnPropertyNames(t)), E(t) && (i.indexOf("message") >= 0 || i.indexOf("description") >= 0)) return f(t);
      if (0 === i.length) {
        if (P(t)) {
          var s = t.name ? ": " + t.name : "";
          return e.stylize("[Function" + s + "]", "special")
        }
        if (w(t)) return e.stylize(RegExp.prototype.toString.call(t), "regexp");
        if (z(t)) return e.stylize(Date.prototype.toString.call(t), "date");
        if (E(t)) return f(t)
      }
      var b, h = "",
        m = !1,
        x = ["{", "}"];
      (d(t) && (m = !0, x = ["[", "]"]), P(t)) && (h = " [Function" + (t.name ? ": " + t.name : "") + "]");
      return w(t) && (h = " " + RegExp.prototype.toString.call(t)), z(t) && (h = " " + Date.prototype.toUTCString.call(t)), E(t) && (h = " " + f(t)), 0 !== i.length || m && 0 != t.length ? r < 0 ? w(t) ? e.stylize(RegExp.prototype.toString.call(t), "regexp") : e.stylize("[Object]", "special") : (e.seen.push(t), b = m ? a(e, t, r, u, i) : i.map(function(n) {
        return y(e, t, r, u, n, m)
      }), e.seen.pop(), g(b, h, x)) : x[0] + h + x[1]
    }

    function l(e, t) {
      if (j(t)) return e.stylize("undefined", "undefined");
      if (v(t)) {
        var r = "'" + JSON.stringify(t).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
        return e.stylize(r, "string")
      }
      return x(t) ? e.stylize("" + t, "number") : b(t) ? e.stylize("" + t, "boolean") : h(t) ? e.stylize("null", "null") : void 0
    }

    function f(e) {
      return "[" + Error.prototype.toString.call(e) + "]"
    }

    function a(e, t, r, n, o) {
      for (var i = [], u = 0, s = t.length; u < s; ++u) A(t, String(u)) ? i.push(y(e, t, r, n, String(u), !0)) : i.push("");
      return o.forEach(function(o) {
        o.match(/^\d+$/) || i.push(y(e, t, r, n, o, !0))
      }), i
    }

    function y(e, t, r, n, o, i) {
      var u, s, c;
      if ((c = Object.getOwnPropertyDescriptor(t, o) || {
          value: t[o]
        }).get ? s = c.set ? e.stylize("[Getter/Setter]", "special") : e.stylize("[Getter]", "special") : c.set && (s = e.stylize("[Setter]", "special")), A(n, o) || (u = "[" + o + "]"), s || (e.seen.indexOf(c.value) < 0 ? (s = h(r) ? p(e, c.value, null) : p(e, c.value, r - 1)).indexOf("\n") > -1 && (s = i ? s.split("\n").map(function(e) {
          return "  " + e
        }).join("\n").substr(2) : "\n" + s.split("\n").map(function(e) {
          return "   " + e
        }).join("\n")) : s = e.stylize("[Circular]", "special")), j(u)) {
        if (i && o.match(/^\d+$/)) return s;
        (u = JSON.stringify("" + o)).match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/) ? (u = u.substr(1, u.length - 2), u = e.stylize(u, "name")) : (u = u.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'"), u = e.stylize(u, "string"))
      }
      return u + ": " + s
    }

    function g(e, t, r) {
      return e.reduce(function(e, t) {
        return 0, t.indexOf("\n") >= 0 && 0, e + t.replace(/\u001b\[\d\d?m/g, "").length + 1
      }, 0) > 60 ? r[0] + ("" === t ? "" : t + "\n ") + " " + e.join(",\n  ") + " " + r[1] : r[0] + t + " " + e.join(", ") + " " + r[1]
    }

    function d(e) {
      return Array.isArray(e)
    }

    function b(e) {
      return "boolean" == typeof e
    }

    function h(e) {
      return null === e
    }

    function m(e) {
      return null == e
    }

    function x(e) {
      return "number" == typeof e
    }

    function v(e) {
      return "string" == typeof e
    }

    function O(e) {
      return "symbol" == typeof e
    }

    function j(e) {
      return void 0 === e
    }

    function w(e) {
      return S(e) && "[object RegExp]" === T(e)
    }

    function S(e) {
      return "object" == typeof e && null !== e
    }

    function z(e) {
      return S(e) && "[object Date]" === T(e)
    }

    function E(e) {
      return S(e) && ("[object Error]" === T(e) || e instanceof Error)
    }

    function P(e) {
      return "function" == typeof e
    }

    function D(e) {
      return null === e || "boolean" == typeof e || "number" == typeof e || "string" == typeof e || "symbol" == typeof e || void 0 === e
    }

    function T(e) {
      return Object.prototype.toString.call(e)
    }

    function N(e) {
      return e < 10 ? "0" + e.toString(10) : e.toString(10)
    }
    exports.debuglog = function(t) {
      if (j(n) && (n = ""), t = t.toUpperCase(), !o[t])
        if (new RegExp("\\b" + t + "\\b", "i").test(n)) {
          var r = e.pid;
          o[t] = function() {
            var e = exports.format.apply(exports, arguments);
            console.error("%s %d: %s", t, r, e)
          }
        } else o[t] = function() {};
      return o[t]
    }, exports.inspect = i, i.colors = {
      bold: [1, 22],
      italic: [3, 23],
      underline: [4, 24],
      inverse: [7, 27],
      white: [37, 39],
      grey: [90, 39],
      black: [30, 39],
      blue: [34, 39],
      cyan: [36, 39],
      green: [32, 39],
      magenta: [35, 39],
      red: [31, 39],
      yellow: [33, 39]
    }, i.styles = {
      special: "cyan",
      number: "yellow",
      boolean: "yellow",
      undefined: "grey",
      null: "bold",
      string: "green",
      date: "magenta",
      regexp: "red"
    }, exports.isArray = d, exports.isBoolean = b, exports.isNull = h, exports.isNullOrUndefined = m, exports.isNumber = x, exports.isString = v, exports.isSymbol = O, exports.isUndefined = j, exports.isRegExp = w, exports.isObject = S, exports.isDate = z, exports.isError = E, exports.isFunction = P, exports.isPrimitive = D, exports.isBuffer = require("./support/isBuffer");
    var F = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];

    function k() {
      var e = new Date,
        t = [N(e.getHours()), N(e.getMinutes()), N(e.getSeconds())].join(":");
      return [e.getDate(), F[e.getMonth()], t].join(" ")
    }

    function A(e, t) {
      return Object.prototype.hasOwnProperty.call(e, t)
    }
    exports.log = function() {
      console.log("%s - %s", k(), exports.format.apply(exports, arguments))
    }, exports.inherits = require("inherits"), exports._extend = function(e, t) {
      if (!t || !S(t)) return e;
      for (var r = Object.keys(t), n = r.length; n--;) e[r[n]] = t[r[n]];
      return e
    };
    var J = "undefined" != typeof Symbol ? Symbol("util.promisify.custom") : void 0;

    function R(e, t) {
      if (!e) {
        var r = new Error("Promise was rejected with a falsy value");
        r.reason = e, e = r
      }
      return t(e)
    }

    function H(r) {
      if ("function" != typeof r) throw new TypeError('The "original" argument must be of type Function');

      function n() {
        for (var t = [], n = 0; n < arguments.length; n++) t.push(arguments[n]);
        var o = t.pop();
        if ("function" != typeof o) throw new TypeError("The last argument must be of type Function");
        var i = this,
          u = function() {
            return o.apply(i, arguments)
          };
        r.apply(this, t).then(function(t) {
          e.nextTick(u, null, t)
        }, function(t) {
          e.nextTick(R, t, u)
        })
      }
      return Object.setPrototypeOf(n, Object.getPrototypeOf(r)), Object.defineProperties(n, t(r)), n
    }
    exports.promisify = function(e) {
      if ("function" != typeof e) throw new TypeError('The "original" argument must be of type Function');
      if (J && e[J]) {
        var r;
        if ("function" != typeof(r = e[J])) throw new TypeError('The "util.promisify.custom" argument must be of type Function');
        return Object.defineProperty(r, J, {
          value: r,
          enumerable: !1,
          writable: !1,
          configurable: !0
        }), r
      }

      function r() {
        for (var t, r, n = new Promise(function(e, n) {
            t = e, r = n
          }), o = [], i = 0; i < arguments.length; i++) o.push(arguments[i]);
        o.push(function(e, n) {
          e ? r(e) : t(n)
        });
        try {
          e.apply(this, o)
        } catch (u) {
          r(u)
        }
        return n
      }
      return Object.setPrototypeOf(r, Object.getPrototypeOf(e)), J && Object.defineProperty(r, J, {
        value: r,
        enumerable: !1,
        writable: !1,
        configurable: !0
      }), Object.defineProperties(r, t(e))
    }, exports.promisify.custom = J, exports.callbackify = H;
  }, {
    "./support/isBuffer": "vexR",
    "inherits": "tcrG",
    "process": "pBGv"
  }],
  "h15N": [function(require, module, exports) {
    var global = arguments[3];
    var define;
    var n, r = arguments[3];
    ! function() {
      var t = "object" == typeof self && self.self === self && self || "object" == typeof r && r.global === r && r || this || {},
        e = t._,
        u = Array.prototype,
        i = Object.prototype,
        o = "undefined" != typeof Symbol ? Symbol.prototype : null,
        a = u.push,
        c = u.slice,
        l = i.toString,
        f = i.hasOwnProperty,
        s = Array.isArray,
        p = Object.keys,
        v = Object.create,
        h = function() {},
        y = function(n) {
          return n instanceof y ? n : this instanceof y ? void(this._wrapped = n) : new y(n)
        };
      "undefined" == typeof exports || exports.nodeType ? t._ = y : ("undefined" != typeof module && !module.nodeType && module.exports && (exports = module.exports = y), exports._ = y), y.VERSION = "1.9.1";
      var d, g = function(n, r, t) {
          if (void 0 === r) return n;
          switch (null == t ? 3 : t) {
            case 1:
              return function(t) {
                return n.call(r, t)
              };
            case 3:
              return function(t, e, u) {
                return n.call(r, t, e, u)
              };
            case 4:
              return function(t, e, u, i) {
                return n.call(r, t, e, u, i)
              }
          }
          return function() {
            return n.apply(r, arguments)
          }
        },
        m = function(n, r, t) {
          return y.iteratee !== d ? y.iteratee(n, r) : null == n ? y.identity : y.isFunction(n) ? g(n, r, t) : y.isObject(n) && !y.isArray(n) ? y.matcher(n) : y.property(n)
        };
      y.iteratee = d = function(n, r) {
        return m(n, r, 1 / 0)
      };
      var b = function(n, r) {
          return r = null == r ? n.length - 1 : +r,
            function() {
              for (var t = Math.max(arguments.length - r, 0), e = Array(t), u = 0; u < t; u++) e[u] = arguments[u + r];
              switch (r) {
                case 0:
                  return n.call(this, e);
                case 1:
                  return n.call(this, arguments[0], e);
                case 2:
                  return n.call(this, arguments[0], arguments[1], e)
              }
              var i = Array(r + 1);
              for (u = 0; u < r; u++) i[u] = arguments[u];
              return i[r] = e, n.apply(this, i)
            }
        },
        j = function(n) {
          if (!y.isObject(n)) return {};
          if (v) return v(n);
          h.prototype = n;
          var r = new h;
          return h.prototype = null, r
        },
        x = function(n) {
          return function(r) {
            return null == r ? void 0 : r[n]
          }
        },
        _ = function(n, r) {
          return null != n && f.call(n, r)
        },
        A = function(n, r) {
          for (var t = r.length, e = 0; e < t; e++) {
            if (null == n) return;
            n = n[r[e]]
          }
          return t ? n : void 0
        },
        w = Math.pow(2, 53) - 1,
        O = x("length"),
        k = function(n) {
          var r = O(n);
          return "number" == typeof r && r >= 0 && r <= w
        };
      y.each = y.forEach = function(n, r, t) {
        var e, u;
        if (r = g(r, t), k(n))
          for (e = 0, u = n.length; e < u; e++) r(n[e], e, n);
        else {
          var i = y.keys(n);
          for (e = 0, u = i.length; e < u; e++) r(n[i[e]], i[e], n)
        }
        return n
      }, y.map = y.collect = function(n, r, t) {
        r = m(r, t);
        for (var e = !k(n) && y.keys(n), u = (e || n).length, i = Array(u), o = 0; o < u; o++) {
          var a = e ? e[o] : o;
          i[o] = r(n[a], a, n)
        }
        return i
      };
      var S = function(n) {
        return function(r, t, e, u) {
          var i = arguments.length >= 3;
          return function(r, t, e, u) {
            var i = !k(r) && y.keys(r),
              o = (i || r).length,
              a = n > 0 ? 0 : o - 1;
            for (u || (e = r[i ? i[a] : a], a += n); a >= 0 && a < o; a += n) {
              var c = i ? i[a] : a;
              e = t(e, r[c], c, r)
            }
            return e
          }(r, g(t, u, 4), e, i)
        }
      };
      y.reduce = y.foldl = y.inject = S(1), y.reduceRight = y.foldr = S(-1), y.find = y.detect = function(n, r, t) {
        var e = (k(n) ? y.findIndex : y.findKey)(n, r, t);
        if (void 0 !== e && -1 !== e) return n[e]
      }, y.filter = y.select = function(n, r, t) {
        var e = [];
        return r = m(r, t), y.each(n, function(n, t, u) {
          r(n, t, u) && e.push(n)
        }), e
      }, y.reject = function(n, r, t) {
        return y.filter(n, y.negate(m(r)), t)
      }, y.every = y.all = function(n, r, t) {
        r = m(r, t);
        for (var e = !k(n) && y.keys(n), u = (e || n).length, i = 0; i < u; i++) {
          var o = e ? e[i] : i;
          if (!r(n[o], o, n)) return !1
        }
        return !0
      }, y.some = y.any = function(n, r, t) {
        r = m(r, t);
        for (var e = !k(n) && y.keys(n), u = (e || n).length, i = 0; i < u; i++) {
          var o = e ? e[i] : i;
          if (r(n[o], o, n)) return !0
        }
        return !1
      }, y.contains = y.includes = y.include = function(n, r, t, e) {
        return k(n) || (n = y.values(n)), ("number" != typeof t || e) && (t = 0), y.indexOf(n, r, t) >= 0
      }, y.invoke = b(function(n, r, t) {
        var e, u;
        return y.isFunction(r) ? u = r : y.isArray(r) && (e = r.slice(0, -1), r = r[r.length - 1]), y.map(n, function(n) {
          var i = u;
          if (!i) {
            if (e && e.length && (n = A(n, e)), null == n) return;
            i = n[r]
          }
          return null == i ? i : i.apply(n, t)
        })
      }), y.pluck = function(n, r) {
        return y.map(n, y.property(r))
      }, y.where = function(n, r) {
        return y.filter(n, y.matcher(r))
      }, y.findWhere = function(n, r) {
        return y.find(n, y.matcher(r))
      }, y.max = function(n, r, t) {
        var e, u, i = -1 / 0,
          o = -1 / 0;
        if (null == r || "number" == typeof r && "object" != typeof n[0] && null != n)
          for (var a = 0, c = (n = k(n) ? n : y.values(n)).length; a < c; a++) null != (e = n[a]) && e > i && (i = e);
        else r = m(r, t), y.each(n, function(n, t, e) {
          ((u = r(n, t, e)) > o || u === -1 / 0 && i === -1 / 0) && (i = n, o = u)
        });
        return i
      }, y.min = function(n, r, t) {
        var e, u, i = 1 / 0,
          o = 1 / 0;
        if (null == r || "number" == typeof r && "object" != typeof n[0] && null != n)
          for (var a = 0, c = (n = k(n) ? n : y.values(n)).length; a < c; a++) null != (e = n[a]) && e < i && (i = e);
        else r = m(r, t), y.each(n, function(n, t, e) {
          ((u = r(n, t, e)) < o || u === 1 / 0 && i === 1 / 0) && (i = n, o = u)
        });
        return i
      }, y.shuffle = function(n) {
        return y.sample(n, 1 / 0)
      }, y.sample = function(n, r, t) {
        if (null == r || t) return k(n) || (n = y.values(n)), n[y.random(n.length - 1)];
        var e = k(n) ? y.clone(n) : y.values(n),
          u = O(e);
        r = Math.max(Math.min(r, u), 0);
        for (var i = u - 1, o = 0; o < r; o++) {
          var a = y.random(o, i),
            c = e[o];
          e[o] = e[a], e[a] = c
        }
        return e.slice(0, r)
      }, y.sortBy = function(n, r, t) {
        var e = 0;
        return r = m(r, t), y.pluck(y.map(n, function(n, t, u) {
          return {
            value: n,
            index: e++,
            criteria: r(n, t, u)
          }
        }).sort(function(n, r) {
          var t = n.criteria,
            e = r.criteria;
          if (t !== e) {
            if (t > e || void 0 === t) return 1;
            if (t < e || void 0 === e) return -1
          }
          return n.index - r.index
        }), "value")
      };
      var M = function(n, r) {
        return function(t, e, u) {
          var i = r ? [
            [],
            []
          ] : {};
          return e = m(e, u), y.each(t, function(r, u) {
            var o = e(r, u, t);
            n(i, r, o)
          }), i
        }
      };
      y.groupBy = M(function(n, r, t) {
        _(n, t) ? n[t].push(r) : n[t] = [r]
      }), y.indexBy = M(function(n, r, t) {
        n[t] = r
      }), y.countBy = M(function(n, r, t) {
        _(n, t) ? n[t]++ : n[t] = 1
      });
      var F = /[^\ud800-\udfff]|[\ud800-\udbff][\udc00-\udfff]|[\ud800-\udfff]/g;
      y.toArray = function(n) {
        return n ? y.isArray(n) ? c.call(n) : y.isString(n) ? n.match(F) : k(n) ? y.map(n, y.identity) : y.values(n) : []
      }, y.size = function(n) {
        return null == n ? 0 : k(n) ? n.length : y.keys(n).length
      }, y.partition = M(function(n, r, t) {
        n[t ? 0 : 1].push(r)
      }, !0), y.first = y.head = y.take = function(n, r, t) {
        return null == n || n.length < 1 ? null == r ? void 0 : [] : null == r || t ? n[0] : y.initial(n, n.length - r)
      }, y.initial = function(n, r, t) {
        return c.call(n, 0, Math.max(0, n.length - (null == r || t ? 1 : r)))
      }, y.last = function(n, r, t) {
        return null == n || n.length < 1 ? null == r ? void 0 : [] : null == r || t ? n[n.length - 1] : y.rest(n, Math.max(0, n.length - r))
      }, y.rest = y.tail = y.drop = function(n, r, t) {
        return c.call(n, null == r || t ? 1 : r)
      }, y.compact = function(n) {
        return y.filter(n, Boolean)
      };
      var E = function(n, r, t, e) {
        for (var u = (e = e || []).length, i = 0, o = O(n); i < o; i++) {
          var a = n[i];
          if (k(a) && (y.isArray(a) || y.isArguments(a)))
            if (r)
              for (var c = 0, l = a.length; c < l;) e[u++] = a[c++];
            else E(a, r, t, e), u = e.length;
          else t || (e[u++] = a)
        }
        return e
      };
      y.flatten = function(n, r) {
        return E(n, r, !1)
      }, y.without = b(function(n, r) {
        return y.difference(n, r)
      }), y.uniq = y.unique = function(n, r, t, e) {
        y.isBoolean(r) || (e = t, t = r, r = !1), null != t && (t = m(t, e));
        for (var u = [], i = [], o = 0, a = O(n); o < a; o++) {
          var c = n[o],
            l = t ? t(c, o, n) : c;
          r && !t ? (o && i === l || u.push(c), i = l) : t ? y.contains(i, l) || (i.push(l), u.push(c)) : y.contains(u, c) || u.push(c)
        }
        return u
      }, y.union = b(function(n) {
        return y.uniq(E(n, !0, !0))
      }), y.intersection = function(n) {
        for (var r = [], t = arguments.length, e = 0, u = O(n); e < u; e++) {
          var i = n[e];
          if (!y.contains(r, i)) {
            var o;
            for (o = 1; o < t && y.contains(arguments[o], i); o++);
            o === t && r.push(i)
          }
        }
        return r
      }, y.difference = b(function(n, r) {
        return r = E(r, !0, !0), y.filter(n, function(n) {
          return !y.contains(r, n)
        })
      }), y.unzip = function(n) {
        for (var r = n && y.max(n, O).length || 0, t = Array(r), e = 0; e < r; e++) t[e] = y.pluck(n, e);
        return t
      }, y.zip = b(y.unzip), y.object = function(n, r) {
        for (var t = {}, e = 0, u = O(n); e < u; e++) r ? t[n[e]] = r[e] : t[n[e][0]] = n[e][1];
        return t
      };
      var N = function(n) {
        return function(r, t, e) {
          t = m(t, e);
          for (var u = O(r), i = n > 0 ? 0 : u - 1; i >= 0 && i < u; i += n)
            if (t(r[i], i, r)) return i;
          return -1
        }
      };
      y.findIndex = N(1), y.findLastIndex = N(-1), y.sortedIndex = function(n, r, t, e) {
        for (var u = (t = m(t, e, 1))(r), i = 0, o = O(n); i < o;) {
          var a = Math.floor((i + o) / 2);
          t(n[a]) < u ? i = a + 1 : o = a
        }
        return i
      };
      var I = function(n, r, t) {
        return function(e, u, i) {
          var o = 0,
            a = O(e);
          if ("number" == typeof i) n > 0 ? o = i >= 0 ? i : Math.max(i + a, o) : a = i >= 0 ? Math.min(i + 1, a) : i + a + 1;
          else if (t && i && a) return e[i = t(e, u)] === u ? i : -1;
          if (u != u) return (i = r(c.call(e, o, a), y.isNaN)) >= 0 ? i + o : -1;
          for (i = n > 0 ? o : a - 1; i >= 0 && i < a; i += n)
            if (e[i] === u) return i;
          return -1
        }
      };
      y.indexOf = I(1, y.findIndex, y.sortedIndex), y.lastIndexOf = I(-1, y.findLastIndex), y.range = function(n, r, t) {
        null == r && (r = n || 0, n = 0), t || (t = r < n ? -1 : 1);
        for (var e = Math.max(Math.ceil((r - n) / t), 0), u = Array(e), i = 0; i < e; i++, n += t) u[i] = n;
        return u
      }, y.chunk = function(n, r) {
        if (null == r || r < 1) return [];
        for (var t = [], e = 0, u = n.length; e < u;) t.push(c.call(n, e, e += r));
        return t
      };
      var T = function(n, r, t, e, u) {
        if (!(e instanceof r)) return n.apply(t, u);
        var i = j(n.prototype),
          o = n.apply(i, u);
        return y.isObject(o) ? o : i
      };
      y.bind = b(function(n, r, t) {
        if (!y.isFunction(n)) throw new TypeError("Bind must be called on a function");
        var e = b(function(u) {
          return T(n, e, r, this, t.concat(u))
        });
        return e
      }), y.partial = b(function(n, r) {
        var t = y.partial.placeholder,
          e = function() {
            for (var u = 0, i = r.length, o = Array(i), a = 0; a < i; a++) o[a] = r[a] === t ? arguments[u++] : r[a];
            for (; u < arguments.length;) o.push(arguments[u++]);
            return T(n, e, this, this, o)
          };
        return e
      }), y.partial.placeholder = y, y.bindAll = b(function(n, r) {
        var t = (r = E(r, !1, !1)).length;
        if (t < 1) throw new Error("bindAll must be passed function names");
        for (; t--;) {
          var e = r[t];
          n[e] = y.bind(n[e], n)
        }
      }), y.memoize = function(n, r) {
        var t = function(e) {
          var u = t.cache,
            i = "" + (r ? r.apply(this, arguments) : e);
          return _(u, i) || (u[i] = n.apply(this, arguments)), u[i]
        };
        return t.cache = {}, t
      }, y.delay = b(function(n, r, t) {
        return setTimeout(function() {
          return n.apply(null, t)
        }, r)
      }), y.defer = y.partial(y.delay, y, 1), y.throttle = function(n, r, t) {
        var e, u, i, o, a = 0;
        t || (t = {});
        var c = function() {
            a = !1 === t.leading ? 0 : y.now(), e = null, o = n.apply(u, i), e || (u = i = null)
          },
          l = function() {
            var l = y.now();
            a || !1 !== t.leading || (a = l);
            var f = r - (l - a);
            return u = this, i = arguments, f <= 0 || f > r ? (e && (clearTimeout(e), e = null), a = l, o = n.apply(u, i), e || (u = i = null)) : e || !1 === t.trailing || (e = setTimeout(c, f)), o
          };
        return l.cancel = function() {
          clearTimeout(e), a = 0, e = u = i = null
        }, l
      }, y.debounce = function(n, r, t) {
        var e, u, i = function(r, t) {
            e = null, t && (u = n.apply(r, t))
          },
          o = b(function(o) {
            if (e && clearTimeout(e), t) {
              var a = !e;
              e = setTimeout(i, r), a && (u = n.apply(this, o))
            } else e = y.delay(i, r, this, o);
            return u
          });
        return o.cancel = function() {
          clearTimeout(e), e = null
        }, o
      }, y.wrap = function(n, r) {
        return y.partial(r, n)
      }, y.negate = function(n) {
        return function() {
          return !n.apply(this, arguments)
        }
      }, y.compose = function() {
        var n = arguments,
          r = n.length - 1;
        return function() {
          for (var t = r, e = n[r].apply(this, arguments); t--;) e = n[t].call(this, e);
          return e
        }
      }, y.after = function(n, r) {
        return function() {
          if (--n < 1) return r.apply(this, arguments)
        }
      }, y.before = function(n, r) {
        var t;
        return function() {
          return --n > 0 && (t = r.apply(this, arguments)), n <= 1 && (r = null), t
        }
      }, y.once = y.partial(y.before, 2), y.restArguments = b;
      var B = !{
          toString: null
        }.propertyIsEnumerable("toString"),
        R = ["valueOf", "isPrototypeOf", "toString", "propertyIsEnumerable", "hasOwnProperty", "toLocaleString"],
        q = function(n, r) {
          var t = R.length,
            e = n.constructor,
            u = y.isFunction(e) && e.prototype || i,
            o = "constructor";
          for (_(n, o) && !y.contains(r, o) && r.push(o); t--;)(o = R[t]) in n && n[o] !== u[o] && !y.contains(r, o) && r.push(o)
        };
      y.keys = function(n) {
        if (!y.isObject(n)) return [];
        if (p) return p(n);
        var r = [];
        for (var t in n) _(n, t) && r.push(t);
        return B && q(n, r), r
      }, y.allKeys = function(n) {
        if (!y.isObject(n)) return [];
        var r = [];
        for (var t in n) r.push(t);
        return B && q(n, r), r
      }, y.values = function(n) {
        for (var r = y.keys(n), t = r.length, e = Array(t), u = 0; u < t; u++) e[u] = n[r[u]];
        return e
      }, y.mapObject = function(n, r, t) {
        r = m(r, t);
        for (var e = y.keys(n), u = e.length, i = {}, o = 0; o < u; o++) {
          var a = e[o];
          i[a] = r(n[a], a, n)
        }
        return i
      }, y.pairs = function(n) {
        for (var r = y.keys(n), t = r.length, e = Array(t), u = 0; u < t; u++) e[u] = [r[u], n[r[u]]];
        return e
      }, y.invert = function(n) {
        for (var r = {}, t = y.keys(n), e = 0, u = t.length; e < u; e++) r[n[t[e]]] = t[e];
        return r
      }, y.functions = y.methods = function(n) {
        var r = [];
        for (var t in n) y.isFunction(n[t]) && r.push(t);
        return r.sort()
      };
      var K = function(n, r) {
        return function(t) {
          var e = arguments.length;
          if (r && (t = Object(t)), e < 2 || null == t) return t;
          for (var u = 1; u < e; u++)
            for (var i = arguments[u], o = n(i), a = o.length, c = 0; c < a; c++) {
              var l = o[c];
              r && void 0 !== t[l] || (t[l] = i[l])
            }
          return t
        }
      };
      y.extend = K(y.allKeys), y.extendOwn = y.assign = K(y.keys), y.findKey = function(n, r, t) {
        r = m(r, t);
        for (var e, u = y.keys(n), i = 0, o = u.length; i < o; i++)
          if (r(n[e = u[i]], e, n)) return e
      };
      var z, D, L = function(n, r, t) {
        return r in t
      };
      y.pick = b(function(n, r) {
        var t = {},
          e = r[0];
        if (null == n) return t;
        y.isFunction(e) ? (r.length > 1 && (e = g(e, r[1])), r = y.allKeys(n)) : (e = L, r = E(r, !1, !1), n = Object(n));
        for (var u = 0, i = r.length; u < i; u++) {
          var o = r[u],
            a = n[o];
          e(a, o, n) && (t[o] = a)
        }
        return t
      }), y.omit = b(function(n, r) {
        var t, e = r[0];
        return y.isFunction(e) ? (e = y.negate(e), r.length > 1 && (t = r[1])) : (r = y.map(E(r, !1, !1), String), e = function(n, t) {
          return !y.contains(r, t)
        }), y.pick(n, e, t)
      }), y.defaults = K(y.allKeys, !0), y.create = function(n, r) {
        var t = j(n);
        return r && y.extendOwn(t, r), t
      }, y.clone = function(n) {
        return y.isObject(n) ? y.isArray(n) ? n.slice() : y.extend({}, n) : n
      }, y.tap = function(n, r) {
        return r(n), n
      }, y.isMatch = function(n, r) {
        var t = y.keys(r),
          e = t.length;
        if (null == n) return !e;
        for (var u = Object(n), i = 0; i < e; i++) {
          var o = t[i];
          if (r[o] !== u[o] || !(o in u)) return !1
        }
        return !0
      }, z = function(n, r, t, e) {
        if (n === r) return 0 !== n || 1 / n == 1 / r;
        if (null == n || null == r) return !1;
        if (n != n) return r != r;
        var u = typeof n;
        return ("function" === u || "object" === u || "object" == typeof r) && D(n, r, t, e)
      }, D = function(n, r, t, e) {
        n instanceof y && (n = n._wrapped), r instanceof y && (r = r._wrapped);
        var u = l.call(n);
        if (u !== l.call(r)) return !1;
        switch (u) {
          case "[object RegExp]":
          case "[object String]":
            return "" + n == "" + r;
          case "[object Number]":
            return +n != +n ? +r != +r : 0 == +n ? 1 / +n == 1 / r : +n == +r;
          case "[object Date]":
          case "[object Boolean]":
            return +n == +r;
          case "[object Symbol]":
            return o.valueOf.call(n) === o.valueOf.call(r)
        }
        var i = "[object Array]" === u;
        if (!i) {
          if ("object" != typeof n || "object" != typeof r) return !1;
          var a = n.constructor,
            c = r.constructor;
          if (a !== c && !(y.isFunction(a) && a instanceof a && y.isFunction(c) && c instanceof c) && "constructor" in n && "constructor" in r) return !1
        }
        e = e || [];
        for (var f = (t = t || []).length; f--;)
          if (t[f] === n) return e[f] === r;
        if (t.push(n), e.push(r), i) {
          if ((f = n.length) !== r.length) return !1;
          for (; f--;)
            if (!z(n[f], r[f], t, e)) return !1
        } else {
          var s, p = y.keys(n);
          if (f = p.length, y.keys(r).length !== f) return !1;
          for (; f--;)
            if (s = p[f], !_(r, s) || !z(n[s], r[s], t, e)) return !1
        }
        return t.pop(), e.pop(), !0
      }, y.isEqual = function(n, r) {
        return z(n, r)
      }, y.isEmpty = function(n) {
        return null == n || (k(n) && (y.isArray(n) || y.isString(n) || y.isArguments(n)) ? 0 === n.length : 0 === y.keys(n).length)
      }, y.isElement = function(n) {
        return !(!n || 1 !== n.nodeType)
      }, y.isArray = s || function(n) {
        return "[object Array]" === l.call(n)
      }, y.isObject = function(n) {
        var r = typeof n;
        return "function" === r || "object" === r && !!n
      }, y.each(["Arguments", "Function", "String", "Number", "Date", "RegExp", "Error", "Symbol", "Map", "WeakMap", "Set", "WeakSet"], function(n) {
        y["is" + n] = function(r) {
          return l.call(r) === "[object " + n + "]"
        }
      }), y.isArguments(arguments) || (y.isArguments = function(n) {
        return _(n, "callee")
      });
      var P = t.document && t.document.childNodes;
      "function" != typeof /./ && "object" != typeof Int8Array && "function" != typeof P && (y.isFunction = function(n) {
        return "function" == typeof n || !1
      }), y.isFinite = function(n) {
        return !y.isSymbol(n) && isFinite(n) && !isNaN(parseFloat(n))
      }, y.isNaN = function(n) {
        return y.isNumber(n) && isNaN(n)
      }, y.isBoolean = function(n) {
        return !0 === n || !1 === n || "[object Boolean]" === l.call(n)
      }, y.isNull = function(n) {
        return null === n
      }, y.isUndefined = function(n) {
        return void 0 === n
      }, y.has = function(n, r) {
        if (!y.isArray(r)) return _(n, r);
        for (var t = r.length, e = 0; e < t; e++) {
          var u = r[e];
          if (null == n || !f.call(n, u)) return !1;
          n = n[u]
        }
        return !!t
      }, y.noConflict = function() {
        return t._ = e, this
      }, y.identity = function(n) {
        return n
      }, y.constant = function(n) {
        return function() {
          return n
        }
      }, y.noop = function() {}, y.property = function(n) {
        return y.isArray(n) ? function(r) {
          return A(r, n)
        } : x(n)
      }, y.propertyOf = function(n) {
        return null == n ? function() {} : function(r) {
          return y.isArray(r) ? A(n, r) : n[r]
        }
      }, y.matcher = y.matches = function(n) {
        return n = y.extendOwn({}, n),
          function(r) {
            return y.isMatch(r, n)
          }
      }, y.times = function(n, r, t) {
        var e = Array(Math.max(0, n));
        r = g(r, t, 1);
        for (var u = 0; u < n; u++) e[u] = r(u);
        return e
      }, y.random = function(n, r) {
        return null == r && (r = n, n = 0), n + Math.floor(Math.random() * (r - n + 1))
      }, y.now = Date.now || function() {
        return (new Date).getTime()
      };
      var W = {
          "&": "&amp;",
          "<": "&lt;",
          ">": "&gt;",
          '"': "&quot;",
          "'": "&#x27;",
          "`": "&#x60;"
        },
        C = y.invert(W),
        J = function(n) {
          var r = function(r) {
              return n[r]
            },
            t = "(?:" + y.keys(n).join("|") + ")",
            e = RegExp(t),
            u = RegExp(t, "g");
          return function(n) {
            return n = null == n ? "" : "" + n, e.test(n) ? n.replace(u, r) : n
          }
        };
      y.escape = J(W), y.unescape = J(C), y.result = function(n, r, t) {
        y.isArray(r) || (r = [r]);
        var e = r.length;
        if (!e) return y.isFunction(t) ? t.call(n) : t;
        for (var u = 0; u < e; u++) {
          var i = null == n ? void 0 : n[r[u]];
          void 0 === i && (i = t, u = e), n = y.isFunction(i) ? i.call(n) : i
        }
        return n
      };
      var U = 0;
      y.uniqueId = function(n) {
        var r = ++U + "";
        return n ? n + r : r
      }, y.templateSettings = {
        evaluate: /<%([\s\S]+?)%>/g,
        interpolate: /<%=([\s\S]+?)%>/g,
        escape: /<%-([\s\S]+?)%>/g
      };
      var V = /(.)^/,
        $ = {
          "'": "'",
          "\\": "\\",
          "\r": "r",
          "\n": "n",
          "\u2028": "u2028",
          "\u2029": "u2029"
        },
        G = /\\|'|\r|\n|\u2028|\u2029/g,
        H = function(n) {
          return "\\" + $[n]
        };
      y.template = function(n, r, t) {
        !r && t && (r = t), r = y.defaults({}, r, y.templateSettings);
        var e, u = RegExp([(r.escape || V).source, (r.interpolate || V).source, (r.evaluate || V).source].join("|") + "|$", "g"),
          i = 0,
          o = "__p+='";
        n.replace(u, function(r, t, e, u, a) {
          return o += n.slice(i, a).replace(G, H), i = a + r.length, t ? o += "'+\n((__t=(" + t + "))==null?'':_.escape(__t))+\n'" : e ? o += "'+\n((__t=(" + e + "))==null?'':__t)+\n'" : u && (o += "';\n" + u + "\n__p+='"), r
        }), o += "';\n", r.variable || (o = "with(obj||{}){\n" + o + "}\n"), o = "var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};\n" + o + "return __p;\n";
        try {
          e = new Function(r.variable || "obj", "_", o)
        } catch (l) {
          throw l.source = o, l
        }
        var a = function(n) {
            return e.call(this, n, y)
          },
          c = r.variable || "obj";
        return a.source = "function(" + c + "){\n" + o + "}", a
      }, y.chain = function(n) {
        var r = y(n);
        return r._chain = !0, r
      };
      var Q = function(n, r) {
        return n._chain ? y(r).chain() : r
      };
      y.mixin = function(n) {
        return y.each(y.functions(n), function(r) {
          var t = y[r] = n[r];
          y.prototype[r] = function() {
            var n = [this._wrapped];
            return a.apply(n, arguments), Q(this, t.apply(y, n))
          }
        }), y
      }, y.mixin(y), y.each(["pop", "push", "reverse", "shift", "sort", "splice", "unshift"], function(n) {
        var r = u[n];
        y.prototype[n] = function() {
          var t = this._wrapped;
          return r.apply(t, arguments), "shift" !== n && "splice" !== n || 0 !== t.length || delete t[0], Q(this, t)
        }
      }), y.each(["concat", "join", "slice"], function(n) {
        var r = u[n];
        y.prototype[n] = function() {
          return Q(this, r.apply(this._wrapped, arguments))
        }
      }), y.prototype.value = function() {
        return this._wrapped
      }, y.prototype.valueOf = y.prototype.toJSON = y.prototype.value, y.prototype.toString = function() {
        return String(this._wrapped)
      }, "function" == typeof n && n.amd && n("underscore", [], function() {
        return y
      })
    }();
  }, {}],
  "NETG": [function(require, module, exports) {
    "use strict";

    function r(n) {
      return (r = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(r) {
        return typeof r
      } : function(r) {
        return r && "function" == typeof Symbol && r.constructor === Symbol && r !== Symbol.prototype ? "symbol" : typeof r
      })(n)
    }
    module.exports = {
      ErrorResponse: function(r) {
        var n = r && r.error && r.error.message ? r.error.message : JSON.stringify(r),
          e = r.error && r.error.data ? r.error.data : null,
          o = new Error("Returned error: " + n);
        return o.data = e, o
      },
      InvalidNumberOfParams: function(r, n, e) {
        return new Error('Invalid number of parameters for "' + e + '". Got ' + r + " expected " + n + "!")
      },
      InvalidConnection: function(r, n) {
        return this.ConnectionError("CONNECTION ERROR: Couldn't connect to node " + r + ".", n)
      },
      InvalidProvider: function() {
        return new Error("Provider not set or invalid")
      },
      InvalidResponse: function(r) {
        var n = r && r.error && r.error.message ? r.error.message : "Invalid JSON RPC response: " + JSON.stringify(r);
        return new Error(n)
      },
      ConnectionTimeout: function(r) {
        return new Error("CONNECTION TIMEOUT: timeout of " + r + " ms achived")
      },
      ConnectionNotOpenError: function(r) {
        return this.ConnectionError("connection not open on send()", r)
      },
      ConnectionCloseError: function(n) {
        return "object" === r(n) && n.code && n.reason ? this.ConnectionError("CONNECTION ERROR: The connection got closed with the close code `" + n.code + "` and the following reason string `" + n.reason + "`", n) : new Error("CONNECTION ERROR: The connection closed unexpectedly")
      },
      MaxAttemptsReachedOnReconnectingError: function() {
        return new Error("Maximum number of reconnect attempts reached!")
      },
      PendingRequestsOnReconnectingError: function() {
        return new Error("CONNECTION ERROR: Provider started to reconnect before the response got received!")
      },
      ConnectionError: function(r, n) {
        var e = new Error(r);
        return n && (e.code = n.code, e.reason = n.reason), e
      },
      RevertInstructionError: function(r, n) {
        var e = new Error("Your request got reverted with the following reason string: " + r);
        return e.reason = r, e.signature = n, e
      },
      TransactionRevertInstructionError: function(r, n, e) {
        var o = new Error("Transaction has been reverted by the EVM:\n" + JSON.stringify(e, null, 2));
        return o.reason = r, o.signature = n, o.receipt = e, o
      },
      TransactionError: function(r, n) {
        var e = new Error(r);
        return e.receipt = n, e
      },
      NoContractAddressFoundError: function(r) {
        return this.TransactionError("The transaction receipt didn't contain a contract address.", r)
      },
      ContractCodeNotStoredError: function(r) {
        return this.TransactionError("The contract code couldn't be stored, please check your gas limit.", r)
      },
      TransactionRevertedWithoutReasonError: function(r) {
        return this.TransactionError("Transaction has been reverted by the EVM:\n" + JSON.stringify(r, null, 2), r)
      },
      TransactionOutOfGasError: function(r) {
        return this.TransactionError("Transaction ran out of gas. Please provide more gas:\n" + JSON.stringify(r, null, 2), r)
      },
      ResolverMethodMissingError: function(r, n) {
        return new Error("The resolver at " + r + 'does not implement requested method: "' + n + '".')
      },
      ContractMissingABIError: function() {
        return new Error("You must provide the json interface of the contract when instantiating a contract object.")
      },
      ContractOnceRequiresCallbackError: function() {
        return new Error("Once requires a callback as the second parameter.")
      },
      ContractEventDoesNotExistError: function(r) {
        return new Error('Event "' + r + "\" doesn't exist in this contract.")
      },
      ContractReservedEventError: function(r) {
        return new Error('The event "' + r + "\" is a reserved event name, you can't use it.")
      },
      ContractMissingDeployDataError: function() {
        return new Error('No "data" specified in neither the given options, nor the default options.')
      },
      ContractNoAddressDefinedError: function() {
        return new Error("This contract object doesn't have address set yet, please set an address first.")
      },
      ContractNoFromAddressDefinedError: function() {
        return new Error('No "from" address specified in neither the given options, nor the default options.')
      }
    };
  }, {}],
  "yh9p": [function(require, module, exports) {
    "use strict";
    exports.byteLength = u, exports.toByteArray = i, exports.fromByteArray = d;
    for (var r = [], t = [], e = "undefined" != typeof Uint8Array ? Uint8Array : Array, n = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", o = 0, a = n.length; o < a; ++o) r[o] = n[o], t[n.charCodeAt(o)] = o;

    function h(r) {
      var t = r.length;
      if (t % 4 > 0) throw new Error("Invalid string. Length must be a multiple of 4");
      var e = r.indexOf("=");
      return -1 === e && (e = t), [e, e === t ? 0 : 4 - e % 4]
    }

    function u(r) {
      var t = h(r),
        e = t[0],
        n = t[1];
      return 3 * (e + n) / 4 - n
    }

    function c(r, t, e) {
      return 3 * (t + e) / 4 - e
    }

    function i(r) {
      var n, o, a = h(r),
        u = a[0],
        i = a[1],
        f = new e(c(r, u, i)),
        A = 0,
        d = i > 0 ? u - 4 : u;
      for (o = 0; o < d; o += 4) n = t[r.charCodeAt(o)] << 18 | t[r.charCodeAt(o + 1)] << 12 | t[r.charCodeAt(o + 2)] << 6 | t[r.charCodeAt(o + 3)], f[A++] = n >> 16 & 255, f[A++] = n >> 8 & 255, f[A++] = 255 & n;
      return 2 === i && (n = t[r.charCodeAt(o)] << 2 | t[r.charCodeAt(o + 1)] >> 4, f[A++] = 255 & n), 1 === i && (n = t[r.charCodeAt(o)] << 10 | t[r.charCodeAt(o + 1)] << 4 | t[r.charCodeAt(o + 2)] >> 2, f[A++] = n >> 8 & 255, f[A++] = 255 & n), f
    }

    function f(t) {
      return r[t >> 18 & 63] + r[t >> 12 & 63] + r[t >> 6 & 63] + r[63 & t]
    }

    function A(r, t, e) {
      for (var n, o = [], a = t; a < e; a += 3) n = (r[a] << 16 & 16711680) + (r[a + 1] << 8 & 65280) + (255 & r[a + 2]), o.push(f(n));
      return o.join("")
    }

    function d(t) {
      for (var e, n = t.length, o = n % 3, a = [], h = 0, u = n - o; h < u; h += 16383) a.push(A(t, h, h + 16383 > u ? u : h + 16383));
      return 1 === o ? (e = t[n - 1], a.push(r[e >> 2] + r[e << 4 & 63] + "==")) : 2 === o && (e = (t[n - 2] << 8) + t[n - 1], a.push(r[e >> 10] + r[e >> 4 & 63] + r[e << 2 & 63] + "=")), a.join("")
    }
    t["-".charCodeAt(0)] = 62, t["_".charCodeAt(0)] = 63;
  }, {}],
  "JgNJ": [function(require, module, exports) {
    exports.read = function(a, o, t, r, h) {
      var M, p, w = 8 * h - r - 1,
        f = (1 << w) - 1,
        e = f >> 1,
        i = -7,
        N = t ? h - 1 : 0,
        n = t ? -1 : 1,
        s = a[o + N];
      for (N += n, M = s & (1 << -i) - 1, s >>= -i, i += w; i > 0; M = 256 * M + a[o + N], N += n, i -= 8);
      for (p = M & (1 << -i) - 1, M >>= -i, i += r; i > 0; p = 256 * p + a[o + N], N += n, i -= 8);
      if (0 === M) M = 1 - e;
      else {
        if (M === f) return p ? NaN : 1 / 0 * (s ? -1 : 1);
        p += Math.pow(2, r), M -= e
      }
      return (s ? -1 : 1) * p * Math.pow(2, M - r)
    }, exports.write = function(a, o, t, r, h, M) {
      var p, w, f, e = 8 * M - h - 1,
        i = (1 << e) - 1,
        N = i >> 1,
        n = 23 === h ? Math.pow(2, -24) - Math.pow(2, -77) : 0,
        s = r ? 0 : M - 1,
        u = r ? 1 : -1,
        l = o < 0 || 0 === o && 1 / o < 0 ? 1 : 0;
      for (o = Math.abs(o), isNaN(o) || o === 1 / 0 ? (w = isNaN(o) ? 1 : 0, p = i) : (p = Math.floor(Math.log(o) / Math.LN2), o * (f = Math.pow(2, -p)) < 1 && (p--, f *= 2), (o += p + N >= 1 ? n / f : n * Math.pow(2, 1 - N)) * f >= 2 && (p++, f /= 2), p + N >= i ? (w = 0, p = i) : p + N >= 1 ? (w = (o * f - 1) * Math.pow(2, h), p += N) : (w = o * Math.pow(2, N - 1) * Math.pow(2, h), p = 0)); h >= 8; a[t + s] = 255 & w, s += u, w /= 256, h -= 8);
      for (p = p << h | w, e += h; e > 0; a[t + s] = 255 & p, s += u, p /= 256, e -= 8);
      a[t + s - u] |= 128 * l
    };
  }, {}],
  "REa7": [function(require, module, exports) {
    var r = {}.toString;
    module.exports = Array.isArray || function(t) {
      return "[object Array]" == r.call(t)
    };
  }, {}],
  "dskh": [function(require, module, exports) {

    var global = arguments[3];
    var t = arguments[3],
      r = require("base64-js"),
      e = require("ieee754"),
      n = require("isarray");

    function i() {
      try {
        var t = new Uint8Array(1);
        return t.__proto__ = {
          __proto__: Uint8Array.prototype,
          foo: function() {
            return 42
          }
        }, 42 === t.foo() && "function" == typeof t.subarray && 0 === t.subarray(1, 1).byteLength
      } catch (r) {
        return !1
      }
    }

    function o() {
      return f.TYPED_ARRAY_SUPPORT ? 2147483647 : 1073741823
    }

    function u(t, r) {
      if (o() < r) throw new RangeError("Invalid typed array length");
      return f.TYPED_ARRAY_SUPPORT ? (t = new Uint8Array(r)).__proto__ = f.prototype : (null === t && (t = new f(r)), t.length = r), t
    }

    function f(t, r, e) {
      if (!(f.TYPED_ARRAY_SUPPORT || this instanceof f)) return new f(t, r, e);
      if ("number" == typeof t) {
        if ("string" == typeof r) throw new Error("If encoding is specified then the first argument must be a string");
        return c(this, t)
      }
      return s(this, t, r, e)
    }

    function s(t, r, e, n) {
      if ("number" == typeof r) throw new TypeError('"value" argument must not be a number');
      return "undefined" != typeof ArrayBuffer && r instanceof ArrayBuffer ? g(t, r, e, n) : "string" == typeof r ? l(t, r, e) : y(t, r)
    }

    function h(t) {
      if ("number" != typeof t) throw new TypeError('"size" argument must be a number');
      if (t < 0) throw new RangeError('"size" argument must not be negative')
    }

    function a(t, r, e, n) {
      return h(r), r <= 0 ? u(t, r) : void 0 !== e ? "string" == typeof n ? u(t, r).fill(e, n) : u(t, r).fill(e) : u(t, r)
    }

    function c(t, r) {
      if (h(r), t = u(t, r < 0 ? 0 : 0 | w(r)), !f.TYPED_ARRAY_SUPPORT)
        for (var e = 0; e < r; ++e) t[e] = 0;
      return t
    }

    function l(t, r, e) {
      if ("string" == typeof e && "" !== e || (e = "utf8"), !f.isEncoding(e)) throw new TypeError('"encoding" must be a valid string encoding');
      var n = 0 | v(r, e),
        i = (t = u(t, n)).write(r, e);
      return i !== n && (t = t.slice(0, i)), t
    }

    function p(t, r) {
      var e = r.length < 0 ? 0 : 0 | w(r.length);
      t = u(t, e);
      for (var n = 0; n < e; n += 1) t[n] = 255 & r[n];
      return t
    }

    function g(t, r, e, n) {
      if (r.byteLength, e < 0 || r.byteLength < e) throw new RangeError("'offset' is out of bounds");
      if (r.byteLength < e + (n || 0)) throw new RangeError("'length' is out of bounds");
      return r = void 0 === e && void 0 === n ? new Uint8Array(r) : void 0 === n ? new Uint8Array(r, e) : new Uint8Array(r, e, n), f.TYPED_ARRAY_SUPPORT ? (t = r).__proto__ = f.prototype : t = p(t, r), t
    }

    function y(t, r) {
      if (f.isBuffer(r)) {
        var e = 0 | w(r.length);
        return 0 === (t = u(t, e)).length ? t : (r.copy(t, 0, 0, e), t)
      }
      if (r) {
        if ("undefined" != typeof ArrayBuffer && r.buffer instanceof ArrayBuffer || "length" in r) return "number" != typeof r.length || W(r.length) ? u(t, 0) : p(t, r);
        if ("Buffer" === r.type && n(r.data)) return p(t, r.data)
      }
      throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.")
    }

    function w(t) {
      if (t >= o()) throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + o().toString(16) + " bytes");
      return 0 | t
    }

    function d(t) {
      return +t != t && (t = 0), f.alloc(+t)
    }

    function v(t, r) {
      if (f.isBuffer(t)) return t.length;
      if ("undefined" != typeof ArrayBuffer && "function" == typeof ArrayBuffer.isView && (ArrayBuffer.isView(t) || t instanceof ArrayBuffer)) return t.byteLength;
      "string" != typeof t && (t = "" + t);
      var e = t.length;
      if (0 === e) return 0;
      for (var n = !1;;) switch (r) {
        case "ascii":
        case "latin1":
        case "binary":
          return e;
        case "utf8":
        case "utf-8":
        case void 0:
          return $(t).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return 2 * e;
        case "hex":
          return e >>> 1;
        case "base64":
          return K(t).length;
        default:
          if (n) return $(t).length;
          r = ("" + r).toLowerCase(), n = !0
      }
    }

    function E(t, r, e) {
      var n = !1;
      if ((void 0 === r || r < 0) && (r = 0), r > this.length) return "";
      if ((void 0 === e || e > this.length) && (e = this.length), e <= 0) return "";
      if ((e >>>= 0) <= (r >>>= 0)) return "";
      for (t || (t = "utf8");;) switch (t) {
        case "hex":
          return x(this, r, e);
        case "utf8":
        case "utf-8":
          return Y(this, r, e);
        case "ascii":
          return L(this, r, e);
        case "latin1":
        case "binary":
          return D(this, r, e);
        case "base64":
          return S(this, r, e);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return C(this, r, e);
        default:
          if (n) throw new TypeError("Unknown encoding: " + t);
          t = (t + "").toLowerCase(), n = !0
      }
    }

    function b(t, r, e) {
      var n = t[r];
      t[r] = t[e], t[e] = n
    }

    function R(t, r, e, n, i) {
      if (0 === t.length) return -1;
      if ("string" == typeof e ? (n = e, e = 0) : e > 2147483647 ? e = 2147483647 : e < -2147483648 && (e = -2147483648), e = +e, isNaN(e) && (e = i ? 0 : t.length - 1), e < 0 && (e = t.length + e), e >= t.length) {
        if (i) return -1;
        e = t.length - 1
      } else if (e < 0) {
        if (!i) return -1;
        e = 0
      }
      if ("string" == typeof r && (r = f.from(r, n)), f.isBuffer(r)) return 0 === r.length ? -1 : _(t, r, e, n, i);
      if ("number" == typeof r) return r &= 255, f.TYPED_ARRAY_SUPPORT && "function" == typeof Uint8Array.prototype.indexOf ? i ? Uint8Array.prototype.indexOf.call(t, r, e) : Uint8Array.prototype.lastIndexOf.call(t, r, e) : _(t, [r], e, n, i);
      throw new TypeError("val must be string, number or Buffer")
    }

    function _(t, r, e, n, i) {
      var o, u = 1,
        f = t.length,
        s = r.length;
      if (void 0 !== n && ("ucs2" === (n = String(n).toLowerCase()) || "ucs-2" === n || "utf16le" === n || "utf-16le" === n)) {
        if (t.length < 2 || r.length < 2) return -1;
        u = 2, f /= 2, s /= 2, e /= 2
      }

      function h(t, r) {
        return 1 === u ? t[r] : t.readUInt16BE(r * u)
      }
      if (i) {
        var a = -1;
        for (o = e; o < f; o++)
          if (h(t, o) === h(r, -1 === a ? 0 : o - a)) {
            if (-1 === a && (a = o), o - a + 1 === s) return a * u
          } else -1 !== a && (o -= o - a), a = -1
      } else
        for (e + s > f && (e = f - s), o = e; o >= 0; o--) {
          for (var c = !0, l = 0; l < s; l++)
            if (h(t, o + l) !== h(r, l)) {
              c = !1;
              break
            } if (c) return o
        }
      return -1
    }

    function A(t, r, e, n) {
      e = Number(e) || 0;
      var i = t.length - e;
      n ? (n = Number(n)) > i && (n = i) : n = i;
      var o = r.length;
      if (o % 2 != 0) throw new TypeError("Invalid hex string");
      n > o / 2 && (n = o / 2);
      for (var u = 0; u < n; ++u) {
        var f = parseInt(r.substr(2 * u, 2), 16);
        if (isNaN(f)) return u;
        t[e + u] = f
      }
      return u
    }

    function m(t, r, e, n) {
      return Q($(r, t.length - e), t, e, n)
    }

    function P(t, r, e, n) {
      return Q(G(r), t, e, n)
    }

    function T(t, r, e, n) {
      return P(t, r, e, n)
    }

    function B(t, r, e, n) {
      return Q(K(r), t, e, n)
    }

    function U(t, r, e, n) {
      return Q(H(r, t.length - e), t, e, n)
    }

    function S(t, e, n) {
      return 0 === e && n === t.length ? r.fromByteArray(t) : r.fromByteArray(t.slice(e, n))
    }

    function Y(t, r, e) {
      e = Math.min(t.length, e);
      for (var n = [], i = r; i < e;) {
        var o, u, f, s, h = t[i],
          a = null,
          c = h > 239 ? 4 : h > 223 ? 3 : h > 191 ? 2 : 1;
        if (i + c <= e) switch (c) {
          case 1:
            h < 128 && (a = h);
            break;
          case 2:
            128 == (192 & (o = t[i + 1])) && (s = (31 & h) << 6 | 63 & o) > 127 && (a = s);
            break;
          case 3:
            o = t[i + 1], u = t[i + 2], 128 == (192 & o) && 128 == (192 & u) && (s = (15 & h) << 12 | (63 & o) << 6 | 63 & u) > 2047 && (s < 55296 || s > 57343) && (a = s);
            break;
          case 4:
            o = t[i + 1], u = t[i + 2], f = t[i + 3], 128 == (192 & o) && 128 == (192 & u) && 128 == (192 & f) && (s = (15 & h) << 18 | (63 & o) << 12 | (63 & u) << 6 | 63 & f) > 65535 && s < 1114112 && (a = s)
        }
        null === a ? (a = 65533, c = 1) : a > 65535 && (a -= 65536, n.push(a >>> 10 & 1023 | 55296), a = 56320 | 1023 & a), n.push(a), i += c
      }
      return O(n)
    }
    exports.Buffer = f, exports.SlowBuffer = d, exports.INSPECT_MAX_BYTES = 50, f.TYPED_ARRAY_SUPPORT = void 0 !== t.TYPED_ARRAY_SUPPORT ? t.TYPED_ARRAY_SUPPORT : i(), exports.kMaxLength = o(), f.poolSize = 8192, f._augment = function(t) {
      return t.__proto__ = f.prototype, t
    }, f.from = function(t, r, e) {
      return s(null, t, r, e)
    }, f.TYPED_ARRAY_SUPPORT && (f.prototype.__proto__ = Uint8Array.prototype, f.__proto__ = Uint8Array, "undefined" != typeof Symbol && Symbol.species && f[Symbol.species] === f && Object.defineProperty(f, Symbol.species, {
      value: null,
      configurable: !0
    })), f.alloc = function(t, r, e) {
      return a(null, t, r, e)
    }, f.allocUnsafe = function(t) {
      return c(null, t)
    }, f.allocUnsafeSlow = function(t) {
      return c(null, t)
    }, f.isBuffer = function(t) {
      return !(null == t || !t._isBuffer)
    }, f.compare = function(t, r) {
      if (!f.isBuffer(t) || !f.isBuffer(r)) throw new TypeError("Arguments must be Buffers");
      if (t === r) return 0;
      for (var e = t.length, n = r.length, i = 0, o = Math.min(e, n); i < o; ++i)
        if (t[i] !== r[i]) {
          e = t[i], n = r[i];
          break
        } return e < n ? -1 : n < e ? 1 : 0
    }, f.isEncoding = function(t) {
      switch (String(t).toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return !0;
        default:
          return !1
      }
    }, f.concat = function(t, r) {
      if (!n(t)) throw new TypeError('"list" argument must be an Array of Buffers');
      if (0 === t.length) return f.alloc(0);
      var e;
      if (void 0 === r)
        for (r = 0, e = 0; e < t.length; ++e) r += t[e].length;
      var i = f.allocUnsafe(r),
        o = 0;
      for (e = 0; e < t.length; ++e) {
        var u = t[e];
        if (!f.isBuffer(u)) throw new TypeError('"list" argument must be an Array of Buffers');
        u.copy(i, o), o += u.length
      }
      return i
    }, f.byteLength = v, f.prototype._isBuffer = !0, f.prototype.swap16 = function() {
      var t = this.length;
      if (t % 2 != 0) throw new RangeError("Buffer size must be a multiple of 16-bits");
      for (var r = 0; r < t; r += 2) b(this, r, r + 1);
      return this
    }, f.prototype.swap32 = function() {
      var t = this.length;
      if (t % 4 != 0) throw new RangeError("Buffer size must be a multiple of 32-bits");
      for (var r = 0; r < t; r += 4) b(this, r, r + 3), b(this, r + 1, r + 2);
      return this
    }, f.prototype.swap64 = function() {
      var t = this.length;
      if (t % 8 != 0) throw new RangeError("Buffer size must be a multiple of 64-bits");
      for (var r = 0; r < t; r += 8) b(this, r, r + 7), b(this, r + 1, r + 6), b(this, r + 2, r + 5), b(this, r + 3, r + 4);
      return this
    }, f.prototype.toString = function() {
      var t = 0 | this.length;
      return 0 === t ? "" : 0 === arguments.length ? Y(this, 0, t) : E.apply(this, arguments)
    }, f.prototype.equals = function(t) {
      if (!f.isBuffer(t)) throw new TypeError("Argument must be a Buffer");
      return this === t || 0 === f.compare(this, t)
    }, f.prototype.inspect = function() {
      var t = "",
        r = exports.INSPECT_MAX_BYTES;
      return this.length > 0 && (t = this.toString("hex", 0, r).match(/.{2}/g).join(" "), this.length > r && (t += " ... ")), "<Buffer " + t + ">"
    }, f.prototype.compare = function(t, r, e, n, i) {
      if (!f.isBuffer(t)) throw new TypeError("Argument must be a Buffer");
      if (void 0 === r && (r = 0), void 0 === e && (e = t ? t.length : 0), void 0 === n && (n = 0), void 0 === i && (i = this.length), r < 0 || e > t.length || n < 0 || i > this.length) throw new RangeError("out of range index");
      if (n >= i && r >= e) return 0;
      if (n >= i) return -1;
      if (r >= e) return 1;
      if (this === t) return 0;
      for (var o = (i >>>= 0) - (n >>>= 0), u = (e >>>= 0) - (r >>>= 0), s = Math.min(o, u), h = this.slice(n, i), a = t.slice(r, e), c = 0; c < s; ++c)
        if (h[c] !== a[c]) {
          o = h[c], u = a[c];
          break
        } return o < u ? -1 : u < o ? 1 : 0
    }, f.prototype.includes = function(t, r, e) {
      return -1 !== this.indexOf(t, r, e)
    }, f.prototype.indexOf = function(t, r, e) {
      return R(this, t, r, e, !0)
    }, f.prototype.lastIndexOf = function(t, r, e) {
      return R(this, t, r, e, !1)
    }, f.prototype.write = function(t, r, e, n) {
      if (void 0 === r) n = "utf8", e = this.length, r = 0;
      else if (void 0 === e && "string" == typeof r) n = r, e = this.length, r = 0;
      else {
        if (!isFinite(r)) throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
        r |= 0, isFinite(e) ? (e |= 0, void 0 === n && (n = "utf8")) : (n = e, e = void 0)
      }
      var i = this.length - r;
      if ((void 0 === e || e > i) && (e = i), t.length > 0 && (e < 0 || r < 0) || r > this.length) throw new RangeError("Attempt to write outside buffer bounds");
      n || (n = "utf8");
      for (var o = !1;;) switch (n) {
        case "hex":
          return A(this, t, r, e);
        case "utf8":
        case "utf-8":
          return m(this, t, r, e);
        case "ascii":
          return P(this, t, r, e);
        case "latin1":
        case "binary":
          return T(this, t, r, e);
        case "base64":
          return B(this, t, r, e);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return U(this, t, r, e);
        default:
          if (o) throw new TypeError("Unknown encoding: " + n);
          n = ("" + n).toLowerCase(), o = !0
      }
    }, f.prototype.toJSON = function() {
      return {
        type: "Buffer",
        data: Array.prototype.slice.call(this._arr || this, 0)
      }
    };
    var I = 4096;

    function O(t) {
      var r = t.length;
      if (r <= I) return String.fromCharCode.apply(String, t);
      for (var e = "", n = 0; n < r;) e += String.fromCharCode.apply(String, t.slice(n, n += I));
      return e
    }

    function L(t, r, e) {
      var n = "";
      e = Math.min(t.length, e);
      for (var i = r; i < e; ++i) n += String.fromCharCode(127 & t[i]);
      return n
    }

    function D(t, r, e) {
      var n = "";
      e = Math.min(t.length, e);
      for (var i = r; i < e; ++i) n += String.fromCharCode(t[i]);
      return n
    }

    function x(t, r, e) {
      var n = t.length;
      (!r || r < 0) && (r = 0), (!e || e < 0 || e > n) && (e = n);
      for (var i = "", o = r; o < e; ++o) i += Z(t[o]);
      return i
    }

    function C(t, r, e) {
      for (var n = t.slice(r, e), i = "", o = 0; o < n.length; o += 2) i += String.fromCharCode(n[o] + 256 * n[o + 1]);
      return i
    }

    function M(t, r, e) {
      if (t % 1 != 0 || t < 0) throw new RangeError("offset is not uint");
      if (t + r > e) throw new RangeError("Trying to access beyond buffer length")
    }

    function k(t, r, e, n, i, o) {
      if (!f.isBuffer(t)) throw new TypeError('"buffer" argument must be a Buffer instance');
      if (r > i || r < o) throw new RangeError('"value" argument is out of bounds');
      if (e + n > t.length) throw new RangeError("Index out of range")
    }

    function N(t, r, e, n) {
      r < 0 && (r = 65535 + r + 1);
      for (var i = 0, o = Math.min(t.length - e, 2); i < o; ++i) t[e + i] = (r & 255 << 8 * (n ? i : 1 - i)) >>> 8 * (n ? i : 1 - i)
    }

    function z(t, r, e, n) {
      r < 0 && (r = 4294967295 + r + 1);
      for (var i = 0, o = Math.min(t.length - e, 4); i < o; ++i) t[e + i] = r >>> 8 * (n ? i : 3 - i) & 255
    }

    function F(t, r, e, n, i, o) {
      if (e + n > t.length) throw new RangeError("Index out of range");
      if (e < 0) throw new RangeError("Index out of range")
    }

    function j(t, r, n, i, o) {
      return o || F(t, r, n, 4, 3.4028234663852886e38, -3.4028234663852886e38), e.write(t, r, n, i, 23, 4), n + 4
    }

    function q(t, r, n, i, o) {
      return o || F(t, r, n, 8, 1.7976931348623157e308, -1.7976931348623157e308), e.write(t, r, n, i, 52, 8), n + 8
    }
    f.prototype.slice = function(t, r) {
      var e, n = this.length;
      if ((t = ~~t) < 0 ? (t += n) < 0 && (t = 0) : t > n && (t = n), (r = void 0 === r ? n : ~~r) < 0 ? (r += n) < 0 && (r = 0) : r > n && (r = n), r < t && (r = t), f.TYPED_ARRAY_SUPPORT)(e = this.subarray(t, r)).__proto__ = f.prototype;
      else {
        var i = r - t;
        e = new f(i, void 0);
        for (var o = 0; o < i; ++o) e[o] = this[o + t]
      }
      return e
    }, f.prototype.readUIntLE = function(t, r, e) {
      t |= 0, r |= 0, e || M(t, r, this.length);
      for (var n = this[t], i = 1, o = 0; ++o < r && (i *= 256);) n += this[t + o] * i;
      return n
    }, f.prototype.readUIntBE = function(t, r, e) {
      t |= 0, r |= 0, e || M(t, r, this.length);
      for (var n = this[t + --r], i = 1; r > 0 && (i *= 256);) n += this[t + --r] * i;
      return n
    }, f.prototype.readUInt8 = function(t, r) {
      return r || M(t, 1, this.length), this[t]
    }, f.prototype.readUInt16LE = function(t, r) {
      return r || M(t, 2, this.length), this[t] | this[t + 1] << 8
    }, f.prototype.readUInt16BE = function(t, r) {
      return r || M(t, 2, this.length), this[t] << 8 | this[t + 1]
    }, f.prototype.readUInt32LE = function(t, r) {
      return r || M(t, 4, this.length), (this[t] | this[t + 1] << 8 | this[t + 2] << 16) + 16777216 * this[t + 3]
    }, f.prototype.readUInt32BE = function(t, r) {
      return r || M(t, 4, this.length), 16777216 * this[t] + (this[t + 1] << 16 | this[t + 2] << 8 | this[t + 3])
    }, f.prototype.readIntLE = function(t, r, e) {
      t |= 0, r |= 0, e || M(t, r, this.length);
      for (var n = this[t], i = 1, o = 0; ++o < r && (i *= 256);) n += this[t + o] * i;
      return n >= (i *= 128) && (n -= Math.pow(2, 8 * r)), n
    }, f.prototype.readIntBE = function(t, r, e) {
      t |= 0, r |= 0, e || M(t, r, this.length);
      for (var n = r, i = 1, o = this[t + --n]; n > 0 && (i *= 256);) o += this[t + --n] * i;
      return o >= (i *= 128) && (o -= Math.pow(2, 8 * r)), o
    }, f.prototype.readInt8 = function(t, r) {
      return r || M(t, 1, this.length), 128 & this[t] ? -1 * (255 - this[t] + 1) : this[t]
    }, f.prototype.readInt16LE = function(t, r) {
      r || M(t, 2, this.length);
      var e = this[t] | this[t + 1] << 8;
      return 32768 & e ? 4294901760 | e : e
    }, f.prototype.readInt16BE = function(t, r) {
      r || M(t, 2, this.length);
      var e = this[t + 1] | this[t] << 8;
      return 32768 & e ? 4294901760 | e : e
    }, f.prototype.readInt32LE = function(t, r) {
      return r || M(t, 4, this.length), this[t] | this[t + 1] << 8 | this[t + 2] << 16 | this[t + 3] << 24
    }, f.prototype.readInt32BE = function(t, r) {
      return r || M(t, 4, this.length), this[t] << 24 | this[t + 1] << 16 | this[t + 2] << 8 | this[t + 3]
    }, f.prototype.readFloatLE = function(t, r) {
      return r || M(t, 4, this.length), e.read(this, t, !0, 23, 4)
    }, f.prototype.readFloatBE = function(t, r) {
      return r || M(t, 4, this.length), e.read(this, t, !1, 23, 4)
    }, f.prototype.readDoubleLE = function(t, r) {
      return r || M(t, 8, this.length), e.read(this, t, !0, 52, 8)
    }, f.prototype.readDoubleBE = function(t, r) {
      return r || M(t, 8, this.length), e.read(this, t, !1, 52, 8)
    }, f.prototype.writeUIntLE = function(t, r, e, n) {
      (t = +t, r |= 0, e |= 0, n) || k(this, t, r, e, Math.pow(2, 8 * e) - 1, 0);
      var i = 1,
        o = 0;
      for (this[r] = 255 & t; ++o < e && (i *= 256);) this[r + o] = t / i & 255;
      return r + e
    }, f.prototype.writeUIntBE = function(t, r, e, n) {
      (t = +t, r |= 0, e |= 0, n) || k(this, t, r, e, Math.pow(2, 8 * e) - 1, 0);
      var i = e - 1,
        o = 1;
      for (this[r + i] = 255 & t; --i >= 0 && (o *= 256);) this[r + i] = t / o & 255;
      return r + e
    }, f.prototype.writeUInt8 = function(t, r, e) {
      return t = +t, r |= 0, e || k(this, t, r, 1, 255, 0), f.TYPED_ARRAY_SUPPORT || (t = Math.floor(t)), this[r] = 255 & t, r + 1
    }, f.prototype.writeUInt16LE = function(t, r, e) {
      return t = +t, r |= 0, e || k(this, t, r, 2, 65535, 0), f.TYPED_ARRAY_SUPPORT ? (this[r] = 255 & t, this[r + 1] = t >>> 8) : N(this, t, r, !0), r + 2
    }, f.prototype.writeUInt16BE = function(t, r, e) {
      return t = +t, r |= 0, e || k(this, t, r, 2, 65535, 0), f.TYPED_ARRAY_SUPPORT ? (this[r] = t >>> 8, this[r + 1] = 255 & t) : N(this, t, r, !1), r + 2
    }, f.prototype.writeUInt32LE = function(t, r, e) {
      return t = +t, r |= 0, e || k(this, t, r, 4, 4294967295, 0), f.TYPED_ARRAY_SUPPORT ? (this[r + 3] = t >>> 24, this[r + 2] = t >>> 16, this[r + 1] = t >>> 8, this[r] = 255 & t) : z(this, t, r, !0), r + 4
    }, f.prototype.writeUInt32BE = function(t, r, e) {
      return t = +t, r |= 0, e || k(this, t, r, 4, 4294967295, 0), f.TYPED_ARRAY_SUPPORT ? (this[r] = t >>> 24, this[r + 1] = t >>> 16, this[r + 2] = t >>> 8, this[r + 3] = 255 & t) : z(this, t, r, !1), r + 4
    }, f.prototype.writeIntLE = function(t, r, e, n) {
      if (t = +t, r |= 0, !n) {
        var i = Math.pow(2, 8 * e - 1);
        k(this, t, r, e, i - 1, -i)
      }
      var o = 0,
        u = 1,
        f = 0;
      for (this[r] = 255 & t; ++o < e && (u *= 256);) t < 0 && 0 === f && 0 !== this[r + o - 1] && (f = 1), this[r + o] = (t / u >> 0) - f & 255;
      return r + e
    }, f.prototype.writeIntBE = function(t, r, e, n) {
      if (t = +t, r |= 0, !n) {
        var i = Math.pow(2, 8 * e - 1);
        k(this, t, r, e, i - 1, -i)
      }
      var o = e - 1,
        u = 1,
        f = 0;
      for (this[r + o] = 255 & t; --o >= 0 && (u *= 256);) t < 0 && 0 === f && 0 !== this[r + o + 1] && (f = 1), this[r + o] = (t / u >> 0) - f & 255;
      return r + e
    }, f.prototype.writeInt8 = function(t, r, e) {
      return t = +t, r |= 0, e || k(this, t, r, 1, 127, -128), f.TYPED_ARRAY_SUPPORT || (t = Math.floor(t)), t < 0 && (t = 255 + t + 1), this[r] = 255 & t, r + 1
    }, f.prototype.writeInt16LE = function(t, r, e) {
      return t = +t, r |= 0, e || k(this, t, r, 2, 32767, -32768), f.TYPED_ARRAY_SUPPORT ? (this[r] = 255 & t, this[r + 1] = t >>> 8) : N(this, t, r, !0), r + 2
    }, f.prototype.writeInt16BE = function(t, r, e) {
      return t = +t, r |= 0, e || k(this, t, r, 2, 32767, -32768), f.TYPED_ARRAY_SUPPORT ? (this[r] = t >>> 8, this[r + 1] = 255 & t) : N(this, t, r, !1), r + 2
    }, f.prototype.writeInt32LE = function(t, r, e) {
      return t = +t, r |= 0, e || k(this, t, r, 4, 2147483647, -2147483648), f.TYPED_ARRAY_SUPPORT ? (this[r] = 255 & t, this[r + 1] = t >>> 8, this[r + 2] = t >>> 16, this[r + 3] = t >>> 24) : z(this, t, r, !0), r + 4
    }, f.prototype.writeInt32BE = function(t, r, e) {
      return t = +t, r |= 0, e || k(this, t, r, 4, 2147483647, -2147483648), t < 0 && (t = 4294967295 + t + 1), f.TYPED_ARRAY_SUPPORT ? (this[r] = t >>> 24, this[r + 1] = t >>> 16, this[r + 2] = t >>> 8, this[r + 3] = 255 & t) : z(this, t, r, !1), r + 4
    }, f.prototype.writeFloatLE = function(t, r, e) {
      return j(this, t, r, !0, e)
    }, f.prototype.writeFloatBE = function(t, r, e) {
      return j(this, t, r, !1, e)
    }, f.prototype.writeDoubleLE = function(t, r, e) {
      return q(this, t, r, !0, e)
    }, f.prototype.writeDoubleBE = function(t, r, e) {
      return q(this, t, r, !1, e)
    }, f.prototype.copy = function(t, r, e, n) {
      if (e || (e = 0), n || 0 === n || (n = this.length), r >= t.length && (r = t.length), r || (r = 0), n > 0 && n < e && (n = e), n === e) return 0;
      if (0 === t.length || 0 === this.length) return 0;
      if (r < 0) throw new RangeError("targetStart out of bounds");
      if (e < 0 || e >= this.length) throw new RangeError("sourceStart out of bounds");
      if (n < 0) throw new RangeError("sourceEnd out of bounds");
      n > this.length && (n = this.length), t.length - r < n - e && (n = t.length - r + e);
      var i, o = n - e;
      if (this === t && e < r && r < n)
        for (i = o - 1; i >= 0; --i) t[i + r] = this[i + e];
      else if (o < 1e3 || !f.TYPED_ARRAY_SUPPORT)
        for (i = 0; i < o; ++i) t[i + r] = this[i + e];
      else Uint8Array.prototype.set.call(t, this.subarray(e, e + o), r);
      return o
    }, f.prototype.fill = function(t, r, e, n) {
      if ("string" == typeof t) {
        if ("string" == typeof r ? (n = r, r = 0, e = this.length) : "string" == typeof e && (n = e, e = this.length), 1 === t.length) {
          var i = t.charCodeAt(0);
          i < 256 && (t = i)
        }
        if (void 0 !== n && "string" != typeof n) throw new TypeError("encoding must be a string");
        if ("string" == typeof n && !f.isEncoding(n)) throw new TypeError("Unknown encoding: " + n)
      } else "number" == typeof t && (t &= 255);
      if (r < 0 || this.length < r || this.length < e) throw new RangeError("Out of range index");
      if (e <= r) return this;
      var o;
      if (r >>>= 0, e = void 0 === e ? this.length : e >>> 0, t || (t = 0), "number" == typeof t)
        for (o = r; o < e; ++o) this[o] = t;
      else {
        var u = f.isBuffer(t) ? t : $(new f(t, n).toString()),
          s = u.length;
        for (o = 0; o < e - r; ++o) this[o + r] = u[o % s]
      }
      return this
    };
    var V = /[^+\/0-9A-Za-z-_]/g;

    function X(t) {
      if ((t = J(t).replace(V, "")).length < 2) return "";
      for (; t.length % 4 != 0;) t += "=";
      return t
    }

    function J(t) {
      return t.trim ? t.trim() : t.replace(/^\s+|\s+$/g, "")
    }

    function Z(t) {
      return t < 16 ? "0" + t.toString(16) : t.toString(16)
    }

    function $(t, r) {
      var e;
      r = r || 1 / 0;
      for (var n = t.length, i = null, o = [], u = 0; u < n; ++u) {
        if ((e = t.charCodeAt(u)) > 55295 && e < 57344) {
          if (!i) {
            if (e > 56319) {
              (r -= 3) > -1 && o.push(239, 191, 189);
              continue
            }
            if (u + 1 === n) {
              (r -= 3) > -1 && o.push(239, 191, 189);
              continue
            }
            i = e;
            continue
          }
          if (e < 56320) {
            (r -= 3) > -1 && o.push(239, 191, 189), i = e;
            continue
          }
          e = 65536 + (i - 55296 << 10 | e - 56320)
        } else i && (r -= 3) > -1 && o.push(239, 191, 189);
        if (i = null, e < 128) {
          if ((r -= 1) < 0) break;
          o.push(e)
        } else if (e < 2048) {
          if ((r -= 2) < 0) break;
          o.push(e >> 6 | 192, 63 & e | 128)
        } else if (e < 65536) {
          if ((r -= 3) < 0) break;
          o.push(e >> 12 | 224, e >> 6 & 63 | 128, 63 & e | 128)
        } else {
          if (!(e < 1114112)) throw new Error("Invalid code point");
          if ((r -= 4) < 0) break;
          o.push(e >> 18 | 240, e >> 12 & 63 | 128, e >> 6 & 63 | 128, 63 & e | 128)
        }
      }
      return o
    }

    function G(t) {
      for (var r = [], e = 0; e < t.length; ++e) r.push(255 & t.charCodeAt(e));
      return r
    }

    function H(t, r) {
      for (var e, n, i, o = [], u = 0; u < t.length && !((r -= 2) < 0); ++u) n = (e = t.charCodeAt(u)) >> 8, i = e % 256, o.push(i), o.push(n);
      return o
    }

    function K(t) {
      return r.toByteArray(X(t))
    }

    function Q(t, r, e, n) {
      for (var i = 0; i < n && !(i + e >= r.length || i >= t.length); ++i) r[i + e] = t[i];
      return i
    }

    function W(t) {
      return t != t
    }
  }, {
    "base64-js": "yh9p",
    "ieee754": "JgNJ",
    "isarray": "REa7",
    "buffer": "dskh"
  }],
  "u1k2": [function(require, module, exports) {
    var Buffer = require("buffer").Buffer;
    var t = require("buffer").Buffer;
    ! function(t, i) {
      "use strict";

      function r(t, i) {
        if (!t) throw new Error(i || "Assertion failed")
      }

      function h(t, i) {
        t.super_ = i;
        var r = function() {};
        r.prototype = i.prototype, t.prototype = new r, t.prototype.constructor = t
      }

      function n(t, i, r) {
        if (n.isBN(t)) return t;
        this.negative = 0, this.words = null, this.length = 0, this.red = null, null !== t && ("le" !== i && "be" !== i || (r = i, i = 10), this._init(t || 0, i || 10, r || "be"))
      }
      var e;
      "object" == typeof t ? t.exports = n : i.BN = n, n.BN = n, n.wordSize = 26;
      try {
        e = require("buffer").Buffer
      } catch (k) {}

      function o(t, i, r) {
        for (var h = 0, n = Math.min(t.length, r), e = i; e < n; e++) {
          var o = t.charCodeAt(e) - 48;
          h <<= 4, h |= o >= 49 && o <= 54 ? o - 49 + 10 : o >= 17 && o <= 22 ? o - 17 + 10 : 15 & o
        }
        return h
      }

      function s(t, i, r, h) {
        for (var n = 0, e = Math.min(t.length, r), o = i; o < e; o++) {
          var s = t.charCodeAt(o) - 48;
          n *= h, n += s >= 49 ? s - 49 + 10 : s >= 17 ? s - 17 + 10 : s
        }
        return n
      }
      n.isBN = function(t) {
        return t instanceof n || null !== t && "object" == typeof t && t.constructor.wordSize === n.wordSize && Array.isArray(t.words)
      }, n.max = function(t, i) {
        return t.cmp(i) > 0 ? t : i
      }, n.min = function(t, i) {
        return t.cmp(i) < 0 ? t : i
      }, n.prototype._init = function(t, i, h) {
        if ("number" == typeof t) return this._initNumber(t, i, h);
        if ("object" == typeof t) return this._initArray(t, i, h);
        "hex" === i && (i = 16), r(i === (0 | i) && i >= 2 && i <= 36);
        var n = 0;
        "-" === (t = t.toString().replace(/\s+/g, ""))[0] && n++, 16 === i ? this._parseHex(t, n) : this._parseBase(t, i, n), "-" === t[0] && (this.negative = 1), this.strip(), "le" === h && this._initArray(this.toArray(), i, h)
      }, n.prototype._initNumber = function(t, i, h) {
        t < 0 && (this.negative = 1, t = -t), t < 67108864 ? (this.words = [67108863 & t], this.length = 1) : t < 4503599627370496 ? (this.words = [67108863 & t, t / 67108864 & 67108863], this.length = 2) : (r(t < 9007199254740992), this.words = [67108863 & t, t / 67108864 & 67108863, 1], this.length = 3), "le" === h && this._initArray(this.toArray(), i, h)
      }, n.prototype._initArray = function(t, i, h) {
        if (r("number" == typeof t.length), t.length <= 0) return this.words = [0], this.length = 1, this;
        this.length = Math.ceil(t.length / 3), this.words = new Array(this.length);
        for (var n = 0; n < this.length; n++) this.words[n] = 0;
        var e, o, s = 0;
        if ("be" === h)
          for (n = t.length - 1, e = 0; n >= 0; n -= 3) o = t[n] | t[n - 1] << 8 | t[n - 2] << 16, this.words[e] |= o << s & 67108863, this.words[e + 1] = o >>> 26 - s & 67108863, (s += 24) >= 26 && (s -= 26, e++);
        else if ("le" === h)
          for (n = 0, e = 0; n < t.length; n += 3) o = t[n] | t[n + 1] << 8 | t[n + 2] << 16, this.words[e] |= o << s & 67108863, this.words[e + 1] = o >>> 26 - s & 67108863, (s += 24) >= 26 && (s -= 26, e++);
        return this.strip()
      }, n.prototype._parseHex = function(t, i) {
        this.length = Math.ceil((t.length - i) / 6), this.words = new Array(this.length);
        for (var r = 0; r < this.length; r++) this.words[r] = 0;
        var h, n, e = 0;
        for (r = t.length - 6, h = 0; r >= i; r -= 6) n = o(t, r, r + 6), this.words[h] |= n << e & 67108863, this.words[h + 1] |= n >>> 26 - e & 4194303, (e += 24) >= 26 && (e -= 26, h++);
        r + 6 !== i && (n = o(t, i, r + 6), this.words[h] |= n << e & 67108863, this.words[h + 1] |= n >>> 26 - e & 4194303), this.strip()
      }, n.prototype._parseBase = function(t, i, r) {
        this.words = [0], this.length = 1;
        for (var h = 0, n = 1; n <= 67108863; n *= i) h++;
        h--, n = n / i | 0;
        for (var e = t.length - r, o = e % h, u = Math.min(e, e - o) + r, a = 0, l = r; l < u; l += h) a = s(t, l, l + h, i), this.imuln(n), this.words[0] + a < 67108864 ? this.words[0] += a : this._iaddn(a);
        if (0 !== o) {
          var m = 1;
          for (a = s(t, l, t.length, i), l = 0; l < o; l++) m *= i;
          this.imuln(m), this.words[0] + a < 67108864 ? this.words[0] += a : this._iaddn(a)
        }
      }, n.prototype.copy = function(t) {
        t.words = new Array(this.length);
        for (var i = 0; i < this.length; i++) t.words[i] = this.words[i];
        t.length = this.length, t.negative = this.negative, t.red = this.red
      }, n.prototype.clone = function() {
        var t = new n(null);
        return this.copy(t), t
      }, n.prototype._expand = function(t) {
        for (; this.length < t;) this.words[this.length++] = 0;
        return this
      }, n.prototype.strip = function() {
        for (; this.length > 1 && 0 === this.words[this.length - 1];) this.length--;
        return this._normSign()
      }, n.prototype._normSign = function() {
        return 1 === this.length && 0 === this.words[0] && (this.negative = 0), this
      }, n.prototype.inspect = function() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">"
      };
      var u = ["", "0", "00", "000", "0000", "00000", "000000", "0000000", "00000000", "000000000", "0000000000", "00000000000", "000000000000", "0000000000000", "00000000000000", "000000000000000", "0000000000000000", "00000000000000000", "000000000000000000", "0000000000000000000", "00000000000000000000", "000000000000000000000", "0000000000000000000000", "00000000000000000000000", "000000000000000000000000", "0000000000000000000000000"],
        a = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5],
        l = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64e6, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 243e5, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176];

      function m(t, i, r) {
        r.negative = i.negative ^ t.negative;
        var h = t.length + i.length | 0;
        r.length = h, h = h - 1 | 0;
        var n = 0 | t.words[0],
          e = 0 | i.words[0],
          o = n * e,
          s = 67108863 & o,
          u = o / 67108864 | 0;
        r.words[0] = s;
        for (var a = 1; a < h; a++) {
          for (var l = u >>> 26, m = 67108863 & u, f = Math.min(a, i.length - 1), d = Math.max(0, a - t.length + 1); d <= f; d++) {
            var p = a - d | 0;
            l += (o = (n = 0 | t.words[p]) * (e = 0 | i.words[d]) + m) / 67108864 | 0, m = 67108863 & o
          }
          r.words[a] = 0 | m, u = 0 | l
        }
        return 0 !== u ? r.words[a] = 0 | u : r.length--, r.strip()
      }
      n.prototype.toString = function(t, i) {
        var h;
        if (i = 0 | i || 1, 16 === (t = t || 10) || "hex" === t) {
          h = "";
          for (var n = 0, e = 0, o = 0; o < this.length; o++) {
            var s = this.words[o],
              m = (16777215 & (s << n | e)).toString(16);
            h = 0 !== (e = s >>> 24 - n & 16777215) || o !== this.length - 1 ? u[6 - m.length] + m + h : m + h, (n += 2) >= 26 && (n -= 26, o--)
          }
          for (0 !== e && (h = e.toString(16) + h); h.length % i != 0;) h = "0" + h;
          return 0 !== this.negative && (h = "-" + h), h
        }
        if (t === (0 | t) && t >= 2 && t <= 36) {
          var f = a[t],
            d = l[t];
          h = "";
          var p = this.clone();
          for (p.negative = 0; !p.isZero();) {
            var M = p.modn(d).toString(t);
            h = (p = p.idivn(d)).isZero() ? M + h : u[f - M.length] + M + h
          }
          for (this.isZero() && (h = "0" + h); h.length % i != 0;) h = "0" + h;
          return 0 !== this.negative && (h = "-" + h), h
        }
        r(!1, "Base should be between 2 and 36")
      }, n.prototype.toNumber = function() {
        var t = this.words[0];
        return 2 === this.length ? t += 67108864 * this.words[1] : 3 === this.length && 1 === this.words[2] ? t += 4503599627370496 + 67108864 * this.words[1] : this.length > 2 && r(!1, "Number can only safely store up to 53 bits"), 0 !== this.negative ? -t : t
      }, n.prototype.toJSON = function() {
        return this.toString(16)
      }, n.prototype.toBuffer = function(t, i) {
        return r(void 0 !== e), this.toArrayLike(e, t, i)
      }, n.prototype.toArray = function(t, i) {
        return this.toArrayLike(Array, t, i)
      }, n.prototype.toArrayLike = function(t, i, h) {
        var n = this.byteLength(),
          e = h || Math.max(1, n);
        r(n <= e, "byte array longer than desired length"), r(e > 0, "Requested array length <= 0"), this.strip();
        var o, s, u = "le" === i,
          a = new t(e),
          l = this.clone();
        if (u) {
          for (s = 0; !l.isZero(); s++) o = l.andln(255), l.iushrn(8), a[s] = o;
          for (; s < e; s++) a[s] = 0
        } else {
          for (s = 0; s < e - n; s++) a[s] = 0;
          for (s = 0; !l.isZero(); s++) o = l.andln(255), l.iushrn(8), a[e - s - 1] = o
        }
        return a
      }, Math.clz32 ? n.prototype._countBits = function(t) {
        return 32 - Math.clz32(t)
      } : n.prototype._countBits = function(t) {
        var i = t,
          r = 0;
        return i >= 4096 && (r += 13, i >>>= 13), i >= 64 && (r += 7, i >>>= 7), i >= 8 && (r += 4, i >>>= 4), i >= 2 && (r += 2, i >>>= 2), r + i
      }, n.prototype._zeroBits = function(t) {
        if (0 === t) return 26;
        var i = t,
          r = 0;
        return 0 == (8191 & i) && (r += 13, i >>>= 13), 0 == (127 & i) && (r += 7, i >>>= 7), 0 == (15 & i) && (r += 4, i >>>= 4), 0 == (3 & i) && (r += 2, i >>>= 2), 0 == (1 & i) && r++, r
      }, n.prototype.bitLength = function() {
        var t = this.words[this.length - 1],
          i = this._countBits(t);
        return 26 * (this.length - 1) + i
      }, n.prototype.zeroBits = function() {
        if (this.isZero()) return 0;
        for (var t = 0, i = 0; i < this.length; i++) {
          var r = this._zeroBits(this.words[i]);
          if (t += r, 26 !== r) break
        }
        return t
      }, n.prototype.byteLength = function() {
        return Math.ceil(this.bitLength() / 8)
      }, n.prototype.toTwos = function(t) {
        return 0 !== this.negative ? this.abs().inotn(t).iaddn(1) : this.clone()
      }, n.prototype.fromTwos = function(t) {
        return this.testn(t - 1) ? this.notn(t).iaddn(1).ineg() : this.clone()
      }, n.prototype.isNeg = function() {
        return 0 !== this.negative
      }, n.prototype.neg = function() {
        return this.clone().ineg()
      }, n.prototype.ineg = function() {
        return this.isZero() || (this.negative ^= 1), this
      }, n.prototype.iuor = function(t) {
        for (; this.length < t.length;) this.words[this.length++] = 0;
        for (var i = 0; i < t.length; i++) this.words[i] = this.words[i] | t.words[i];
        return this.strip()
      }, n.prototype.ior = function(t) {
        return r(0 == (this.negative | t.negative)), this.iuor(t)
      }, n.prototype.or = function(t) {
        return this.length > t.length ? this.clone().ior(t) : t.clone().ior(this)
      }, n.prototype.uor = function(t) {
        return this.length > t.length ? this.clone().iuor(t) : t.clone().iuor(this)
      }, n.prototype.iuand = function(t) {
        var i;
        i = this.length > t.length ? t : this;
        for (var r = 0; r < i.length; r++) this.words[r] = this.words[r] & t.words[r];
        return this.length = i.length, this.strip()
      }, n.prototype.iand = function(t) {
        return r(0 == (this.negative | t.negative)), this.iuand(t)
      }, n.prototype.and = function(t) {
        return this.length > t.length ? this.clone().iand(t) : t.clone().iand(this)
      }, n.prototype.uand = function(t) {
        return this.length > t.length ? this.clone().iuand(t) : t.clone().iuand(this)
      }, n.prototype.iuxor = function(t) {
        var i, r;
        this.length > t.length ? (i = this, r = t) : (i = t, r = this);
        for (var h = 0; h < r.length; h++) this.words[h] = i.words[h] ^ r.words[h];
        if (this !== i)
          for (; h < i.length; h++) this.words[h] = i.words[h];
        return this.length = i.length, this.strip()
      }, n.prototype.ixor = function(t) {
        return r(0 == (this.negative | t.negative)), this.iuxor(t)
      }, n.prototype.xor = function(t) {
        return this.length > t.length ? this.clone().ixor(t) : t.clone().ixor(this)
      }, n.prototype.uxor = function(t) {
        return this.length > t.length ? this.clone().iuxor(t) : t.clone().iuxor(this)
      }, n.prototype.inotn = function(t) {
        r("number" == typeof t && t >= 0);
        var i = 0 | Math.ceil(t / 26),
          h = t % 26;
        this._expand(i), h > 0 && i--;
        for (var n = 0; n < i; n++) this.words[n] = 67108863 & ~this.words[n];
        return h > 0 && (this.words[n] = ~this.words[n] & 67108863 >> 26 - h), this.strip()
      }, n.prototype.notn = function(t) {
        return this.clone().inotn(t)
      }, n.prototype.setn = function(t, i) {
        r("number" == typeof t && t >= 0);
        var h = t / 26 | 0,
          n = t % 26;
        return this._expand(h + 1), this.words[h] = i ? this.words[h] | 1 << n : this.words[h] & ~(1 << n), this.strip()
      }, n.prototype.iadd = function(t) {
        var i, r, h;
        if (0 !== this.negative && 0 === t.negative) return this.negative = 0, i = this.isub(t), this.negative ^= 1, this._normSign();
        if (0 === this.negative && 0 !== t.negative) return t.negative = 0, i = this.isub(t), t.negative = 1, i._normSign();
        this.length > t.length ? (r = this, h = t) : (r = t, h = this);
        for (var n = 0, e = 0; e < h.length; e++) i = (0 | r.words[e]) + (0 | h.words[e]) + n, this.words[e] = 67108863 & i, n = i >>> 26;
        for (; 0 !== n && e < r.length; e++) i = (0 | r.words[e]) + n, this.words[e] = 67108863 & i, n = i >>> 26;
        if (this.length = r.length, 0 !== n) this.words[this.length] = n, this.length++;
        else if (r !== this)
          for (; e < r.length; e++) this.words[e] = r.words[e];
        return this
      }, n.prototype.add = function(t) {
        var i;
        return 0 !== t.negative && 0 === this.negative ? (t.negative = 0, i = this.sub(t), t.negative ^= 1, i) : 0 === t.negative && 0 !== this.negative ? (this.negative = 0, i = t.sub(this), this.negative = 1, i) : this.length > t.length ? this.clone().iadd(t) : t.clone().iadd(this)
      }, n.prototype.isub = function(t) {
        if (0 !== t.negative) {
          t.negative = 0;
          var i = this.iadd(t);
          return t.negative = 1, i._normSign()
        }
        if (0 !== this.negative) return this.negative = 0, this.iadd(t), this.negative = 1, this._normSign();
        var r, h, n = this.cmp(t);
        if (0 === n) return this.negative = 0, this.length = 1, this.words[0] = 0, this;
        n > 0 ? (r = this, h = t) : (r = t, h = this);
        for (var e = 0, o = 0; o < h.length; o++) e = (i = (0 | r.words[o]) - (0 | h.words[o]) + e) >> 26, this.words[o] = 67108863 & i;
        for (; 0 !== e && o < r.length; o++) e = (i = (0 | r.words[o]) + e) >> 26, this.words[o] = 67108863 & i;
        if (0 === e && o < r.length && r !== this)
          for (; o < r.length; o++) this.words[o] = r.words[o];
        return this.length = Math.max(this.length, o), r !== this && (this.negative = 1), this.strip()
      }, n.prototype.sub = function(t) {
        return this.clone().isub(t)
      };
      var f = function(t, i, r) {
        var h, n, e, o = t.words,
          s = i.words,
          u = r.words,
          a = 0,
          l = 0 | o[0],
          m = 8191 & l,
          f = l >>> 13,
          d = 0 | o[1],
          p = 8191 & d,
          M = d >>> 13,
          v = 0 | o[2],
          g = 8191 & v,
          c = v >>> 13,
          w = 0 | o[3],
          y = 8191 & w,
          b = w >>> 13,
          _ = 0 | o[4],
          k = 8191 & _,
          A = _ >>> 13,
          x = 0 | o[5],
          S = 8191 & x,
          q = x >>> 13,
          Z = 0 | o[6],
          B = 8191 & Z,
          R = Z >>> 13,
          N = 0 | o[7],
          L = 8191 & N,
          I = N >>> 13,
          z = 0 | o[8],
          T = 8191 & z,
          E = z >>> 13,
          O = 0 | o[9],
          j = 8191 & O,
          K = O >>> 13,
          P = 0 | s[0],
          F = 8191 & P,
          C = P >>> 13,
          D = 0 | s[1],
          H = 8191 & D,
          J = D >>> 13,
          U = 0 | s[2],
          G = 8191 & U,
          Q = U >>> 13,
          V = 0 | s[3],
          W = 8191 & V,
          X = V >>> 13,
          Y = 0 | s[4],
          $ = 8191 & Y,
          tt = Y >>> 13,
          it = 0 | s[5],
          rt = 8191 & it,
          ht = it >>> 13,
          nt = 0 | s[6],
          et = 8191 & nt,
          ot = nt >>> 13,
          st = 0 | s[7],
          ut = 8191 & st,
          at = st >>> 13,
          lt = 0 | s[8],
          mt = 8191 & lt,
          ft = lt >>> 13,
          dt = 0 | s[9],
          pt = 8191 & dt,
          Mt = dt >>> 13;
        r.negative = t.negative ^ i.negative, r.length = 19;
        var vt = (a + (h = Math.imul(m, F)) | 0) + ((8191 & (n = (n = Math.imul(m, C)) + Math.imul(f, F) | 0)) << 13) | 0;
        a = ((e = Math.imul(f, C)) + (n >>> 13) | 0) + (vt >>> 26) | 0, vt &= 67108863, h = Math.imul(p, F), n = (n = Math.imul(p, C)) + Math.imul(M, F) | 0, e = Math.imul(M, C);
        var gt = (a + (h = h + Math.imul(m, H) | 0) | 0) + ((8191 & (n = (n = n + Math.imul(m, J) | 0) + Math.imul(f, H) | 0)) << 13) | 0;
        a = ((e = e + Math.imul(f, J) | 0) + (n >>> 13) | 0) + (gt >>> 26) | 0, gt &= 67108863, h = Math.imul(g, F), n = (n = Math.imul(g, C)) + Math.imul(c, F) | 0, e = Math.imul(c, C), h = h + Math.imul(p, H) | 0, n = (n = n + Math.imul(p, J) | 0) + Math.imul(M, H) | 0, e = e + Math.imul(M, J) | 0;
        var ct = (a + (h = h + Math.imul(m, G) | 0) | 0) + ((8191 & (n = (n = n + Math.imul(m, Q) | 0) + Math.imul(f, G) | 0)) << 13) | 0;
        a = ((e = e + Math.imul(f, Q) | 0) + (n >>> 13) | 0) + (ct >>> 26) | 0, ct &= 67108863, h = Math.imul(y, F), n = (n = Math.imul(y, C)) + Math.imul(b, F) | 0, e = Math.imul(b, C), h = h + Math.imul(g, H) | 0, n = (n = n + Math.imul(g, J) | 0) + Math.imul(c, H) | 0, e = e + Math.imul(c, J) | 0, h = h + Math.imul(p, G) | 0, n = (n = n + Math.imul(p, Q) | 0) + Math.imul(M, G) | 0, e = e + Math.imul(M, Q) | 0;
        var wt = (a + (h = h + Math.imul(m, W) | 0) | 0) + ((8191 & (n = (n = n + Math.imul(m, X) | 0) + Math.imul(f, W) | 0)) << 13) | 0;
        a = ((e = e + Math.imul(f, X) | 0) + (n >>> 13) | 0) + (wt >>> 26) | 0, wt &= 67108863, h = Math.imul(k, F), n = (n = Math.imul(k, C)) + Math.imul(A, F) | 0, e = Math.imul(A, C), h = h + Math.imul(y, H) | 0, n = (n = n + Math.imul(y, J) | 0) + Math.imul(b, H) | 0, e = e + Math.imul(b, J) | 0, h = h + Math.imul(g, G) | 0, n = (n = n + Math.imul(g, Q) | 0) + Math.imul(c, G) | 0, e = e + Math.imul(c, Q) | 0, h = h + Math.imul(p, W) | 0, n = (n = n + Math.imul(p, X) | 0) + Math.imul(M, W) | 0, e = e + Math.imul(M, X) | 0;
        var yt = (a + (h = h + Math.imul(m, $) | 0) | 0) + ((8191 & (n = (n = n + Math.imul(m, tt) | 0) + Math.imul(f, $) | 0)) << 13) | 0;
        a = ((e = e + Math.imul(f, tt) | 0) + (n >>> 13) | 0) + (yt >>> 26) | 0, yt &= 67108863, h = Math.imul(S, F), n = (n = Math.imul(S, C)) + Math.imul(q, F) | 0, e = Math.imul(q, C), h = h + Math.imul(k, H) | 0, n = (n = n + Math.imul(k, J) | 0) + Math.imul(A, H) | 0, e = e + Math.imul(A, J) | 0, h = h + Math.imul(y, G) | 0, n = (n = n + Math.imul(y, Q) | 0) + Math.imul(b, G) | 0, e = e + Math.imul(b, Q) | 0, h = h + Math.imul(g, W) | 0, n = (n = n + Math.imul(g, X) | 0) + Math.imul(c, W) | 0, e = e + Math.imul(c, X) | 0, h = h + Math.imul(p, $) | 0, n = (n = n + Math.imul(p, tt) | 0) + Math.imul(M, $) | 0, e = e + Math.imul(M, tt) | 0;
        var bt = (a + (h = h + Math.imul(m, rt) | 0) | 0) + ((8191 & (n = (n = n + Math.imul(m, ht) | 0) + Math.imul(f, rt) | 0)) << 13) | 0;
        a = ((e = e + Math.imul(f, ht) | 0) + (n >>> 13) | 0) + (bt >>> 26) | 0, bt &= 67108863, h = Math.imul(B, F), n = (n = Math.imul(B, C)) + Math.imul(R, F) | 0, e = Math.imul(R, C), h = h + Math.imul(S, H) | 0, n = (n = n + Math.imul(S, J) | 0) + Math.imul(q, H) | 0, e = e + Math.imul(q, J) | 0, h = h + Math.imul(k, G) | 0, n = (n = n + Math.imul(k, Q) | 0) + Math.imul(A, G) | 0, e = e + Math.imul(A, Q) | 0, h = h + Math.imul(y, W) | 0, n = (n = n + Math.imul(y, X) | 0) + Math.imul(b, W) | 0, e = e + Math.imul(b, X) | 0, h = h + Math.imul(g, $) | 0, n = (n = n + Math.imul(g, tt) | 0) + Math.imul(c, $) | 0, e = e + Math.imul(c, tt) | 0, h = h + Math.imul(p, rt) | 0, n = (n = n + Math.imul(p, ht) | 0) + Math.imul(M, rt) | 0, e = e + Math.imul(M, ht) | 0;
        var _t = (a + (h = h + Math.imul(m, et) | 0) | 0) + ((8191 & (n = (n = n + Math.imul(m, ot) | 0) + Math.imul(f, et) | 0)) << 13) | 0;
        a = ((e = e + Math.imul(f, ot) | 0) + (n >>> 13) | 0) + (_t >>> 26) | 0, _t &= 67108863, h = Math.imul(L, F), n = (n = Math.imul(L, C)) + Math.imul(I, F) | 0, e = Math.imul(I, C), h = h + Math.imul(B, H) | 0, n = (n = n + Math.imul(B, J) | 0) + Math.imul(R, H) | 0, e = e + Math.imul(R, J) | 0, h = h + Math.imul(S, G) | 0, n = (n = n + Math.imul(S, Q) | 0) + Math.imul(q, G) | 0, e = e + Math.imul(q, Q) | 0, h = h + Math.imul(k, W) | 0, n = (n = n + Math.imul(k, X) | 0) + Math.imul(A, W) | 0, e = e + Math.imul(A, X) | 0, h = h + Math.imul(y, $) | 0, n = (n = n + Math.imul(y, tt) | 0) + Math.imul(b, $) | 0, e = e + Math.imul(b, tt) | 0, h = h + Math.imul(g, rt) | 0, n = (n = n + Math.imul(g, ht) | 0) + Math.imul(c, rt) | 0, e = e + Math.imul(c, ht) | 0, h = h + Math.imul(p, et) | 0, n = (n = n + Math.imul(p, ot) | 0) + Math.imul(M, et) | 0, e = e + Math.imul(M, ot) | 0;
        var kt = (a + (h = h + Math.imul(m, ut) | 0) | 0) + ((8191 & (n = (n = n + Math.imul(m, at) | 0) + Math.imul(f, ut) | 0)) << 13) | 0;
        a = ((e = e + Math.imul(f, at) | 0) + (n >>> 13) | 0) + (kt >>> 26) | 0, kt &= 67108863, h = Math.imul(T, F), n = (n = Math.imul(T, C)) + Math.imul(E, F) | 0, e = Math.imul(E, C), h = h + Math.imul(L, H) | 0, n = (n = n + Math.imul(L, J) | 0) + Math.imul(I, H) | 0, e = e + Math.imul(I, J) | 0, h = h + Math.imul(B, G) | 0, n = (n = n + Math.imul(B, Q) | 0) + Math.imul(R, G) | 0, e = e + Math.imul(R, Q) | 0, h = h + Math.imul(S, W) | 0, n = (n = n + Math.imul(S, X) | 0) + Math.imul(q, W) | 0, e = e + Math.imul(q, X) | 0, h = h + Math.imul(k, $) | 0, n = (n = n + Math.imul(k, tt) | 0) + Math.imul(A, $) | 0, e = e + Math.imul(A, tt) | 0, h = h + Math.imul(y, rt) | 0, n = (n = n + Math.imul(y, ht) | 0) + Math.imul(b, rt) | 0, e = e + Math.imul(b, ht) | 0, h = h + Math.imul(g, et) | 0, n = (n = n + Math.imul(g, ot) | 0) + Math.imul(c, et) | 0, e = e + Math.imul(c, ot) | 0, h = h + Math.imul(p, ut) | 0, n = (n = n + Math.imul(p, at) | 0) + Math.imul(M, ut) | 0, e = e + Math.imul(M, at) | 0;
        var At = (a + (h = h + Math.imul(m, mt) | 0) | 0) + ((8191 & (n = (n = n + Math.imul(m, ft) | 0) + Math.imul(f, mt) | 0)) << 13) | 0;
        a = ((e = e + Math.imul(f, ft) | 0) + (n >>> 13) | 0) + (At >>> 26) | 0, At &= 67108863, h = Math.imul(j, F), n = (n = Math.imul(j, C)) + Math.imul(K, F) | 0, e = Math.imul(K, C), h = h + Math.imul(T, H) | 0, n = (n = n + Math.imul(T, J) | 0) + Math.imul(E, H) | 0, e = e + Math.imul(E, J) | 0, h = h + Math.imul(L, G) | 0, n = (n = n + Math.imul(L, Q) | 0) + Math.imul(I, G) | 0, e = e + Math.imul(I, Q) | 0, h = h + Math.imul(B, W) | 0, n = (n = n + Math.imul(B, X) | 0) + Math.imul(R, W) | 0, e = e + Math.imul(R, X) | 0, h = h + Math.imul(S, $) | 0, n = (n = n + Math.imul(S, tt) | 0) + Math.imul(q, $) | 0, e = e + Math.imul(q, tt) | 0, h = h + Math.imul(k, rt) | 0, n = (n = n + Math.imul(k, ht) | 0) + Math.imul(A, rt) | 0, e = e + Math.imul(A, ht) | 0, h = h + Math.imul(y, et) | 0, n = (n = n + Math.imul(y, ot) | 0) + Math.imul(b, et) | 0, e = e + Math.imul(b, ot) | 0, h = h + Math.imul(g, ut) | 0, n = (n = n + Math.imul(g, at) | 0) + Math.imul(c, ut) | 0, e = e + Math.imul(c, at) | 0, h = h + Math.imul(p, mt) | 0, n = (n = n + Math.imul(p, ft) | 0) + Math.imul(M, mt) | 0, e = e + Math.imul(M, ft) | 0;
        var xt = (a + (h = h + Math.imul(m, pt) | 0) | 0) + ((8191 & (n = (n = n + Math.imul(m, Mt) | 0) + Math.imul(f, pt) | 0)) << 13) | 0;
        a = ((e = e + Math.imul(f, Mt) | 0) + (n >>> 13) | 0) + (xt >>> 26) | 0, xt &= 67108863, h = Math.imul(j, H), n = (n = Math.imul(j, J)) + Math.imul(K, H) | 0, e = Math.imul(K, J), h = h + Math.imul(T, G) | 0, n = (n = n + Math.imul(T, Q) | 0) + Math.imul(E, G) | 0, e = e + Math.imul(E, Q) | 0, h = h + Math.imul(L, W) | 0, n = (n = n + Math.imul(L, X) | 0) + Math.imul(I, W) | 0, e = e + Math.imul(I, X) | 0, h = h + Math.imul(B, $) | 0, n = (n = n + Math.imul(B, tt) | 0) + Math.imul(R, $) | 0, e = e + Math.imul(R, tt) | 0, h = h + Math.imul(S, rt) | 0, n = (n = n + Math.imul(S, ht) | 0) + Math.imul(q, rt) | 0, e = e + Math.imul(q, ht) | 0, h = h + Math.imul(k, et) | 0, n = (n = n + Math.imul(k, ot) | 0) + Math.imul(A, et) | 0, e = e + Math.imul(A, ot) | 0, h = h + Math.imul(y, ut) | 0, n = (n = n + Math.imul(y, at) | 0) + Math.imul(b, ut) | 0, e = e + Math.imul(b, at) | 0, h = h + Math.imul(g, mt) | 0, n = (n = n + Math.imul(g, ft) | 0) + Math.imul(c, mt) | 0, e = e + Math.imul(c, ft) | 0;
        var St = (a + (h = h + Math.imul(p, pt) | 0) | 0) + ((8191 & (n = (n = n + Math.imul(p, Mt) | 0) + Math.imul(M, pt) | 0)) << 13) | 0;
        a = ((e = e + Math.imul(M, Mt) | 0) + (n >>> 13) | 0) + (St >>> 26) | 0, St &= 67108863, h = Math.imul(j, G), n = (n = Math.imul(j, Q)) + Math.imul(K, G) | 0, e = Math.imul(K, Q), h = h + Math.imul(T, W) | 0, n = (n = n + Math.imul(T, X) | 0) + Math.imul(E, W) | 0, e = e + Math.imul(E, X) | 0, h = h + Math.imul(L, $) | 0, n = (n = n + Math.imul(L, tt) | 0) + Math.imul(I, $) | 0, e = e + Math.imul(I, tt) | 0, h = h + Math.imul(B, rt) | 0, n = (n = n + Math.imul(B, ht) | 0) + Math.imul(R, rt) | 0, e = e + Math.imul(R, ht) | 0, h = h + Math.imul(S, et) | 0, n = (n = n + Math.imul(S, ot) | 0) + Math.imul(q, et) | 0, e = e + Math.imul(q, ot) | 0, h = h + Math.imul(k, ut) | 0, n = (n = n + Math.imul(k, at) | 0) + Math.imul(A, ut) | 0, e = e + Math.imul(A, at) | 0, h = h + Math.imul(y, mt) | 0, n = (n = n + Math.imul(y, ft) | 0) + Math.imul(b, mt) | 0, e = e + Math.imul(b, ft) | 0;
        var qt = (a + (h = h + Math.imul(g, pt) | 0) | 0) + ((8191 & (n = (n = n + Math.imul(g, Mt) | 0) + Math.imul(c, pt) | 0)) << 13) | 0;
        a = ((e = e + Math.imul(c, Mt) | 0) + (n >>> 13) | 0) + (qt >>> 26) | 0, qt &= 67108863, h = Math.imul(j, W), n = (n = Math.imul(j, X)) + Math.imul(K, W) | 0, e = Math.imul(K, X), h = h + Math.imul(T, $) | 0, n = (n = n + Math.imul(T, tt) | 0) + Math.imul(E, $) | 0, e = e + Math.imul(E, tt) | 0, h = h + Math.imul(L, rt) | 0, n = (n = n + Math.imul(L, ht) | 0) + Math.imul(I, rt) | 0, e = e + Math.imul(I, ht) | 0, h = h + Math.imul(B, et) | 0, n = (n = n + Math.imul(B, ot) | 0) + Math.imul(R, et) | 0, e = e + Math.imul(R, ot) | 0, h = h + Math.imul(S, ut) | 0, n = (n = n + Math.imul(S, at) | 0) + Math.imul(q, ut) | 0, e = e + Math.imul(q, at) | 0, h = h + Math.imul(k, mt) | 0, n = (n = n + Math.imul(k, ft) | 0) + Math.imul(A, mt) | 0, e = e + Math.imul(A, ft) | 0;
        var Zt = (a + (h = h + Math.imul(y, pt) | 0) | 0) + ((8191 & (n = (n = n + Math.imul(y, Mt) | 0) + Math.imul(b, pt) | 0)) << 13) | 0;
        a = ((e = e + Math.imul(b, Mt) | 0) + (n >>> 13) | 0) + (Zt >>> 26) | 0, Zt &= 67108863, h = Math.imul(j, $), n = (n = Math.imul(j, tt)) + Math.imul(K, $) | 0, e = Math.imul(K, tt), h = h + Math.imul(T, rt) | 0, n = (n = n + Math.imul(T, ht) | 0) + Math.imul(E, rt) | 0, e = e + Math.imul(E, ht) | 0, h = h + Math.imul(L, et) | 0, n = (n = n + Math.imul(L, ot) | 0) + Math.imul(I, et) | 0, e = e + Math.imul(I, ot) | 0, h = h + Math.imul(B, ut) | 0, n = (n = n + Math.imul(B, at) | 0) + Math.imul(R, ut) | 0, e = e + Math.imul(R, at) | 0, h = h + Math.imul(S, mt) | 0, n = (n = n + Math.imul(S, ft) | 0) + Math.imul(q, mt) | 0, e = e + Math.imul(q, ft) | 0;
        var Bt = (a + (h = h + Math.imul(k, pt) | 0) | 0) + ((8191 & (n = (n = n + Math.imul(k, Mt) | 0) + Math.imul(A, pt) | 0)) << 13) | 0;
        a = ((e = e + Math.imul(A, Mt) | 0) + (n >>> 13) | 0) + (Bt >>> 26) | 0, Bt &= 67108863, h = Math.imul(j, rt), n = (n = Math.imul(j, ht)) + Math.imul(K, rt) | 0, e = Math.imul(K, ht), h = h + Math.imul(T, et) | 0, n = (n = n + Math.imul(T, ot) | 0) + Math.imul(E, et) | 0, e = e + Math.imul(E, ot) | 0, h = h + Math.imul(L, ut) | 0, n = (n = n + Math.imul(L, at) | 0) + Math.imul(I, ut) | 0, e = e + Math.imul(I, at) | 0, h = h + Math.imul(B, mt) | 0, n = (n = n + Math.imul(B, ft) | 0) + Math.imul(R, mt) | 0, e = e + Math.imul(R, ft) | 0;
        var Rt = (a + (h = h + Math.imul(S, pt) | 0) | 0) + ((8191 & (n = (n = n + Math.imul(S, Mt) | 0) + Math.imul(q, pt) | 0)) << 13) | 0;
        a = ((e = e + Math.imul(q, Mt) | 0) + (n >>> 13) | 0) + (Rt >>> 26) | 0, Rt &= 67108863, h = Math.imul(j, et), n = (n = Math.imul(j, ot)) + Math.imul(K, et) | 0, e = Math.imul(K, ot), h = h + Math.imul(T, ut) | 0, n = (n = n + Math.imul(T, at) | 0) + Math.imul(E, ut) | 0, e = e + Math.imul(E, at) | 0, h = h + Math.imul(L, mt) | 0, n = (n = n + Math.imul(L, ft) | 0) + Math.imul(I, mt) | 0, e = e + Math.imul(I, ft) | 0;
        var Nt = (a + (h = h + Math.imul(B, pt) | 0) | 0) + ((8191 & (n = (n = n + Math.imul(B, Mt) | 0) + Math.imul(R, pt) | 0)) << 13) | 0;
        a = ((e = e + Math.imul(R, Mt) | 0) + (n >>> 13) | 0) + (Nt >>> 26) | 0, Nt &= 67108863, h = Math.imul(j, ut), n = (n = Math.imul(j, at)) + Math.imul(K, ut) | 0, e = Math.imul(K, at), h = h + Math.imul(T, mt) | 0, n = (n = n + Math.imul(T, ft) | 0) + Math.imul(E, mt) | 0, e = e + Math.imul(E, ft) | 0;
        var Lt = (a + (h = h + Math.imul(L, pt) | 0) | 0) + ((8191 & (n = (n = n + Math.imul(L, Mt) | 0) + Math.imul(I, pt) | 0)) << 13) | 0;
        a = ((e = e + Math.imul(I, Mt) | 0) + (n >>> 13) | 0) + (Lt >>> 26) | 0, Lt &= 67108863, h = Math.imul(j, mt), n = (n = Math.imul(j, ft)) + Math.imul(K, mt) | 0, e = Math.imul(K, ft);
        var It = (a + (h = h + Math.imul(T, pt) | 0) | 0) + ((8191 & (n = (n = n + Math.imul(T, Mt) | 0) + Math.imul(E, pt) | 0)) << 13) | 0;
        a = ((e = e + Math.imul(E, Mt) | 0) + (n >>> 13) | 0) + (It >>> 26) | 0, It &= 67108863;
        var zt = (a + (h = Math.imul(j, pt)) | 0) + ((8191 & (n = (n = Math.imul(j, Mt)) + Math.imul(K, pt) | 0)) << 13) | 0;
        return a = ((e = Math.imul(K, Mt)) + (n >>> 13) | 0) + (zt >>> 26) | 0, zt &= 67108863, u[0] = vt, u[1] = gt, u[2] = ct, u[3] = wt, u[4] = yt, u[5] = bt, u[6] = _t, u[7] = kt, u[8] = At, u[9] = xt, u[10] = St, u[11] = qt, u[12] = Zt, u[13] = Bt, u[14] = Rt, u[15] = Nt, u[16] = Lt, u[17] = It, u[18] = zt, 0 !== a && (u[19] = a, r.length++), r
      };

      function d(t, i, r) {
        return (new p).mulp(t, i, r)
      }

      function p(t, i) {
        this.x = t, this.y = i
      }
      Math.imul || (f = m), n.prototype.mulTo = function(t, i) {
        var r = this.length + t.length;
        return 10 === this.length && 10 === t.length ? f(this, t, i) : r < 63 ? m(this, t, i) : r < 1024 ? function(t, i, r) {
          r.negative = i.negative ^ t.negative, r.length = t.length + i.length;
          for (var h = 0, n = 0, e = 0; e < r.length - 1; e++) {
            var o = n;
            n = 0;
            for (var s = 67108863 & h, u = Math.min(e, i.length - 1), a = Math.max(0, e - t.length + 1); a <= u; a++) {
              var l = e - a,
                m = (0 | t.words[l]) * (0 | i.words[a]),
                f = 67108863 & m;
              s = 67108863 & (f = f + s | 0), n += (o = (o = o + (m / 67108864 | 0) | 0) + (f >>> 26) | 0) >>> 26, o &= 67108863
            }
            r.words[e] = s, h = o, o = n
          }
          return 0 !== h ? r.words[e] = h : r.length--, r.strip()
        }(this, t, i) : d(this, t, i)
      }, p.prototype.makeRBT = function(t) {
        for (var i = new Array(t), r = n.prototype._countBits(t) - 1, h = 0; h < t; h++) i[h] = this.revBin(h, r, t);
        return i
      }, p.prototype.revBin = function(t, i, r) {
        if (0 === t || t === r - 1) return t;
        for (var h = 0, n = 0; n < i; n++) h |= (1 & t) << i - n - 1, t >>= 1;
        return h
      }, p.prototype.permute = function(t, i, r, h, n, e) {
        for (var o = 0; o < e; o++) h[o] = i[t[o]], n[o] = r[t[o]]
      }, p.prototype.transform = function(t, i, r, h, n, e) {
        this.permute(e, t, i, r, h, n);
        for (var o = 1; o < n; o <<= 1)
          for (var s = o << 1, u = Math.cos(2 * Math.PI / s), a = Math.sin(2 * Math.PI / s), l = 0; l < n; l += s)
            for (var m = u, f = a, d = 0; d < o; d++) {
              var p = r[l + d],
                M = h[l + d],
                v = r[l + d + o],
                g = h[l + d + o],
                c = m * v - f * g;
              g = m * g + f * v, v = c, r[l + d] = p + v, h[l + d] = M + g, r[l + d + o] = p - v, h[l + d + o] = M - g, d !== s && (c = u * m - a * f, f = u * f + a * m, m = c)
            }
      }, p.prototype.guessLen13b = function(t, i) {
        var r = 1 | Math.max(i, t),
          h = 1 & r,
          n = 0;
        for (r = r / 2 | 0; r; r >>>= 1) n++;
        return 1 << n + 1 + h
      }, p.prototype.conjugate = function(t, i, r) {
        if (!(r <= 1))
          for (var h = 0; h < r / 2; h++) {
            var n = t[h];
            t[h] = t[r - h - 1], t[r - h - 1] = n, n = i[h], i[h] = -i[r - h - 1], i[r - h - 1] = -n
          }
      }, p.prototype.normalize13b = function(t, i) {
        for (var r = 0, h = 0; h < i / 2; h++) {
          var n = 8192 * Math.round(t[2 * h + 1] / i) + Math.round(t[2 * h] / i) + r;
          t[h] = 67108863 & n, r = n < 67108864 ? 0 : n / 67108864 | 0
        }
        return t
      }, p.prototype.convert13b = function(t, i, h, n) {
        for (var e = 0, o = 0; o < i; o++) e += 0 | t[o], h[2 * o] = 8191 & e, e >>>= 13, h[2 * o + 1] = 8191 & e, e >>>= 13;
        for (o = 2 * i; o < n; ++o) h[o] = 0;
        r(0 === e), r(0 == (-8192 & e))
      }, p.prototype.stub = function(t) {
        for (var i = new Array(t), r = 0; r < t; r++) i[r] = 0;
        return i
      }, p.prototype.mulp = function(t, i, r) {
        var h = 2 * this.guessLen13b(t.length, i.length),
          n = this.makeRBT(h),
          e = this.stub(h),
          o = new Array(h),
          s = new Array(h),
          u = new Array(h),
          a = new Array(h),
          l = new Array(h),
          m = new Array(h),
          f = r.words;
        f.length = h, this.convert13b(t.words, t.length, o, h), this.convert13b(i.words, i.length, a, h), this.transform(o, e, s, u, h, n), this.transform(a, e, l, m, h, n);
        for (var d = 0; d < h; d++) {
          var p = s[d] * l[d] - u[d] * m[d];
          u[d] = s[d] * m[d] + u[d] * l[d], s[d] = p
        }
        return this.conjugate(s, u, h), this.transform(s, u, f, e, h, n), this.conjugate(f, e, h), this.normalize13b(f, h), r.negative = t.negative ^ i.negative, r.length = t.length + i.length, r.strip()
      }, n.prototype.mul = function(t) {
        var i = new n(null);
        return i.words = new Array(this.length + t.length), this.mulTo(t, i)
      }, n.prototype.mulf = function(t) {
        var i = new n(null);
        return i.words = new Array(this.length + t.length), d(this, t, i)
      }, n.prototype.imul = function(t) {
        return this.clone().mulTo(t, this)
      }, n.prototype.imuln = function(t) {
        r("number" == typeof t), r(t < 67108864);
        for (var i = 0, h = 0; h < this.length; h++) {
          var n = (0 | this.words[h]) * t,
            e = (67108863 & n) + (67108863 & i);
          i >>= 26, i += n / 67108864 | 0, i += e >>> 26, this.words[h] = 67108863 & e
        }
        return 0 !== i && (this.words[h] = i, this.length++), this
      }, n.prototype.muln = function(t) {
        return this.clone().imuln(t)
      }, n.prototype.sqr = function() {
        return this.mul(this)
      }, n.prototype.isqr = function() {
        return this.imul(this.clone())
      }, n.prototype.pow = function(t) {
        var i = function(t) {
          for (var i = new Array(t.bitLength()), r = 0; r < i.length; r++) {
            var h = r / 26 | 0,
              n = r % 26;
            i[r] = (t.words[h] & 1 << n) >>> n
          }
          return i
        }(t);
        if (0 === i.length) return new n(1);
        for (var r = this, h = 0; h < i.length && 0 === i[h]; h++, r = r.sqr());
        if (++h < i.length)
          for (var e = r.sqr(); h < i.length; h++, e = e.sqr()) 0 !== i[h] && (r = r.mul(e));
        return r
      }, n.prototype.iushln = function(t) {
        r("number" == typeof t && t >= 0);
        var i, h = t % 26,
          n = (t - h) / 26,
          e = 67108863 >>> 26 - h << 26 - h;
        if (0 !== h) {
          var o = 0;
          for (i = 0; i < this.length; i++) {
            var s = this.words[i] & e,
              u = (0 | this.words[i]) - s << h;
            this.words[i] = u | o, o = s >>> 26 - h
          }
          o && (this.words[i] = o, this.length++)
        }
        if (0 !== n) {
          for (i = this.length - 1; i >= 0; i--) this.words[i + n] = this.words[i];
          for (i = 0; i < n; i++) this.words[i] = 0;
          this.length += n
        }
        return this.strip()
      }, n.prototype.ishln = function(t) {
        return r(0 === this.negative), this.iushln(t)
      }, n.prototype.iushrn = function(t, i, h) {
        var n;
        r("number" == typeof t && t >= 0), n = i ? (i - i % 26) / 26 : 0;
        var e = t % 26,
          o = Math.min((t - e) / 26, this.length),
          s = 67108863 ^ 67108863 >>> e << e,
          u = h;
        if (n -= o, n = Math.max(0, n), u) {
          for (var a = 0; a < o; a++) u.words[a] = this.words[a];
          u.length = o
        }
        if (0 === o);
        else if (this.length > o)
          for (this.length -= o, a = 0; a < this.length; a++) this.words[a] = this.words[a + o];
        else this.words[0] = 0, this.length = 1;
        var l = 0;
        for (a = this.length - 1; a >= 0 && (0 !== l || a >= n); a--) {
          var m = 0 | this.words[a];
          this.words[a] = l << 26 - e | m >>> e, l = m & s
        }
        return u && 0 !== l && (u.words[u.length++] = l), 0 === this.length && (this.words[0] = 0, this.length = 1), this.strip()
      }, n.prototype.ishrn = function(t, i, h) {
        return r(0 === this.negative), this.iushrn(t, i, h)
      }, n.prototype.shln = function(t) {
        return this.clone().ishln(t)
      }, n.prototype.ushln = function(t) {
        return this.clone().iushln(t)
      }, n.prototype.shrn = function(t) {
        return this.clone().ishrn(t)
      }, n.prototype.ushrn = function(t) {
        return this.clone().iushrn(t)
      }, n.prototype.testn = function(t) {
        r("number" == typeof t && t >= 0);
        var i = t % 26,
          h = (t - i) / 26,
          n = 1 << i;
        return !(this.length <= h) && !!(this.words[h] & n)
      }, n.prototype.imaskn = function(t) {
        r("number" == typeof t && t >= 0);
        var i = t % 26,
          h = (t - i) / 26;
        if (r(0 === this.negative, "imaskn works only with positive numbers"), this.length <= h) return this;
        if (0 !== i && h++, this.length = Math.min(h, this.length), 0 !== i) {
          var n = 67108863 ^ 67108863 >>> i << i;
          this.words[this.length - 1] &= n
        }
        return this.strip()
      }, n.prototype.maskn = function(t) {
        return this.clone().imaskn(t)
      }, n.prototype.iaddn = function(t) {
        return r("number" == typeof t), r(t < 67108864), t < 0 ? this.isubn(-t) : 0 !== this.negative ? 1 === this.length && (0 | this.words[0]) < t ? (this.words[0] = t - (0 | this.words[0]), this.negative = 0, this) : (this.negative = 0, this.isubn(t), this.negative = 1, this) : this._iaddn(t)
      }, n.prototype._iaddn = function(t) {
        this.words[0] += t;
        for (var i = 0; i < this.length && this.words[i] >= 67108864; i++) this.words[i] -= 67108864, i === this.length - 1 ? this.words[i + 1] = 1 : this.words[i + 1]++;
        return this.length = Math.max(this.length, i + 1), this
      }, n.prototype.isubn = function(t) {
        if (r("number" == typeof t), r(t < 67108864), t < 0) return this.iaddn(-t);
        if (0 !== this.negative) return this.negative = 0, this.iaddn(t), this.negative = 1, this;
        if (this.words[0] -= t, 1 === this.length && this.words[0] < 0) this.words[0] = -this.words[0], this.negative = 1;
        else
          for (var i = 0; i < this.length && this.words[i] < 0; i++) this.words[i] += 67108864, this.words[i + 1] -= 1;
        return this.strip()
      }, n.prototype.addn = function(t) {
        return this.clone().iaddn(t)
      }, n.prototype.subn = function(t) {
        return this.clone().isubn(t)
      }, n.prototype.iabs = function() {
        return this.negative = 0, this
      }, n.prototype.abs = function() {
        return this.clone().iabs()
      }, n.prototype._ishlnsubmul = function(t, i, h) {
        var n, e, o = t.length + h;
        this._expand(o);
        var s = 0;
        for (n = 0; n < t.length; n++) {
          e = (0 | this.words[n + h]) + s;
          var u = (0 | t.words[n]) * i;
          s = ((e -= 67108863 & u) >> 26) - (u / 67108864 | 0), this.words[n + h] = 67108863 & e
        }
        for (; n < this.length - h; n++) s = (e = (0 | this.words[n + h]) + s) >> 26, this.words[n + h] = 67108863 & e;
        if (0 === s) return this.strip();
        for (r(-1 === s), s = 0, n = 0; n < this.length; n++) s = (e = -(0 | this.words[n]) + s) >> 26, this.words[n] = 67108863 & e;
        return this.negative = 1, this.strip()
      }, n.prototype._wordDiv = function(t, i) {
        var r = (this.length, t.length),
          h = this.clone(),
          e = t,
          o = 0 | e.words[e.length - 1];
        0 !== (r = 26 - this._countBits(o)) && (e = e.ushln(r), h.iushln(r), o = 0 | e.words[e.length - 1]);
        var s, u = h.length - e.length;
        if ("mod" !== i) {
          (s = new n(null)).length = u + 1, s.words = new Array(s.length);
          for (var a = 0; a < s.length; a++) s.words[a] = 0
        }
        var l = h.clone()._ishlnsubmul(e, 1, u);
        0 === l.negative && (h = l, s && (s.words[u] = 1));
        for (var m = u - 1; m >= 0; m--) {
          var f = 67108864 * (0 | h.words[e.length + m]) + (0 | h.words[e.length + m - 1]);
          for (f = Math.min(f / o | 0, 67108863), h._ishlnsubmul(e, f, m); 0 !== h.negative;) f--, h.negative = 0, h._ishlnsubmul(e, 1, m), h.isZero() || (h.negative ^= 1);
          s && (s.words[m] = f)
        }
        return s && s.strip(), h.strip(), "div" !== i && 0 !== r && h.iushrn(r), {
          div: s || null,
          mod: h
        }
      }, n.prototype.divmod = function(t, i, h) {
        return r(!t.isZero()), this.isZero() ? {
          div: new n(0),
          mod: new n(0)
        } : 0 !== this.negative && 0 === t.negative ? (s = this.neg().divmod(t, i), "mod" !== i && (e = s.div.neg()), "div" !== i && (o = s.mod.neg(), h && 0 !== o.negative && o.iadd(t)), {
          div: e,
          mod: o
        }) : 0 === this.negative && 0 !== t.negative ? (s = this.divmod(t.neg(), i), "mod" !== i && (e = s.div.neg()), {
          div: e,
          mod: s.mod
        }) : 0 != (this.negative & t.negative) ? (s = this.neg().divmod(t.neg(), i), "div" !== i && (o = s.mod.neg(), h && 0 !== o.negative && o.isub(t)), {
          div: s.div,
          mod: o
        }) : t.length > this.length || this.cmp(t) < 0 ? {
          div: new n(0),
          mod: this
        } : 1 === t.length ? "div" === i ? {
          div: this.divn(t.words[0]),
          mod: null
        } : "mod" === i ? {
          div: null,
          mod: new n(this.modn(t.words[0]))
        } : {
          div: this.divn(t.words[0]),
          mod: new n(this.modn(t.words[0]))
        } : this._wordDiv(t, i);
        var e, o, s
      }, n.prototype.div = function(t) {
        return this.divmod(t, "div", !1).div
      }, n.prototype.mod = function(t) {
        return this.divmod(t, "mod", !1).mod
      }, n.prototype.umod = function(t) {
        return this.divmod(t, "mod", !0).mod
      }, n.prototype.divRound = function(t) {
        var i = this.divmod(t);
        if (i.mod.isZero()) return i.div;
        var r = 0 !== i.div.negative ? i.mod.isub(t) : i.mod,
          h = t.ushrn(1),
          n = t.andln(1),
          e = r.cmp(h);
        return e < 0 || 1 === n && 0 === e ? i.div : 0 !== i.div.negative ? i.div.isubn(1) : i.div.iaddn(1)
      }, n.prototype.modn = function(t) {
        r(t <= 67108863);
        for (var i = (1 << 26) % t, h = 0, n = this.length - 1; n >= 0; n--) h = (i * h + (0 | this.words[n])) % t;
        return h
      }, n.prototype.idivn = function(t) {
        r(t <= 67108863);
        for (var i = 0, h = this.length - 1; h >= 0; h--) {
          var n = (0 | this.words[h]) + 67108864 * i;
          this.words[h] = n / t | 0, i = n % t
        }
        return this.strip()
      }, n.prototype.divn = function(t) {
        return this.clone().idivn(t)
      }, n.prototype.egcd = function(t) {
        r(0 === t.negative), r(!t.isZero());
        var i = this,
          h = t.clone();
        i = 0 !== i.negative ? i.umod(t) : i.clone();
        for (var e = new n(1), o = new n(0), s = new n(0), u = new n(1), a = 0; i.isEven() && h.isEven();) i.iushrn(1), h.iushrn(1), ++a;
        for (var l = h.clone(), m = i.clone(); !i.isZero();) {
          for (var f = 0, d = 1; 0 == (i.words[0] & d) && f < 26; ++f, d <<= 1);
          if (f > 0)
            for (i.iushrn(f); f-- > 0;)(e.isOdd() || o.isOdd()) && (e.iadd(l), o.isub(m)), e.iushrn(1), o.iushrn(1);
          for (var p = 0, M = 1; 0 == (h.words[0] & M) && p < 26; ++p, M <<= 1);
          if (p > 0)
            for (h.iushrn(p); p-- > 0;)(s.isOdd() || u.isOdd()) && (s.iadd(l), u.isub(m)), s.iushrn(1), u.iushrn(1);
          i.cmp(h) >= 0 ? (i.isub(h), e.isub(s), o.isub(u)) : (h.isub(i), s.isub(e), u.isub(o))
        }
        return {
          a: s,
          b: u,
          gcd: h.iushln(a)
        }
      }, n.prototype._invmp = function(t) {
        r(0 === t.negative), r(!t.isZero());
        var i = this,
          h = t.clone();
        i = 0 !== i.negative ? i.umod(t) : i.clone();
        for (var e, o = new n(1), s = new n(0), u = h.clone(); i.cmpn(1) > 0 && h.cmpn(1) > 0;) {
          for (var a = 0, l = 1; 0 == (i.words[0] & l) && a < 26; ++a, l <<= 1);
          if (a > 0)
            for (i.iushrn(a); a-- > 0;) o.isOdd() && o.iadd(u), o.iushrn(1);
          for (var m = 0, f = 1; 0 == (h.words[0] & f) && m < 26; ++m, f <<= 1);
          if (m > 0)
            for (h.iushrn(m); m-- > 0;) s.isOdd() && s.iadd(u), s.iushrn(1);
          i.cmp(h) >= 0 ? (i.isub(h), o.isub(s)) : (h.isub(i), s.isub(o))
        }
        return (e = 0 === i.cmpn(1) ? o : s).cmpn(0) < 0 && e.iadd(t), e
      }, n.prototype.gcd = function(t) {
        if (this.isZero()) return t.abs();
        if (t.isZero()) return this.abs();
        var i = this.clone(),
          r = t.clone();
        i.negative = 0, r.negative = 0;
        for (var h = 0; i.isEven() && r.isEven(); h++) i.iushrn(1), r.iushrn(1);
        for (;;) {
          for (; i.isEven();) i.iushrn(1);
          for (; r.isEven();) r.iushrn(1);
          var n = i.cmp(r);
          if (n < 0) {
            var e = i;
            i = r, r = e
          } else if (0 === n || 0 === r.cmpn(1)) break;
          i.isub(r)
        }
        return r.iushln(h)
      }, n.prototype.invm = function(t) {
        return this.egcd(t).a.umod(t)
      }, n.prototype.isEven = function() {
        return 0 == (1 & this.words[0])
      }, n.prototype.isOdd = function() {
        return 1 == (1 & this.words[0])
      }, n.prototype.andln = function(t) {
        return this.words[0] & t
      }, n.prototype.bincn = function(t) {
        r("number" == typeof t);
        var i = t % 26,
          h = (t - i) / 26,
          n = 1 << i;
        if (this.length <= h) return this._expand(h + 1), this.words[h] |= n, this;
        for (var e = n, o = h; 0 !== e && o < this.length; o++) {
          var s = 0 | this.words[o];
          e = (s += e) >>> 26, s &= 67108863, this.words[o] = s
        }
        return 0 !== e && (this.words[o] = e, this.length++), this
      }, n.prototype.isZero = function() {
        return 1 === this.length && 0 === this.words[0]
      }, n.prototype.cmpn = function(t) {
        var i, h = t < 0;
        if (0 !== this.negative && !h) return -1;
        if (0 === this.negative && h) return 1;
        if (this.strip(), this.length > 1) i = 1;
        else {
          h && (t = -t), r(t <= 67108863, "Number is too big");
          var n = 0 | this.words[0];
          i = n === t ? 0 : n < t ? -1 : 1
        }
        return 0 !== this.negative ? 0 | -i : i
      }, n.prototype.cmp = function(t) {
        if (0 !== this.negative && 0 === t.negative) return -1;
        if (0 === this.negative && 0 !== t.negative) return 1;
        var i = this.ucmp(t);
        return 0 !== this.negative ? 0 | -i : i
      }, n.prototype.ucmp = function(t) {
        if (this.length > t.length) return 1;
        if (this.length < t.length) return -1;
        for (var i = 0, r = this.length - 1; r >= 0; r--) {
          var h = 0 | this.words[r],
            n = 0 | t.words[r];
          if (h !== n) {
            h < n ? i = -1 : h > n && (i = 1);
            break
          }
        }
        return i
      }, n.prototype.gtn = function(t) {
        return 1 === this.cmpn(t)
      }, n.prototype.gt = function(t) {
        return 1 === this.cmp(t)
      }, n.prototype.gten = function(t) {
        return this.cmpn(t) >= 0
      }, n.prototype.gte = function(t) {
        return this.cmp(t) >= 0
      }, n.prototype.ltn = function(t) {
        return -1 === this.cmpn(t)
      }, n.prototype.lt = function(t) {
        return -1 === this.cmp(t)
      }, n.prototype.lten = function(t) {
        return this.cmpn(t) <= 0
      }, n.prototype.lte = function(t) {
        return this.cmp(t) <= 0
      }, n.prototype.eqn = function(t) {
        return 0 === this.cmpn(t)
      }, n.prototype.eq = function(t) {
        return 0 === this.cmp(t)
      }, n.red = function(t) {
        return new b(t)
      }, n.prototype.toRed = function(t) {
        return r(!this.red, "Already a number in reduction context"), r(0 === this.negative, "red works only with positives"), t.convertTo(this)._forceRed(t)
      }, n.prototype.fromRed = function() {
        return r(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this)
      }, n.prototype._forceRed = function(t) {
        return this.red = t, this
      }, n.prototype.forceRed = function(t) {
        return r(!this.red, "Already a number in reduction context"), this._forceRed(t)
      }, n.prototype.redAdd = function(t) {
        return r(this.red, "redAdd works only with red numbers"), this.red.add(this, t)
      }, n.prototype.redIAdd = function(t) {
        return r(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, t)
      }, n.prototype.redSub = function(t) {
        return r(this.red, "redSub works only with red numbers"), this.red.sub(this, t)
      }, n.prototype.redISub = function(t) {
        return r(this.red, "redISub works only with red numbers"), this.red.isub(this, t)
      }, n.prototype.redShl = function(t) {
        return r(this.red, "redShl works only with red numbers"), this.red.shl(this, t)
      }, n.prototype.redMul = function(t) {
        return r(this.red, "redMul works only with red numbers"), this.red._verify2(this, t), this.red.mul(this, t)
      }, n.prototype.redIMul = function(t) {
        return r(this.red, "redMul works only with red numbers"), this.red._verify2(this, t), this.red.imul(this, t)
      }, n.prototype.redSqr = function() {
        return r(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this)
      }, n.prototype.redISqr = function() {
        return r(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this)
      }, n.prototype.redSqrt = function() {
        return r(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this)
      }, n.prototype.redInvm = function() {
        return r(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this)
      }, n.prototype.redNeg = function() {
        return r(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this)
      }, n.prototype.redPow = function(t) {
        return r(this.red && !t.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, t)
      };
      var M = {
        k256: null,
        p224: null,
        p192: null,
        p25519: null
      };

      function v(t, i) {
        this.name = t, this.p = new n(i, 16), this.n = this.p.bitLength(), this.k = new n(1).iushln(this.n).isub(this.p), this.tmp = this._tmp()
      }

      function g() {
        v.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f")
      }

      function c() {
        v.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001")
      }

      function w() {
        v.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff")
      }

      function y() {
        v.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed")
      }

      function b(t) {
        if ("string" == typeof t) {
          var i = n._prime(t);
          this.m = i.p, this.prime = i
        } else r(t.gtn(1), "modulus must be greater than 1"), this.m = t, this.prime = null
      }

      function _(t) {
        b.call(this, t), this.shift = this.m.bitLength(), this.shift % 26 != 0 && (this.shift += 26 - this.shift % 26), this.r = new n(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv)
      }
      v.prototype._tmp = function() {
        var t = new n(null);
        return t.words = new Array(Math.ceil(this.n / 13)), t
      }, v.prototype.ireduce = function(t) {
        var i, r = t;
        do {
          this.split(r, this.tmp), i = (r = (r = this.imulK(r)).iadd(this.tmp)).bitLength()
        } while (i > this.n);
        var h = i < this.n ? -1 : r.ucmp(this.p);
        return 0 === h ? (r.words[0] = 0, r.length = 1) : h > 0 ? r.isub(this.p) : r.strip(), r
      }, v.prototype.split = function(t, i) {
        t.iushrn(this.n, 0, i)
      }, v.prototype.imulK = function(t) {
        return t.imul(this.k)
      }, h(g, v), g.prototype.split = function(t, i) {
        for (var r = Math.min(t.length, 9), h = 0; h < r; h++) i.words[h] = t.words[h];
        if (i.length = r, t.length <= 9) return t.words[0] = 0, void(t.length = 1);
        var n = t.words[9];
        for (i.words[i.length++] = 4194303 & n, h = 10; h < t.length; h++) {
          var e = 0 | t.words[h];
          t.words[h - 10] = (4194303 & e) << 4 | n >>> 22, n = e
        }
        n >>>= 22, t.words[h - 10] = n, 0 === n && t.length > 10 ? t.length -= 10 : t.length -= 9
      }, g.prototype.imulK = function(t) {
        t.words[t.length] = 0, t.words[t.length + 1] = 0, t.length += 2;
        for (var i = 0, r = 0; r < t.length; r++) {
          var h = 0 | t.words[r];
          i += 977 * h, t.words[r] = 67108863 & i, i = 64 * h + (i / 67108864 | 0)
        }
        return 0 === t.words[t.length - 1] && (t.length--, 0 === t.words[t.length - 1] && t.length--), t
      }, h(c, v), h(w, v), h(y, v), y.prototype.imulK = function(t) {
        for (var i = 0, r = 0; r < t.length; r++) {
          var h = 19 * (0 | t.words[r]) + i,
            n = 67108863 & h;
          h >>>= 26, t.words[r] = n, i = h
        }
        return 0 !== i && (t.words[t.length++] = i), t
      }, n._prime = function(t) {
        if (M[t]) return M[t];
        var i;
        if ("k256" === t) i = new g;
        else if ("p224" === t) i = new c;
        else if ("p192" === t) i = new w;
        else {
          if ("p25519" !== t) throw new Error("Unknown prime " + t);
          i = new y
        }
        return M[t] = i, i
      }, b.prototype._verify1 = function(t) {
        r(0 === t.negative, "red works only with positives"), r(t.red, "red works only with red numbers")
      }, b.prototype._verify2 = function(t, i) {
        r(0 == (t.negative | i.negative), "red works only with positives"), r(t.red && t.red === i.red, "red works only with red numbers")
      }, b.prototype.imod = function(t) {
        return this.prime ? this.prime.ireduce(t)._forceRed(this) : t.umod(this.m)._forceRed(this)
      }, b.prototype.neg = function(t) {
        return t.isZero() ? t.clone() : this.m.sub(t)._forceRed(this)
      }, b.prototype.add = function(t, i) {
        this._verify2(t, i);
        var r = t.add(i);
        return r.cmp(this.m) >= 0 && r.isub(this.m), r._forceRed(this)
      }, b.prototype.iadd = function(t, i) {
        this._verify2(t, i);
        var r = t.iadd(i);
        return r.cmp(this.m) >= 0 && r.isub(this.m), r
      }, b.prototype.sub = function(t, i) {
        this._verify2(t, i);
        var r = t.sub(i);
        return r.cmpn(0) < 0 && r.iadd(this.m), r._forceRed(this)
      }, b.prototype.isub = function(t, i) {
        this._verify2(t, i);
        var r = t.isub(i);
        return r.cmpn(0) < 0 && r.iadd(this.m), r
      }, b.prototype.shl = function(t, i) {
        return this._verify1(t), this.imod(t.ushln(i))
      }, b.prototype.imul = function(t, i) {
        return this._verify2(t, i), this.imod(t.imul(i))
      }, b.prototype.mul = function(t, i) {
        return this._verify2(t, i), this.imod(t.mul(i))
      }, b.prototype.isqr = function(t) {
        return this.imul(t, t.clone())
      }, b.prototype.sqr = function(t) {
        return this.mul(t, t)
      }, b.prototype.sqrt = function(t) {
        if (t.isZero()) return t.clone();
        var i = this.m.andln(3);
        if (r(i % 2 == 1), 3 === i) {
          var h = this.m.add(new n(1)).iushrn(2);
          return this.pow(t, h)
        }
        for (var e = this.m.subn(1), o = 0; !e.isZero() && 0 === e.andln(1);) o++, e.iushrn(1);
        r(!e.isZero());
        var s = new n(1).toRed(this),
          u = s.redNeg(),
          a = this.m.subn(1).iushrn(1),
          l = this.m.bitLength();
        for (l = new n(2 * l * l).toRed(this); 0 !== this.pow(l, a).cmp(u);) l.redIAdd(u);
        for (var m = this.pow(l, e), f = this.pow(t, e.addn(1).iushrn(1)), d = this.pow(t, e), p = o; 0 !== d.cmp(s);) {
          for (var M = d, v = 0; 0 !== M.cmp(s); v++) M = M.redSqr();
          r(v < p);
          var g = this.pow(m, new n(1).iushln(p - v - 1));
          f = f.redMul(g), m = g.redSqr(), d = d.redMul(m), p = v
        }
        return f
      }, b.prototype.invm = function(t) {
        var i = t._invmp(this.m);
        return 0 !== i.negative ? (i.negative = 0, this.imod(i).redNeg()) : this.imod(i)
      }, b.prototype.pow = function(t, i) {
        if (i.isZero()) return new n(1);
        if (0 === i.cmpn(1)) return t.clone();
        var r = new Array(16);
        r[0] = new n(1).toRed(this), r[1] = t;
        for (var h = 2; h < r.length; h++) r[h] = this.mul(r[h - 1], t);
        var e = r[0],
          o = 0,
          s = 0,
          u = i.bitLength() % 26;
        for (0 === u && (u = 26), h = i.length - 1; h >= 0; h--) {
          for (var a = i.words[h], l = u - 1; l >= 0; l--) {
            var m = a >> l & 1;
            e !== r[0] && (e = this.sqr(e)), 0 !== m || 0 !== o ? (o <<= 1, o |= m, (4 === ++s || 0 === h && 0 === l) && (e = this.mul(e, r[o]), s = 0, o = 0)) : s = 0
          }
          u = 26
        }
        return e
      }, b.prototype.convertTo = function(t) {
        var i = t.umod(this.m);
        return i === t ? i.clone() : i
      }, b.prototype.convertFrom = function(t) {
        var i = t.clone();
        return i.red = null, i
      }, n.mont = function(t) {
        return new _(t)
      }, h(_, b), _.prototype.convertTo = function(t) {
        return this.imod(t.ushln(this.shift))
      }, _.prototype.convertFrom = function(t) {
        var i = this.imod(t.mul(this.rinv));
        return i.red = null, i
      }, _.prototype.imul = function(t, i) {
        if (t.isZero() || i.isZero()) return t.words[0] = 0, t.length = 1, t;
        var r = t.imul(i),
          h = r.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m),
          n = r.isub(h).iushrn(this.shift),
          e = n;
        return n.cmp(this.m) >= 0 ? e = n.isub(this.m) : n.cmpn(0) < 0 && (e = n.iadd(this.m)), e._forceRed(this)
      }, _.prototype.mul = function(t, i) {
        if (t.isZero() || i.isZero()) return new n(0)._forceRed(this);
        var r = t.mul(i),
          h = r.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m),
          e = r.isub(h).iushrn(this.shift),
          o = e;
        return e.cmp(this.m) >= 0 ? o = e.isub(this.m) : e.cmpn(0) < 0 && (o = e.iadd(this.m)), o._forceRed(this)
      }, _.prototype.invm = function(t) {
        return this.imod(t._invmp(this.m).mul(this.r2))._forceRed(this)
      }
    }("undefined" == typeof module || module, this);
  }, {
    "buffer": "dskh"
  }],
  "xMCX": [function(require, module, exports) {
    function t(e) {
      return (t = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t) {
        return typeof t
      } : function(t) {
        return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
      })(e)
    }
    module.exports = function(e) {
      if ("string" != typeof e) throw new Error("[is-hex-prefixed] value must be type 'string', is currently type " + t(e) + ", while checking isHexPrefixed.");
      return "0x" === e.slice(0, 2)
    };
  }, {}],
  "kqPR": [function(require, module, exports) {
    var e = require("is-hex-prefixed");
    module.exports = function(r) {
      return "string" != typeof r ? r : e(r) ? r.slice(2) : r
    };
  }, {
    "is-hex-prefixed": "xMCX"
  }],
  "EEAC": [function(require, module, exports) {
    function t(e) {
      return (t = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t) {
        return typeof t
      } : function(t) {
        return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
      })(e)
    }
    var e = require("bn.js"),
      r = require("strip-hex-prefix");
    module.exports = function(n) {
      if ("string" == typeof n || "number" == typeof n) {
        var o = new e(1),
          i = String(n).toLowerCase().trim(),
          u = "0x" === i.substr(0, 2) || "-0x" === i.substr(0, 3),
          m = r(i);
        if ("-" === m.substr(0, 1) && (m = r(m.slice(1)), o = new e(-1, 10)), !(m = "" === m ? "0" : m).match(/^-?[0-9]+$/) && m.match(/^[0-9A-Fa-f]+$/) || m.match(/^[a-fA-F]+$/) || !0 === u && m.match(/^[0-9A-Fa-f]+$/)) return new e(m, 16).mul(o);
        if ((m.match(/^-?[0-9]+$/) || "" === m) && !1 === u) return new e(m, 10).mul(o)
      } else if ("object" === t(n) && n.toString && !n.pop && !n.push && n.toString(10).match(/^-?[0-9]+$/) && (n.mul || n.dividedToIntegerBy)) return new e(n.toString(10), 10);
      throw new Error("[number-to-bn] while converting number " + JSON.stringify(n) + " to BN.js instance, error: invalid number value. Value must be an integer, hex string, BN or BigNumber instance. Note, decimals are not supported.")
    };
  }, {
    "bn.js": "u1k2",
    "strip-hex-prefix": "kqPR"
  }],
  "QU2j": [function(require, module, exports) {
    "use strict";

    function e(t) {
      return (e = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
        return typeof e
      } : function(e) {
        return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
      })(t)
    }
    var t = require("bn.js"),
      r = require("number-to-bn"),
      n = new t(0),
      o = new t(-1),
      i = {
        noether: "0",
        wei: "1",
        kwei: "1000",
        Kwei: "1000",
        babbage: "1000",
        femtoether: "1000",
        mwei: "1000000",
        Mwei: "1000000",
        lovelace: "1000000",
        picoether: "1000000",
        gwei: "1000000000",
        Gwei: "1000000000",
        shannon: "1000000000",
        nanoether: "1000000000",
        nano: "1000000000",
        szabo: "1000000000000",
        microether: "1000000000000",
        micro: "1000000000000",
        finney: "1000000000000000",
        milliether: "1000000000000000",
        milli: "1000000000000000",
        ether: "1000000000000000000",
        kether: "1000000000000000000000",
        grand: "1000000000000000000000",
        mether: "1000000000000000000000000",
        gether: "1000000000000000000000000000",
        tether: "1000000000000000000000000000000"
      };

    function u(e) {
      var r = e ? e.toLowerCase() : "ether",
        n = i[r];
      if ("string" != typeof n) throw new Error("[ethjs-unit] the unit provided " + e + " doesn't exists, please use the one of the following units " + JSON.stringify(i, null, 2));
      return new t(n, 10)
    }

    function l(t) {
      if ("string" == typeof t) {
        if (!t.match(/^-?[0-9.]+$/)) throw new Error("while converting number to string, invalid number value '" + t + "', should be a number matching (^-?[0-9.]+).");
        return t
      }
      if ("number" == typeof t) return String(t);
      if ("object" === e(t) && t.toString && (t.toTwos || t.dividedToIntegerBy)) return t.toPrecision ? String(t.toPrecision()) : t.toString(10);
      throw new Error("while converting number to string, invalid number value '" + t + "' type " + e(t) + ".")
    }

    function a(e, t, l) {
      var a = r(e),
        h = a.lt(n),
        m = u(t),
        s = i[t].length - 1 || 1,
        w = l || {};
      h && (a = a.mul(o));
      for (var f = a.mod(m).toString(10); f.length < s;) f = "0" + f;
      w.pad || (f = f.match(/^([0-9]*[1-9]|0)(0*)/)[1]);
      var g = a.div(m).toString(10);
      w.commify && (g = g.replace(/\B(?=(\d{3})+(?!\d))/g, ","));
      var c = g + ("0" == f ? "" : "." + f);
      return h && (c = "-" + c), c
    }

    function h(e, r) {
      var n = l(e),
        a = u(r),
        h = i[r].length - 1 || 1,
        m = "-" === n.substring(0, 1);
      if (m && (n = n.substring(1)), "." === n) throw new Error("[ethjs-unit] while converting number " + e + " to wei, invalid value");
      var s = n.split(".");
      if (s.length > 2) throw new Error("[ethjs-unit] while converting number " + e + " to wei,  too many decimal points");
      var w = s[0],
        f = s[1];
      if (w || (w = "0"), f || (f = "0"), f.length > h) throw new Error("[ethjs-unit] while converting number " + e + " to wei, too many decimal places");
      for (; f.length < h;) f += "0";
      w = new t(w), f = new t(f);
      var g = w.mul(a).add(f);
      return m && (g = g.mul(o)), new t(g.toString(10), 10)
    }
    module.exports = {
      unitMap: i,
      numberToString: l,
      getValueOfUnit: u,
      fromWei: a,
      toWei: h
    };
  }, {
    "bn.js": "u1k2",
    "number-to-bn": "EEAC"
  }],
  "rDCW": [function(require, module, exports) {

  }, {}],
  "AGD1": [function(require, module, exports) {
    var Buffer = require("buffer").Buffer;
    var t = require("buffer").Buffer;
    ! function(t, i) {
      "use strict";

      function r(t, i) {
        if (!t) throw new Error(i || "Assertion failed")
      }

      function n(t, i) {
        t.super_ = i;
        var r = function() {};
        r.prototype = i.prototype, t.prototype = new r, t.prototype.constructor = t
      }

      function h(t, i, r) {
        if (h.isBN(t)) return t;
        this.negative = 0, this.words = null, this.length = 0, this.red = null, null !== t && ("le" !== i && "be" !== i || (r = i, i = 10), this._init(t || 0, i || 10, r || "be"))
      }
      var e;
      "object" == typeof t ? t.exports = h : i.BN = h, h.BN = h, h.wordSize = 26;
      try {
        e = "undefined" != typeof window && void 0 !== window.Buffer ? window.Buffer : require("buffer").Buffer
      } catch (A) {}

      function o(t, i) {
        var r = t.charCodeAt(i);
        return r >= 65 && r <= 70 ? r - 55 : r >= 97 && r <= 102 ? r - 87 : r - 48 & 15
      }

      function s(t, i, r) {
        var n = o(t, r);
        return r - 1 >= i && (n |= o(t, r - 1) << 4), n
      }

      function u(t, i, r, n) {
        for (var h = 0, e = Math.min(t.length, r), o = i; o < e; o++) {
          var s = t.charCodeAt(o) - 48;
          h *= n, h += s >= 49 ? s - 49 + 10 : s >= 17 ? s - 17 + 10 : s
        }
        return h
      }
      h.isBN = function(t) {
        return t instanceof h || null !== t && "object" == typeof t && t.constructor.wordSize === h.wordSize && Array.isArray(t.words)
      }, h.max = function(t, i) {
        return t.cmp(i) > 0 ? t : i
      }, h.min = function(t, i) {
        return t.cmp(i) < 0 ? t : i
      }, h.prototype._init = function(t, i, n) {
        if ("number" == typeof t) return this._initNumber(t, i, n);
        if ("object" == typeof t) return this._initArray(t, i, n);
        "hex" === i && (i = 16), r(i === (0 | i) && i >= 2 && i <= 36);
        var h = 0;
        "-" === (t = t.toString().replace(/\s+/g, ""))[0] && (h++, this.negative = 1), h < t.length && (16 === i ? this._parseHex(t, h, n) : (this._parseBase(t, i, h), "le" === n && this._initArray(this.toArray(), i, n)))
      }, h.prototype._initNumber = function(t, i, n) {
        t < 0 && (this.negative = 1, t = -t), t < 67108864 ? (this.words = [67108863 & t], this.length = 1) : t < 4503599627370496 ? (this.words = [67108863 & t, t / 67108864 & 67108863], this.length = 2) : (r(t < 9007199254740992), this.words = [67108863 & t, t / 67108864 & 67108863, 1], this.length = 3), "le" === n && this._initArray(this.toArray(), i, n)
      }, h.prototype._initArray = function(t, i, n) {
        if (r("number" == typeof t.length), t.length <= 0) return this.words = [0], this.length = 1, this;
        this.length = Math.ceil(t.length / 3), this.words = new Array(this.length);
        for (var h = 0; h < this.length; h++) this.words[h] = 0;
        var e, o, s = 0;
        if ("be" === n)
          for (h = t.length - 1, e = 0; h >= 0; h -= 3) o = t[h] | t[h - 1] << 8 | t[h - 2] << 16, this.words[e] |= o << s & 67108863, this.words[e + 1] = o >>> 26 - s & 67108863, (s += 24) >= 26 && (s -= 26, e++);
        else if ("le" === n)
          for (h = 0, e = 0; h < t.length; h += 3) o = t[h] | t[h + 1] << 8 | t[h + 2] << 16, this.words[e] |= o << s & 67108863, this.words[e + 1] = o >>> 26 - s & 67108863, (s += 24) >= 26 && (s -= 26, e++);
        return this.strip()
      }, h.prototype._parseHex = function(t, i, r) {
        this.length = Math.ceil((t.length - i) / 6), this.words = new Array(this.length);
        for (var n = 0; n < this.length; n++) this.words[n] = 0;
        var h, e = 0,
          o = 0;
        if ("be" === r)
          for (n = t.length - 1; n >= i; n -= 2) h = s(t, i, n) << e, this.words[o] |= 67108863 & h, e >= 18 ? (e -= 18, o += 1, this.words[o] |= h >>> 26) : e += 8;
        else
          for (n = (t.length - i) % 2 == 0 ? i + 1 : i; n < t.length; n += 2) h = s(t, i, n) << e, this.words[o] |= 67108863 & h, e >= 18 ? (e -= 18, o += 1, this.words[o] |= h >>> 26) : e += 8;
        this.strip()
      }, h.prototype._parseBase = function(t, i, r) {
        this.words = [0], this.length = 1;
        for (var n = 0, h = 1; h <= 67108863; h *= i) n++;
        n--, h = h / i | 0;
        for (var e = t.length - r, o = e % n, s = Math.min(e, e - o) + r, a = 0, l = r; l < s; l += n) a = u(t, l, l + n, i), this.imuln(h), this.words[0] + a < 67108864 ? this.words[0] += a : this._iaddn(a);
        if (0 !== o) {
          var m = 1;
          for (a = u(t, l, t.length, i), l = 0; l < o; l++) m *= i;
          this.imuln(m), this.words[0] + a < 67108864 ? this.words[0] += a : this._iaddn(a)
        }
        this.strip()
      }, h.prototype.copy = function(t) {
        t.words = new Array(this.length);
        for (var i = 0; i < this.length; i++) t.words[i] = this.words[i];
        t.length = this.length, t.negative = this.negative, t.red = this.red
      }, h.prototype.clone = function() {
        var t = new h(null);
        return this.copy(t), t
      }, h.prototype._expand = function(t) {
        for (; this.length < t;) this.words[this.length++] = 0;
        return this
      }, h.prototype.strip = function() {
        for (; this.length > 1 && 0 === this.words[this.length - 1];) this.length--;
        return this._normSign()
      }, h.prototype._normSign = function() {
        return 1 === this.length && 0 === this.words[0] && (this.negative = 0), this
      }, h.prototype.inspect = function() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">"
      };
      var a = ["", "0", "00", "000", "0000", "00000", "000000", "0000000", "00000000", "000000000", "0000000000", "00000000000", "000000000000", "0000000000000", "00000000000000", "000000000000000", "0000000000000000", "00000000000000000", "000000000000000000", "0000000000000000000", "00000000000000000000", "000000000000000000000", "0000000000000000000000", "00000000000000000000000", "000000000000000000000000", "0000000000000000000000000"],
        l = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5],
        m = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64e6, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 243e5, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176];

      function f(t, i, r) {
        r.negative = i.negative ^ t.negative;
        var n = t.length + i.length | 0;
        r.length = n, n = n - 1 | 0;
        var h = 0 | t.words[0],
          e = 0 | i.words[0],
          o = h * e,
          s = 67108863 & o,
          u = o / 67108864 | 0;
        r.words[0] = s;
        for (var a = 1; a < n; a++) {
          for (var l = u >>> 26, m = 67108863 & u, f = Math.min(a, i.length - 1), d = Math.max(0, a - t.length + 1); d <= f; d++) {
            var p = a - d | 0;
            l += (o = (h = 0 | t.words[p]) * (e = 0 | i.words[d]) + m) / 67108864 | 0, m = 67108863 & o
          }
          r.words[a] = 0 | m, u = 0 | l
        }
        return 0 !== u ? r.words[a] = 0 | u : r.length--, r.strip()
      }
      h.prototype.toString = function(t, i) {
        var n;
        if (i = 0 | i || 1, 16 === (t = t || 10) || "hex" === t) {
          n = "";
          for (var h = 0, e = 0, o = 0; o < this.length; o++) {
            var s = this.words[o],
              u = (16777215 & (s << h | e)).toString(16);
            n = 0 !== (e = s >>> 24 - h & 16777215) || o !== this.length - 1 ? a[6 - u.length] + u + n : u + n, (h += 2) >= 26 && (h -= 26, o--)
          }
          for (0 !== e && (n = e.toString(16) + n); n.length % i != 0;) n = "0" + n;
          return 0 !== this.negative && (n = "-" + n), n
        }
        if (t === (0 | t) && t >= 2 && t <= 36) {
          var f = l[t],
            d = m[t];
          n = "";
          var p = this.clone();
          for (p.negative = 0; !p.isZero();) {
            var M = p.modn(d).toString(t);
            n = (p = p.idivn(d)).isZero() ? M + n : a[f - M.length] + M + n
          }
          for (this.isZero() && (n = "0" + n); n.length % i != 0;) n = "0" + n;
          return 0 !== this.negative && (n = "-" + n), n
        }
        r(!1, "Base should be between 2 and 36")
      }, h.prototype.toNumber = function() {
        var t = this.words[0];
        return 2 === this.length ? t += 67108864 * this.words[1] : 3 === this.length && 1 === this.words[2] ? t += 4503599627370496 + 67108864 * this.words[1] : this.length > 2 && r(!1, "Number can only safely store up to 53 bits"), 0 !== this.negative ? -t : t
      }, h.prototype.toJSON = function() {
        return this.toString(16)
      }, h.prototype.toBuffer = function(t, i) {
        return r(void 0 !== e), this.toArrayLike(e, t, i)
      }, h.prototype.toArray = function(t, i) {
        return this.toArrayLike(Array, t, i)
      }, h.prototype.toArrayLike = function(t, i, n) {
        var h = this.byteLength(),
          e = n || Math.max(1, h);
        r(h <= e, "byte array longer than desired length"), r(e > 0, "Requested array length <= 0"), this.strip();
        var o, s, u = "le" === i,
          a = new t(e),
          l = this.clone();
        if (u) {
          for (s = 0; !l.isZero(); s++) o = l.andln(255), l.iushrn(8), a[s] = o;
          for (; s < e; s++) a[s] = 0
        } else {
          for (s = 0; s < e - h; s++) a[s] = 0;
          for (s = 0; !l.isZero(); s++) o = l.andln(255), l.iushrn(8), a[e - s - 1] = o
        }
        return a
      }, Math.clz32 ? h.prototype._countBits = function(t) {
        return 32 - Math.clz32(t)
      } : h.prototype._countBits = function(t) {
        var i = t,
          r = 0;
        return i >= 4096 && (r += 13, i >>>= 13), i >= 64 && (r += 7, i >>>= 7), i >= 8 && (r += 4, i >>>= 4), i >= 2 && (r += 2, i >>>= 2), r + i
      }, h.prototype._zeroBits = function(t) {
        if (0 === t) return 26;
        var i = t,
          r = 0;
        return 0 == (8191 & i) && (r += 13, i >>>= 13), 0 == (127 & i) && (r += 7, i >>>= 7), 0 == (15 & i) && (r += 4, i >>>= 4), 0 == (3 & i) && (r += 2, i >>>= 2), 0 == (1 & i) && r++, r
      }, h.prototype.bitLength = function() {
        var t = this.words[this.length - 1],
          i = this._countBits(t);
        return 26 * (this.length - 1) + i
      }, h.prototype.zeroBits = function() {
        if (this.isZero()) return 0;
        for (var t = 0, i = 0; i < this.length; i++) {
          var r = this._zeroBits(this.words[i]);
          if (t += r, 26 !== r) break
        }
        return t
      }, h.prototype.byteLength = function() {
        return Math.ceil(this.bitLength() / 8)
      }, h.prototype.toTwos = function(t) {
        return 0 !== this.negative ? this.abs().inotn(t).iaddn(1) : this.clone()
      }, h.prototype.fromTwos = function(t) {
        return this.testn(t - 1) ? this.notn(t).iaddn(1).ineg() : this.clone()
      }, h.prototype.isNeg = function() {
        return 0 !== this.negative
      }, h.prototype.neg = function() {
        return this.clone().ineg()
      }, h.prototype.ineg = function() {
        return this.isZero() || (this.negative ^= 1), this
      }, h.prototype.iuor = function(t) {
        for (; this.length < t.length;) this.words[this.length++] = 0;
        for (var i = 0; i < t.length; i++) this.words[i] = this.words[i] | t.words[i];
        return this.strip()
      }, h.prototype.ior = function(t) {
        return r(0 == (this.negative | t.negative)), this.iuor(t)
      }, h.prototype.or = function(t) {
        return this.length > t.length ? this.clone().ior(t) : t.clone().ior(this)
      }, h.prototype.uor = function(t) {
        return this.length > t.length ? this.clone().iuor(t) : t.clone().iuor(this)
      }, h.prototype.iuand = function(t) {
        var i;
        i = this.length > t.length ? t : this;
        for (var r = 0; r < i.length; r++) this.words[r] = this.words[r] & t.words[r];
        return this.length = i.length, this.strip()
      }, h.prototype.iand = function(t) {
        return r(0 == (this.negative | t.negative)), this.iuand(t)
      }, h.prototype.and = function(t) {
        return this.length > t.length ? this.clone().iand(t) : t.clone().iand(this)
      }, h.prototype.uand = function(t) {
        return this.length > t.length ? this.clone().iuand(t) : t.clone().iuand(this)
      }, h.prototype.iuxor = function(t) {
        var i, r;
        this.length > t.length ? (i = this, r = t) : (i = t, r = this);
        for (var n = 0; n < r.length; n++) this.words[n] = i.words[n] ^ r.words[n];
        if (this !== i)
          for (; n < i.length; n++) this.words[n] = i.words[n];
        return this.length = i.length, this.strip()
      }, h.prototype.ixor = function(t) {
        return r(0 == (this.negative | t.negative)), this.iuxor(t)
      }, h.prototype.xor = function(t) {
        return this.length > t.length ? this.clone().ixor(t) : t.clone().ixor(this)
      }, h.prototype.uxor = function(t) {
        return this.length > t.length ? this.clone().iuxor(t) : t.clone().iuxor(this)
      }, h.prototype.inotn = function(t) {
        r("number" == typeof t && t >= 0);
        var i = 0 | Math.ceil(t / 26),
          n = t % 26;
        this._expand(i), n > 0 && i--;
        for (var h = 0; h < i; h++) this.words[h] = 67108863 & ~this.words[h];
        return n > 0 && (this.words[h] = ~this.words[h] & 67108863 >> 26 - n), this.strip()
      }, h.prototype.notn = function(t) {
        return this.clone().inotn(t)
      }, h.prototype.setn = function(t, i) {
        r("number" == typeof t && t >= 0);
        var n = t / 26 | 0,
          h = t % 26;
        return this._expand(n + 1), this.words[n] = i ? this.words[n] | 1 << h : this.words[n] & ~(1 << h), this.strip()
      }, h.prototype.iadd = function(t) {
        var i, r, n;
        if (0 !== this.negative && 0 === t.negative) return this.negative = 0, i = this.isub(t), this.negative ^= 1, this._normSign();
        if (0 === this.negative && 0 !== t.negative) return t.negative = 0, i = this.isub(t), t.negative = 1, i._normSign();
        this.length > t.length ? (r = this, n = t) : (r = t, n = this);
        for (var h = 0, e = 0; e < n.length; e++) i = (0 | r.words[e]) + (0 | n.words[e]) + h, this.words[e] = 67108863 & i, h = i >>> 26;
        for (; 0 !== h && e < r.length; e++) i = (0 | r.words[e]) + h, this.words[e] = 67108863 & i, h = i >>> 26;
        if (this.length = r.length, 0 !== h) this.words[this.length] = h, this.length++;
        else if (r !== this)
          for (; e < r.length; e++) this.words[e] = r.words[e];
        return this
      }, h.prototype.add = function(t) {
        var i;
        return 0 !== t.negative && 0 === this.negative ? (t.negative = 0, i = this.sub(t), t.negative ^= 1, i) : 0 === t.negative && 0 !== this.negative ? (this.negative = 0, i = t.sub(this), this.negative = 1, i) : this.length > t.length ? this.clone().iadd(t) : t.clone().iadd(this)
      }, h.prototype.isub = function(t) {
        if (0 !== t.negative) {
          t.negative = 0;
          var i = this.iadd(t);
          return t.negative = 1, i._normSign()
        }
        if (0 !== this.negative) return this.negative = 0, this.iadd(t), this.negative = 1, this._normSign();
        var r, n, h = this.cmp(t);
        if (0 === h) return this.negative = 0, this.length = 1, this.words[0] = 0, this;
        h > 0 ? (r = this, n = t) : (r = t, n = this);
        for (var e = 0, o = 0; o < n.length; o++) e = (i = (0 | r.words[o]) - (0 | n.words[o]) + e) >> 26, this.words[o] = 67108863 & i;
        for (; 0 !== e && o < r.length; o++) e = (i = (0 | r.words[o]) + e) >> 26, this.words[o] = 67108863 & i;
        if (0 === e && o < r.length && r !== this)
          for (; o < r.length; o++) this.words[o] = r.words[o];
        return this.length = Math.max(this.length, o), r !== this && (this.negative = 1), this.strip()
      }, h.prototype.sub = function(t) {
        return this.clone().isub(t)
      };
      var d = function(t, i, r) {
        var n, h, e, o = t.words,
          s = i.words,
          u = r.words,
          a = 0,
          l = 0 | o[0],
          m = 8191 & l,
          f = l >>> 13,
          d = 0 | o[1],
          p = 8191 & d,
          M = d >>> 13,
          v = 0 | o[2],
          g = 8191 & v,
          c = v >>> 13,
          w = 0 | o[3],
          y = 8191 & w,
          b = w >>> 13,
          _ = 0 | o[4],
          k = 8191 & _,
          A = _ >>> 13,
          x = 0 | o[5],
          S = 8191 & x,
          q = x >>> 13,
          B = 0 | o[6],
          Z = 8191 & B,
          R = B >>> 13,
          N = 0 | o[7],
          L = 8191 & N,
          I = N >>> 13,
          z = 0 | o[8],
          T = 8191 & z,
          E = z >>> 13,
          O = 0 | o[9],
          j = 8191 & O,
          K = O >>> 13,
          P = 0 | s[0],
          F = 8191 & P,
          C = P >>> 13,
          D = 0 | s[1],
          H = 8191 & D,
          J = D >>> 13,
          U = 0 | s[2],
          G = 8191 & U,
          Q = U >>> 13,
          V = 0 | s[3],
          W = 8191 & V,
          X = V >>> 13,
          Y = 0 | s[4],
          $ = 8191 & Y,
          tt = Y >>> 13,
          it = 0 | s[5],
          rt = 8191 & it,
          nt = it >>> 13,
          ht = 0 | s[6],
          et = 8191 & ht,
          ot = ht >>> 13,
          st = 0 | s[7],
          ut = 8191 & st,
          at = st >>> 13,
          lt = 0 | s[8],
          mt = 8191 & lt,
          ft = lt >>> 13,
          dt = 0 | s[9],
          pt = 8191 & dt,
          Mt = dt >>> 13;
        r.negative = t.negative ^ i.negative, r.length = 19;
        var vt = (a + (n = Math.imul(m, F)) | 0) + ((8191 & (h = (h = Math.imul(m, C)) + Math.imul(f, F) | 0)) << 13) | 0;
        a = ((e = Math.imul(f, C)) + (h >>> 13) | 0) + (vt >>> 26) | 0, vt &= 67108863, n = Math.imul(p, F), h = (h = Math.imul(p, C)) + Math.imul(M, F) | 0, e = Math.imul(M, C);
        var gt = (a + (n = n + Math.imul(m, H) | 0) | 0) + ((8191 & (h = (h = h + Math.imul(m, J) | 0) + Math.imul(f, H) | 0)) << 13) | 0;
        a = ((e = e + Math.imul(f, J) | 0) + (h >>> 13) | 0) + (gt >>> 26) | 0, gt &= 67108863, n = Math.imul(g, F), h = (h = Math.imul(g, C)) + Math.imul(c, F) | 0, e = Math.imul(c, C), n = n + Math.imul(p, H) | 0, h = (h = h + Math.imul(p, J) | 0) + Math.imul(M, H) | 0, e = e + Math.imul(M, J) | 0;
        var ct = (a + (n = n + Math.imul(m, G) | 0) | 0) + ((8191 & (h = (h = h + Math.imul(m, Q) | 0) + Math.imul(f, G) | 0)) << 13) | 0;
        a = ((e = e + Math.imul(f, Q) | 0) + (h >>> 13) | 0) + (ct >>> 26) | 0, ct &= 67108863, n = Math.imul(y, F), h = (h = Math.imul(y, C)) + Math.imul(b, F) | 0, e = Math.imul(b, C), n = n + Math.imul(g, H) | 0, h = (h = h + Math.imul(g, J) | 0) + Math.imul(c, H) | 0, e = e + Math.imul(c, J) | 0, n = n + Math.imul(p, G) | 0, h = (h = h + Math.imul(p, Q) | 0) + Math.imul(M, G) | 0, e = e + Math.imul(M, Q) | 0;
        var wt = (a + (n = n + Math.imul(m, W) | 0) | 0) + ((8191 & (h = (h = h + Math.imul(m, X) | 0) + Math.imul(f, W) | 0)) << 13) | 0;
        a = ((e = e + Math.imul(f, X) | 0) + (h >>> 13) | 0) + (wt >>> 26) | 0, wt &= 67108863, n = Math.imul(k, F), h = (h = Math.imul(k, C)) + Math.imul(A, F) | 0, e = Math.imul(A, C), n = n + Math.imul(y, H) | 0, h = (h = h + Math.imul(y, J) | 0) + Math.imul(b, H) | 0, e = e + Math.imul(b, J) | 0, n = n + Math.imul(g, G) | 0, h = (h = h + Math.imul(g, Q) | 0) + Math.imul(c, G) | 0, e = e + Math.imul(c, Q) | 0, n = n + Math.imul(p, W) | 0, h = (h = h + Math.imul(p, X) | 0) + Math.imul(M, W) | 0, e = e + Math.imul(M, X) | 0;
        var yt = (a + (n = n + Math.imul(m, $) | 0) | 0) + ((8191 & (h = (h = h + Math.imul(m, tt) | 0) + Math.imul(f, $) | 0)) << 13) | 0;
        a = ((e = e + Math.imul(f, tt) | 0) + (h >>> 13) | 0) + (yt >>> 26) | 0, yt &= 67108863, n = Math.imul(S, F), h = (h = Math.imul(S, C)) + Math.imul(q, F) | 0, e = Math.imul(q, C), n = n + Math.imul(k, H) | 0, h = (h = h + Math.imul(k, J) | 0) + Math.imul(A, H) | 0, e = e + Math.imul(A, J) | 0, n = n + Math.imul(y, G) | 0, h = (h = h + Math.imul(y, Q) | 0) + Math.imul(b, G) | 0, e = e + Math.imul(b, Q) | 0, n = n + Math.imul(g, W) | 0, h = (h = h + Math.imul(g, X) | 0) + Math.imul(c, W) | 0, e = e + Math.imul(c, X) | 0, n = n + Math.imul(p, $) | 0, h = (h = h + Math.imul(p, tt) | 0) + Math.imul(M, $) | 0, e = e + Math.imul(M, tt) | 0;
        var bt = (a + (n = n + Math.imul(m, rt) | 0) | 0) + ((8191 & (h = (h = h + Math.imul(m, nt) | 0) + Math.imul(f, rt) | 0)) << 13) | 0;
        a = ((e = e + Math.imul(f, nt) | 0) + (h >>> 13) | 0) + (bt >>> 26) | 0, bt &= 67108863, n = Math.imul(Z, F), h = (h = Math.imul(Z, C)) + Math.imul(R, F) | 0, e = Math.imul(R, C), n = n + Math.imul(S, H) | 0, h = (h = h + Math.imul(S, J) | 0) + Math.imul(q, H) | 0, e = e + Math.imul(q, J) | 0, n = n + Math.imul(k, G) | 0, h = (h = h + Math.imul(k, Q) | 0) + Math.imul(A, G) | 0, e = e + Math.imul(A, Q) | 0, n = n + Math.imul(y, W) | 0, h = (h = h + Math.imul(y, X) | 0) + Math.imul(b, W) | 0, e = e + Math.imul(b, X) | 0, n = n + Math.imul(g, $) | 0, h = (h = h + Math.imul(g, tt) | 0) + Math.imul(c, $) | 0, e = e + Math.imul(c, tt) | 0, n = n + Math.imul(p, rt) | 0, h = (h = h + Math.imul(p, nt) | 0) + Math.imul(M, rt) | 0, e = e + Math.imul(M, nt) | 0;
        var _t = (a + (n = n + Math.imul(m, et) | 0) | 0) + ((8191 & (h = (h = h + Math.imul(m, ot) | 0) + Math.imul(f, et) | 0)) << 13) | 0;
        a = ((e = e + Math.imul(f, ot) | 0) + (h >>> 13) | 0) + (_t >>> 26) | 0, _t &= 67108863, n = Math.imul(L, F), h = (h = Math.imul(L, C)) + Math.imul(I, F) | 0, e = Math.imul(I, C), n = n + Math.imul(Z, H) | 0, h = (h = h + Math.imul(Z, J) | 0) + Math.imul(R, H) | 0, e = e + Math.imul(R, J) | 0, n = n + Math.imul(S, G) | 0, h = (h = h + Math.imul(S, Q) | 0) + Math.imul(q, G) | 0, e = e + Math.imul(q, Q) | 0, n = n + Math.imul(k, W) | 0, h = (h = h + Math.imul(k, X) | 0) + Math.imul(A, W) | 0, e = e + Math.imul(A, X) | 0, n = n + Math.imul(y, $) | 0, h = (h = h + Math.imul(y, tt) | 0) + Math.imul(b, $) | 0, e = e + Math.imul(b, tt) | 0, n = n + Math.imul(g, rt) | 0, h = (h = h + Math.imul(g, nt) | 0) + Math.imul(c, rt) | 0, e = e + Math.imul(c, nt) | 0, n = n + Math.imul(p, et) | 0, h = (h = h + Math.imul(p, ot) | 0) + Math.imul(M, et) | 0, e = e + Math.imul(M, ot) | 0;
        var kt = (a + (n = n + Math.imul(m, ut) | 0) | 0) + ((8191 & (h = (h = h + Math.imul(m, at) | 0) + Math.imul(f, ut) | 0)) << 13) | 0;
        a = ((e = e + Math.imul(f, at) | 0) + (h >>> 13) | 0) + (kt >>> 26) | 0, kt &= 67108863, n = Math.imul(T, F), h = (h = Math.imul(T, C)) + Math.imul(E, F) | 0, e = Math.imul(E, C), n = n + Math.imul(L, H) | 0, h = (h = h + Math.imul(L, J) | 0) + Math.imul(I, H) | 0, e = e + Math.imul(I, J) | 0, n = n + Math.imul(Z, G) | 0, h = (h = h + Math.imul(Z, Q) | 0) + Math.imul(R, G) | 0, e = e + Math.imul(R, Q) | 0, n = n + Math.imul(S, W) | 0, h = (h = h + Math.imul(S, X) | 0) + Math.imul(q, W) | 0, e = e + Math.imul(q, X) | 0, n = n + Math.imul(k, $) | 0, h = (h = h + Math.imul(k, tt) | 0) + Math.imul(A, $) | 0, e = e + Math.imul(A, tt) | 0, n = n + Math.imul(y, rt) | 0, h = (h = h + Math.imul(y, nt) | 0) + Math.imul(b, rt) | 0, e = e + Math.imul(b, nt) | 0, n = n + Math.imul(g, et) | 0, h = (h = h + Math.imul(g, ot) | 0) + Math.imul(c, et) | 0, e = e + Math.imul(c, ot) | 0, n = n + Math.imul(p, ut) | 0, h = (h = h + Math.imul(p, at) | 0) + Math.imul(M, ut) | 0, e = e + Math.imul(M, at) | 0;
        var At = (a + (n = n + Math.imul(m, mt) | 0) | 0) + ((8191 & (h = (h = h + Math.imul(m, ft) | 0) + Math.imul(f, mt) | 0)) << 13) | 0;
        a = ((e = e + Math.imul(f, ft) | 0) + (h >>> 13) | 0) + (At >>> 26) | 0, At &= 67108863, n = Math.imul(j, F), h = (h = Math.imul(j, C)) + Math.imul(K, F) | 0, e = Math.imul(K, C), n = n + Math.imul(T, H) | 0, h = (h = h + Math.imul(T, J) | 0) + Math.imul(E, H) | 0, e = e + Math.imul(E, J) | 0, n = n + Math.imul(L, G) | 0, h = (h = h + Math.imul(L, Q) | 0) + Math.imul(I, G) | 0, e = e + Math.imul(I, Q) | 0, n = n + Math.imul(Z, W) | 0, h = (h = h + Math.imul(Z, X) | 0) + Math.imul(R, W) | 0, e = e + Math.imul(R, X) | 0, n = n + Math.imul(S, $) | 0, h = (h = h + Math.imul(S, tt) | 0) + Math.imul(q, $) | 0, e = e + Math.imul(q, tt) | 0, n = n + Math.imul(k, rt) | 0, h = (h = h + Math.imul(k, nt) | 0) + Math.imul(A, rt) | 0, e = e + Math.imul(A, nt) | 0, n = n + Math.imul(y, et) | 0, h = (h = h + Math.imul(y, ot) | 0) + Math.imul(b, et) | 0, e = e + Math.imul(b, ot) | 0, n = n + Math.imul(g, ut) | 0, h = (h = h + Math.imul(g, at) | 0) + Math.imul(c, ut) | 0, e = e + Math.imul(c, at) | 0, n = n + Math.imul(p, mt) | 0, h = (h = h + Math.imul(p, ft) | 0) + Math.imul(M, mt) | 0, e = e + Math.imul(M, ft) | 0;
        var xt = (a + (n = n + Math.imul(m, pt) | 0) | 0) + ((8191 & (h = (h = h + Math.imul(m, Mt) | 0) + Math.imul(f, pt) | 0)) << 13) | 0;
        a = ((e = e + Math.imul(f, Mt) | 0) + (h >>> 13) | 0) + (xt >>> 26) | 0, xt &= 67108863, n = Math.imul(j, H), h = (h = Math.imul(j, J)) + Math.imul(K, H) | 0, e = Math.imul(K, J), n = n + Math.imul(T, G) | 0, h = (h = h + Math.imul(T, Q) | 0) + Math.imul(E, G) | 0, e = e + Math.imul(E, Q) | 0, n = n + Math.imul(L, W) | 0, h = (h = h + Math.imul(L, X) | 0) + Math.imul(I, W) | 0, e = e + Math.imul(I, X) | 0, n = n + Math.imul(Z, $) | 0, h = (h = h + Math.imul(Z, tt) | 0) + Math.imul(R, $) | 0, e = e + Math.imul(R, tt) | 0, n = n + Math.imul(S, rt) | 0, h = (h = h + Math.imul(S, nt) | 0) + Math.imul(q, rt) | 0, e = e + Math.imul(q, nt) | 0, n = n + Math.imul(k, et) | 0, h = (h = h + Math.imul(k, ot) | 0) + Math.imul(A, et) | 0, e = e + Math.imul(A, ot) | 0, n = n + Math.imul(y, ut) | 0, h = (h = h + Math.imul(y, at) | 0) + Math.imul(b, ut) | 0, e = e + Math.imul(b, at) | 0, n = n + Math.imul(g, mt) | 0, h = (h = h + Math.imul(g, ft) | 0) + Math.imul(c, mt) | 0, e = e + Math.imul(c, ft) | 0;
        var St = (a + (n = n + Math.imul(p, pt) | 0) | 0) + ((8191 & (h = (h = h + Math.imul(p, Mt) | 0) + Math.imul(M, pt) | 0)) << 13) | 0;
        a = ((e = e + Math.imul(M, Mt) | 0) + (h >>> 13) | 0) + (St >>> 26) | 0, St &= 67108863, n = Math.imul(j, G), h = (h = Math.imul(j, Q)) + Math.imul(K, G) | 0, e = Math.imul(K, Q), n = n + Math.imul(T, W) | 0, h = (h = h + Math.imul(T, X) | 0) + Math.imul(E, W) | 0, e = e + Math.imul(E, X) | 0, n = n + Math.imul(L, $) | 0, h = (h = h + Math.imul(L, tt) | 0) + Math.imul(I, $) | 0, e = e + Math.imul(I, tt) | 0, n = n + Math.imul(Z, rt) | 0, h = (h = h + Math.imul(Z, nt) | 0) + Math.imul(R, rt) | 0, e = e + Math.imul(R, nt) | 0, n = n + Math.imul(S, et) | 0, h = (h = h + Math.imul(S, ot) | 0) + Math.imul(q, et) | 0, e = e + Math.imul(q, ot) | 0, n = n + Math.imul(k, ut) | 0, h = (h = h + Math.imul(k, at) | 0) + Math.imul(A, ut) | 0, e = e + Math.imul(A, at) | 0, n = n + Math.imul(y, mt) | 0, h = (h = h + Math.imul(y, ft) | 0) + Math.imul(b, mt) | 0, e = e + Math.imul(b, ft) | 0;
        var qt = (a + (n = n + Math.imul(g, pt) | 0) | 0) + ((8191 & (h = (h = h + Math.imul(g, Mt) | 0) + Math.imul(c, pt) | 0)) << 13) | 0;
        a = ((e = e + Math.imul(c, Mt) | 0) + (h >>> 13) | 0) + (qt >>> 26) | 0, qt &= 67108863, n = Math.imul(j, W), h = (h = Math.imul(j, X)) + Math.imul(K, W) | 0, e = Math.imul(K, X), n = n + Math.imul(T, $) | 0, h = (h = h + Math.imul(T, tt) | 0) + Math.imul(E, $) | 0, e = e + Math.imul(E, tt) | 0, n = n + Math.imul(L, rt) | 0, h = (h = h + Math.imul(L, nt) | 0) + Math.imul(I, rt) | 0, e = e + Math.imul(I, nt) | 0, n = n + Math.imul(Z, et) | 0, h = (h = h + Math.imul(Z, ot) | 0) + Math.imul(R, et) | 0, e = e + Math.imul(R, ot) | 0, n = n + Math.imul(S, ut) | 0, h = (h = h + Math.imul(S, at) | 0) + Math.imul(q, ut) | 0, e = e + Math.imul(q, at) | 0, n = n + Math.imul(k, mt) | 0, h = (h = h + Math.imul(k, ft) | 0) + Math.imul(A, mt) | 0, e = e + Math.imul(A, ft) | 0;
        var Bt = (a + (n = n + Math.imul(y, pt) | 0) | 0) + ((8191 & (h = (h = h + Math.imul(y, Mt) | 0) + Math.imul(b, pt) | 0)) << 13) | 0;
        a = ((e = e + Math.imul(b, Mt) | 0) + (h >>> 13) | 0) + (Bt >>> 26) | 0, Bt &= 67108863, n = Math.imul(j, $), h = (h = Math.imul(j, tt)) + Math.imul(K, $) | 0, e = Math.imul(K, tt), n = n + Math.imul(T, rt) | 0, h = (h = h + Math.imul(T, nt) | 0) + Math.imul(E, rt) | 0, e = e + Math.imul(E, nt) | 0, n = n + Math.imul(L, et) | 0, h = (h = h + Math.imul(L, ot) | 0) + Math.imul(I, et) | 0, e = e + Math.imul(I, ot) | 0, n = n + Math.imul(Z, ut) | 0, h = (h = h + Math.imul(Z, at) | 0) + Math.imul(R, ut) | 0, e = e + Math.imul(R, at) | 0, n = n + Math.imul(S, mt) | 0, h = (h = h + Math.imul(S, ft) | 0) + Math.imul(q, mt) | 0, e = e + Math.imul(q, ft) | 0;
        var Zt = (a + (n = n + Math.imul(k, pt) | 0) | 0) + ((8191 & (h = (h = h + Math.imul(k, Mt) | 0) + Math.imul(A, pt) | 0)) << 13) | 0;
        a = ((e = e + Math.imul(A, Mt) | 0) + (h >>> 13) | 0) + (Zt >>> 26) | 0, Zt &= 67108863, n = Math.imul(j, rt), h = (h = Math.imul(j, nt)) + Math.imul(K, rt) | 0, e = Math.imul(K, nt), n = n + Math.imul(T, et) | 0, h = (h = h + Math.imul(T, ot) | 0) + Math.imul(E, et) | 0, e = e + Math.imul(E, ot) | 0, n = n + Math.imul(L, ut) | 0, h = (h = h + Math.imul(L, at) | 0) + Math.imul(I, ut) | 0, e = e + Math.imul(I, at) | 0, n = n + Math.imul(Z, mt) | 0, h = (h = h + Math.imul(Z, ft) | 0) + Math.imul(R, mt) | 0, e = e + Math.imul(R, ft) | 0;
        var Rt = (a + (n = n + Math.imul(S, pt) | 0) | 0) + ((8191 & (h = (h = h + Math.imul(S, Mt) | 0) + Math.imul(q, pt) | 0)) << 13) | 0;
        a = ((e = e + Math.imul(q, Mt) | 0) + (h >>> 13) | 0) + (Rt >>> 26) | 0, Rt &= 67108863, n = Math.imul(j, et), h = (h = Math.imul(j, ot)) + Math.imul(K, et) | 0, e = Math.imul(K, ot), n = n + Math.imul(T, ut) | 0, h = (h = h + Math.imul(T, at) | 0) + Math.imul(E, ut) | 0, e = e + Math.imul(E, at) | 0, n = n + Math.imul(L, mt) | 0, h = (h = h + Math.imul(L, ft) | 0) + Math.imul(I, mt) | 0, e = e + Math.imul(I, ft) | 0;
        var Nt = (a + (n = n + Math.imul(Z, pt) | 0) | 0) + ((8191 & (h = (h = h + Math.imul(Z, Mt) | 0) + Math.imul(R, pt) | 0)) << 13) | 0;
        a = ((e = e + Math.imul(R, Mt) | 0) + (h >>> 13) | 0) + (Nt >>> 26) | 0, Nt &= 67108863, n = Math.imul(j, ut), h = (h = Math.imul(j, at)) + Math.imul(K, ut) | 0, e = Math.imul(K, at), n = n + Math.imul(T, mt) | 0, h = (h = h + Math.imul(T, ft) | 0) + Math.imul(E, mt) | 0, e = e + Math.imul(E, ft) | 0;
        var Lt = (a + (n = n + Math.imul(L, pt) | 0) | 0) + ((8191 & (h = (h = h + Math.imul(L, Mt) | 0) + Math.imul(I, pt) | 0)) << 13) | 0;
        a = ((e = e + Math.imul(I, Mt) | 0) + (h >>> 13) | 0) + (Lt >>> 26) | 0, Lt &= 67108863, n = Math.imul(j, mt), h = (h = Math.imul(j, ft)) + Math.imul(K, mt) | 0, e = Math.imul(K, ft);
        var It = (a + (n = n + Math.imul(T, pt) | 0) | 0) + ((8191 & (h = (h = h + Math.imul(T, Mt) | 0) + Math.imul(E, pt) | 0)) << 13) | 0;
        a = ((e = e + Math.imul(E, Mt) | 0) + (h >>> 13) | 0) + (It >>> 26) | 0, It &= 67108863;
        var zt = (a + (n = Math.imul(j, pt)) | 0) + ((8191 & (h = (h = Math.imul(j, Mt)) + Math.imul(K, pt) | 0)) << 13) | 0;
        return a = ((e = Math.imul(K, Mt)) + (h >>> 13) | 0) + (zt >>> 26) | 0, zt &= 67108863, u[0] = vt, u[1] = gt, u[2] = ct, u[3] = wt, u[4] = yt, u[5] = bt, u[6] = _t, u[7] = kt, u[8] = At, u[9] = xt, u[10] = St, u[11] = qt, u[12] = Bt, u[13] = Zt, u[14] = Rt, u[15] = Nt, u[16] = Lt, u[17] = It, u[18] = zt, 0 !== a && (u[19] = a, r.length++), r
      };

      function p(t, i, r) {
        return (new M).mulp(t, i, r)
      }

      function M(t, i) {
        this.x = t, this.y = i
      }
      Math.imul || (d = f), h.prototype.mulTo = function(t, i) {
        var r = this.length + t.length;
        return 10 === this.length && 10 === t.length ? d(this, t, i) : r < 63 ? f(this, t, i) : r < 1024 ? function(t, i, r) {
          r.negative = i.negative ^ t.negative, r.length = t.length + i.length;
          for (var n = 0, h = 0, e = 0; e < r.length - 1; e++) {
            var o = h;
            h = 0;
            for (var s = 67108863 & n, u = Math.min(e, i.length - 1), a = Math.max(0, e - t.length + 1); a <= u; a++) {
              var l = e - a,
                m = (0 | t.words[l]) * (0 | i.words[a]),
                f = 67108863 & m;
              s = 67108863 & (f = f + s | 0), h += (o = (o = o + (m / 67108864 | 0) | 0) + (f >>> 26) | 0) >>> 26, o &= 67108863
            }
            r.words[e] = s, n = o, o = h
          }
          return 0 !== n ? r.words[e] = n : r.length--, r.strip()
        }(this, t, i) : p(this, t, i)
      }, M.prototype.makeRBT = function(t) {
        for (var i = new Array(t), r = h.prototype._countBits(t) - 1, n = 0; n < t; n++) i[n] = this.revBin(n, r, t);
        return i
      }, M.prototype.revBin = function(t, i, r) {
        if (0 === t || t === r - 1) return t;
        for (var n = 0, h = 0; h < i; h++) n |= (1 & t) << i - h - 1, t >>= 1;
        return n
      }, M.prototype.permute = function(t, i, r, n, h, e) {
        for (var o = 0; o < e; o++) n[o] = i[t[o]], h[o] = r[t[o]]
      }, M.prototype.transform = function(t, i, r, n, h, e) {
        this.permute(e, t, i, r, n, h);
        for (var o = 1; o < h; o <<= 1)
          for (var s = o << 1, u = Math.cos(2 * Math.PI / s), a = Math.sin(2 * Math.PI / s), l = 0; l < h; l += s)
            for (var m = u, f = a, d = 0; d < o; d++) {
              var p = r[l + d],
                M = n[l + d],
                v = r[l + d + o],
                g = n[l + d + o],
                c = m * v - f * g;
              g = m * g + f * v, v = c, r[l + d] = p + v, n[l + d] = M + g, r[l + d + o] = p - v, n[l + d + o] = M - g, d !== s && (c = u * m - a * f, f = u * f + a * m, m = c)
            }
      }, M.prototype.guessLen13b = function(t, i) {
        var r = 1 | Math.max(i, t),
          n = 1 & r,
          h = 0;
        for (r = r / 2 | 0; r; r >>>= 1) h++;
        return 1 << h + 1 + n
      }, M.prototype.conjugate = function(t, i, r) {
        if (!(r <= 1))
          for (var n = 0; n < r / 2; n++) {
            var h = t[n];
            t[n] = t[r - n - 1], t[r - n - 1] = h, h = i[n], i[n] = -i[r - n - 1], i[r - n - 1] = -h
          }
      }, M.prototype.normalize13b = function(t, i) {
        for (var r = 0, n = 0; n < i / 2; n++) {
          var h = 8192 * Math.round(t[2 * n + 1] / i) + Math.round(t[2 * n] / i) + r;
          t[n] = 67108863 & h, r = h < 67108864 ? 0 : h / 67108864 | 0
        }
        return t
      }, M.prototype.convert13b = function(t, i, n, h) {
        for (var e = 0, o = 0; o < i; o++) e += 0 | t[o], n[2 * o] = 8191 & e, e >>>= 13, n[2 * o + 1] = 8191 & e, e >>>= 13;
        for (o = 2 * i; o < h; ++o) n[o] = 0;
        r(0 === e), r(0 == (-8192 & e))
      }, M.prototype.stub = function(t) {
        for (var i = new Array(t), r = 0; r < t; r++) i[r] = 0;
        return i
      }, M.prototype.mulp = function(t, i, r) {
        var n = 2 * this.guessLen13b(t.length, i.length),
          h = this.makeRBT(n),
          e = this.stub(n),
          o = new Array(n),
          s = new Array(n),
          u = new Array(n),
          a = new Array(n),
          l = new Array(n),
          m = new Array(n),
          f = r.words;
        f.length = n, this.convert13b(t.words, t.length, o, n), this.convert13b(i.words, i.length, a, n), this.transform(o, e, s, u, n, h), this.transform(a, e, l, m, n, h);
        for (var d = 0; d < n; d++) {
          var p = s[d] * l[d] - u[d] * m[d];
          u[d] = s[d] * m[d] + u[d] * l[d], s[d] = p
        }
        return this.conjugate(s, u, n), this.transform(s, u, f, e, n, h), this.conjugate(f, e, n), this.normalize13b(f, n), r.negative = t.negative ^ i.negative, r.length = t.length + i.length, r.strip()
      }, h.prototype.mul = function(t) {
        var i = new h(null);
        return i.words = new Array(this.length + t.length), this.mulTo(t, i)
      }, h.prototype.mulf = function(t) {
        var i = new h(null);
        return i.words = new Array(this.length + t.length), p(this, t, i)
      }, h.prototype.imul = function(t) {
        return this.clone().mulTo(t, this)
      }, h.prototype.imuln = function(t) {
        r("number" == typeof t), r(t < 67108864);
        for (var i = 0, n = 0; n < this.length; n++) {
          var h = (0 | this.words[n]) * t,
            e = (67108863 & h) + (67108863 & i);
          i >>= 26, i += h / 67108864 | 0, i += e >>> 26, this.words[n] = 67108863 & e
        }
        return 0 !== i && (this.words[n] = i, this.length++), this
      }, h.prototype.muln = function(t) {
        return this.clone().imuln(t)
      }, h.prototype.sqr = function() {
        return this.mul(this)
      }, h.prototype.isqr = function() {
        return this.imul(this.clone())
      }, h.prototype.pow = function(t) {
        var i = function(t) {
          for (var i = new Array(t.bitLength()), r = 0; r < i.length; r++) {
            var n = r / 26 | 0,
              h = r % 26;
            i[r] = (t.words[n] & 1 << h) >>> h
          }
          return i
        }(t);
        if (0 === i.length) return new h(1);
        for (var r = this, n = 0; n < i.length && 0 === i[n]; n++, r = r.sqr());
        if (++n < i.length)
          for (var e = r.sqr(); n < i.length; n++, e = e.sqr()) 0 !== i[n] && (r = r.mul(e));
        return r
      }, h.prototype.iushln = function(t) {
        r("number" == typeof t && t >= 0);
        var i, n = t % 26,
          h = (t - n) / 26,
          e = 67108863 >>> 26 - n << 26 - n;
        if (0 !== n) {
          var o = 0;
          for (i = 0; i < this.length; i++) {
            var s = this.words[i] & e,
              u = (0 | this.words[i]) - s << n;
            this.words[i] = u | o, o = s >>> 26 - n
          }
          o && (this.words[i] = o, this.length++)
        }
        if (0 !== h) {
          for (i = this.length - 1; i >= 0; i--) this.words[i + h] = this.words[i];
          for (i = 0; i < h; i++) this.words[i] = 0;
          this.length += h
        }
        return this.strip()
      }, h.prototype.ishln = function(t) {
        return r(0 === this.negative), this.iushln(t)
      }, h.prototype.iushrn = function(t, i, n) {
        var h;
        r("number" == typeof t && t >= 0), h = i ? (i - i % 26) / 26 : 0;
        var e = t % 26,
          o = Math.min((t - e) / 26, this.length),
          s = 67108863 ^ 67108863 >>> e << e,
          u = n;
        if (h -= o, h = Math.max(0, h), u) {
          for (var a = 0; a < o; a++) u.words[a] = this.words[a];
          u.length = o
        }
        if (0 === o);
        else if (this.length > o)
          for (this.length -= o, a = 0; a < this.length; a++) this.words[a] = this.words[a + o];
        else this.words[0] = 0, this.length = 1;
        var l = 0;
        for (a = this.length - 1; a >= 0 && (0 !== l || a >= h); a--) {
          var m = 0 | this.words[a];
          this.words[a] = l << 26 - e | m >>> e, l = m & s
        }
        return u && 0 !== l && (u.words[u.length++] = l), 0 === this.length && (this.words[0] = 0, this.length = 1), this.strip()
      }, h.prototype.ishrn = function(t, i, n) {
        return r(0 === this.negative), this.iushrn(t, i, n)
      }, h.prototype.shln = function(t) {
        return this.clone().ishln(t)
      }, h.prototype.ushln = function(t) {
        return this.clone().iushln(t)
      }, h.prototype.shrn = function(t) {
        return this.clone().ishrn(t)
      }, h.prototype.ushrn = function(t) {
        return this.clone().iushrn(t)
      }, h.prototype.testn = function(t) {
        r("number" == typeof t && t >= 0);
        var i = t % 26,
          n = (t - i) / 26,
          h = 1 << i;
        return !(this.length <= n) && !!(this.words[n] & h)
      }, h.prototype.imaskn = function(t) {
        r("number" == typeof t && t >= 0);
        var i = t % 26,
          n = (t - i) / 26;
        if (r(0 === this.negative, "imaskn works only with positive numbers"), this.length <= n) return this;
        if (0 !== i && n++, this.length = Math.min(n, this.length), 0 !== i) {
          var h = 67108863 ^ 67108863 >>> i << i;
          this.words[this.length - 1] &= h
        }
        return this.strip()
      }, h.prototype.maskn = function(t) {
        return this.clone().imaskn(t)
      }, h.prototype.iaddn = function(t) {
        return r("number" == typeof t), r(t < 67108864), t < 0 ? this.isubn(-t) : 0 !== this.negative ? 1 === this.length && (0 | this.words[0]) < t ? (this.words[0] = t - (0 | this.words[0]), this.negative = 0, this) : (this.negative = 0, this.isubn(t), this.negative = 1, this) : this._iaddn(t)
      }, h.prototype._iaddn = function(t) {
        this.words[0] += t;
        for (var i = 0; i < this.length && this.words[i] >= 67108864; i++) this.words[i] -= 67108864, i === this.length - 1 ? this.words[i + 1] = 1 : this.words[i + 1]++;
        return this.length = Math.max(this.length, i + 1), this
      }, h.prototype.isubn = function(t) {
        if (r("number" == typeof t), r(t < 67108864), t < 0) return this.iaddn(-t);
        if (0 !== this.negative) return this.negative = 0, this.iaddn(t), this.negative = 1, this;
        if (this.words[0] -= t, 1 === this.length && this.words[0] < 0) this.words[0] = -this.words[0], this.negative = 1;
        else
          for (var i = 0; i < this.length && this.words[i] < 0; i++) this.words[i] += 67108864, this.words[i + 1] -= 1;
        return this.strip()
      }, h.prototype.addn = function(t) {
        return this.clone().iaddn(t)
      }, h.prototype.subn = function(t) {
        return this.clone().isubn(t)
      }, h.prototype.iabs = function() {
        return this.negative = 0, this
      }, h.prototype.abs = function() {
        return this.clone().iabs()
      }, h.prototype._ishlnsubmul = function(t, i, n) {
        var h, e, o = t.length + n;
        this._expand(o);
        var s = 0;
        for (h = 0; h < t.length; h++) {
          e = (0 | this.words[h + n]) + s;
          var u = (0 | t.words[h]) * i;
          s = ((e -= 67108863 & u) >> 26) - (u / 67108864 | 0), this.words[h + n] = 67108863 & e
        }
        for (; h < this.length - n; h++) s = (e = (0 | this.words[h + n]) + s) >> 26, this.words[h + n] = 67108863 & e;
        if (0 === s) return this.strip();
        for (r(-1 === s), s = 0, h = 0; h < this.length; h++) s = (e = -(0 | this.words[h]) + s) >> 26, this.words[h] = 67108863 & e;
        return this.negative = 1, this.strip()
      }, h.prototype._wordDiv = function(t, i) {
        var r = (this.length, t.length),
          n = this.clone(),
          e = t,
          o = 0 | e.words[e.length - 1];
        0 !== (r = 26 - this._countBits(o)) && (e = e.ushln(r), n.iushln(r), o = 0 | e.words[e.length - 1]);
        var s, u = n.length - e.length;
        if ("mod" !== i) {
          (s = new h(null)).length = u + 1, s.words = new Array(s.length);
          for (var a = 0; a < s.length; a++) s.words[a] = 0
        }
        var l = n.clone()._ishlnsubmul(e, 1, u);
        0 === l.negative && (n = l, s && (s.words[u] = 1));
        for (var m = u - 1; m >= 0; m--) {
          var f = 67108864 * (0 | n.words[e.length + m]) + (0 | n.words[e.length + m - 1]);
          for (f = Math.min(f / o | 0, 67108863), n._ishlnsubmul(e, f, m); 0 !== n.negative;) f--, n.negative = 0, n._ishlnsubmul(e, 1, m), n.isZero() || (n.negative ^= 1);
          s && (s.words[m] = f)
        }
        return s && s.strip(), n.strip(), "div" !== i && 0 !== r && n.iushrn(r), {
          div: s || null,
          mod: n
        }
      }, h.prototype.divmod = function(t, i, n) {
        return r(!t.isZero()), this.isZero() ? {
          div: new h(0),
          mod: new h(0)
        } : 0 !== this.negative && 0 === t.negative ? (s = this.neg().divmod(t, i), "mod" !== i && (e = s.div.neg()), "div" !== i && (o = s.mod.neg(), n && 0 !== o.negative && o.iadd(t)), {
          div: e,
          mod: o
        }) : 0 === this.negative && 0 !== t.negative ? (s = this.divmod(t.neg(), i), "mod" !== i && (e = s.div.neg()), {
          div: e,
          mod: s.mod
        }) : 0 != (this.negative & t.negative) ? (s = this.neg().divmod(t.neg(), i), "div" !== i && (o = s.mod.neg(), n && 0 !== o.negative && o.isub(t)), {
          div: s.div,
          mod: o
        }) : t.length > this.length || this.cmp(t) < 0 ? {
          div: new h(0),
          mod: this
        } : 1 === t.length ? "div" === i ? {
          div: this.divn(t.words[0]),
          mod: null
        } : "mod" === i ? {
          div: null,
          mod: new h(this.modn(t.words[0]))
        } : {
          div: this.divn(t.words[0]),
          mod: new h(this.modn(t.words[0]))
        } : this._wordDiv(t, i);
        var e, o, s
      }, h.prototype.div = function(t) {
        return this.divmod(t, "div", !1).div
      }, h.prototype.mod = function(t) {
        return this.divmod(t, "mod", !1).mod
      }, h.prototype.umod = function(t) {
        return this.divmod(t, "mod", !0).mod
      }, h.prototype.divRound = function(t) {
        var i = this.divmod(t);
        if (i.mod.isZero()) return i.div;
        var r = 0 !== i.div.negative ? i.mod.isub(t) : i.mod,
          n = t.ushrn(1),
          h = t.andln(1),
          e = r.cmp(n);
        return e < 0 || 1 === h && 0 === e ? i.div : 0 !== i.div.negative ? i.div.isubn(1) : i.div.iaddn(1)
      }, h.prototype.modn = function(t) {
        r(t <= 67108863);
        for (var i = (1 << 26) % t, n = 0, h = this.length - 1; h >= 0; h--) n = (i * n + (0 | this.words[h])) % t;
        return n
      }, h.prototype.idivn = function(t) {
        r(t <= 67108863);
        for (var i = 0, n = this.length - 1; n >= 0; n--) {
          var h = (0 | this.words[n]) + 67108864 * i;
          this.words[n] = h / t | 0, i = h % t
        }
        return this.strip()
      }, h.prototype.divn = function(t) {
        return this.clone().idivn(t)
      }, h.prototype.egcd = function(t) {
        r(0 === t.negative), r(!t.isZero());
        var i = this,
          n = t.clone();
        i = 0 !== i.negative ? i.umod(t) : i.clone();
        for (var e = new h(1), o = new h(0), s = new h(0), u = new h(1), a = 0; i.isEven() && n.isEven();) i.iushrn(1), n.iushrn(1), ++a;
        for (var l = n.clone(), m = i.clone(); !i.isZero();) {
          for (var f = 0, d = 1; 0 == (i.words[0] & d) && f < 26; ++f, d <<= 1);
          if (f > 0)
            for (i.iushrn(f); f-- > 0;)(e.isOdd() || o.isOdd()) && (e.iadd(l), o.isub(m)), e.iushrn(1), o.iushrn(1);
          for (var p = 0, M = 1; 0 == (n.words[0] & M) && p < 26; ++p, M <<= 1);
          if (p > 0)
            for (n.iushrn(p); p-- > 0;)(s.isOdd() || u.isOdd()) && (s.iadd(l), u.isub(m)), s.iushrn(1), u.iushrn(1);
          i.cmp(n) >= 0 ? (i.isub(n), e.isub(s), o.isub(u)) : (n.isub(i), s.isub(e), u.isub(o))
        }
        return {
          a: s,
          b: u,
          gcd: n.iushln(a)
        }
      }, h.prototype._invmp = function(t) {
        r(0 === t.negative), r(!t.isZero());
        var i = this,
          n = t.clone();
        i = 0 !== i.negative ? i.umod(t) : i.clone();
        for (var e, o = new h(1), s = new h(0), u = n.clone(); i.cmpn(1) > 0 && n.cmpn(1) > 0;) {
          for (var a = 0, l = 1; 0 == (i.words[0] & l) && a < 26; ++a, l <<= 1);
          if (a > 0)
            for (i.iushrn(a); a-- > 0;) o.isOdd() && o.iadd(u), o.iushrn(1);
          for (var m = 0, f = 1; 0 == (n.words[0] & f) && m < 26; ++m, f <<= 1);
          if (m > 0)
            for (n.iushrn(m); m-- > 0;) s.isOdd() && s.iadd(u), s.iushrn(1);
          i.cmp(n) >= 0 ? (i.isub(n), o.isub(s)) : (n.isub(i), s.isub(o))
        }
        return (e = 0 === i.cmpn(1) ? o : s).cmpn(0) < 0 && e.iadd(t), e
      }, h.prototype.gcd = function(t) {
        if (this.isZero()) return t.abs();
        if (t.isZero()) return this.abs();
        var i = this.clone(),
          r = t.clone();
        i.negative = 0, r.negative = 0;
        for (var n = 0; i.isEven() && r.isEven(); n++) i.iushrn(1), r.iushrn(1);
        for (;;) {
          for (; i.isEven();) i.iushrn(1);
          for (; r.isEven();) r.iushrn(1);
          var h = i.cmp(r);
          if (h < 0) {
            var e = i;
            i = r, r = e
          } else if (0 === h || 0 === r.cmpn(1)) break;
          i.isub(r)
        }
        return r.iushln(n)
      }, h.prototype.invm = function(t) {
        return this.egcd(t).a.umod(t)
      }, h.prototype.isEven = function() {
        return 0 == (1 & this.words[0])
      }, h.prototype.isOdd = function() {
        return 1 == (1 & this.words[0])
      }, h.prototype.andln = function(t) {
        return this.words[0] & t
      }, h.prototype.bincn = function(t) {
        r("number" == typeof t);
        var i = t % 26,
          n = (t - i) / 26,
          h = 1 << i;
        if (this.length <= n) return this._expand(n + 1), this.words[n] |= h, this;
        for (var e = h, o = n; 0 !== e && o < this.length; o++) {
          var s = 0 | this.words[o];
          e = (s += e) >>> 26, s &= 67108863, this.words[o] = s
        }
        return 0 !== e && (this.words[o] = e, this.length++), this
      }, h.prototype.isZero = function() {
        return 1 === this.length && 0 === this.words[0]
      }, h.prototype.cmpn = function(t) {
        var i, n = t < 0;
        if (0 !== this.negative && !n) return -1;
        if (0 === this.negative && n) return 1;
        if (this.strip(), this.length > 1) i = 1;
        else {
          n && (t = -t), r(t <= 67108863, "Number is too big");
          var h = 0 | this.words[0];
          i = h === t ? 0 : h < t ? -1 : 1
        }
        return 0 !== this.negative ? 0 | -i : i
      }, h.prototype.cmp = function(t) {
        if (0 !== this.negative && 0 === t.negative) return -1;
        if (0 === this.negative && 0 !== t.negative) return 1;
        var i = this.ucmp(t);
        return 0 !== this.negative ? 0 | -i : i
      }, h.prototype.ucmp = function(t) {
        if (this.length > t.length) return 1;
        if (this.length < t.length) return -1;
        for (var i = 0, r = this.length - 1; r >= 0; r--) {
          var n = 0 | this.words[r],
            h = 0 | t.words[r];
          if (n !== h) {
            n < h ? i = -1 : n > h && (i = 1);
            break
          }
        }
        return i
      }, h.prototype.gtn = function(t) {
        return 1 === this.cmpn(t)
      }, h.prototype.gt = function(t) {
        return 1 === this.cmp(t)
      }, h.prototype.gten = function(t) {
        return this.cmpn(t) >= 0
      }, h.prototype.gte = function(t) {
        return this.cmp(t) >= 0
      }, h.prototype.ltn = function(t) {
        return -1 === this.cmpn(t)
      }, h.prototype.lt = function(t) {
        return -1 === this.cmp(t)
      }, h.prototype.lten = function(t) {
        return this.cmpn(t) <= 0
      }, h.prototype.lte = function(t) {
        return this.cmp(t) <= 0
      }, h.prototype.eqn = function(t) {
        return 0 === this.cmpn(t)
      }, h.prototype.eq = function(t) {
        return 0 === this.cmp(t)
      }, h.red = function(t) {
        return new _(t)
      }, h.prototype.toRed = function(t) {
        return r(!this.red, "Already a number in reduction context"), r(0 === this.negative, "red works only with positives"), t.convertTo(this)._forceRed(t)
      }, h.prototype.fromRed = function() {
        return r(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this)
      }, h.prototype._forceRed = function(t) {
        return this.red = t, this
      }, h.prototype.forceRed = function(t) {
        return r(!this.red, "Already a number in reduction context"), this._forceRed(t)
      }, h.prototype.redAdd = function(t) {
        return r(this.red, "redAdd works only with red numbers"), this.red.add(this, t)
      }, h.prototype.redIAdd = function(t) {
        return r(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, t)
      }, h.prototype.redSub = function(t) {
        return r(this.red, "redSub works only with red numbers"), this.red.sub(this, t)
      }, h.prototype.redISub = function(t) {
        return r(this.red, "redISub works only with red numbers"), this.red.isub(this, t)
      }, h.prototype.redShl = function(t) {
        return r(this.red, "redShl works only with red numbers"), this.red.shl(this, t)
      }, h.prototype.redMul = function(t) {
        return r(this.red, "redMul works only with red numbers"), this.red._verify2(this, t), this.red.mul(this, t)
      }, h.prototype.redIMul = function(t) {
        return r(this.red, "redMul works only with red numbers"), this.red._verify2(this, t), this.red.imul(this, t)
      }, h.prototype.redSqr = function() {
        return r(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this)
      }, h.prototype.redISqr = function() {
        return r(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this)
      }, h.prototype.redSqrt = function() {
        return r(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this)
      }, h.prototype.redInvm = function() {
        return r(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this)
      }, h.prototype.redNeg = function() {
        return r(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this)
      }, h.prototype.redPow = function(t) {
        return r(this.red && !t.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, t)
      };
      var v = {
        k256: null,
        p224: null,
        p192: null,
        p25519: null
      };

      function g(t, i) {
        this.name = t, this.p = new h(i, 16), this.n = this.p.bitLength(), this.k = new h(1).iushln(this.n).isub(this.p), this.tmp = this._tmp()
      }

      function c() {
        g.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f")
      }

      function w() {
        g.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001")
      }

      function y() {
        g.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff")
      }

      function b() {
        g.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed")
      }

      function _(t) {
        if ("string" == typeof t) {
          var i = h._prime(t);
          this.m = i.p, this.prime = i
        } else r(t.gtn(1), "modulus must be greater than 1"), this.m = t, this.prime = null
      }

      function k(t) {
        _.call(this, t), this.shift = this.m.bitLength(), this.shift % 26 != 0 && (this.shift += 26 - this.shift % 26), this.r = new h(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv)
      }
      g.prototype._tmp = function() {
        var t = new h(null);
        return t.words = new Array(Math.ceil(this.n / 13)), t
      }, g.prototype.ireduce = function(t) {
        var i, r = t;
        do {
          this.split(r, this.tmp), i = (r = (r = this.imulK(r)).iadd(this.tmp)).bitLength()
        } while (i > this.n);
        var n = i < this.n ? -1 : r.ucmp(this.p);
        return 0 === n ? (r.words[0] = 0, r.length = 1) : n > 0 ? r.isub(this.p) : void 0 !== r.strip ? r.strip() : r._strip(), r
      }, g.prototype.split = function(t, i) {
        t.iushrn(this.n, 0, i)
      }, g.prototype.imulK = function(t) {
        return t.imul(this.k)
      }, n(c, g), c.prototype.split = function(t, i) {
        for (var r = Math.min(t.length, 9), n = 0; n < r; n++) i.words[n] = t.words[n];
        if (i.length = r, t.length <= 9) return t.words[0] = 0, void(t.length = 1);
        var h = t.words[9];
        for (i.words[i.length++] = 4194303 & h, n = 10; n < t.length; n++) {
          var e = 0 | t.words[n];
          t.words[n - 10] = (4194303 & e) << 4 | h >>> 22, h = e
        }
        h >>>= 22, t.words[n - 10] = h, 0 === h && t.length > 10 ? t.length -= 10 : t.length -= 9
      }, c.prototype.imulK = function(t) {
        t.words[t.length] = 0, t.words[t.length + 1] = 0, t.length += 2;
        for (var i = 0, r = 0; r < t.length; r++) {
          var n = 0 | t.words[r];
          i += 977 * n, t.words[r] = 67108863 & i, i = 64 * n + (i / 67108864 | 0)
        }
        return 0 === t.words[t.length - 1] && (t.length--, 0 === t.words[t.length - 1] && t.length--), t
      }, n(w, g), n(y, g), n(b, g), b.prototype.imulK = function(t) {
        for (var i = 0, r = 0; r < t.length; r++) {
          var n = 19 * (0 | t.words[r]) + i,
            h = 67108863 & n;
          n >>>= 26, t.words[r] = h, i = n
        }
        return 0 !== i && (t.words[t.length++] = i), t
      }, h._prime = function(t) {
        if (v[t]) return v[t];
        var i;
        if ("k256" === t) i = new c;
        else if ("p224" === t) i = new w;
        else if ("p192" === t) i = new y;
        else {
          if ("p25519" !== t) throw new Error("Unknown prime " + t);
          i = new b
        }
        return v[t] = i, i
      }, _.prototype._verify1 = function(t) {
        r(0 === t.negative, "red works only with positives"), r(t.red, "red works only with red numbers")
      }, _.prototype._verify2 = function(t, i) {
        r(0 == (t.negative | i.negative), "red works only with positives"), r(t.red && t.red === i.red, "red works only with red numbers")
      }, _.prototype.imod = function(t) {
        return this.prime ? this.prime.ireduce(t)._forceRed(this) : t.umod(this.m)._forceRed(this)
      }, _.prototype.neg = function(t) {
        return t.isZero() ? t.clone() : this.m.sub(t)._forceRed(this)
      }, _.prototype.add = function(t, i) {
        this._verify2(t, i);
        var r = t.add(i);
        return r.cmp(this.m) >= 0 && r.isub(this.m), r._forceRed(this)
      }, _.prototype.iadd = function(t, i) {
        this._verify2(t, i);
        var r = t.iadd(i);
        return r.cmp(this.m) >= 0 && r.isub(this.m), r
      }, _.prototype.sub = function(t, i) {
        this._verify2(t, i);
        var r = t.sub(i);
        return r.cmpn(0) < 0 && r.iadd(this.m), r._forceRed(this)
      }, _.prototype.isub = function(t, i) {
        this._verify2(t, i);
        var r = t.isub(i);
        return r.cmpn(0) < 0 && r.iadd(this.m), r
      }, _.prototype.shl = function(t, i) {
        return this._verify1(t), this.imod(t.ushln(i))
      }, _.prototype.imul = function(t, i) {
        return this._verify2(t, i), this.imod(t.imul(i))
      }, _.prototype.mul = function(t, i) {
        return this._verify2(t, i), this.imod(t.mul(i))
      }, _.prototype.isqr = function(t) {
        return this.imul(t, t.clone())
      }, _.prototype.sqr = function(t) {
        return this.mul(t, t)
      }, _.prototype.sqrt = function(t) {
        if (t.isZero()) return t.clone();
        var i = this.m.andln(3);
        if (r(i % 2 == 1), 3 === i) {
          var n = this.m.add(new h(1)).iushrn(2);
          return this.pow(t, n)
        }
        for (var e = this.m.subn(1), o = 0; !e.isZero() && 0 === e.andln(1);) o++, e.iushrn(1);
        r(!e.isZero());
        var s = new h(1).toRed(this),
          u = s.redNeg(),
          a = this.m.subn(1).iushrn(1),
          l = this.m.bitLength();
        for (l = new h(2 * l * l).toRed(this); 0 !== this.pow(l, a).cmp(u);) l.redIAdd(u);
        for (var m = this.pow(l, e), f = this.pow(t, e.addn(1).iushrn(1)), d = this.pow(t, e), p = o; 0 !== d.cmp(s);) {
          for (var M = d, v = 0; 0 !== M.cmp(s); v++) M = M.redSqr();
          r(v < p);
          var g = this.pow(m, new h(1).iushln(p - v - 1));
          f = f.redMul(g), m = g.redSqr(), d = d.redMul(m), p = v
        }
        return f
      }, _.prototype.invm = function(t) {
        var i = t._invmp(this.m);
        return 0 !== i.negative ? (i.negative = 0, this.imod(i).redNeg()) : this.imod(i)
      }, _.prototype.pow = function(t, i) {
        if (i.isZero()) return new h(1).toRed(this);
        if (0 === i.cmpn(1)) return t.clone();
        var r = new Array(16);
        r[0] = new h(1).toRed(this), r[1] = t;
        for (var n = 2; n < r.length; n++) r[n] = this.mul(r[n - 1], t);
        var e = r[0],
          o = 0,
          s = 0,
          u = i.bitLength() % 26;
        for (0 === u && (u = 26), n = i.length - 1; n >= 0; n--) {
          for (var a = i.words[n], l = u - 1; l >= 0; l--) {
            var m = a >> l & 1;
            e !== r[0] && (e = this.sqr(e)), 0 !== m || 0 !== o ? (o <<= 1, o |= m, (4 === ++s || 0 === n && 0 === l) && (e = this.mul(e, r[o]), s = 0, o = 0)) : s = 0
          }
          u = 26
        }
        return e
      }, _.prototype.convertTo = function(t) {
        var i = t.umod(this.m);
        return i === t ? i.clone() : i
      }, _.prototype.convertFrom = function(t) {
        var i = t.clone();
        return i.red = null, i
      }, h.mont = function(t) {
        return new k(t)
      }, n(k, _), k.prototype.convertTo = function(t) {
        return this.imod(t.ushln(this.shift))
      }, k.prototype.convertFrom = function(t) {
        var i = this.imod(t.mul(this.rinv));
        return i.red = null, i
      }, k.prototype.imul = function(t, i) {
        if (t.isZero() || i.isZero()) return t.words[0] = 0, t.length = 1, t;
        var r = t.imul(i),
          n = r.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m),
          h = r.isub(n).iushrn(this.shift),
          e = h;
        return h.cmp(this.m) >= 0 ? e = h.isub(this.m) : h.cmpn(0) < 0 && (e = h.iadd(this.m)), e._forceRed(this)
      }, k.prototype.mul = function(t, i) {
        if (t.isZero() || i.isZero()) return new h(0)._forceRed(this);
        var r = t.mul(i),
          n = r.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m),
          e = r.isub(n).iushrn(this.shift),
          o = e;
        return e.cmp(this.m) >= 0 ? o = e.isub(this.m) : e.cmpn(0) < 0 && (o = e.iadd(this.m)), o._forceRed(this)
      }, k.prototype.invm = function(t) {
        return this.imod(t._invmp(this.m).mul(this.r2))._forceRed(this)
      }
    }("undefined" == typeof module || module, this);
  }, {
    "buffer": "rDCW"
  }],
  "OBrI": [function(require, module, exports) {
    ! function(r) {
      var n, t, o, e = String.fromCharCode;

      function i(r) {
        for (var n, t, o = [], e = 0, i = r.length; e < i;)(n = r.charCodeAt(e++)) >= 55296 && n <= 56319 && e < i ? 56320 == (64512 & (t = r.charCodeAt(e++))) ? o.push(((1023 & n) << 10) + (1023 & t) + 65536) : (o.push(n), e--) : o.push(n);
        return o
      }

      function u(r) {
        if (r >= 55296 && r <= 57343) throw Error("Lone surrogate U+" + r.toString(16).toUpperCase() + " is not a scalar value")
      }

      function f(r, n) {
        return e(r >> n & 63 | 128)
      }

      function a(r) {
        if (0 == (4294967168 & r)) return e(r);
        var n = "";
        return 0 == (4294965248 & r) ? n = e(r >> 6 & 31 | 192) : 0 == (4294901760 & r) ? (u(r), n = e(r >> 12 & 15 | 224), n += f(r, 6)) : 0 == (4292870144 & r) && (n = e(r >> 18 & 7 | 240), n += f(r, 12), n += f(r, 6)), n += e(63 & r | 128)
      }

      function c() {
        if (o >= t) throw Error("Invalid byte index");
        var r = 255 & n[o];
        if (o++, 128 == (192 & r)) return 63 & r;
        throw Error("Invalid continuation byte")
      }

      function h() {
        var r, e;
        if (o > t) throw Error("Invalid byte index");
        if (o == t) return !1;
        if (r = 255 & n[o], o++, 0 == (128 & r)) return r;
        if (192 == (224 & r)) {
          if ((e = (31 & r) << 6 | c()) >= 128) return e;
          throw Error("Invalid continuation byte")
        }
        if (224 == (240 & r)) {
          if ((e = (15 & r) << 12 | c() << 6 | c()) >= 2048) return u(e), e;
          throw Error("Invalid continuation byte")
        }
        if (240 == (248 & r) && (e = (7 & r) << 18 | c() << 12 | c() << 6 | c()) >= 65536 && e <= 1114111) return e;
        throw Error("Invalid UTF-8 detected")
      }
      r.version = "3.0.0", r.encode = function(r) {
        for (var n = i(r), t = n.length, o = -1, e = ""; ++o < t;) e += a(n[o]);
        return e
      }, r.decode = function(r) {
        n = i(r), t = n.length, o = 0;
        for (var u, f = []; !1 !== (u = h());) f.push(u);
        return function(r) {
          for (var n, t = r.length, o = -1, i = ""; ++o < t;)(n = r[o]) > 65535 && (i += e((n -= 65536) >>> 10 & 1023 | 55296), n = 56320 | 1023 & n), i += e(n);
          return i
        }(f)
      }
    }("undefined" == typeof exports ? this.utf8 = {} : exports);
  }, {}],
  "Swo0": [function(require, module, exports) {
    const t = "0123456789abcdef".split(""),
      e = [1, 256, 65536, 16777216],
      r = [0, 8, 16, 24],
      o = [1, 0, 32898, 0, 32906, 2147483648, 2147516416, 2147483648, 32907, 0, 2147483649, 0, 2147516545, 2147483648, 32777, 2147483648, 138, 0, 136, 0, 2147516425, 0, 2147483658, 0, 2147516555, 0, 139, 2147483648, 32905, 2147483648, 32771, 2147483648, 32770, 2147483648, 128, 2147483648, 32778, 0, 2147483658, 2147483648, 2147516545, 2147483648, 32896, 2147483648, 2147483649, 0, 2147516424, 2147483648],
      s = t => ({
        blocks: [],
        reset: !0,
        block: 0,
        start: 0,
        blockCount: 1600 - (t << 1) >> 5,
        outputBlocks: t >> 5,
        s: (t => [].concat(t, t, t, t, t))([0, 0, 0, 0, 0, 0, 0, 0, 0, 0])
      }),
      c = (o, s) => {
        for (var c, l = s.length, f = o.blocks, k = o.blockCount << 2, n = o.blockCount, u = o.outputBlocks, b = o.s, i = 0; i < l;) {
          if (o.reset)
            for (o.reset = !1, f[0] = o.block, x = 1; x < n + 1; ++x) f[x] = 0;
          if ("string" != typeof s)
            for (x = o.start; i < l && x < k; ++i) f[x >> 2] |= s[i] << r[3 & x++];
          else
            for (x = o.start; i < l && x < k; ++i)(c = s.charCodeAt(i)) < 128 ? f[x >> 2] |= c << r[3 & x++] : c < 2048 ? (f[x >> 2] |= (192 | c >> 6) << r[3 & x++], f[x >> 2] |= (128 | 63 & c) << r[3 & x++]) : c < 55296 || c >= 57344 ? (f[x >> 2] |= (224 | c >> 12) << r[3 & x++], f[x >> 2] |= (128 | c >> 6 & 63) << r[3 & x++], f[x >> 2] |= (128 | 63 & c) << r[3 & x++]) : (c = 65536 + ((1023 & c) << 10 | 1023 & s.charCodeAt(++i)), f[x >> 2] |= (240 | c >> 18) << r[3 & x++], f[x >> 2] |= (128 | c >> 12 & 63) << r[3 & x++], f[x >> 2] |= (128 | c >> 6 & 63) << r[3 & x++], f[x >> 2] |= (128 | 63 & c) << r[3 & x++]);
          if (o.lastByteIndex = x, x >= k) {
            for (o.start = x - k, o.block = f[n], x = 0; x < n; ++x) b[x] ^= f[x];
            a(b), o.reset = !0
          } else o.start = x
        }
        if (f[(x = o.lastByteIndex) >> 2] |= e[3 & x], o.lastByteIndex === k)
          for (f[0] = f[n], x = 1; x < n + 1; ++x) f[x] = 0;
        for (f[n - 1] |= 2147483648, x = 0; x < n; ++x) b[x] ^= f[x];
        a(b);
        for (var d, p = "", x = 0, h = 0; h < u;) {
          for (x = 0; x < n && h < u; ++x, ++h) d = b[x], p += t[d >> 4 & 15] + t[15 & d] + t[d >> 12 & 15] + t[d >> 8 & 15] + t[d >> 20 & 15] + t[d >> 16 & 15] + t[d >> 28 & 15] + t[d >> 24 & 15];
          h % n == 0 && (a(b), x = 0)
        }
        return "0x" + p
      },
      a = t => {
        var e, r, s, c, a, l, f, k, n, u, b, i, d, p, x, h, v, B, C, y, I, g, A, m, j, q, w, z, D, E, F, G, H, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y, Z, $, _, tt, et, rt, ot, st, ct, at, lt, ft, kt, nt;
        for (s = 0; s < 48; s += 2) c = t[0] ^ t[10] ^ t[20] ^ t[30] ^ t[40], a = t[1] ^ t[11] ^ t[21] ^ t[31] ^ t[41], l = t[2] ^ t[12] ^ t[22] ^ t[32] ^ t[42], f = t[3] ^ t[13] ^ t[23] ^ t[33] ^ t[43], k = t[4] ^ t[14] ^ t[24] ^ t[34] ^ t[44], n = t[5] ^ t[15] ^ t[25] ^ t[35] ^ t[45], u = t[6] ^ t[16] ^ t[26] ^ t[36] ^ t[46], b = t[7] ^ t[17] ^ t[27] ^ t[37] ^ t[47], e = (i = t[8] ^ t[18] ^ t[28] ^ t[38] ^ t[48]) ^ (l << 1 | f >>> 31), r = (d = t[9] ^ t[19] ^ t[29] ^ t[39] ^ t[49]) ^ (f << 1 | l >>> 31), t[0] ^= e, t[1] ^= r, t[10] ^= e, t[11] ^= r, t[20] ^= e, t[21] ^= r, t[30] ^= e, t[31] ^= r, t[40] ^= e, t[41] ^= r, e = c ^ (k << 1 | n >>> 31), r = a ^ (n << 1 | k >>> 31), t[2] ^= e, t[3] ^= r, t[12] ^= e, t[13] ^= r, t[22] ^= e, t[23] ^= r, t[32] ^= e, t[33] ^= r, t[42] ^= e, t[43] ^= r, e = l ^ (u << 1 | b >>> 31), r = f ^ (b << 1 | u >>> 31), t[4] ^= e, t[5] ^= r, t[14] ^= e, t[15] ^= r, t[24] ^= e, t[25] ^= r, t[34] ^= e, t[35] ^= r, t[44] ^= e, t[45] ^= r, e = k ^ (i << 1 | d >>> 31), r = n ^ (d << 1 | i >>> 31), t[6] ^= e, t[7] ^= r, t[16] ^= e, t[17] ^= r, t[26] ^= e, t[27] ^= r, t[36] ^= e, t[37] ^= r, t[46] ^= e, t[47] ^= r, e = u ^ (c << 1 | a >>> 31), r = b ^ (a << 1 | c >>> 31), t[8] ^= e, t[9] ^= r, t[18] ^= e, t[19] ^= r, t[28] ^= e, t[29] ^= r, t[38] ^= e, t[39] ^= r, t[48] ^= e, t[49] ^= r, p = t[0], x = t[1], V = t[11] << 4 | t[10] >>> 28, W = t[10] << 4 | t[11] >>> 28, z = t[20] << 3 | t[21] >>> 29, D = t[21] << 3 | t[20] >>> 29, lt = t[31] << 9 | t[30] >>> 23, ft = t[30] << 9 | t[31] >>> 23, R = t[40] << 18 | t[41] >>> 14, S = t[41] << 18 | t[40] >>> 14, J = t[2] << 1 | t[3] >>> 31, K = t[3] << 1 | t[2] >>> 31, h = t[13] << 12 | t[12] >>> 20, v = t[12] << 12 | t[13] >>> 20, X = t[22] << 10 | t[23] >>> 22, Y = t[23] << 10 | t[22] >>> 22, E = t[33] << 13 | t[32] >>> 19, F = t[32] << 13 | t[33] >>> 19, kt = t[42] << 2 | t[43] >>> 30, nt = t[43] << 2 | t[42] >>> 30, et = t[5] << 30 | t[4] >>> 2, rt = t[4] << 30 | t[5] >>> 2, L = t[14] << 6 | t[15] >>> 26, M = t[15] << 6 | t[14] >>> 26, B = t[25] << 11 | t[24] >>> 21, C = t[24] << 11 | t[25] >>> 21, Z = t[34] << 15 | t[35] >>> 17, $ = t[35] << 15 | t[34] >>> 17, G = t[45] << 29 | t[44] >>> 3, H = t[44] << 29 | t[45] >>> 3, m = t[6] << 28 | t[7] >>> 4, j = t[7] << 28 | t[6] >>> 4, ot = t[17] << 23 | t[16] >>> 9, st = t[16] << 23 | t[17] >>> 9, N = t[26] << 25 | t[27] >>> 7, O = t[27] << 25 | t[26] >>> 7, y = t[36] << 21 | t[37] >>> 11, I = t[37] << 21 | t[36] >>> 11, _ = t[47] << 24 | t[46] >>> 8, tt = t[46] << 24 | t[47] >>> 8, T = t[8] << 27 | t[9] >>> 5, U = t[9] << 27 | t[8] >>> 5, q = t[18] << 20 | t[19] >>> 12, w = t[19] << 20 | t[18] >>> 12, ct = t[29] << 7 | t[28] >>> 25, at = t[28] << 7 | t[29] >>> 25, P = t[38] << 8 | t[39] >>> 24, Q = t[39] << 8 | t[38] >>> 24, g = t[48] << 14 | t[49] >>> 18, A = t[49] << 14 | t[48] >>> 18, t[0] = p ^ ~h & B, t[1] = x ^ ~v & C, t[10] = m ^ ~q & z, t[11] = j ^ ~w & D, t[20] = J ^ ~L & N, t[21] = K ^ ~M & O, t[30] = T ^ ~V & X, t[31] = U ^ ~W & Y, t[40] = et ^ ~ot & ct, t[41] = rt ^ ~st & at, t[2] = h ^ ~B & y, t[3] = v ^ ~C & I, t[12] = q ^ ~z & E, t[13] = w ^ ~D & F, t[22] = L ^ ~N & P, t[23] = M ^ ~O & Q, t[32] = V ^ ~X & Z, t[33] = W ^ ~Y & $, t[42] = ot ^ ~ct & lt, t[43] = st ^ ~at & ft, t[4] = B ^ ~y & g, t[5] = C ^ ~I & A, t[14] = z ^ ~E & G, t[15] = D ^ ~F & H, t[24] = N ^ ~P & R, t[25] = O ^ ~Q & S, t[34] = X ^ ~Z & _, t[35] = Y ^ ~$ & tt, t[44] = ct ^ ~lt & kt, t[45] = at ^ ~ft & nt, t[6] = y ^ ~g & p, t[7] = I ^ ~A & x, t[16] = E ^ ~G & m, t[17] = F ^ ~H & j, t[26] = P ^ ~R & J, t[27] = Q ^ ~S & K, t[36] = Z ^ ~_ & T, t[37] = $ ^ ~tt & U, t[46] = lt ^ ~kt & et, t[47] = ft ^ ~nt & rt, t[8] = g ^ ~p & h, t[9] = A ^ ~x & v, t[18] = G ^ ~m & q, t[19] = H ^ ~j & w, t[28] = R ^ ~J & L, t[29] = S ^ ~K & M, t[38] = _ ^ ~T & V, t[39] = tt ^ ~U & W, t[48] = kt ^ ~et & ot, t[49] = nt ^ ~rt & st, t[0] ^= o[s], t[1] ^= o[s + 1]
      },
      l = t => e => {
        var r;
        if ("0x" === e.slice(0, 2)) {
          r = [];
          for (var o = 2, a = e.length; o < a; o += 2) r.push(parseInt(e.slice(o, o + 2), 16))
        } else r = e;
        return c(s(t), r)
      };
    module.exports = {
      keccak256: l(256),
      keccak512: l(512),
      keccak256s: l(256),
      keccak512s: l(512)
    };
  }, {}],
  "V3wT": [function(require, module, exports) {
    var process = require("process");
    var global = arguments[3];
    var define;
    var t, r = require("process"),
      e = arguments[3];
    ! function() {
      "use strict";
      var n = "input is invalid type",
        i = "object" == typeof window,
        o = i ? window : {};
      o.JS_SHA3_NO_WINDOW && (i = !1);
      var a = !i && "object" == typeof self;
      !o.JS_SHA3_NO_NODE_JS && "object" == typeof r && r.versions && r.versions.node ? o = e : a && (o = self);
      var s = !o.JS_SHA3_NO_COMMON_JS && "object" == typeof module && module.exports,
        u = "function" == typeof t && t.amd,
        f = !o.JS_SHA3_NO_ARRAY_BUFFER && "undefined" != typeof ArrayBuffer,
        h = "0123456789abcdef".split(""),
        c = [4, 1024, 262144, 67108864],
        p = [0, 8, 16, 24],
        d = [1, 0, 32898, 0, 32906, 2147483648, 2147516416, 2147483648, 32907, 0, 2147483649, 0, 2147516545, 2147483648, 32777, 2147483648, 138, 0, 136, 0, 2147516425, 0, 2147483658, 0, 2147516555, 0, 139, 2147483648, 32905, 2147483648, 32771, 2147483648, 32770, 2147483648, 128, 2147483648, 32778, 0, 2147483658, 2147483648, 2147516545, 2147483648, 32896, 2147483648, 2147483649, 0, 2147516424, 2147483648],
        l = [224, 256, 384, 512],
        y = [128, 256],
        b = ["hex", "buffer", "arrayBuffer", "array", "digest"],
        A = {
          128: 168,
          256: 136
        };
      !o.JS_SHA3_NO_NODE_JS && Array.isArray || (Array.isArray = function(t) {
        return "[object Array]" === Object.prototype.toString.call(t)
      }), !f || !o.JS_SHA3_NO_ARRAY_BUFFER_IS_VIEW && ArrayBuffer.isView || (ArrayBuffer.isView = function(t) {
        return "object" == typeof t && t.buffer && t.buffer.constructor === ArrayBuffer
      });
      for (var v = function(t, r, e) {
          return function(n) {
            return new J(t, r, t).update(n)[e]()
          }
        }, w = function(t, r, e) {
          return function(n, i) {
            return new J(t, r, i).update(n)[e]()
          }
        }, B = function(t, r, e) {
          return function(r, n, i, o) {
            return C["cshake" + t].update(r, n, i, o)[e]()
          }
        }, g = function(t, r, e) {
          return function(r, n, i, o) {
            return C["kmac" + t].update(r, n, i, o)[e]()
          }
        }, _ = function(t, r, e, n) {
          for (var i = 0; i < b.length; ++i) {
            var o = b[i];
            t[o] = r(e, n, o)
          }
          return t
        }, k = function(t, r) {
          var e = v(t, r, "hex");
          return e.create = function() {
            return new J(t, r, t)
          }, e.update = function(t) {
            return e.create().update(t)
          }, _(e, v, t, r)
        }, S = [{
          name: "keccak",
          padding: [1, 256, 65536, 16777216],
          bits: l,
          createMethod: k
        }, {
          name: "sha3",
          padding: [6, 1536, 393216, 100663296],
          bits: l,
          createMethod: k
        }, {
          name: "shake",
          padding: [31, 7936, 2031616, 520093696],
          bits: y,
          createMethod: function(t, r) {
            var e = w(t, r, "hex");
            return e.create = function(e) {
              return new J(t, r, e)
            }, e.update = function(t, r) {
              return e.create(r).update(t)
            }, _(e, w, t, r)
          }
        }, {
          name: "cshake",
          padding: c,
          bits: y,
          createMethod: function(t, r) {
            var e = A[t],
              n = B(t, 0, "hex");
            return n.create = function(n, i, o) {
              return i || o ? new J(t, r, n).bytepad([i, o], e) : C["shake" + t].create(n)
            }, n.update = function(t, r, e, i) {
              return n.create(r, e, i).update(t)
            }, _(n, B, t, r)
          }
        }, {
          name: "kmac",
          padding: c,
          bits: y,
          createMethod: function(t, r) {
            var e = A[t],
              n = g(t, 0, "hex");
            return n.create = function(n, i, o) {
              return new M(t, r, i).bytepad(["KMAC", o], e).bytepad([n], e)
            }, n.update = function(t, r, e, i) {
              return n.create(t, e, i).update(r)
            }, _(n, g, t, r)
          }
        }], C = {}, m = [], x = 0; x < S.length; ++x)
        for (var E = S[x], O = E.bits, z = 0; z < O.length; ++z) {
          var N = E.name + "_" + O[z];
          if (m.push(N), C[N] = E.createMethod(O[z], E.padding), "sha3" !== E.name) {
            var j = E.name + O[z];
            m.push(j), C[j] = C[N]
          }
        }

      function J(t, r, e) {
        this.blocks = [], this.s = [], this.padding = r, this.outputBits = e, this.reset = !0, this.finalized = !1, this.block = 0, this.start = 0, this.blockCount = 1600 - (t << 1) >> 5, this.byteCount = this.blockCount << 2, this.outputBlocks = e >> 5, this.extraBytes = (31 & e) >> 3;
        for (var n = 0; n < 50; ++n) this.s[n] = 0
      }

      function M(t, r, e) {
        J.call(this, t, r, e)
      }
      J.prototype.update = function(t) {
        if (this.finalized) throw new Error("finalize already called");
        var r, e = typeof t;
        if ("string" !== e) {
          if ("object" !== e) throw new Error(n);
          if (null === t) throw new Error(n);
          if (f && t.constructor === ArrayBuffer) t = new Uint8Array(t);
          else if (!(Array.isArray(t) || f && ArrayBuffer.isView(t))) throw new Error(n);
          r = !0
        }
        for (var i, o, a = this.blocks, s = this.byteCount, u = t.length, h = this.blockCount, c = 0, d = this.s; c < u;) {
          if (this.reset)
            for (this.reset = !1, a[0] = this.block, i = 1; i < h + 1; ++i) a[i] = 0;
          if (r)
            for (i = this.start; c < u && i < s; ++c) a[i >> 2] |= t[c] << p[3 & i++];
          else
            for (i = this.start; c < u && i < s; ++c)(o = t.charCodeAt(c)) < 128 ? a[i >> 2] |= o << p[3 & i++] : o < 2048 ? (a[i >> 2] |= (192 | o >> 6) << p[3 & i++], a[i >> 2] |= (128 | 63 & o) << p[3 & i++]) : o < 55296 || o >= 57344 ? (a[i >> 2] |= (224 | o >> 12) << p[3 & i++], a[i >> 2] |= (128 | o >> 6 & 63) << p[3 & i++], a[i >> 2] |= (128 | 63 & o) << p[3 & i++]) : (o = 65536 + ((1023 & o) << 10 | 1023 & t.charCodeAt(++c)), a[i >> 2] |= (240 | o >> 18) << p[3 & i++], a[i >> 2] |= (128 | o >> 12 & 63) << p[3 & i++], a[i >> 2] |= (128 | o >> 6 & 63) << p[3 & i++], a[i >> 2] |= (128 | 63 & o) << p[3 & i++]);
          if (this.lastByteIndex = i, i >= s) {
            for (this.start = i - s, this.block = a[h], i = 0; i < h; ++i) d[i] ^= a[i];
            H(d), this.reset = !0
          } else this.start = i
        }
        return this
      }, J.prototype.encode = function(t, r) {
        var e = 255 & t,
          n = 1,
          i = [e];
        for (e = 255 & (t >>= 8); e > 0;) i.unshift(e), e = 255 & (t >>= 8), ++n;
        return r ? i.push(n) : i.unshift(n), this.update(i), i.length
      }, J.prototype.encodeString = function(t) {
        var r, e = typeof t;
        if ("string" !== e) {
          if ("object" !== e) throw new Error(n);
          if (null === t) throw new Error(n);
          if (f && t.constructor === ArrayBuffer) t = new Uint8Array(t);
          else if (!(Array.isArray(t) || f && ArrayBuffer.isView(t))) throw new Error(n);
          r = !0
        }
        var i = 0,
          o = t.length;
        if (r) i = o;
        else
          for (var a = 0; a < t.length; ++a) {
            var s = t.charCodeAt(a);
            s < 128 ? i += 1 : s < 2048 ? i += 2 : s < 55296 || s >= 57344 ? i += 3 : (s = 65536 + ((1023 & s) << 10 | 1023 & t.charCodeAt(++a)), i += 4)
          }
        return i += this.encode(8 * i), this.update(t), i
      }, J.prototype.bytepad = function(t, r) {
        for (var e = this.encode(r), n = 0; n < t.length; ++n) e += this.encodeString(t[n]);
        var i = r - e % r,
          o = [];
        return o.length = i, this.update(o), this
      }, J.prototype.finalize = function() {
        if (!this.finalized) {
          this.finalized = !0;
          var t = this.blocks,
            r = this.lastByteIndex,
            e = this.blockCount,
            n = this.s;
          if (t[r >> 2] |= this.padding[3 & r], this.lastByteIndex === this.byteCount)
            for (t[0] = t[e], r = 1; r < e + 1; ++r) t[r] = 0;
          for (t[e - 1] |= 2147483648, r = 0; r < e; ++r) n[r] ^= t[r];
          H(n)
        }
      }, J.prototype.toString = J.prototype.hex = function() {
        this.finalize();
        for (var t, r = this.blockCount, e = this.s, n = this.outputBlocks, i = this.extraBytes, o = 0, a = 0, s = ""; a < n;) {
          for (o = 0; o < r && a < n; ++o, ++a) t = e[o], s += h[t >> 4 & 15] + h[15 & t] + h[t >> 12 & 15] + h[t >> 8 & 15] + h[t >> 20 & 15] + h[t >> 16 & 15] + h[t >> 28 & 15] + h[t >> 24 & 15];
          a % r == 0 && (H(e), o = 0)
        }
        return i && (t = e[o], s += h[t >> 4 & 15] + h[15 & t], i > 1 && (s += h[t >> 12 & 15] + h[t >> 8 & 15]), i > 2 && (s += h[t >> 20 & 15] + h[t >> 16 & 15])), s
      }, J.prototype.arrayBuffer = function() {
        this.finalize();
        var t, r = this.blockCount,
          e = this.s,
          n = this.outputBlocks,
          i = this.extraBytes,
          o = 0,
          a = 0,
          s = this.outputBits >> 3;
        t = i ? new ArrayBuffer(n + 1 << 2) : new ArrayBuffer(s);
        for (var u = new Uint32Array(t); a < n;) {
          for (o = 0; o < r && a < n; ++o, ++a) u[a] = e[o];
          a % r == 0 && H(e)
        }
        return i && (u[o] = e[o], t = t.slice(0, s)), t
      }, J.prototype.buffer = J.prototype.arrayBuffer, J.prototype.digest = J.prototype.array = function() {
        this.finalize();
        for (var t, r, e = this.blockCount, n = this.s, i = this.outputBlocks, o = this.extraBytes, a = 0, s = 0, u = []; s < i;) {
          for (a = 0; a < e && s < i; ++a, ++s) t = s << 2, r = n[a], u[t] = 255 & r, u[t + 1] = r >> 8 & 255, u[t + 2] = r >> 16 & 255, u[t + 3] = r >> 24 & 255;
          s % e == 0 && H(n)
        }
        return o && (t = s << 2, r = n[a], u[t] = 255 & r, o > 1 && (u[t + 1] = r >> 8 & 255), o > 2 && (u[t + 2] = r >> 16 & 255)), u
      }, M.prototype = new J, M.prototype.finalize = function() {
        return this.encode(this.outputBits, !0), J.prototype.finalize.call(this)
      };
      var H = function(t) {
        var r, e, n, i, o, a, s, u, f, h, c, p, l, y, b, A, v, w, B, g, _, k, S, C, m, x, E, O, z, N, j, J, M, H, I, R, U, V, F, D, W, Y, q, K, G, L, P, Q, T, X, Z, $, tt, rt, et, nt, it, ot, at, st, ut, ft, ht;
        for (n = 0; n < 48; n += 2) i = t[0] ^ t[10] ^ t[20] ^ t[30] ^ t[40], o = t[1] ^ t[11] ^ t[21] ^ t[31] ^ t[41], a = t[2] ^ t[12] ^ t[22] ^ t[32] ^ t[42], s = t[3] ^ t[13] ^ t[23] ^ t[33] ^ t[43], u = t[4] ^ t[14] ^ t[24] ^ t[34] ^ t[44], f = t[5] ^ t[15] ^ t[25] ^ t[35] ^ t[45], h = t[6] ^ t[16] ^ t[26] ^ t[36] ^ t[46], c = t[7] ^ t[17] ^ t[27] ^ t[37] ^ t[47], r = (p = t[8] ^ t[18] ^ t[28] ^ t[38] ^ t[48]) ^ (a << 1 | s >>> 31), e = (l = t[9] ^ t[19] ^ t[29] ^ t[39] ^ t[49]) ^ (s << 1 | a >>> 31), t[0] ^= r, t[1] ^= e, t[10] ^= r, t[11] ^= e, t[20] ^= r, t[21] ^= e, t[30] ^= r, t[31] ^= e, t[40] ^= r, t[41] ^= e, r = i ^ (u << 1 | f >>> 31), e = o ^ (f << 1 | u >>> 31), t[2] ^= r, t[3] ^= e, t[12] ^= r, t[13] ^= e, t[22] ^= r, t[23] ^= e, t[32] ^= r, t[33] ^= e, t[42] ^= r, t[43] ^= e, r = a ^ (h << 1 | c >>> 31), e = s ^ (c << 1 | h >>> 31), t[4] ^= r, t[5] ^= e, t[14] ^= r, t[15] ^= e, t[24] ^= r, t[25] ^= e, t[34] ^= r, t[35] ^= e, t[44] ^= r, t[45] ^= e, r = u ^ (p << 1 | l >>> 31), e = f ^ (l << 1 | p >>> 31), t[6] ^= r, t[7] ^= e, t[16] ^= r, t[17] ^= e, t[26] ^= r, t[27] ^= e, t[36] ^= r, t[37] ^= e, t[46] ^= r, t[47] ^= e, r = h ^ (i << 1 | o >>> 31), e = c ^ (o << 1 | i >>> 31), t[8] ^= r, t[9] ^= e, t[18] ^= r, t[19] ^= e, t[28] ^= r, t[29] ^= e, t[38] ^= r, t[39] ^= e, t[48] ^= r, t[49] ^= e, y = t[0], b = t[1], L = t[11] << 4 | t[10] >>> 28, P = t[10] << 4 | t[11] >>> 28, O = t[20] << 3 | t[21] >>> 29, z = t[21] << 3 | t[20] >>> 29, st = t[31] << 9 | t[30] >>> 23, ut = t[30] << 9 | t[31] >>> 23, Y = t[40] << 18 | t[41] >>> 14, q = t[41] << 18 | t[40] >>> 14, H = t[2] << 1 | t[3] >>> 31, I = t[3] << 1 | t[2] >>> 31, A = t[13] << 12 | t[12] >>> 20, v = t[12] << 12 | t[13] >>> 20, Q = t[22] << 10 | t[23] >>> 22, T = t[23] << 10 | t[22] >>> 22, N = t[33] << 13 | t[32] >>> 19, j = t[32] << 13 | t[33] >>> 19, ft = t[42] << 2 | t[43] >>> 30, ht = t[43] << 2 | t[42] >>> 30, rt = t[5] << 30 | t[4] >>> 2, et = t[4] << 30 | t[5] >>> 2, R = t[14] << 6 | t[15] >>> 26, U = t[15] << 6 | t[14] >>> 26, w = t[25] << 11 | t[24] >>> 21, B = t[24] << 11 | t[25] >>> 21, X = t[34] << 15 | t[35] >>> 17, Z = t[35] << 15 | t[34] >>> 17, J = t[45] << 29 | t[44] >>> 3, M = t[44] << 29 | t[45] >>> 3, C = t[6] << 28 | t[7] >>> 4, m = t[7] << 28 | t[6] >>> 4, nt = t[17] << 23 | t[16] >>> 9, it = t[16] << 23 | t[17] >>> 9, V = t[26] << 25 | t[27] >>> 7, F = t[27] << 25 | t[26] >>> 7, g = t[36] << 21 | t[37] >>> 11, _ = t[37] << 21 | t[36] >>> 11, $ = t[47] << 24 | t[46] >>> 8, tt = t[46] << 24 | t[47] >>> 8, K = t[8] << 27 | t[9] >>> 5, G = t[9] << 27 | t[8] >>> 5, x = t[18] << 20 | t[19] >>> 12, E = t[19] << 20 | t[18] >>> 12, ot = t[29] << 7 | t[28] >>> 25, at = t[28] << 7 | t[29] >>> 25, D = t[38] << 8 | t[39] >>> 24, W = t[39] << 8 | t[38] >>> 24, k = t[48] << 14 | t[49] >>> 18, S = t[49] << 14 | t[48] >>> 18, t[0] = y ^ ~A & w, t[1] = b ^ ~v & B, t[10] = C ^ ~x & O, t[11] = m ^ ~E & z, t[20] = H ^ ~R & V, t[21] = I ^ ~U & F, t[30] = K ^ ~L & Q, t[31] = G ^ ~P & T, t[40] = rt ^ ~nt & ot, t[41] = et ^ ~it & at, t[2] = A ^ ~w & g, t[3] = v ^ ~B & _, t[12] = x ^ ~O & N, t[13] = E ^ ~z & j, t[22] = R ^ ~V & D, t[23] = U ^ ~F & W, t[32] = L ^ ~Q & X, t[33] = P ^ ~T & Z, t[42] = nt ^ ~ot & st, t[43] = it ^ ~at & ut, t[4] = w ^ ~g & k, t[5] = B ^ ~_ & S, t[14] = O ^ ~N & J, t[15] = z ^ ~j & M, t[24] = V ^ ~D & Y, t[25] = F ^ ~W & q, t[34] = Q ^ ~X & $, t[35] = T ^ ~Z & tt, t[44] = ot ^ ~st & ft, t[45] = at ^ ~ut & ht, t[6] = g ^ ~k & y, t[7] = _ ^ ~S & b, t[16] = N ^ ~J & C, t[17] = j ^ ~M & m, t[26] = D ^ ~Y & H, t[27] = W ^ ~q & I, t[36] = X ^ ~$ & K, t[37] = Z ^ ~tt & G, t[46] = st ^ ~ft & rt, t[47] = ut ^ ~ht & et, t[8] = k ^ ~y & A, t[9] = S ^ ~b & v, t[18] = J ^ ~C & x, t[19] = M ^ ~m & E, t[28] = Y ^ ~H & R, t[29] = q ^ ~I & U, t[38] = $ ^ ~K & L, t[39] = tt ^ ~G & P, t[48] = ft ^ ~rt & nt, t[49] = ht ^ ~et & it, t[0] ^= d[n], t[1] ^= d[n + 1]
      };
      if (s) module.exports = C;
      else {
        for (x = 0; x < m.length; ++x) o[m[x]] = C[m[x]];
        u && t(function() {
          return C
        })
      }
    }();
  }, {
    "process": "pBGv"
  }],
  "yZAl": [function(require, module, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    const r = require("js-sha3");

    function t(t) {
      return "0x" + r.keccak_256(n(t))
    }

    function e(r) {
      const t = [];
      for (let e = 0; e < r.length; e++) t.push((r[e] >>> 4).toString(16)), t.push((15 & r[e]).toString(16));
      return `0x${t.join("").replace(/^0+/,"")}`
    }

    function n(r) {
      if (null == r) throw new Error("cannot convert null value to array");
      if ("string" == typeof r) {
        const t = r.match(/^(0x)?[0-9a-fA-F]*$/);
        if (!t) throw new Error("invalid hexidecimal string");
        if ("0x" !== t[1]) throw new Error("hex string must have 0x prefix");
        (r = r.substring(2)).length % 2 && (r = "0" + r);
        const e = [];
        for (let n = 0; n < r.length; n += 2) e.push(parseInt(r.substr(n, 2), 16));
        return i(new Uint8Array(e))
      }
      if (o(r)) return i(new Uint8Array(r));
      throw new Error("invalid arrayify value")
    }

    function o(r) {
      if (!r || parseInt(String(r.length)) != r.length || "string" == typeof r) return !1;
      for (let t = 0; t < r.length; t++) {
        const e = r[t];
        if (e < 0 || e >= 256 || parseInt(String(e)) != e) return !1
      }
      return !0
    }

    function i(r) {
      return void 0 !== r.slice ? r : (r.slice = (() => {
        const t = Array.prototype.slice.call(arguments);
        return i(new Uint8Array(Array.prototype.slice.apply(r, t)))
      }), r)
    }
    exports.keccak256 = t, exports.padLeft = ((r, t) => {
      const e = /^0x/i.test(r) || "number" == typeof r,
        n = t - (r = r.toString().replace(/^0x/i, "")).length + 1 >= 0 ? t - r.length + 1 : 0;
      return (e ? "0x" : "") + new Array(n).join("0") + r
    }), exports.bytesToHex = e, exports.toByteArray = n;
  }, {
    "js-sha3": "V3wT"
  }],
  "PtpP": [function(require, module, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    const r = require("./utils");

    function t(r) {
      return "string" == typeof r && (!!/^(0x)?[0-9a-f]{512}$/i.test(r) && !(!/^(0x)?[0-9a-f]{512}$/.test(r) && !/^(0x)?[0-9A-F]{512}$/.test(r)))
    }

    function e(t, e) {
      "object" == typeof e && e.constructor === Uint8Array && (e = r.bytesToHex(e));
      const n = r.keccak256(e).replace("0x", "");
      for (let r = 0; r < 12; r += 4) {
        const e = (parseInt(n.substr(r, 2), 16) << 8) + parseInt(n.substr(r + 2, 2), 16) & 2047,
          i = 1 << e % 4;
        if ((o(t.charCodeAt(t.length - 1 - Math.floor(e / 4))) & i) !== i) return !1
      }
      return !0
    }

    function o(r) {
      if (r >= 48 && r <= 57) return r - 48;
      if (r >= 65 && r <= 70) return r - 55;
      if (r >= 97 && r <= 102) return r - 87;
      throw new Error("invalid bloom")
    }

    function n(o, n) {
      if (!t(o)) throw new Error("Invalid bloom given");
      if (!u(n)) throw new Error(`Invalid ethereum address given: "${n}"`);
      return e(o, r.padLeft(n, 64))
    }

    function i(r, o) {
      if (!t(r)) throw new Error("Invalid bloom given");
      if (!u(o)) throw new Error(`Invalid contract address given: "${o}"`);
      return e(r, o)
    }

    function s(r, o) {
      if (!t(r)) throw new Error("Invalid bloom given");
      if (!f(o)) throw new Error("Invalid topic");
      return e(r, o)
    }

    function f(r) {
      return "string" == typeof r && (!!/^(0x)?[0-9a-f]{64}$/i.test(r) && !(!/^(0x)?[0-9a-f]{64}$/.test(r) && !/^(0x)?[0-9A-F]{64}$/.test(r)))
    }

    function u(r) {
      return "string" == typeof r && (!!r.match(/^(0x)?[0-9a-fA-F]{40}$/) || !!r.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/))
    }
    exports.isBloom = t, exports.isInBloom = e, exports.isUserEthereumAddressInBloom = n, exports.isContractAddressInBloom = i, exports.isTopicInBloom = s, exports.isTopic = f, exports.isAddress = u;
  }, {
    "./utils": "yZAl"
  }],
  "rSMz": [function(require, module, exports) {
    var Buffer = require("buffer").Buffer;
    var r = require("buffer").Buffer,
      e = require("underscore"),
      t = require("bn.js"),
      n = require("number-to-bn"),
      i = require("utf8"),
      o = require("eth-lib/lib/hash"),
      u = require("ethereum-bloom-filters"),
      s = function(r) {
        return t.isBN(r)
      },
      f = function(r) {
        return r && r.constructor && "BigNumber" === r.constructor.name
      },
      a = function(r) {
        try {
          return n.apply(null, arguments)
        } catch (e) {
          throw new Error(e + ' Given value: "' + r + '"')
        }
      },
      c = function(r) {
        return "0x" + a(r).toTwos(256).toString(16, 64)
      },
      l = function(r) {
        return !!/^(0x)?[0-9a-f]{40}$/i.test(r) && (!(!/^(0x|0X)?[0-9a-f]{40}$/.test(r) && !/^(0x|0X)?[0-9A-F]{40}$/.test(r)) || x(r))
      },
      x = function(r) {
        r = r.replace(/^0x/i, "");
        for (var e = O(r.toLowerCase()).replace(/^0x/i, ""), t = 0; t < 40; t++)
          if (parseInt(e[t], 16) > 7 && r[t].toUpperCase() !== r[t] || parseInt(e[t], 16) <= 7 && r[t].toLowerCase() !== r[t]) return !1;
        return !0
      },
      h = function(r, e, t) {
        var n = /^0x/i.test(r) || "number" == typeof r,
          i = e - (r = r.toString(16).replace(/^0x/i, "")).length + 1 >= 0 ? e - r.length + 1 : 0;
        return (n ? "0x" : "") + new Array(i).join(t || "0") + r
      },
      d = function(r, e, t) {
        var n = /^0x/i.test(r) || "number" == typeof r,
          i = e - (r = r.toString(16).replace(/^0x/i, "")).length + 1 >= 0 ? e - r.length + 1 : 0;
        return (n ? "0x" : "") + r + new Array(i).join(t || "0")
      },
      g = function(r) {
        var e = "";
        r = (r = (r = (r = (r = i.encode(r)).replace(/^(?:\u0000)*/, "")).split("").reverse().join("")).replace(/^(?:\u0000)*/, "")).split("").reverse().join("");
        for (var t = 0; t < r.length; t++) {
          var n = r.charCodeAt(t).toString(16);
          e += n.length < 2 ? "0" + n : n
        }
        return "0x" + e
      },
      p = function(r) {
        if (!T(r)) throw new Error('The parameter "' + r + '" must be a valid HEX string.');
        for (var e = "", t = 0, n = (r = (r = (r = (r = (r = r.replace(/^0x/i, "")).replace(/^(?:00)*/, "")).split("").reverse().join("")).replace(/^(?:00)*/, "")).split("").reverse().join("")).length, o = 0; o < n; o += 2) t = parseInt(r.substr(o, 2), 16), e += String.fromCharCode(t);
        return i.decode(e)
      },
      m = function(r) {
        if (!r) return r;
        if (e.isString(r) && !T(r)) throw new Error('Given value "' + r + '" is not a valid hex string.');
        return a(r).toNumber()
      },
      b = function(r) {
        if (!r) return r;
        if (e.isString(r) && !T(r)) throw new Error('Given value "' + r + '" is not a valid hex string.');
        return a(r).toString(10)
      },
      v = function(r) {
        if (e.isNull(r) || e.isUndefined(r)) return r;
        if (!isFinite(r) && !T(r)) throw new Error('Given input "' + r + '" is not a number.');
        var n = a(r),
          i = n.toString(16);
        return n.lt(new t(0)) ? "-0x" + i.substr(1) : "0x" + i
      },
      w = function(r) {
        for (var e = [], t = 0; t < r.length; t++) e.push((r[t] >>> 4).toString(16)), e.push((15 & r[t]).toString(16));
        return "0x" + e.join("")
      },
      S = function(r) {
        if (r = r.toString(16), !T(r)) throw new Error('Given value "' + r + '" is not a valid hex string.');
        r = r.replace(/^0x/i, "");
        for (var e = [], t = 0; t < r.length; t += 2) e.push(parseInt(r.substr(t, 2), 16));
        return e
      },
      B = function(t, n) {
        if (l(t)) return n ? "address" : "0x" + t.toLowerCase().replace(/^0x/i, "");
        if (e.isBoolean(t)) return n ? "bool" : t ? "0x01" : "0x00";
        if (r.isBuffer(t)) return "0x" + t.toString("hex");
        if (e.isObject(t) && !f(t) && !s(t)) return n ? "string" : g(JSON.stringify(t));
        if (e.isString(t)) {
          if (0 === t.indexOf("-0x") || 0 === t.indexOf("-0X")) return n ? "int256" : v(t);
          if (0 === t.indexOf("0x") || 0 === t.indexOf("0X")) return n ? "bytes" : t;
          if (!isFinite(t)) return n ? "string" : g(t)
        }
        return n ? t < 0 ? "int256" : "uint256" : v(t)
      },
      T = function(r) {
        return (e.isString(r) || e.isNumber(r)) && /^(-)?0x[0-9a-f]*$/i.test(r)
      },
      N = function(r) {
        return (e.isString(r) || e.isNumber(r)) && /^(-0x|0x)?[0-9a-f]*$/i.test(r)
      },
      I = function(r) {
        return 0 !== r && N(r) ? r.replace(/^(-)?0x/i, "$1") : r
      },
      C = function(r) {
        return u.isBloom(r)
      },
      y = function(r, e) {
        return u.isUserEthereumAddressInBloom(r, e)
      },
      A = function(r, e) {
        return u.isContractAddressInBloom(r, e)
      },
      j = function(r) {
        return u.isTopic(r)
      },
      E = function(r, e) {
        return u.isTopicInBloom(r, e)
      },
      H = function(r, e) {
        return u.isInBloom(r, e)
      },
      q = "0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470",
      O = function(r) {
        s(r) && (r = r.toString()), T(r) && /^0x/i.test(r.toString()) && (r = S(r));
        var e = o.keccak256(r);
        return e === q ? null : e
      };
    O._Hash = o;
    var $ = function(r) {
      return null === (r = O(r)) ? q : r
    };
    module.exports = {
      BN: t,
      isBN: s,
      isBigNumber: f,
      toBN: a,
      isAddress: l,
      isBloom: C,
      isUserEthereumAddressInBloom: y,
      isContractAddressInBloom: A,
      isTopic: j,
      isTopicInBloom: E,
      isInBloom: H,
      checkAddressChecksum: x,
      utf8ToHex: g,
      hexToUtf8: p,
      hexToNumber: m,
      hexToNumberString: b,
      numberToHex: v,
      toHex: B,
      hexToBytes: S,
      bytesToHex: w,
      isHex: N,
      isHexStrict: T,
      stripHexPrefix: I,
      leftPad: h,
      rightPad: d,
      toTwosComplement: c,
      sha3: O,
      sha3Raw: $
    };
  }, {
    "underscore": "h15N",
    "bn.js": "AGD1",
    "number-to-bn": "EEAC",
    "utf8": "OBrI",
    "eth-lib/lib/hash": "Swo0",
    "ethereum-bloom-filters": "PtpP",
    "buffer": "dskh"
  }],
  "R2gG": [function(require, module, exports) {
    function t(r) {
      return (t = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t) {
        return typeof t
      } : function(t) {
        return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
      })(r)
    }
    var r = require("underscore"),
      e = require("bn.js"),
      i = require("./utils.js"),
      n = function(t) {
        return t.startsWith("int[") ? "int256" + t.slice(3) : "int" === t ? "int256" : t.startsWith("uint[") ? "uint256" + t.slice(4) : "uint" === t ? "uint256" : t.startsWith("fixed[") ? "fixed128x128" + t.slice(5) : "fixed" === t ? "fixed128x128" : t.startsWith("ufixed[") ? "ufixed128x128" + t.slice(6) : "ufixed" === t ? "ufixed128x128" : t
      },
      o = function(t) {
        var r = /^\D+(\d+).*$/.exec(t);
        return r ? parseInt(r[1], 10) : null
      },
      s = function(t) {
        var r = /^\D+\d*\[(\d+)\]$/.exec(t);
        return r ? parseInt(r[1], 10) : null
      },
      a = function(r) {
        var n = t(r);
        if ("string" === n) return i.isHexStrict(r) ? new e(r.replace(/0x/i, ""), 16) : new e(r, 10);
        if ("number" === n) return new e(r);
        if (i.isBigNumber(r)) return new e(r.toString(10));
        if (i.isBN(r)) return r;
        throw new Error(r + " is not a number")
      },
      u = function(t, r, s) {
        var u, f;
        if ("bytes" === (t = n(t))) {
          if (r.replace(/^0x/i, "").length % 2 != 0) throw new Error("Invalid bytes characters " + r.length);
          return r
        }
        if ("string" === t) return i.utf8ToHex(r);
        if ("bool" === t) return r ? "01" : "00";
        if (t.startsWith("address")) {
          if (u = s ? 64 : 40, !i.isAddress(r)) throw new Error(r + " is not a valid address, or the checksum is invalid.");
          return i.leftPad(r.toLowerCase(), u)
        }
        if (u = o(t), t.startsWith("bytes")) {
          if (!u) throw new Error("bytes[] not yet supported in solidity");
          if (s && (u = 32), u < 1 || u > 32 || u < r.replace(/^0x/i, "").length / 2) throw new Error("Invalid bytes" + u + " for " + r);
          return i.rightPad(r, 2 * u)
        }
        if (t.startsWith("uint")) {
          if (u % 8 || u < 8 || u > 256) throw new Error("Invalid uint" + u + " size");
          if ((f = a(r)).bitLength() > u) throw new Error("Supplied uint exceeds width: " + u + " vs " + f.bitLength());
          if (f.lt(new e(0))) throw new Error("Supplied uint " + f.toString() + " is negative");
          return u ? i.leftPad(f.toString("hex"), u / 8 * 2) : f
        }
        if (t.startsWith("int")) {
          if (u % 8 || u < 8 || u > 256) throw new Error("Invalid int" + u + " size");
          if ((f = a(r)).bitLength() > u) throw new Error("Supplied int exceeds width: " + u + " vs " + f.bitLength());
          return f.lt(new e(0)) ? f.toTwos(u).toString("hex") : u ? i.leftPad(f.toString("hex"), u / 8 * 2) : f
        }
        throw new Error("Unsupported or invalid type: " + t)
      },
      f = function(t) {
        if (r.isArray(t)) throw new Error("Autodetection of array types is not supported.");
        var n, o, a = "";
        if (r.isObject(t) && (t.hasOwnProperty("v") || t.hasOwnProperty("t") || t.hasOwnProperty("value") || t.hasOwnProperty("type")) ? (n = t.hasOwnProperty("t") ? t.t : t.type, a = t.hasOwnProperty("v") ? t.v : t.value) : (n = i.toHex(t, !0), a = i.toHex(t), n.startsWith("int") || n.startsWith("uint") || (n = "bytes")), !n.startsWith("int") && !n.startsWith("uint") || "string" != typeof a || /^(-)?0x/i.test(a) || (a = new e(a)), r.isArray(a)) {
          if ((o = s(n)) && a.length !== o) throw new Error(n + " is not matching the given array " + JSON.stringify(a));
          o = a.length
        }
        return r.isArray(a) ? a.map(function(t) {
          return u(n, t, o).toString("hex").replace("0x", "")
        }).join("") : u(n, a, o).toString("hex").replace("0x", "")
      },
      h = function() {
        var t = Array.prototype.slice.call(arguments),
          e = r.map(t, f);
        return i.sha3("0x" + e.join(""))
      },
      l = function() {
        return i.sha3Raw("0x" + r.map(Array.prototype.slice.call(arguments), f).join(""))
      },
      p = function() {
        var t = Array.prototype.slice.call(arguments);
        return "0x" + r.map(t, f).join("").toLowerCase()
      };
    module.exports = {
      soliditySha3: h,
      soliditySha3Raw: l,
      encodePacked: p
    };
  }, {
    "underscore": "h15N",
    "bn.js": "AGD1",
    "./utils.js": "rSMz"
  }],
  "Wugr": [function(require, module, exports) {

    var r = require("buffer"),
      e = r.Buffer;

    function n(r, e) {
      for (var n in r) e[n] = r[n]
    }

    function o(r, n, o) {
      return e(r, n, o)
    }
    e.from && e.alloc && e.allocUnsafe && e.allocUnsafeSlow ? module.exports = r : (n(r, exports), exports.Buffer = o), n(e, o), o.from = function(r, n, o) {
      if ("number" == typeof r) throw new TypeError("Argument must not be a number");
      return e(r, n, o)
    }, o.alloc = function(r, n, o) {
      if ("number" != typeof r) throw new TypeError("Argument must be a number");
      var f = e(r);
      return void 0 !== n ? "string" == typeof o ? f.fill(n, o) : f.fill(n) : f.fill(0), f
    }, o.allocUnsafe = function(r) {
      if ("number" != typeof r) throw new TypeError("Argument must be a number");
      return e(r)
    }, o.allocUnsafeSlow = function(e) {
      if ("number" != typeof e) throw new TypeError("Argument must be a number");
      return r.SlowBuffer(e)
    };
  }, {
    "buffer": "dskh"
  }],
  "XJNj": [function(require, module, exports) {

    var global = arguments[3];
    var process = require("process");
    var e = arguments[3],
      r = require("process"),
      o = 65536,
      n = 4294967295;

    function t() {
      throw new Error("Secure random number generation is not supported by this browser.\nUse Chrome, Firefox or Internet Explorer 11")
    }
    var s = require("safe-buffer").Buffer,
      u = e.crypto || e.msCrypto;

    function a(e, t) {
      if (e > n) throw new RangeError("requested too many random bytes");
      var a = s.allocUnsafe(e);
      if (e > 0)
        if (e > o)
          for (var f = 0; f < e; f += o) u.getRandomValues(a.slice(f, f + o));
        else u.getRandomValues(a);
      return "function" == typeof t ? r.nextTick(function() {
        t(null, a)
      }) : a
    }
    u && u.getRandomValues ? module.exports = a : module.exports = t;
  }, {
    "safe-buffer": "Wugr",
    "process": "pBGv"
  }],
  "uckD": [function(require, module, exports) {
    function e(t) {
      return (e = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
        return typeof e
      } : function(e) {
        return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
      })(t)
    }
    var t = require("underscore"),
      r = require("ethjs-unit"),
      i = require("./utils.js"),
      o = require("./soliditySha3.js"),
      n = require("randombytes"),
      s = require("bn.js"),
      u = function(e, r, i, o, n) {
        return !t.isObject(e) || e instanceof Error || !e.data || ((t.isObject(e.data) || t.isArray(e.data)) && (e.data = JSON.stringify(e.data, null, 2)), e = e.message + "\n" + e.data), t.isString(e) && (e = new Error(e)), t.isFunction(o) && o(e, n), t.isFunction(i) && ((r && t.isFunction(r.listeners) && r.listeners("error").length || t.isFunction(o)) && r.catch(function() {}), setTimeout(function() {
          i(e)
        }, 1)), r && t.isFunction(r.emit) && setTimeout(function() {
          r.emit("error", e, n), r.removeAllListeners()
        }, 1), r
      },
      a = function(e) {
        return t.isObject(e) && e.name && -1 !== e.name.indexOf("(") ? e.name : e.name + "(" + f(!1, e.inputs).join(",") + ")"
      },
      f = function r(i, o) {
        var n = [];
        return o.forEach(function(o) {
          if ("object" === e(o.components)) {
            if ("tuple" !== o.type.substring(0, 5)) throw new Error("components found but type is not tuple; report on GitHub");
            var s = "",
              u = o.type.indexOf("[");
            u >= 0 && (s = o.type.substring(u));
            var a = r(i, o.components);
            t.isArray(a) && i ? n.push("tuple(" + a.join(",") + ")" + s) : i ? n.push("(" + a + ")") : n.push("(" + a.join(",") + ")" + s)
          } else n.push(o.type)
        }), n
      },
      c = function(e) {
        return "0x" + n(e).toString("hex")
      },
      m = function(e) {
        if (!i.isHexStrict(e)) throw new Error("The parameter must be a valid HEX string.");
        var t = "",
          r = 0,
          o = e.length;
        for ("0x" === e.substring(0, 2) && (r = 2); r < o; r += 2) {
          var n = parseInt(e.substr(r, 2), 16);
          t += String.fromCharCode(n)
        }
        return t
      },
      l = function(e) {
        if (!e) return "0x00";
        for (var t = "", r = 0; r < e.length; r++) {
          var i = e.charCodeAt(r).toString(16);
          t += i.length < 2 ? "0" + i : i
        }
        return "0x" + t
      },
      d = function(e) {
        if (e = e ? e.toLowerCase() : "ether", !r.unitMap[e]) throw new Error('This unit "' + e + "\" doesn't exist, please use the one of the following units" + JSON.stringify(r.unitMap, null, 2));
        return e
      },
      h = function(e, o) {
        if (o = d(o), !i.isBN(e) && !t.isString(e)) throw new Error("Please pass numbers as strings or BN objects to avoid precision errors.");
        return i.isBN(e) ? r.fromWei(e, o) : r.fromWei(e, o).toString(10)
      },
      p = function(e, o) {
        if (o = d(o), !i.isBN(e) && !t.isString(e)) throw new Error("Please pass numbers as strings or BN objects to avoid precision errors.");
        return i.isBN(e) ? r.toWei(e, o) : r.toWei(e, o).toString(10)
      },
      x = function(e) {
        if (void 0 === e) return "";
        if (!/^(0x)?[0-9a-f]{40}$/i.test(e)) throw new Error('Given address "' + e + '" is not a valid Ethereum address.');
        e = e.toLowerCase().replace(/^0x/i, "");
        for (var t = i.sha3(e).replace(/^0x/i, ""), r = "0x", o = 0; o < e.length; o++) parseInt(t[o], 16) > 7 ? r += e[o].toUpperCase() : r += e[o];
        return r
      },
      g = function(e, t) {
        if (e == t) return 0;
        if ("genesis" != e && "earliest" != e && 0 != e || "genesis" != t && "earliest" != t && 0 != t) {
          if ("genesis" == e || "earliest" == e) return -1;
          if ("genesis" == t || "earliest" == t) return 1;
          if ("latest" == e) return "pending" == t ? -1 : 1;
          if ("latest" === t) return "pending" == e ? 1 : -1;
          if ("pending" == e) return 1;
          if ("pending" == t) return -1;
          var r = new s(e),
            i = new s(t);
          return r.lt(i) ? -1 : r.eq(i) ? 0 : 1
        }
        return 0
      };
    module.exports = {
      _fireError: u,
      _jsonInterfaceMethodToString: a,
      _flattenTypes: f,
      randomHex: c,
      _: t,
      BN: i.BN,
      isBN: i.isBN,
      isBigNumber: i.isBigNumber,
      isHex: i.isHex,
      isHexStrict: i.isHexStrict,
      sha3: i.sha3,
      sha3Raw: i.sha3Raw,
      keccak256: i.sha3,
      soliditySha3: o.soliditySha3,
      soliditySha3Raw: o.soliditySha3Raw,
      encodePacked: o.encodePacked,
      isAddress: i.isAddress,
      checkAddressChecksum: i.checkAddressChecksum,
      toChecksumAddress: x,
      toHex: i.toHex,
      toBN: i.toBN,
      bytesToHex: i.bytesToHex,
      hexToBytes: i.hexToBytes,
      hexToNumberString: i.hexToNumberString,
      hexToNumber: i.hexToNumber,
      toDecimal: i.hexToNumber,
      numberToHex: i.numberToHex,
      fromDecimal: i.numberToHex,
      hexToUtf8: i.hexToUtf8,
      hexToString: i.hexToUtf8,
      toUtf8: i.hexToUtf8,
      stripHexPrefix: i.stripHexPrefix,
      utf8ToHex: i.utf8ToHex,
      stringToHex: i.utf8ToHex,
      fromUtf8: i.utf8ToHex,
      hexToAscii: m,
      toAscii: m,
      asciiToHex: l,
      fromAscii: l,
      unitMap: r.unitMap,
      toWei: p,
      fromWei: h,
      padLeft: i.leftPad,
      leftPad: i.leftPad,
      padRight: i.rightPad,
      rightPad: i.rightPad,
      toTwosComplement: i.toTwosComplement,
      isBloom: i.isBloom,
      isUserEthereumAddressInBloom: i.isUserEthereumAddressInBloom,
      isContractAddressInBloom: i.isContractAddressInBloom,
      isTopic: i.isTopic,
      isTopicInBloom: i.isTopicInBloom,
      isInBloom: i.isInBloom,
      compareBlockNumbers: g
    };
  }, {
    "underscore": "h15N",
    "ethjs-unit": "QU2j",
    "./utils.js": "rSMz",
    "./soliditySha3.js": "R2gG",
    "randombytes": "XJNj",
    "bn.js": "AGD1"
  }],
  "qamH": [function(require, module, exports) {
    "use strict";

    function e(e, n) {
      if (!(e instanceof n)) throw new TypeError("Cannot call a class as a function")
    }

    function n(e, n) {
      for (var t = 0; t < n.length; t++) {
        var r = n[t];
        r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
      }
    }

    function t(e, t, r) {
      return t && n(e.prototype, t), r && n(e, r), e
    }
    var r = require("web3-utils"),
      i = require("bn.js"),
      s = function(e, n) {
        for (var t = e; t.length < 2 * n;) t = "0" + t;
        return t
      },
      u = function(e) {
        var n = "A".charCodeAt(0),
          t = "Z".charCodeAt(0);
        return (e = (e = e.toUpperCase()).substr(4) + e.substr(0, 4)).split("").map(function(e) {
          var r = e.charCodeAt(0);
          return r >= n && r <= t ? r - n + 10 : e
        }).join("")
      },
      a = function(e) {
        for (var n, t = e; t.length > 2;) n = t.slice(0, 9), t = parseInt(n, 10) % 97 + t.slice(n.length);
        return parseInt(t, 10) % 97
      },
      o = function() {
        function n(t) {
          e(this, n), this._iban = t
        }
        return t(n, [{
          key: "isValid",
          value: function() {
            return /^XE[0-9]{2}(ETH[0-9A-Z]{13}|[0-9A-Z]{30,31})$/.test(this._iban) && 1 === a(u(this._iban))
          }
        }, {
          key: "isDirect",
          value: function() {
            return 34 === this._iban.length || 35 === this._iban.length
          }
        }, {
          key: "isIndirect",
          value: function() {
            return 20 === this._iban.length
          }
        }, {
          key: "checksum",
          value: function() {
            return this._iban.substr(2, 2)
          }
        }, {
          key: "institution",
          value: function() {
            return this.isIndirect() ? this._iban.substr(7, 4) : ""
          }
        }, {
          key: "client",
          value: function() {
            return this.isIndirect() ? this._iban.substr(11) : ""
          }
        }, {
          key: "toAddress",
          value: function() {
            if (this.isDirect()) {
              var e = this._iban.substr(4),
                n = new i(e, 36);
              return r.toChecksumAddress(n.toString(16, 20))
            }
            return ""
          }
        }, {
          key: "toString",
          value: function() {
            return this._iban
          }
        }], [{
          key: "toAddress",
          value: function(e) {
            if (!(e = new n(e)).isDirect()) throw new Error("IBAN is indirect and can't be converted");
            return e.toAddress()
          }
        }, {
          key: "toIban",
          value: function(e) {
            return n.fromAddress(e).toString()
          }
        }, {
          key: "fromAddress",
          value: function(e) {
            if (!r.isAddress(e)) throw new Error("Provided address is not a valid address: " + e);
            e = e.replace("0x", "").replace("0X", "");
            var t = new i(e, 16).toString(36),
              u = s(t, 15);
            return n.fromBban(u.toUpperCase())
          }
        }, {
          key: "fromBban",
          value: function(e) {
            return new n("XE" + ("0" + (98 - a(u("XE00" + e)))).slice(-2) + e)
          }
        }, {
          key: "createIndirect",
          value: function(e) {
            return n.fromBban("ETH" + e.institution + e.identifier)
          }
        }, {
          key: "isValid",
          value: function(e) {
            return new n(e).isValid()
          }
        }]), n
      }();
    module.exports = o;
  }, {
    "web3-utils": "uckD",
    "bn.js": "AGD1"
  }],
  "ZGhA": [function(require, module, exports) {
    "use strict";

    function t(e) {
      return (t = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t) {
        return typeof t
      } : function(t) {
        return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
      })(e)
    }
    var e = require("underscore"),
      r = require("web3-utils"),
      o = require("web3-eth-iban"),
      n = function(t) {
        return t.map(r.numberToHex)
      },
      i = function(t) {
        return t.address = r.toChecksumAddress(t.address), t.nonce = r.hexToNumberString(t.nonce), t.balance = r.hexToNumberString(t.balance), t
      },
      s = function(t) {
        return r.toBN(t).toString(10)
      },
      u = function(t) {
        return "latest" === t || "pending" === t || "earliest" === t
      },
      a = function(t) {
        return c(this && null == t ? this.defaultBlock : t)
      },
      c = function(t) {
        if (void 0 !== t) return u(t) ? t : "genesis" === t ? "0x0" : r.isHexStrict(t) ? e.isString(t) ? t.toLowerCase() : t : r.numberToHex(t)
      },
      l = function(t) {
        if (t.to && (t.to = T(t.to)), t.data && t.input) throw new Error('You can\'t have "data" and "input" as properties of transactions at the same time, please use either "data" or "input" instead.');
        if (!t.data && t.input && (t.data = t.input, delete t.input), t.data && !t.data.startsWith("0x") && (t.data = "0x" + t.data), t.data && !r.isHex(t.data)) throw new Error("The data field must be HEX encoded data.");
        return (t.gas || t.gasLimit) && (t.gas = t.gas || t.gasLimit), ["gasPrice", "gas", "value", "nonce"].filter(function(e) {
          return void 0 !== t[e]
        }).forEach(function(e) {
          t[e] = r.numberToHex(t[e])
        }), t
      },
      m = function(t) {
        var e = (t = l(t)).from || (this ? this.defaultAccount : null);
        return e && (t.from = T(e)), t
      },
      d = function(t) {
        if (t = l(t), !e.isNumber(t.from) && !e.isObject(t.from)) {
          if (t.from = t.from || (this ? this.defaultAccount : null), !t.from && !e.isNumber(t.from)) throw new Error('The send transactions "from" field must be defined!');
          t.from = T(t.from)
        }
        return t
      },
      f = function(t) {
        return r.isHexStrict(t) ? t : r.utf8ToHex(t)
      },
      b = function(t) {
        return null !== t.blockNumber && (t.blockNumber = r.hexToNumber(t.blockNumber)), null !== t.transactionIndex && (t.transactionIndex = r.hexToNumber(t.transactionIndex)), t.nonce = r.hexToNumber(t.nonce), t.gas = r.hexToNumber(t.gas), t.gasPrice = s(t.gasPrice), t.value = s(t.value), t.to && r.isAddress(t.to) ? t.to = r.toChecksumAddress(t.to) : t.to = null, t.from && (t.from = r.toChecksumAddress(t.from)), t
      },
      p = function(o) {
        if ("object" !== t(o)) throw new Error("Received receipt is invalid: " + o);
        return null !== o.blockNumber && (o.blockNumber = r.hexToNumber(o.blockNumber)), null !== o.transactionIndex && (o.transactionIndex = r.hexToNumber(o.transactionIndex)), o.cumulativeGasUsed = r.hexToNumber(o.cumulativeGasUsed), o.gasUsed = r.hexToNumber(o.gasUsed), e.isArray(o.logs) && (o.logs = o.logs.map(g)), o.contractAddress && (o.contractAddress = r.toChecksumAddress(o.contractAddress)), void 0 !== o.status && null !== o.status && (o.status = Boolean(parseInt(o.status))), o
      },
      x = function(t) {
        return t.gasLimit = r.hexToNumber(t.gasLimit), t.gasUsed = r.hexToNumber(t.gasUsed), t.size = r.hexToNumber(t.size), t.timestamp = r.hexToNumber(t.timestamp), null !== t.number && (t.number = r.hexToNumber(t.number)), t.difficulty && (t.difficulty = s(t.difficulty)), t.totalDifficulty && (t.totalDifficulty = s(t.totalDifficulty)), e.isArray(t.transactions) && t.transactions.forEach(function(t) {
          if (!e.isString(t)) return b(t)
        }), t.miner && (t.miner = r.toChecksumAddress(t.miner)), t
      },
      h = function(t) {
        var o = function(t) {
          return null == t ? null : 0 === (t = String(t)).indexOf("0x") ? t : r.fromUtf8(t)
        };
        return void 0 === t && (t = {}), void 0 === t.fromBlock && (t = {
          ...t,
          fromBlock: "latest"
        }), (t.fromBlock || 0 === t.fromBlock) && (t.fromBlock = c(t.fromBlock)), (t.toBlock || 0 === t.toBlock) && (t.toBlock = c(t.toBlock)), t.topics = t.topics || [], t.topics = t.topics.map(function(t) {
          return e.isArray(t) ? t.map(o) : o(t)
        }), o = null, t.address && (t.address = e.isArray(t.address) ? t.address.map(function(t) {
          return T(t)
        }) : T(t.address)), t
      },
      g = function(t) {
        if ("string" == typeof t.blockHash && "string" == typeof t.transactionHash && "string" == typeof t.logIndex) {
          var e = r.sha3(t.blockHash.replace("0x", "") + t.transactionHash.replace("0x", "") + t.logIndex.replace("0x", ""));
          t.id = "log_" + e.replace("0x", "").substr(0, 8)
        } else t.id || (t.id = null);
        return null !== t.blockNumber && (t.blockNumber = r.hexToNumber(t.blockNumber)), null !== t.transactionIndex && (t.transactionIndex = r.hexToNumber(t.transactionIndex)), null !== t.logIndex && (t.logIndex = r.hexToNumber(t.logIndex)), t.address && (t.address = r.toChecksumAddress(t.address)), t
      },
      k = function(t) {
        return t.ttl && (t.ttl = r.numberToHex(t.ttl)), t.workToProve && (t.workToProve = r.numberToHex(t.workToProve)), t.priority && (t.priority = r.numberToHex(t.priority)), e.isArray(t.topics) || (t.topics = t.topics ? [t.topics] : []), t.topics = t.topics.map(function(t) {
          return 0 === t.indexOf("0x") ? t : r.fromUtf8(t)
        }), t
      },
      N = function(t) {
        return t.expiry = r.hexToNumber(t.expiry), t.sent = r.hexToNumber(t.sent), t.ttl = r.hexToNumber(t.ttl), t.workProved = r.hexToNumber(t.workProved), t.topics || (t.topics = []), t.topics = t.topics.map(function(t) {
          return r.toUtf8(t)
        }), t
      },
      T = function(t) {
        var e = new o(t);
        if (e.isValid() && e.isDirect()) return e.toAddress().toLowerCase();
        if (r.isAddress(t)) return "0x" + t.toLowerCase().replace("0x", "");
        throw new Error("Provided address ".concat(t, " is invalid, the capitalization checksum test failed, or it's an indirect IBAN address which can't be converted."))
      },
      y = function(t) {
        return t.startingBlock = r.hexToNumber(t.startingBlock), t.currentBlock = r.hexToNumber(t.currentBlock), t.highestBlock = r.hexToNumber(t.highestBlock), t.knownStates && (t.knownStates = r.hexToNumber(t.knownStates), t.pulledStates = r.hexToNumber(t.pulledStates)), t
      };
    module.exports = {
      inputDefaultBlockNumberFormatter: a,
      inputBlockNumberFormatter: c,
      inputCallFormatter: m,
      inputTransactionFormatter: d,
      inputAddressFormatter: T,
      inputPostFormatter: k,
      inputLogFormatter: h,
      inputSignFormatter: f,
      inputStorageKeysFormatter: n,
      outputProofFormatter: i,
      outputBigNumberFormatter: s,
      outputTransactionFormatter: b,
      outputTransactionReceiptFormatter: p,
      outputBlockFormatter: x,
      outputLogFormatter: g,
      outputPostFormatter: N,
      outputSyncingFormatter: y
    };
  }, {
    "underscore": "h15N",
    "web3-utils": "uckD",
    "web3-eth-iban": "qamH"
  }],
  "EoeS": [function(require, module, exports) {
    "use strict";
    var r = require("./errors"),
      e = require("./formatters");
    module.exports = {
      errors: r,
      formatters: e
    };
  }, {
    "./errors": "NETG",
    "./formatters": "ZGhA"
  }],
  "sE12": [function(require, module, exports) {
    "use strict";
    var r = {
      messageId: 0,
      toPayload: function(e, o) {
        if (!e) throw new Error('JSONRPC method should be specified for params: "' + JSON.stringify(o) + '"!');
        return r.messageId++, {
          jsonrpc: "2.0",
          id: r.messageId,
          method: e,
          params: o || []
        }
      },
      isValidResponse: function(r) {
        return Array.isArray(r) ? r.every(e) : e(r);

        function e(r) {
          return !(!r || r.error || "2.0" !== r.jsonrpc || "number" != typeof r.id && "string" != typeof r.id || void 0 === r.result)
        }
      },
      toBatchPayload: function(e) {
        return e.map(function(e) {
          return r.toPayload(e.method, e.params)
        })
      }
    };
    module.exports = r;
  }, {}],
  "eTNq": [function(require, module, exports) {
    "use strict";
    var e = require("./jsonrpc"),
      r = require("web3-core-helpers").errors,
      t = function(e) {
        this.requestManager = e, this.requests = []
      };
    t.prototype.add = function(e) {
      this.requests.push(e)
    }, t.prototype.execute = function() {
      var t = this.requests;
      this.requestManager.sendBatch(t, function(s, a) {
        a = a || [], t.map(function(e, r) {
          return a[r] || {}
        }).forEach(function(a, c) {
          if (t[c].callback) {
            if (a && a.error) return t[c].callback(r.ErrorResponse(a));
            if (!e.isValidResponse(a)) return t[c].callback(r.InvalidResponse(a));
            try {
              t[c].callback(null, t[c].format ? t[c].format(a.result) : a.result)
            } catch (s) {
              t[c].callback(s)
            }
          }
        })
      })
    }, module.exports = t;
  }, {
    "./jsonrpc": "sE12",
    "web3-core-helpers": "EoeS"
  }],
  "IMA1": [function(require, module, exports) {

    "use strict";
    var e, r = null;
    try {
      e = Function("return this")()
    } catch (n) {
      e = window
    }
    void 0 !== e.ethereum ? r = e.ethereum : void 0 !== e.web3 && e.web3.currentProvider && (e.web3.currentProvider.sendAsync && (e.web3.currentProvider.send = e.web3.currentProvider.sendAsync, delete e.web3.currentProvider.sendAsync), !e.web3.currentProvider.on && e.web3.currentProvider.connection && "ipcProviderWrapper" === e.web3.currentProvider.connection.constructor.name && (e.web3.currentProvider.on = function(e, r) {
      if ("function" != typeof r) throw new Error("The second parameter callback must be a function.");
      switch (e) {
        case "data":
          this.connection.on("data", function(e) {
            var t = "";
            e = e.toString();
            try {
              t = JSON.parse(e)
            } catch (n) {
              return r(new Error("Couldn't parse response data" + e))
            }
            t.id || -1 === t.method.indexOf("_subscription") || r(null, t)
          });
          break;
        default:
          this.connection.on(e, r)
      }
    }), r = e.web3.currentProvider), module.exports = r;
  }, {}],
  "JJlS": [function(require, module, exports) {
    "use strict";
    var e = Object.prototype.hasOwnProperty,
      t = "~";

    function n() {}

    function r(e, t, n) {
      this.fn = e, this.context = t, this.once = n || !1
    }

    function o(e, n, o, s, i) {
      if ("function" != typeof o) throw new TypeError("The listener must be a function");
      var c = new r(o, s || e, i),
        f = t ? t + n : n;
      return e._events[f] ? e._events[f].fn ? e._events[f] = [e._events[f], c] : e._events[f].push(c) : (e._events[f] = c, e._eventsCount++), e
    }

    function s(e, t) {
      0 == --e._eventsCount ? e._events = new n : delete e._events[t]
    }

    function i() {
      this._events = new n, this._eventsCount = 0
    }
    Object.create && (n.prototype = Object.create(null), (new n).__proto__ || (t = !1)), i.prototype.eventNames = function() {
      var n, r, o = [];
      if (0 === this._eventsCount) return o;
      for (r in n = this._events) e.call(n, r) && o.push(t ? r.slice(1) : r);
      return Object.getOwnPropertySymbols ? o.concat(Object.getOwnPropertySymbols(n)) : o
    }, i.prototype.listeners = function(e) {
      var n = t ? t + e : e,
        r = this._events[n];
      if (!r) return [];
      if (r.fn) return [r.fn];
      for (var o = 0, s = r.length, i = new Array(s); o < s; o++) i[o] = r[o].fn;
      return i
    }, i.prototype.listenerCount = function(e) {
      var n = t ? t + e : e,
        r = this._events[n];
      return r ? r.fn ? 1 : r.length : 0
    }, i.prototype.emit = function(e, n, r, o, s, i) {
      var c = t ? t + e : e;
      if (!this._events[c]) return !1;
      var f, u, a = this._events[c],
        l = arguments.length;
      if (a.fn) {
        switch (a.once && this.removeListener(e, a.fn, void 0, !0), l) {
          case 1:
            return a.fn.call(a.context), !0;
          case 2:
            return a.fn.call(a.context, n), !0;
          case 3:
            return a.fn.call(a.context, n, r), !0;
          case 4:
            return a.fn.call(a.context, n, r, o), !0;
          case 5:
            return a.fn.call(a.context, n, r, o, s), !0;
          case 6:
            return a.fn.call(a.context, n, r, o, s, i), !0
        }
        for (u = 1, f = new Array(l - 1); u < l; u++) f[u - 1] = arguments[u];
        a.fn.apply(a.context, f)
      } else {
        var v, h = a.length;
        for (u = 0; u < h; u++) switch (a[u].once && this.removeListener(e, a[u].fn, void 0, !0), l) {
          case 1:
            a[u].fn.call(a[u].context);
            break;
          case 2:
            a[u].fn.call(a[u].context, n);
            break;
          case 3:
            a[u].fn.call(a[u].context, n, r);
            break;
          case 4:
            a[u].fn.call(a[u].context, n, r, o);
            break;
          default:
            if (!f)
              for (v = 1, f = new Array(l - 1); v < l; v++) f[v - 1] = arguments[v];
            a[u].fn.apply(a[u].context, f)
        }
      }
      return !0
    }, i.prototype.on = function(e, t, n) {
      return o(this, e, t, n, !1)
    }, i.prototype.once = function(e, t, n) {
      return o(this, e, t, n, !0)
    }, i.prototype.removeListener = function(e, n, r, o) {
      var i = t ? t + e : e;
      if (!this._events[i]) return this;
      if (!n) return s(this, i), this;
      var c = this._events[i];
      if (c.fn) c.fn !== n || o && !c.once || r && c.context !== r || s(this, i);
      else {
        for (var f = 0, u = [], a = c.length; f < a; f++)(c[f].fn !== n || o && !c[f].once || r && c[f].context !== r) && u.push(c[f]);
        u.length ? this._events[i] = 1 === u.length ? u[0] : u : s(this, i)
      }
      return this
    }, i.prototype.removeAllListeners = function(e) {
      var r;
      return e ? (r = t ? t + e : e, this._events[r] && s(this, r)) : (this._events = new n, this._eventsCount = 0), this
    }, i.prototype.off = i.prototype.removeListener, i.prototype.addListener = i.prototype.on, i.prefixed = t, i.EventEmitter = i, "undefined" != typeof module && (module.exports = i);
  }, {}],
  "FIMm": [function(require, module, exports) {
    var global = arguments[3];
    var define;
    var o, e = arguments[3];
    ! function(n) {
      var r = "object" == typeof exports && exports && !exports.nodeType && exports,
        t = "object" == typeof module && module && !module.nodeType && module,
        u = "object" == typeof e && e;
      u.global !== u && u.window !== u && u.self !== u || (n = u);
      var i, f, c = 2147483647,
        l = 36,
        s = 1,
        p = 26,
        a = 38,
        d = 700,
        h = 72,
        v = 128,
        g = "-",
        w = /^xn--/,
        x = /[^\x20-\x7E]/,
        y = /[\x2E\u3002\uFF0E\uFF61]/g,
        m = {
          overflow: "Overflow: input needs wider integers to process",
          "not-basic": "Illegal input >= 0x80 (not a basic code point)",
          "invalid-input": "Invalid input"
        },
        C = l - s,
        b = Math.floor,
        j = String.fromCharCode;

      function A(o) {
        throw new RangeError(m[o])
      }

      function I(o, e) {
        for (var n = o.length, r = []; n--;) r[n] = e(o[n]);
        return r
      }

      function E(o, e) {
        var n = o.split("@"),
          r = "";
        return n.length > 1 && (r = n[0] + "@", o = n[1]), r + I((o = o.replace(y, ".")).split("."), e).join(".")
      }

      function F(o) {
        for (var e, n, r = [], t = 0, u = o.length; t < u;)(e = o.charCodeAt(t++)) >= 55296 && e <= 56319 && t < u ? 56320 == (64512 & (n = o.charCodeAt(t++))) ? r.push(((1023 & e) << 10) + (1023 & n) + 65536) : (r.push(e), t--) : r.push(e);
        return r
      }

      function O(o) {
        return I(o, function(o) {
          var e = "";
          return o > 65535 && (e += j((o -= 65536) >>> 10 & 1023 | 55296), o = 56320 | 1023 & o), e += j(o)
        }).join("")
      }

      function S(o, e) {
        return o + 22 + 75 * (o < 26) - ((0 != e) << 5)
      }

      function T(o, e, n) {
        var r = 0;
        for (o = n ? b(o / d) : o >> 1, o += b(o / e); o > C * p >> 1; r += l) o = b(o / C);
        return b(r + (C + 1) * o / (o + a))
      }

      function L(o) {
        var e, n, r, t, u, i, f, a, d, w, x, y = [],
          m = o.length,
          C = 0,
          j = v,
          I = h;
        for ((n = o.lastIndexOf(g)) < 0 && (n = 0), r = 0; r < n; ++r) o.charCodeAt(r) >= 128 && A("not-basic"), y.push(o.charCodeAt(r));
        for (t = n > 0 ? n + 1 : 0; t < m;) {
          for (u = C, i = 1, f = l; t >= m && A("invalid-input"), ((a = (x = o.charCodeAt(t++)) - 48 < 10 ? x - 22 : x - 65 < 26 ? x - 65 : x - 97 < 26 ? x - 97 : l) >= l || a > b((c - C) / i)) && A("overflow"), C += a * i, !(a < (d = f <= I ? s : f >= I + p ? p : f - I)); f += l) i > b(c / (w = l - d)) && A("overflow"), i *= w;
          I = T(C - u, e = y.length + 1, 0 == u), b(C / e) > c - j && A("overflow"), j += b(C / e), C %= e, y.splice(C++, 0, j)
        }
        return O(y)
      }

      function M(o) {
        var e, n, r, t, u, i, f, a, d, w, x, y, m, C, I, E = [];
        for (y = (o = F(o)).length, e = v, n = 0, u = h, i = 0; i < y; ++i)(x = o[i]) < 128 && E.push(j(x));
        for (r = t = E.length, t && E.push(g); r < y;) {
          for (f = c, i = 0; i < y; ++i)(x = o[i]) >= e && x < f && (f = x);
          for (f - e > b((c - n) / (m = r + 1)) && A("overflow"), n += (f - e) * m, e = f, i = 0; i < y; ++i)
            if ((x = o[i]) < e && ++n > c && A("overflow"), x == e) {
              for (a = n, d = l; !(a < (w = d <= u ? s : d >= u + p ? p : d - u)); d += l) I = a - w, C = l - w, E.push(j(S(w + I % C, 0))), a = b(I / C);
              E.push(j(S(a, 0))), u = T(n, m, r == t), n = 0, ++r
            }++ n, ++e
        }
        return E.join("")
      }
      if (i = {
          version: "1.4.1",
          ucs2: {
            decode: F,
            encode: O
          },
          decode: L,
          encode: M,
          toASCII: function(o) {
            return E(o, function(o) {
              return x.test(o) ? "xn--" + M(o) : o
            })
          },
          toUnicode: function(o) {
            return E(o, function(o) {
              return w.test(o) ? L(o.slice(4).toLowerCase()) : o
            })
          }
        }, "function" == typeof o && "object" == typeof o.amd && o.amd) o("punycode", function() {
        return i
      });
      else if (r && t)
        if (module.exports == r) t.exports = i;
        else
          for (f in i) i.hasOwnProperty(f) && (r[f] = i[f]);
      else n.punycode = i
    }(this);
  }, {}],
  "YsIc": [function(require, module, exports) {
    "use strict";
    module.exports = {
      isString: function(n) {
        return "string" == typeof n
      },
      isObject: function(n) {
        return "object" == typeof n && null !== n
      },
      isNull: function(n) {
        return null === n
      },
      isNullOrUndefined: function(n) {
        return null == n
      }
    };
  }, {}],
  "J6GP": [function(require, module, exports) {
    "use strict";

    function r(r, e) {
      return Object.prototype.hasOwnProperty.call(r, e)
    }
    module.exports = function(t, n, o, a) {
      n = n || "&", o = o || "=";
      var s = {};
      if ("string" != typeof t || 0 === t.length) return s;
      var p = /\+/g;
      t = t.split(n);
      var u = 1e3;
      a && "number" == typeof a.maxKeys && (u = a.maxKeys);
      var c = t.length;
      u > 0 && c > u && (c = u);
      for (var i = 0; i < c; ++i) {
        var y, l, f, v, b = t[i].replace(p, "%20"),
          d = b.indexOf(o);
        d >= 0 ? (y = b.substr(0, d), l = b.substr(d + 1)) : (y = b, l = ""), f = decodeURIComponent(y), v = decodeURIComponent(l), r(s, f) ? e(s[f]) ? s[f].push(v) : s[f] = [s[f], v] : s[f] = v
      }
      return s
    };
    var e = Array.isArray || function(r) {
      return "[object Array]" === Object.prototype.toString.call(r)
    };
  }, {}],
  "bvhO": [function(require, module, exports) {
    "use strict";
    var n = function(n) {
      switch (typeof n) {
        case "string":
          return n;
        case "boolean":
          return n ? "true" : "false";
        case "number":
          return isFinite(n) ? n : "";
        default:
          return ""
      }
    };
    module.exports = function(o, u, c, a) {
      return u = u || "&", c = c || "=", null === o && (o = void 0), "object" == typeof o ? r(t(o), function(t) {
        var a = encodeURIComponent(n(t)) + c;
        return e(o[t]) ? r(o[t], function(e) {
          return a + encodeURIComponent(n(e))
        }).join(u) : a + encodeURIComponent(n(o[t]))
      }).join(u) : a ? encodeURIComponent(n(a)) + c + encodeURIComponent(n(o)) : ""
    };
    var e = Array.isArray || function(n) {
      return "[object Array]" === Object.prototype.toString.call(n)
    };

    function r(n, e) {
      if (n.map) return n.map(e);
      for (var r = [], t = 0; t < n.length; t++) r.push(e(n[t], t));
      return r
    }
    var t = Object.keys || function(n) {
      var e = [];
      for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && e.push(r);
      return e
    };
  }, {}],
  "fk5h": [function(require, module, exports) {
    "use strict";
    exports.decode = exports.parse = require("./decode"), exports.encode = exports.stringify = require("./encode");
  }, {
    "./decode": "J6GP",
    "./encode": "bvhO"
  }],
  "Mej7": [function(require, module, exports) {
    "use strict";
    var t = require("punycode"),
      s = require("./util");

    function h() {
      this.protocol = null, this.slashes = null, this.auth = null, this.host = null, this.port = null, this.hostname = null, this.hash = null, this.search = null, this.query = null, this.pathname = null, this.path = null, this.href = null
    }
    exports.parse = b, exports.resolve = O, exports.resolveObject = d, exports.format = q, exports.Url = h;
    var e = /^([a-z0-9.+-]+:)/i,
      a = /:[0-9]*$/,
      r = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/,
      o = ["<", ">", '"', "`", " ", "\r", "\n", "\t"],
      n = ["{", "}", "|", "\\", "^", "`"].concat(o),
      i = ["'"].concat(n),
      l = ["%", "/", "?", ";", "#"].concat(i),
      p = ["/", "?", "#"],
      c = 255,
      u = /^[+a-z0-9A-Z_-]{0,63}$/,
      f = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,
      m = {
        javascript: !0,
        "javascript:": !0
      },
      v = {
        javascript: !0,
        "javascript:": !0
      },
      g = {
        http: !0,
        https: !0,
        ftp: !0,
        gopher: !0,
        file: !0,
        "http:": !0,
        "https:": !0,
        "ftp:": !0,
        "gopher:": !0,
        "file:": !0
      },
      y = require("querystring");

    function b(t, e, a) {
      if (t && s.isObject(t) && t instanceof h) return t;
      var r = new h;
      return r.parse(t, e, a), r
    }

    function q(t) {
      return s.isString(t) && (t = b(t)), t instanceof h ? t.format() : h.prototype.format.call(t)
    }

    function O(t, s) {
      return b(t, !1, !0).resolve(s)
    }

    function d(t, s) {
      return t ? b(t, !1, !0).resolveObject(s) : s
    }
    h.prototype.parse = function(h, a, o) {
      if (!s.isString(h)) throw new TypeError("Parameter 'url' must be a string, not " + typeof h);
      var n = h.indexOf("?"),
        b = -1 !== n && n < h.indexOf("#") ? "?" : "#",
        q = h.split(b);
      q[0] = q[0].replace(/\\/g, "/");
      var O = h = q.join(b);
      if (O = O.trim(), !o && 1 === h.split("#").length) {
        var d = r.exec(O);
        if (d) return this.path = O, this.href = O, this.pathname = d[1], d[2] ? (this.search = d[2], this.query = a ? y.parse(this.search.substr(1)) : this.search.substr(1)) : a && (this.search = "", this.query = {}), this
      }
      var j = e.exec(O);
      if (j) {
        var x = (j = j[0]).toLowerCase();
        this.protocol = x, O = O.substr(j.length)
      }
      if (o || j || O.match(/^\/\/[^@\/]+@[^@\/]+/)) {
        var A = "//" === O.substr(0, 2);
        !A || j && v[j] || (O = O.substr(2), this.slashes = !0)
      }
      if (!v[j] && (A || j && !g[j])) {
        for (var C, I, w = -1, U = 0; U < p.length; U++) {
          -1 !== (k = O.indexOf(p[U])) && (-1 === w || k < w) && (w = k)
        } - 1 !== (I = -1 === w ? O.lastIndexOf("@") : O.lastIndexOf("@", w)) && (C = O.slice(0, I), O = O.slice(I + 1), this.auth = decodeURIComponent(C)), w = -1;
        for (U = 0; U < l.length; U++) {
          var k; - 1 !== (k = O.indexOf(l[U])) && (-1 === w || k < w) && (w = k)
        } - 1 === w && (w = O.length), this.host = O.slice(0, w), O = O.slice(w), this.parseHost(), this.hostname = this.hostname || "";
        var N = "[" === this.hostname[0] && "]" === this.hostname[this.hostname.length - 1];
        if (!N)
          for (var R = this.hostname.split(/\./), S = (U = 0, R.length); U < S; U++) {
            var $ = R[U];
            if ($ && !$.match(u)) {
              for (var z = "", H = 0, L = $.length; H < L; H++) $.charCodeAt(H) > 127 ? z += "x" : z += $[H];
              if (!z.match(u)) {
                var Z = R.slice(0, U),
                  _ = R.slice(U + 1),
                  E = $.match(f);
                E && (Z.push(E[1]), _.unshift(E[2])), _.length && (O = "/" + _.join(".") + O), this.hostname = Z.join(".");
                break
              }
            }
          }
        this.hostname.length > c ? this.hostname = "" : this.hostname = this.hostname.toLowerCase(), N || (this.hostname = t.toASCII(this.hostname));
        var P = this.port ? ":" + this.port : "",
          T = this.hostname || "";
        this.host = T + P, this.href += this.host, N && (this.hostname = this.hostname.substr(1, this.hostname.length - 2), "/" !== O[0] && (O = "/" + O))
      }
      if (!m[x])
        for (U = 0, S = i.length; U < S; U++) {
          var B = i[U];
          if (-1 !== O.indexOf(B)) {
            var D = encodeURIComponent(B);
            D === B && (D = escape(B)), O = O.split(B).join(D)
          }
        }
      var F = O.indexOf("#"); - 1 !== F && (this.hash = O.substr(F), O = O.slice(0, F));
      var G = O.indexOf("?");
      if (-1 !== G ? (this.search = O.substr(G), this.query = O.substr(G + 1), a && (this.query = y.parse(this.query)), O = O.slice(0, G)) : a && (this.search = "", this.query = {}), O && (this.pathname = O), g[x] && this.hostname && !this.pathname && (this.pathname = "/"), this.pathname || this.search) {
        P = this.pathname || "";
        var J = this.search || "";
        this.path = P + J
      }
      return this.href = this.format(), this
    }, h.prototype.format = function() {
      var t = this.auth || "";
      t && (t = (t = encodeURIComponent(t)).replace(/%3A/i, ":"), t += "@");
      var h = this.protocol || "",
        e = this.pathname || "",
        a = this.hash || "",
        r = !1,
        o = "";
      this.host ? r = t + this.host : this.hostname && (r = t + (-1 === this.hostname.indexOf(":") ? this.hostname : "[" + this.hostname + "]"), this.port && (r += ":" + this.port)), this.query && s.isObject(this.query) && Object.keys(this.query).length && (o = y.stringify(this.query));
      var n = this.search || o && "?" + o || "";
      return h && ":" !== h.substr(-1) && (h += ":"), this.slashes || (!h || g[h]) && !1 !== r ? (r = "//" + (r || ""), e && "/" !== e.charAt(0) && (e = "/" + e)) : r || (r = ""), a && "#" !== a.charAt(0) && (a = "#" + a), n && "?" !== n.charAt(0) && (n = "?" + n), h + r + (e = e.replace(/[?#]/g, function(t) {
        return encodeURIComponent(t)
      })) + (n = n.replace("#", "%23")) + a
    }, h.prototype.resolve = function(t) {
      return this.resolveObject(b(t, !1, !0)).format()
    }, h.prototype.resolveObject = function(t) {
      if (s.isString(t)) {
        var e = new h;
        e.parse(t, !1, !0), t = e
      }
      for (var a = new h, r = Object.keys(this), o = 0; o < r.length; o++) {
        var n = r[o];
        a[n] = this[n]
      }
      if (a.hash = t.hash, "" === t.href) return a.href = a.format(), a;
      if (t.slashes && !t.protocol) {
        for (var i = Object.keys(t), l = 0; l < i.length; l++) {
          var p = i[l];
          "protocol" !== p && (a[p] = t[p])
        }
        return g[a.protocol] && a.hostname && !a.pathname && (a.path = a.pathname = "/"), a.href = a.format(), a
      }
      if (t.protocol && t.protocol !== a.protocol) {
        if (!g[t.protocol]) {
          for (var c = Object.keys(t), u = 0; u < c.length; u++) {
            var f = c[u];
            a[f] = t[f]
          }
          return a.href = a.format(), a
        }
        if (a.protocol = t.protocol, t.host || v[t.protocol]) a.pathname = t.pathname;
        else {
          for (var m = (t.pathname || "").split("/"); m.length && !(t.host = m.shift()););
          t.host || (t.host = ""), t.hostname || (t.hostname = ""), "" !== m[0] && m.unshift(""), m.length < 2 && m.unshift(""), a.pathname = m.join("/")
        }
        if (a.search = t.search, a.query = t.query, a.host = t.host || "", a.auth = t.auth, a.hostname = t.hostname || t.host, a.port = t.port, a.pathname || a.search) {
          var y = a.pathname || "",
            b = a.search || "";
          a.path = y + b
        }
        return a.slashes = a.slashes || t.slashes, a.href = a.format(), a
      }
      var q = a.pathname && "/" === a.pathname.charAt(0),
        O = t.host || t.pathname && "/" === t.pathname.charAt(0),
        d = O || q || a.host && t.pathname,
        j = d,
        x = a.pathname && a.pathname.split("/") || [],
        A = (m = t.pathname && t.pathname.split("/") || [], a.protocol && !g[a.protocol]);
      if (A && (a.hostname = "", a.port = null, a.host && ("" === x[0] ? x[0] = a.host : x.unshift(a.host)), a.host = "", t.protocol && (t.hostname = null, t.port = null, t.host && ("" === m[0] ? m[0] = t.host : m.unshift(t.host)), t.host = null), d = d && ("" === m[0] || "" === x[0])), O) a.host = t.host || "" === t.host ? t.host : a.host, a.hostname = t.hostname || "" === t.hostname ? t.hostname : a.hostname, a.search = t.search, a.query = t.query, x = m;
      else if (m.length) x || (x = []), x.pop(), x = x.concat(m), a.search = t.search, a.query = t.query;
      else if (!s.isNullOrUndefined(t.search)) {
        if (A) a.hostname = a.host = x.shift(), (k = !!(a.host && a.host.indexOf("@") > 0) && a.host.split("@")) && (a.auth = k.shift(), a.host = a.hostname = k.shift());
        return a.search = t.search, a.query = t.query, s.isNull(a.pathname) && s.isNull(a.search) || (a.path = (a.pathname ? a.pathname : "") + (a.search ? a.search : "")), a.href = a.format(), a
      }
      if (!x.length) return a.pathname = null, a.search ? a.path = "/" + a.search : a.path = null, a.href = a.format(), a;
      for (var C = x.slice(-1)[0], I = (a.host || t.host || x.length > 1) && ("." === C || ".." === C) || "" === C, w = 0, U = x.length; U >= 0; U--) "." === (C = x[U]) ? x.splice(U, 1) : ".." === C ? (x.splice(U, 1), w++) : w && (x.splice(U, 1), w--);
      if (!d && !j)
        for (; w--; w) x.unshift("..");
      !d || "" === x[0] || x[0] && "/" === x[0].charAt(0) || x.unshift(""), I && "/" !== x.join("/").substr(-1) && x.push("");
      var k, N = "" === x[0] || x[0] && "/" === x[0].charAt(0);
      A && (a.hostname = a.host = N ? "" : x.length ? x.shift() : "", (k = !!(a.host && a.host.indexOf("@") > 0) && a.host.split("@")) && (a.auth = k.shift(), a.host = a.hostname = k.shift()));
      return (d = d || a.host && x.length) && !N && x.unshift(""), x.length ? a.pathname = x.join("/") : (a.pathname = null, a.path = null), s.isNull(a.pathname) && s.isNull(a.search) || (a.path = (a.pathname ? a.pathname : "") + (a.search ? a.search : "")), a.auth = t.auth || a.auth, a.slashes = a.slashes || t.slashes, a.href = a.format(), a
    }, h.prototype.parseHost = function() {
      var t = this.host,
        s = a.exec(t);
      s && (":" !== (s = s[0]) && (this.port = s.substr(1)), t = t.substr(0, t.length - s.length)), t && (this.hostname = t)
    };
  }, {
    "punycode": "FIMm",
    "./util": "YsIc",
    "querystring": "fk5h"
  }],
  "fTWV": [function(require, module, exports) {
    var process = require("process");
    var Buffer = require("buffer").Buffer;
    var e = require("process"),
      r = require("buffer").Buffer,
      t = "[object process]" === Object.prototype.toString.call(void 0 !== e ? e : 0),
      n = "undefined" != typeof navigator && "ReactNative" === navigator.product,
      o = null,
      u = null;
    if (t || n) {
      o = function(e) {
        return r.from(e).toString("base64")
      };
      var i = require("url");
      if (i.URL) {
        var a = i.URL;
        u = function(e) {
          return new a(e)
        }
      } else u = require("url").parse
    } else o = btoa.bind(window), u = function(e) {
      return new URL(e)
    };
    module.exports = {
      parseURL: u,
      btoa: o
    };
  }, {
    "url": "Mej7",
    "process": "pBGv",
    "buffer": "dskh"
  }],
  "kFoP": [function(require, module, exports) {
    var t = function() {
      if ("object" == typeof self && self) return self;
      if ("object" == typeof window && window) return window;
      throw new Error("Unable to resolve global `this`")
    };
    module.exports = function() {
      if (this) return this;
      if ("object" == typeof globalThis && globalThis) return globalThis;
      try {
        Object.defineProperty(Object.prototype, "__global__", {
          get: function() {
            return this
          },
          configurable: !0
        })
      } catch (e) {
        return t()
      }
      try {
        return __global__ || t()
      } finally {
        delete Object.prototype.__global__
      }
    }();
  }, {}],
  "TOKy": [function(require, module, exports) {
    module.exports = {
      _args: [
        ["websocket@1.0.34", "C:\\Users\\jesh\\Desktop\\o1t site\\new site"]
      ],
      _from: "websocket@1.0.34",
      _id: "websocket@1.0.34",
      _inBundle: !1,
      _integrity: "sha512-PRDso2sGwF6kM75QykIesBijKSVceR6jL2G8NGYyq2XrItNC2P5/qL5XeR056GhA+Ly7JMFvJb9I312mJfmqnQ==",
      _location: "/websocket",
      _phantomChildren: {},
      _requested: {
        type: "version",
        registry: !0,
        raw: "websocket@1.0.34",
        name: "websocket",
        escapedName: "websocket",
        rawSpec: "1.0.34",
        saveSpec: null,
        fetchSpec: "1.0.34"
      },
      _requiredBy: ["/web3-providers-ws"],
      _resolved: "https://registry.npmjs.org/websocket/-/websocket-1.0.34.tgz",
      _spec: "1.0.34",
      _where: "C:\\Users\\jesh\\Desktop\\o1t site\\new site",
      author: {
        name: "Brian McKelvey",
        email: "theturtle32@gmail.com",
        url: "https://github.com/theturtle32"
      },
      browser: "lib/browser.js",
      bugs: {
        url: "https://github.com/theturtle32/WebSocket-Node/issues"
      },
      config: {
        verbose: !1
      },
      contributors: [{
        name: "Iaki Baz Castillo",
        email: "ibc@aliax.net",
        url: "http://dev.sipdoc.net"
      }],
      dependencies: {
        bufferutil: "^4.0.1",
        debug: "^2.2.0",
        "es5-ext": "^0.10.50",
        "typedarray-to-buffer": "^3.1.5",
        "utf-8-validate": "^5.0.2",
        yaeti: "^0.0.6"
      },
      description: "Websocket Client & Server Library implementing the WebSocket protocol as specified in RFC 6455.",
      devDependencies: {
        "buffer-equal": "^1.0.0",
        gulp: "^4.0.2",
        "gulp-jshint": "^2.0.4",
        jshint: "^2.0.0",
        "jshint-stylish": "^2.2.1",
        tape: "^4.9.1"
      },
      directories: {
        lib: "./lib"
      },
      engines: {
        node: ">=4.0.0"
      },
      homepage: "https://github.com/theturtle32/WebSocket-Node",
      keywords: ["websocket", "websockets", "socket", "networking", "comet", "push", "RFC-6455", "realtime", "server", "client"],
      license: "Apache-2.0",
      main: "index",
      name: "websocket",
      repository: {
        type: "git",
        url: "git+https://github.com/theturtle32/WebSocket-Node.git"
      },
      scripts: {
        gulp: "gulp",
        test: "tape test/unit/*.js"
      },
      version: "1.0.34"
    };
  }, {}],
  "Z6gL": [function(require, module, exports) {
    module.exports = require("../package.json").version;
  }, {
    "../package.json": "TOKy"
  }],
  "AA2m": [function(require, module, exports) {
    function e(o) {
      return (e = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
        return typeof e
      } : function(e) {
        return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
      })(o)
    }
    var o;
    if ("object" === ("undefined" == typeof globalThis ? "undefined" : e(globalThis))) o = globalThis;
    else try {
      o = require("es5-ext/global")
    } catch (i) {} finally {
      if (o || "undefined" == typeof window || (o = window), !o) throw new Error("Could not determine global this")
    }
    var t = o.WebSocket || o.MozWebSocket,
      n = require("./version");

    function r(e, o) {
      return o ? new t(e, o) : new t(e)
    }
    t && ["CONNECTING", "OPEN", "CLOSING", "CLOSED"].forEach(function(e) {
      Object.defineProperty(r, e, {
        get: function() {
          return t[e]
        }
      })
    }), module.exports = {
      w3cwebsocket: t ? r : null,
      version: n
    };
  }, {
    "es5-ext/global": "kFoP",
    "./version": "Z6gL"
  }],
  "OPSa": [function(require, module, exports) {
    "use strict";
    var e = require("eventemitter3"),
      t = require("./helpers.js"),
      n = require("web3-core-helpers").errors,
      s = require("websocket").w3cwebsocket,
      o = function(n, s) {
        e.call(this), s = s || {}, this.url = n, this._customTimeout = s.timeout || 15e3, this.headers = s.headers || {}, this.protocol = s.protocol || void 0, this.reconnectOptions = Object.assign({
          auto: !1,
          delay: 5e3,
          maxAttempts: !1,
          onTimeout: !1
        }, s.reconnect), this.clientConfig = s.clientConfig || void 0, this.requestOptions = s.requestOptions || void 0, this.DATA = "data", this.CLOSE = "close", this.ERROR = "error", this.CONNECT = "connect", this.RECONNECT = "reconnect", this.connection = null, this.requestQueue = new Map, this.responseQueue = new Map, this.reconnectAttempts = 0, this.reconnecting = !1;
        var o = t.parseURL(n);
        o.username && o.password && (this.headers.authorization = "Basic " + t.btoa(o.username + ":" + o.password)), o.auth && (this.headers.authorization = "Basic " + t.btoa(o.auth)), Object.defineProperty(this, "connected", {
          get: function() {
            return this.connection && this.connection.readyState === this.connection.OPEN
          },
          enumerable: !0
        }), this.connect()
      };
    o.prototype = Object.create(e.prototype), o.prototype.constructor = o, o.prototype.connect = function() {
      this.connection = new s(this.url, this.protocol, void 0, this.headers, this.requestOptions, this.clientConfig), this._addSocketListeners()
    }, o.prototype._onMessage = function(e) {
      var t = this;
      this._parseResponse("string" == typeof e.data ? e.data : "").forEach(function(e) {
        if (e.method && -1 !== e.method.indexOf("_subscription")) t.emit(t.DATA, e);
        else {
          var n = e.id;
          Array.isArray(e) && (n = e[0].id), t.responseQueue.has(n) && (void 0 !== t.responseQueue.get(n).callback && t.responseQueue.get(n).callback(!1, e), t.responseQueue.delete(n))
        }
      })
    }, o.prototype._onConnect = function() {
      if (this.emit(this.CONNECT), this.reconnectAttempts = 0, this.reconnecting = !1, this.requestQueue.size > 0) {
        var e = this;
        this.requestQueue.forEach(function(t, n) {
          e.send(t.payload, t.callback), e.requestQueue.delete(n)
        })
      }
    }, o.prototype._onClose = function(e) {
      var t = this;
      !this.reconnectOptions.auto || [1e3, 1001].includes(e.code) && !1 !== e.wasClean ? (this.emit(this.CLOSE, e), this.requestQueue.size > 0 && this.requestQueue.forEach(function(s, o) {
        s.callback(n.ConnectionNotOpenError(e)), t.requestQueue.delete(o)
      }), this.responseQueue.size > 0 && this.responseQueue.forEach(function(s, o) {
        s.callback(n.InvalidConnection("on WS", e)), t.responseQueue.delete(o)
      }), this._removeSocketListeners(), this.removeAllListeners()) : this.reconnect()
    }, o.prototype._addSocketListeners = function() {
      this.connection.addEventListener("message", this._onMessage.bind(this)), this.connection.addEventListener("open", this._onConnect.bind(this)), this.connection.addEventListener("close", this._onClose.bind(this))
    }, o.prototype._removeSocketListeners = function() {
      this.connection.removeEventListener("message", this._onMessage), this.connection.removeEventListener("open", this._onConnect), this.connection.removeEventListener("close", this._onClose)
    }, o.prototype._parseResponse = function(e) {
      var t = this,
        s = [];
      return e.replace(/\}[\n\r]?\{/g, "}|--|{").replace(/\}\][\n\r]?\[\{/g, "}]|--|[{").replace(/\}[\n\r]?\[\{/g, "}|--|[{").replace(/\}\][\n\r]?\{/g, "}]|--|{").split("|--|").forEach(function(e) {
        t.lastChunk && (e = t.lastChunk + e);
        var o = null;
        try {
          o = JSON.parse(e)
        } catch (i) {
          return t.lastChunk = e, clearTimeout(t.lastChunkTimeout), void(t.lastChunkTimeout = setTimeout(function() {
            t.reconnectOptions.auto && t.reconnectOptions.onTimeout ? t.reconnect() : (t.emit(t.ERROR, n.ConnectionTimeout(t._customTimeout)), t.requestQueue.size > 0 && t.requestQueue.forEach(function(e, s) {
              e.callback(n.ConnectionTimeout(t._customTimeout)), t.requestQueue.delete(s)
            }))
          }, t._customTimeout))
        }
        clearTimeout(t.lastChunkTimeout), t.lastChunk = null, o && s.push(o)
      }), s
    }, o.prototype.send = function(e, t) {
      var s = e.id,
        o = {
          payload: e,
          callback: t
        };
      if (Array.isArray(e) && (s = e[0].id), this.connection.readyState === this.connection.CONNECTING || this.reconnecting) this.requestQueue.set(s, o);
      else {
        if (this.connection.readyState !== this.connection.OPEN) return this.requestQueue.delete(s), this.emit(this.ERROR, n.ConnectionNotOpenError()), void o.callback(n.ConnectionNotOpenError());
        this.responseQueue.set(s, o), this.requestQueue.delete(s);
        try {
          this.connection.send(JSON.stringify(o.payload))
        } catch (i) {
          o.callback(i), this.responseQueue.delete(s)
        }
      }
    }, o.prototype.reset = function() {
      this.responseQueue.clear(), this.requestQueue.clear(), this.removeAllListeners(), this._removeSocketListeners(), this._addSocketListeners()
    }, o.prototype.disconnect = function(e, t) {
      this._removeSocketListeners(), this.connection.close(e || 1e3, t)
    }, o.prototype.supportsSubscriptions = function() {
      return !0
    }, o.prototype.reconnect = function() {
      var e = this;
      this.reconnecting = !0, this.responseQueue.size > 0 && this.responseQueue.forEach(function(t, s) {
        t.callback(n.PendingRequestsOnReconnectingError()), e.responseQueue.delete(s)
      }), !this.reconnectOptions.maxAttempts || this.reconnectAttempts < this.reconnectOptions.maxAttempts ? setTimeout(function() {
        e.reconnectAttempts++, e._removeSocketListeners(), e.emit(e.RECONNECT, e.reconnectAttempts), e.connect()
      }, this.reconnectOptions.delay) : (this.emit(this.ERROR, n.MaxAttemptsReachedOnReconnectingError()), this.reconnecting = !1, this.requestQueue.size > 0 && this.requestQueue.forEach(function(t, s) {
        t.callback(n.MaxAttemptsReachedOnReconnectingError()), e.requestQueue.delete(s)
      }))
    }, module.exports = o;
  }, {
    "eventemitter3": "JJlS",
    "./helpers.js": "fTWV",
    "web3-core-helpers": "EoeS",
    "websocket": "AA2m"
  }],
  "p5a1": [function(require, module, exports) {
    var global = arguments[3];
    var r, e = arguments[3];
    exports.fetch = s(e.fetch) && s(e.ReadableStream), exports.writableStream = s(e.WritableStream), exports.abortController = s(e.AbortController), exports.blobConstructor = !1;
    try {
      new Blob([new ArrayBuffer(1)]), exports.blobConstructor = !0
    } catch (f) {}

    function t() {
      if (void 0 !== r) return r;
      if (e.XMLHttpRequest) {
        r = new e.XMLHttpRequest;
        try {
          r.open("GET", e.XDomainRequest ? "/" : "https://example.com")
        } catch (f) {
          r = null
        }
      } else r = null;
      return r
    }

    function o(r) {
      var e = t();
      if (!e) return !1;
      try {
        return e.responseType = r, e.responseType === r
      } catch (f) {}
      return !1
    }
    var a = void 0 !== e.ArrayBuffer,
      n = a && s(e.ArrayBuffer.prototype.slice);

    function s(r) {
      return "function" == typeof r
    }
    exports.arraybuffer = exports.fetch || a && o("arraybuffer"), exports.msstream = !exports.fetch && n && o("ms-stream"), exports.mozchunkedarraybuffer = !exports.fetch && a && o("moz-chunked-arraybuffer"), exports.overrideMimeType = exports.fetch || !!t() && s(t().overrideMimeType), exports.vbArray = s(e.VBArray), r = null;
  }, {}],
  "Bm0n": [function(require, module, exports) {
    "function" == typeof Object.create ? module.exports = function(t, e) {
      e && (t.super_ = e, t.prototype = Object.create(e.prototype, {
        constructor: {
          value: t,
          enumerable: !1,
          writable: !0,
          configurable: !0
        }
      }))
    } : module.exports = function(t, e) {
      if (e) {
        t.super_ = e;
        var o = function() {};
        o.prototype = e.prototype, t.prototype = new o, t.prototype.constructor = t
      }
    };
  }, {}],
  "Yj0v": [function(require, module, exports) {
    var process = require("process");
    var n = require("process");

    function e(e, r, t, c) {
      if ("function" != typeof e) throw new TypeError('"callback" argument must be a function');
      var i, l, u = arguments.length;
      switch (u) {
        case 0:
        case 1:
          return n.nextTick(e);
        case 2:
          return n.nextTick(function() {
            e.call(null, r)
          });
        case 3:
          return n.nextTick(function() {
            e.call(null, r, t)
          });
        case 4:
          return n.nextTick(function() {
            e.call(null, r, t, c)
          });
        default:
          for (i = new Array(u - 1), l = 0; l < i.length;) i[l++] = arguments[l];
          return n.nextTick(function() {
            e.apply(null, i)
          })
      }
    }
    void 0 === n || !n.version || 0 === n.version.indexOf("v0.") || 0 === n.version.indexOf("v1.") && 0 !== n.version.indexOf("v1.8.") ? module.exports = {
      nextTick: e
    } : module.exports = n;
  }, {
    "process": "pBGv"
  }],
  "FRpO": [function(require, module, exports) {
    "use strict";
    var e, t = "object" == typeof Reflect ? Reflect : null,
      n = t && "function" == typeof t.apply ? t.apply : function(e, t, n) {
        return Function.prototype.apply.call(e, t, n)
      };

    function r(e) {
      console && console.warn && console.warn(e)
    }
    e = t && "function" == typeof t.ownKeys ? t.ownKeys : Object.getOwnPropertySymbols ? function(e) {
      return Object.getOwnPropertyNames(e).concat(Object.getOwnPropertySymbols(e))
    } : function(e) {
      return Object.getOwnPropertyNames(e)
    };
    var i = Number.isNaN || function(e) {
      return e != e
    };

    function o() {
      o.init.call(this)
    }
    module.exports = o, module.exports.once = m, o.EventEmitter = o, o.prototype._events = void 0, o.prototype._eventsCount = 0, o.prototype._maxListeners = void 0;
    var s = 10;

    function u(e) {
      if ("function" != typeof e) throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof e)
    }

    function f(e) {
      return void 0 === e._maxListeners ? o.defaultMaxListeners : e._maxListeners
    }

    function c(e, t, n, i) {
      var o, s, c;
      if (u(n), void 0 === (s = e._events) ? (s = e._events = Object.create(null), e._eventsCount = 0) : (void 0 !== s.newListener && (e.emit("newListener", t, n.listener ? n.listener : n), s = e._events), c = s[t]), void 0 === c) c = s[t] = n, ++e._eventsCount;
      else if ("function" == typeof c ? c = s[t] = i ? [n, c] : [c, n] : i ? c.unshift(n) : c.push(n), (o = f(e)) > 0 && c.length > o && !c.warned) {
        c.warned = !0;
        var v = new Error("Possible EventEmitter memory leak detected. " + c.length + " " + String(t) + " listeners added. Use emitter.setMaxListeners() to increase limit");
        v.name = "MaxListenersExceededWarning", v.emitter = e, v.type = t, v.count = c.length, r(v)
      }
      return e
    }

    function v() {
      if (!this.fired) return this.target.removeListener(this.type, this.wrapFn), this.fired = !0, 0 === arguments.length ? this.listener.call(this.target) : this.listener.apply(this.target, arguments)
    }

    function l(e, t, n) {
      var r = {
          fired: !1,
          wrapFn: void 0,
          target: e,
          type: t,
          listener: n
        },
        i = v.bind(r);
      return i.listener = n, r.wrapFn = i, i
    }

    function p(e, t, n) {
      var r = e._events;
      if (void 0 === r) return [];
      var i = r[t];
      return void 0 === i ? [] : "function" == typeof i ? n ? [i.listener || i] : [i] : n ? d(i) : h(i, i.length)
    }

    function a(e) {
      var t = this._events;
      if (void 0 !== t) {
        var n = t[e];
        if ("function" == typeof n) return 1;
        if (void 0 !== n) return n.length
      }
      return 0
    }

    function h(e, t) {
      for (var n = new Array(t), r = 0; r < t; ++r) n[r] = e[r];
      return n
    }

    function y(e, t) {
      for (; t + 1 < e.length; t++) e[t] = e[t + 1];
      e.pop()
    }

    function d(e) {
      for (var t = new Array(e.length), n = 0; n < t.length; ++n) t[n] = e[n].listener || e[n];
      return t
    }

    function m(e, t) {
      return new Promise(function(n, r) {
        function i(n) {
          e.removeListener(t, o), r(n)
        }

        function o() {
          "function" == typeof e.removeListener && e.removeListener("error", i), n([].slice.call(arguments))
        }
        g(e, t, o, {
          once: !0
        }), "error" !== t && L(e, i, {
          once: !0
        })
      })
    }

    function L(e, t, n) {
      "function" == typeof e.on && g(e, "error", t, n)
    }

    function g(e, t, n, r) {
      if ("function" == typeof e.on) r.once ? e.once(t, n) : e.on(t, n);
      else {
        if ("function" != typeof e.addEventListener) throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof e);
        e.addEventListener(t, function i(o) {
          r.once && e.removeEventListener(t, i), n(o)
        })
      }
    }
    Object.defineProperty(o, "defaultMaxListeners", {
      enumerable: !0,
      get: function() {
        return s
      },
      set: function(e) {
        if ("number" != typeof e || e < 0 || i(e)) throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + e + ".");
        s = e
      }
    }), o.init = function() {
      void 0 !== this._events && this._events !== Object.getPrototypeOf(this)._events || (this._events = Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0
    }, o.prototype.setMaxListeners = function(e) {
      if ("number" != typeof e || e < 0 || i(e)) throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + e + ".");
      return this._maxListeners = e, this
    }, o.prototype.getMaxListeners = function() {
      return f(this)
    }, o.prototype.emit = function(e) {
      for (var t = [], r = 1; r < arguments.length; r++) t.push(arguments[r]);
      var i = "error" === e,
        o = this._events;
      if (void 0 !== o) i = i && void 0 === o.error;
      else if (!i) return !1;
      if (i) {
        var s;
        if (t.length > 0 && (s = t[0]), s instanceof Error) throw s;
        var u = new Error("Unhandled error." + (s ? " (" + s.message + ")" : ""));
        throw u.context = s, u
      }
      var f = o[e];
      if (void 0 === f) return !1;
      if ("function" == typeof f) n(f, this, t);
      else {
        var c = f.length,
          v = h(f, c);
        for (r = 0; r < c; ++r) n(v[r], this, t)
      }
      return !0
    }, o.prototype.addListener = function(e, t) {
      return c(this, e, t, !1)
    }, o.prototype.on = o.prototype.addListener, o.prototype.prependListener = function(e, t) {
      return c(this, e, t, !0)
    }, o.prototype.once = function(e, t) {
      return u(t), this.on(e, l(this, e, t)), this
    }, o.prototype.prependOnceListener = function(e, t) {
      return u(t), this.prependListener(e, l(this, e, t)), this
    }, o.prototype.removeListener = function(e, t) {
      var n, r, i, o, s;
      if (u(t), void 0 === (r = this._events)) return this;
      if (void 0 === (n = r[e])) return this;
      if (n === t || n.listener === t) 0 == --this._eventsCount ? this._events = Object.create(null) : (delete r[e], r.removeListener && this.emit("removeListener", e, n.listener || t));
      else if ("function" != typeof n) {
        for (i = -1, o = n.length - 1; o >= 0; o--)
          if (n[o] === t || n[o].listener === t) {
            s = n[o].listener, i = o;
            break
          } if (i < 0) return this;
        0 === i ? n.shift() : y(n, i), 1 === n.length && (r[e] = n[0]), void 0 !== r.removeListener && this.emit("removeListener", e, s || t)
      }
      return this
    }, o.prototype.off = o.prototype.removeListener, o.prototype.removeAllListeners = function(e) {
      var t, n, r;
      if (void 0 === (n = this._events)) return this;
      if (void 0 === n.removeListener) return 0 === arguments.length ? (this._events = Object.create(null), this._eventsCount = 0) : void 0 !== n[e] && (0 == --this._eventsCount ? this._events = Object.create(null) : delete n[e]), this;
      if (0 === arguments.length) {
        var i, o = Object.keys(n);
        for (r = 0; r < o.length; ++r) "removeListener" !== (i = o[r]) && this.removeAllListeners(i);
        return this.removeAllListeners("removeListener"), this._events = Object.create(null), this._eventsCount = 0, this
      }
      if ("function" == typeof(t = n[e])) this.removeListener(e, t);
      else if (void 0 !== t)
        for (r = t.length - 1; r >= 0; r--) this.removeListener(e, t[r]);
      return this
    }, o.prototype.listeners = function(e) {
      return p(this, e, !0)
    }, o.prototype.rawListeners = function(e) {
      return p(this, e, !1)
    }, o.listenerCount = function(e, t) {
      return "function" == typeof e.listenerCount ? e.listenerCount(t) : a.call(e, t)
    }, o.prototype.listenerCount = a, o.prototype.eventNames = function() {
      return this._eventsCount > 0 ? e(this._events) : []
    };
  }, {}],
  "ExO1": [function(require, module, exports) {
    module.exports = require("events").EventEmitter;
  }, {
    "events": "FRpO"
  }],
  "Q14w": [function(require, module, exports) {
    var Buffer = require("buffer").Buffer;
    var r = require("buffer").Buffer;

    function t(r) {
      return Array.isArray ? Array.isArray(r) : "[object Array]" === a(r)
    }

    function e(r) {
      return "boolean" == typeof r
    }

    function n(r) {
      return null === r
    }

    function o(r) {
      return null == r
    }

    function i(r) {
      return "number" == typeof r
    }

    function u(r) {
      return "string" == typeof r
    }

    function s(r) {
      return "symbol" == typeof r
    }

    function f(r) {
      return void 0 === r
    }

    function p(r) {
      return "[object RegExp]" === a(r)
    }

    function c(r) {
      return "object" == typeof r && null !== r
    }

    function l(r) {
      return "[object Date]" === a(r)
    }

    function y(r) {
      return "[object Error]" === a(r) || r instanceof Error
    }

    function x(r) {
      return "function" == typeof r
    }

    function b(r) {
      return null === r || "boolean" == typeof r || "number" == typeof r || "string" == typeof r || "symbol" == typeof r || void 0 === r
    }

    function a(r) {
      return Object.prototype.toString.call(r)
    }
    exports.isArray = t, exports.isBoolean = e, exports.isNull = n, exports.isNullOrUndefined = o, exports.isNumber = i, exports.isString = u, exports.isSymbol = s, exports.isUndefined = f, exports.isRegExp = p, exports.isObject = c, exports.isDate = l, exports.isError = y, exports.isFunction = x, exports.isPrimitive = b, exports.isBuffer = r.isBuffer;
  }, {
    "buffer": "dskh"
  }],
  "wlMe": [function(require, module, exports) {

    "use strict";

    function t(t, n) {
      if (!(t instanceof n)) throw new TypeError("Cannot call a class as a function")
    }
    var n = require("safe-buffer").Buffer,
      e = require("util");

    function i(t, n, e) {
      t.copy(n, e)
    }
    module.exports = function() {
      function e() {
        t(this, e), this.head = null, this.tail = null, this.length = 0
      }
      return e.prototype.push = function(t) {
        var n = {
          data: t,
          next: null
        };
        this.length > 0 ? this.tail.next = n : this.head = n, this.tail = n, ++this.length
      }, e.prototype.unshift = function(t) {
        var n = {
          data: t,
          next: this.head
        };
        0 === this.length && (this.tail = n), this.head = n, ++this.length
      }, e.prototype.shift = function() {
        if (0 !== this.length) {
          var t = this.head.data;
          return 1 === this.length ? this.head = this.tail = null : this.head = this.head.next, --this.length, t
        }
      }, e.prototype.clear = function() {
        this.head = this.tail = null, this.length = 0
      }, e.prototype.join = function(t) {
        if (0 === this.length) return "";
        for (var n = this.head, e = "" + n.data; n = n.next;) e += t + n.data;
        return e
      }, e.prototype.concat = function(t) {
        if (0 === this.length) return n.alloc(0);
        if (1 === this.length) return this.head.data;
        for (var e = n.allocUnsafe(t >>> 0), h = this.head, a = 0; h;) i(h.data, e, a), a += h.data.length, h = h.next;
        return e
      }, e
    }(), e && e.inspect && e.inspect.custom && (module.exports.prototype[e.inspect.custom] = function() {
      var t = e.inspect({
        length: this.length
      });
      return this.constructor.name + " " + t
    });
  }, {
    "safe-buffer": "Wugr",
    "util": "rDCW"
  }],
  "GRUB": [function(require, module, exports) {
    "use strict";
    var t = require("process-nextick-args");

    function e(e, a) {
      var r = this,
        s = this._readableState && this._readableState.destroyed,
        d = this._writableState && this._writableState.destroyed;
      return s || d ? (a ? a(e) : !e || this._writableState && this._writableState.errorEmitted || t.nextTick(i, this, e), this) : (this._readableState && (this._readableState.destroyed = !0), this._writableState && (this._writableState.destroyed = !0), this._destroy(e || null, function(e) {
        !a && e ? (t.nextTick(i, r, e), r._writableState && (r._writableState.errorEmitted = !0)) : a && a(e)
      }), this)
    }

    function a() {
      this._readableState && (this._readableState.destroyed = !1, this._readableState.reading = !1, this._readableState.ended = !1, this._readableState.endEmitted = !1), this._writableState && (this._writableState.destroyed = !1, this._writableState.ended = !1, this._writableState.ending = !1, this._writableState.finished = !1, this._writableState.errorEmitted = !1)
    }

    function i(t, e) {
      t.emit("error", e)
    }
    module.exports = {
      destroy: e,
      undestroy: a
    };
  }, {
    "process-nextick-args": "Yj0v"
  }],
  "yM1o": [function(require, module, exports) {
    var global = arguments[3];
    var r = arguments[3];

    function t(r, t) {
      if (e("noDeprecation")) return r;
      var n = !1;
      return function() {
        if (!n) {
          if (e("throwDeprecation")) throw new Error(t);
          e("traceDeprecation") ? console.trace(t) : console.warn(t), n = !0
        }
        return r.apply(this, arguments)
      }
    }

    function e(t) {
      try {
        if (!r.localStorage) return !1
      } catch (n) {
        return !1
      }
      var e = r.localStorage[t];
      return null != e && "true" === String(e).toLowerCase()
    }
    module.exports = t;
  }, {}],
  "WSyY": [function(require, module, exports) {
    var process = require("process");

    var global = arguments[3];
    var e = require("process"),
      t = arguments[3],
      n = require("process-nextick-args");

    function r(e, t, n) {
      this.chunk = e, this.encoding = t, this.callback = n, this.next = null
    }

    function i(e) {
      var t = this;
      this.next = null, this.entry = null, this.finish = function() {
        W(t, e)
      }
    }
    module.exports = g;
    var o, s = n.nextTick;
    g.WritableState = y;
    var f = Object.create(require("core-util-is"));
    f.inherits = require("inherits");
    var u = {
        deprecate: require("util-deprecate")
      },
      a = require("./internal/streams/stream"),
      c = require("safe-buffer").Buffer,
      l = t.Uint8Array || function() {};

    function d(e) {
      return c.from(e)
    }

    function h(e) {
      return c.isBuffer(e) || e instanceof l
    }
    var b, p = require("./internal/streams/destroy");

    function w() {}

    function y(e, t) {
      o = o || require("./_stream_duplex"), e = e || {};
      var n = t instanceof o;
      this.objectMode = !!e.objectMode, n && (this.objectMode = this.objectMode || !!e.writableObjectMode);
      var r = e.highWaterMark,
        s = e.writableHighWaterMark,
        f = this.objectMode ? 16 : 16384;
      this.highWaterMark = r || 0 === r ? r : n && (s || 0 === s) ? s : f, this.highWaterMark = Math.floor(this.highWaterMark), this.finalCalled = !1, this.needDrain = !1, this.ending = !1, this.ended = !1, this.finished = !1, this.destroyed = !1;
      var u = !1 === e.decodeStrings;
      this.decodeStrings = !u, this.defaultEncoding = e.defaultEncoding || "utf8", this.length = 0, this.writing = !1, this.corked = 0, this.sync = !0, this.bufferProcessing = !1, this.onwrite = function(e) {
        S(t, e)
      }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = !1, this.errorEmitted = !1, this.bufferedRequestCount = 0, this.corkedRequestsFree = new i(this)
    }

    function g(e) {
      if (o = o || require("./_stream_duplex"), !(b.call(g, this) || this instanceof o)) return new g(e);
      this._writableState = new y(e, this), this.writable = !0, e && ("function" == typeof e.write && (this._write = e.write), "function" == typeof e.writev && (this._writev = e.writev), "function" == typeof e.destroy && (this._destroy = e.destroy), "function" == typeof e.final && (this._final = e.final)), a.call(this)
    }

    function k(e, t) {
      var r = new Error("write after end");
      e.emit("error", r), n.nextTick(t, r)
    }

    function v(e, t, r, i) {
      var o = !0,
        s = !1;
      return null === r ? s = new TypeError("May not write null values to stream") : "string" == typeof r || void 0 === r || t.objectMode || (s = new TypeError("Invalid non-string/buffer chunk")), s && (e.emit("error", s), n.nextTick(i, s), o = !1), o
    }

    function q(e, t, n) {
      return e.objectMode || !1 === e.decodeStrings || "string" != typeof t || (t = c.from(t, n)), t
    }

    function _(e, t, n, r, i, o) {
      if (!n) {
        var s = q(t, r, i);
        r !== s && (n = !0, i = "buffer", r = s)
      }
      var f = t.objectMode ? 1 : r.length;
      t.length += f;
      var u = t.length < t.highWaterMark;
      if (u || (t.needDrain = !0), t.writing || t.corked) {
        var a = t.lastBufferedRequest;
        t.lastBufferedRequest = {
          chunk: r,
          encoding: i,
          isBuf: n,
          callback: o,
          next: null
        }, a ? a.next = t.lastBufferedRequest : t.bufferedRequest = t.lastBufferedRequest, t.bufferedRequestCount += 1
      } else m(e, t, !1, f, r, i, o);
      return u
    }

    function m(e, t, n, r, i, o, s) {
      t.writelen = r, t.writecb = s, t.writing = !0, t.sync = !0, n ? e._writev(i, t.onwrite) : e._write(i, o, t.onwrite), t.sync = !1
    }

    function R(e, t, r, i, o) {
      --t.pendingcb, r ? (n.nextTick(o, i), n.nextTick(T, e, t), e._writableState.errorEmitted = !0, e.emit("error", i)) : (o(i), e._writableState.errorEmitted = !0, e.emit("error", i), T(e, t))
    }

    function x(e) {
      e.writing = !1, e.writecb = null, e.length -= e.writelen, e.writelen = 0
    }

    function S(e, t) {
      var n = e._writableState,
        r = n.sync,
        i = n.writecb;
      if (x(n), t) R(e, n, r, t, i);
      else {
        var o = E(n);
        o || n.corked || n.bufferProcessing || !n.bufferedRequest || B(e, n), r ? s(M, e, n, o, i) : M(e, n, o, i)
      }
    }

    function M(e, t, n, r) {
      n || j(e, t), t.pendingcb--, r(), T(e, t)
    }

    function j(e, t) {
      0 === t.length && t.needDrain && (t.needDrain = !1, e.emit("drain"))
    }

    function B(e, t) {
      t.bufferProcessing = !0;
      var n = t.bufferedRequest;
      if (e._writev && n && n.next) {
        var r = t.bufferedRequestCount,
          o = new Array(r),
          s = t.corkedRequestsFree;
        s.entry = n;
        for (var f = 0, u = !0; n;) o[f] = n, n.isBuf || (u = !1), n = n.next, f += 1;
        o.allBuffers = u, m(e, t, !0, t.length, o, "", s.finish), t.pendingcb++, t.lastBufferedRequest = null, s.next ? (t.corkedRequestsFree = s.next, s.next = null) : t.corkedRequestsFree = new i(t), t.bufferedRequestCount = 0
      } else {
        for (; n;) {
          var a = n.chunk,
            c = n.encoding,
            l = n.callback;
          if (m(e, t, !1, t.objectMode ? 1 : a.length, a, c, l), n = n.next, t.bufferedRequestCount--, t.writing) break
        }
        null === n && (t.lastBufferedRequest = null)
      }
      t.bufferedRequest = n, t.bufferProcessing = !1
    }

    function E(e) {
      return e.ending && 0 === e.length && null === e.bufferedRequest && !e.finished && !e.writing
    }

    function C(e, t) {
      e._final(function(n) {
        t.pendingcb--, n && e.emit("error", n), t.prefinished = !0, e.emit("prefinish"), T(e, t)
      })
    }

    function P(e, t) {
      t.prefinished || t.finalCalled || ("function" == typeof e._final ? (t.pendingcb++, t.finalCalled = !0, n.nextTick(C, e, t)) : (t.prefinished = !0, e.emit("prefinish")))
    }

    function T(e, t) {
      var n = E(t);
      return n && (P(e, t), 0 === t.pendingcb && (t.finished = !0, e.emit("finish"))), n
    }

    function F(e, t, r) {
      t.ending = !0, T(e, t), r && (t.finished ? n.nextTick(r) : e.once("finish", r)), t.ended = !0, e.writable = !1
    }

    function W(e, t, n) {
      var r = e.entry;
      for (e.entry = null; r;) {
        var i = r.callback;
        t.pendingcb--, i(n), r = r.next
      }
      t.corkedRequestsFree ? t.corkedRequestsFree.next = e : t.corkedRequestsFree = e
    }
    f.inherits(g, a), y.prototype.getBuffer = function() {
        for (var e = this.bufferedRequest, t = []; e;) t.push(e), e = e.next;
        return t
      },
      function() {
        try {
          Object.defineProperty(y.prototype, "buffer", {
            get: u.deprecate(function() {
              return this.getBuffer()
            }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
          })
        } catch (e) {}
      }(), "function" == typeof Symbol && Symbol.hasInstance && "function" == typeof Function.prototype[Symbol.hasInstance] ? (b = Function.prototype[Symbol.hasInstance], Object.defineProperty(g, Symbol.hasInstance, {
        value: function(e) {
          return !!b.call(this, e) || this === g && (e && e._writableState instanceof y)
        }
      })) : b = function(e) {
        return e instanceof this
      }, g.prototype.pipe = function() {
        this.emit("error", new Error("Cannot pipe, not readable"))
      }, g.prototype.write = function(e, t, n) {
        var r = this._writableState,
          i = !1,
          o = !r.objectMode && h(e);
        return o && !c.isBuffer(e) && (e = d(e)), "function" == typeof t && (n = t, t = null), o ? t = "buffer" : t || (t = r.defaultEncoding), "function" != typeof n && (n = w), r.ended ? k(this, n) : (o || v(this, r, e, n)) && (r.pendingcb++, i = _(this, r, o, e, t, n)), i
      }, g.prototype.cork = function() {
        this._writableState.corked++
      }, g.prototype.uncork = function() {
        var e = this._writableState;
        e.corked && (e.corked--, e.writing || e.corked || e.finished || e.bufferProcessing || !e.bufferedRequest || B(this, e))
      }, g.prototype.setDefaultEncoding = function(e) {
        if ("string" == typeof e && (e = e.toLowerCase()), !(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((e + "").toLowerCase()) > -1)) throw new TypeError("Unknown encoding: " + e);
        return this._writableState.defaultEncoding = e, this
      }, Object.defineProperty(g.prototype, "writableHighWaterMark", {
        enumerable: !1,
        get: function() {
          return this._writableState.highWaterMark
        }
      }), g.prototype._write = function(e, t, n) {
        n(new Error("_write() is not implemented"))
      }, g.prototype._writev = null, g.prototype.end = function(e, t, n) {
        var r = this._writableState;
        "function" == typeof e ? (n = e, e = null, t = null) : "function" == typeof t && (n = t, t = null), null != e && this.write(e, t), r.corked && (r.corked = 1, this.uncork()), r.ending || r.finished || F(this, r, n)
      }, Object.defineProperty(g.prototype, "destroyed", {
        get: function() {
          return void 0 !== this._writableState && this._writableState.destroyed
        },
        set: function(e) {
          this._writableState && (this._writableState.destroyed = e)
        }
      }), g.prototype.destroy = p.destroy, g.prototype._undestroy = p.undestroy, g.prototype._destroy = function(e, t) {
        this.end(), t(e)
      };
  }, {
    "process-nextick-args": "Yj0v",
    "core-util-is": "Q14w",
    "inherits": "Bm0n",
    "util-deprecate": "yM1o",
    "./internal/streams/stream": "ExO1",
    "safe-buffer": "Wugr",
    "./internal/streams/destroy": "GRUB",
    "./_stream_duplex": "Hba0",
    "process": "pBGv"
  }],
  "Hba0": [function(require, module, exports) {
    "use strict";
    var e = require("process-nextick-args"),
      t = Object.keys || function(e) {
        var t = [];
        for (var r in e) t.push(r);
        return t
      };
    module.exports = l;
    var r = Object.create(require("core-util-is"));
    r.inherits = require("inherits");
    var i = require("./_stream_readable"),
      a = require("./_stream_writable");
    r.inherits(l, i);
    for (var o = t(a.prototype), s = 0; s < o.length; s++) {
      var n = o[s];
      l.prototype[n] || (l.prototype[n] = a.prototype[n])
    }

    function l(e) {
      if (!(this instanceof l)) return new l(e);
      i.call(this, e), a.call(this, e), e && !1 === e.readable && (this.readable = !1), e && !1 === e.writable && (this.writable = !1), this.allowHalfOpen = !0, e && !1 === e.allowHalfOpen && (this.allowHalfOpen = !1), this.once("end", h)
    }

    function h() {
      this.allowHalfOpen || this._writableState.ended || e.nextTick(d, this)
    }

    function d(e) {
      e.end()
    }
    Object.defineProperty(l.prototype, "writableHighWaterMark", {
      enumerable: !1,
      get: function() {
        return this._writableState.highWaterMark
      }
    }), Object.defineProperty(l.prototype, "destroyed", {
      get: function() {
        return void 0 !== this._readableState && void 0 !== this._writableState && (this._readableState.destroyed && this._writableState.destroyed)
      },
      set: function(e) {
        void 0 !== this._readableState && void 0 !== this._writableState && (this._readableState.destroyed = e, this._writableState.destroyed = e)
      }
    }), l.prototype._destroy = function(t, r) {
      this.push(null), this.end(), e.nextTick(r, t)
    };
  }, {
    "process-nextick-args": "Yj0v",
    "core-util-is": "Q14w",
    "inherits": "Bm0n",
    "./_stream_readable": "DHrQ",
    "./_stream_writable": "WSyY"
  }],
  "BUbk": [function(require, module, exports) {

    "use strict";
    var t = require("safe-buffer").Buffer,
      e = t.isEncoding || function(t) {
        switch ((t = "" + t) && t.toLowerCase()) {
          case "hex":
          case "utf8":
          case "utf-8":
          case "ascii":
          case "binary":
          case "base64":
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
          case "raw":
            return !0;
          default:
            return !1
        }
      };

    function s(t) {
      if (!t) return "utf8";
      for (var e;;) switch (t) {
        case "utf8":
        case "utf-8":
          return "utf8";
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return "utf16le";
        case "latin1":
        case "binary":
          return "latin1";
        case "base64":
        case "ascii":
        case "hex":
          return t;
        default:
          if (e) return;
          t = ("" + t).toLowerCase(), e = !0
      }
    }

    function i(i) {
      var a = s(i);
      if ("string" != typeof a && (t.isEncoding === e || !e(i))) throw new Error("Unknown encoding: " + i);
      return a || i
    }

    function a(e) {
      var s;
      switch (this.encoding = i(e), this.encoding) {
        case "utf16le":
          this.text = c, this.end = f, s = 4;
          break;
        case "utf8":
          this.fillLast = l, s = 4;
          break;
        case "base64":
          this.text = d, this.end = g, s = 3;
          break;
        default:
          return this.write = N, void(this.end = v)
      }
      this.lastNeed = 0, this.lastTotal = 0, this.lastChar = t.allocUnsafe(s)
    }

    function r(t) {
      return t <= 127 ? 0 : t >> 5 == 6 ? 2 : t >> 4 == 14 ? 3 : t >> 3 == 30 ? 4 : t >> 6 == 2 ? -1 : -2
    }

    function n(t, e, s) {
      var i = e.length - 1;
      if (i < s) return 0;
      var a = r(e[i]);
      return a >= 0 ? (a > 0 && (t.lastNeed = a - 1), a) : --i < s || -2 === a ? 0 : (a = r(e[i])) >= 0 ? (a > 0 && (t.lastNeed = a - 2), a) : --i < s || -2 === a ? 0 : (a = r(e[i])) >= 0 ? (a > 0 && (2 === a ? a = 0 : t.lastNeed = a - 3), a) : 0
    }

    function h(t, e, s) {
      if (128 != (192 & e[0])) return t.lastNeed = 0, "";
      if (t.lastNeed > 1 && e.length > 1) {
        if (128 != (192 & e[1])) return t.lastNeed = 1, "";
        if (t.lastNeed > 2 && e.length > 2 && 128 != (192 & e[2])) return t.lastNeed = 2, ""
      }
    }

    function l(t) {
      var e = this.lastTotal - this.lastNeed,
        s = h(this, t, e);
      return void 0 !== s ? s : this.lastNeed <= t.length ? (t.copy(this.lastChar, e, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal)) : (t.copy(this.lastChar, e, 0, t.length), void(this.lastNeed -= t.length))
    }

    function u(t, e) {
      var s = n(this, t, e);
      if (!this.lastNeed) return t.toString("utf8", e);
      this.lastTotal = s;
      var i = t.length - (s - this.lastNeed);
      return t.copy(this.lastChar, 0, i), t.toString("utf8", e, i)
    }

    function o(t) {
      var e = t && t.length ? this.write(t) : "";
      return this.lastNeed ? e + "" : e
    }

    function c(t, e) {
      if ((t.length - e) % 2 == 0) {
        var s = t.toString("utf16le", e);
        if (s) {
          var i = s.charCodeAt(s.length - 1);
          if (i >= 55296 && i <= 56319) return this.lastNeed = 2, this.lastTotal = 4, this.lastChar[0] = t[t.length - 2], this.lastChar[1] = t[t.length - 1], s.slice(0, -1)
        }
        return s
      }
      return this.lastNeed = 1, this.lastTotal = 2, this.lastChar[0] = t[t.length - 1], t.toString("utf16le", e, t.length - 1)
    }

    function f(t) {
      var e = t && t.length ? this.write(t) : "";
      if (this.lastNeed) {
        var s = this.lastTotal - this.lastNeed;
        return e + this.lastChar.toString("utf16le", 0, s)
      }
      return e
    }

    function d(t, e) {
      var s = (t.length - e) % 3;
      return 0 === s ? t.toString("base64", e) : (this.lastNeed = 3 - s, this.lastTotal = 3, 1 === s ? this.lastChar[0] = t[t.length - 1] : (this.lastChar[0] = t[t.length - 2], this.lastChar[1] = t[t.length - 1]), t.toString("base64", e, t.length - s))
    }

    function g(t) {
      var e = t && t.length ? this.write(t) : "";
      return this.lastNeed ? e + this.lastChar.toString("base64", 0, 3 - this.lastNeed) : e
    }

    function N(t) {
      return t.toString(this.encoding)
    }

    function v(t) {
      return t && t.length ? this.write(t) : ""
    }
    exports.StringDecoder = a, a.prototype.write = function(t) {
      if (0 === t.length) return "";
      var e, s;
      if (this.lastNeed) {
        if (void 0 === (e = this.fillLast(t))) return "";
        s = this.lastNeed, this.lastNeed = 0
      } else s = 0;
      return s < t.length ? e ? e + this.text(t, s) : this.text(t, s) : e || ""
    }, a.prototype.end = o, a.prototype.text = u, a.prototype.fillLast = function(t) {
      if (this.lastNeed <= t.length) return t.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
      t.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, t.length), this.lastNeed -= t.length
    };
  }, {
    "safe-buffer": "Wugr"
  }],
  "DHrQ": [function(require, module, exports) {

    var global = arguments[3];
    var process = require("process");
    var e = arguments[3],
      t = require("process"),
      n = require("process-nextick-args");
    module.exports = _;
    var r, i = require("isarray");
    _.ReadableState = w;
    var a = require("events").EventEmitter,
      d = function(e, t) {
        return e.listeners(t).length
      },
      o = require("./internal/streams/stream"),
      s = require("safe-buffer").Buffer,
      u = e.Uint8Array || function() {};

    function l(e) {
      return s.from(e)
    }

    function h(e) {
      return s.isBuffer(e) || e instanceof u
    }
    var p = Object.create(require("core-util-is"));
    p.inherits = require("inherits");
    var f = require("util"),
      c = void 0;
    c = f && f.debuglog ? f.debuglog("stream") : function() {};
    var g, b = require("./internal/streams/BufferList"),
      m = require("./internal/streams/destroy");
    p.inherits(_, o);
    var v = ["error", "close", "destroy", "pause", "resume"];

    function y(e, t, n) {
      if ("function" == typeof e.prependListener) return e.prependListener(t, n);
      e._events && e._events[t] ? i(e._events[t]) ? e._events[t].unshift(n) : e._events[t] = [n, e._events[t]] : e.on(t, n)
    }

    function w(e, t) {
      e = e || {};
      var n = t instanceof(r = r || require("./_stream_duplex"));
      this.objectMode = !!e.objectMode, n && (this.objectMode = this.objectMode || !!e.readableObjectMode);
      var i = e.highWaterMark,
        a = e.readableHighWaterMark,
        d = this.objectMode ? 16 : 16384;
      this.highWaterMark = i || 0 === i ? i : n && (a || 0 === a) ? a : d, this.highWaterMark = Math.floor(this.highWaterMark), this.buffer = new b, this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = !1, this.endEmitted = !1, this.reading = !1, this.sync = !0, this.needReadable = !1, this.emittedReadable = !1, this.readableListening = !1, this.resumeScheduled = !1, this.destroyed = !1, this.defaultEncoding = e.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore = !1, this.decoder = null, this.encoding = null, e.encoding && (g || (g = require("string_decoder/").StringDecoder), this.decoder = new g(e.encoding), this.encoding = e.encoding)
    }

    function _(e) {
      if (r = r || require("./_stream_duplex"), !(this instanceof _)) return new _(e);
      this._readableState = new w(e, this), this.readable = !0, e && ("function" == typeof e.read && (this._read = e.read), "function" == typeof e.destroy && (this._destroy = e.destroy)), o.call(this)
    }

    function M(e, t, n, r, i) {
      var a, d = e._readableState;
      null === t ? (d.reading = !1, x(e, d)) : (i || (a = k(d, t)), a ? e.emit("error", a) : d.objectMode || t && t.length > 0 ? ("string" == typeof t || d.objectMode || Object.getPrototypeOf(t) === s.prototype || (t = l(t)), r ? d.endEmitted ? e.emit("error", new Error("stream.unshift() after end event")) : S(e, d, t, !0) : d.ended ? e.emit("error", new Error("stream.push() after EOF")) : (d.reading = !1, d.decoder && !n ? (t = d.decoder.write(t), d.objectMode || 0 !== t.length ? S(e, d, t, !1) : C(e, d)) : S(e, d, t, !1))) : r || (d.reading = !1));
      return j(d)
    }

    function S(e, t, n, r) {
      t.flowing && 0 === t.length && !t.sync ? (e.emit("data", n), e.read(0)) : (t.length += t.objectMode ? 1 : n.length, r ? t.buffer.unshift(n) : t.buffer.push(n), t.needReadable && q(e)), C(e, t)
    }

    function k(e, t) {
      var n;
      return h(t) || "string" == typeof t || void 0 === t || e.objectMode || (n = new TypeError("Invalid non-string/buffer chunk")), n
    }

    function j(e) {
      return !e.ended && (e.needReadable || e.length < e.highWaterMark || 0 === e.length)
    }
    Object.defineProperty(_.prototype, "destroyed", {
      get: function() {
        return void 0 !== this._readableState && this._readableState.destroyed
      },
      set: function(e) {
        this._readableState && (this._readableState.destroyed = e)
      }
    }), _.prototype.destroy = m.destroy, _.prototype._undestroy = m.undestroy, _.prototype._destroy = function(e, t) {
      this.push(null), t(e)
    }, _.prototype.push = function(e, t) {
      var n, r = this._readableState;
      return r.objectMode ? n = !0 : "string" == typeof e && ((t = t || r.defaultEncoding) !== r.encoding && (e = s.from(e, t), t = ""), n = !0), M(this, e, t, !1, n)
    }, _.prototype.unshift = function(e) {
      return M(this, e, null, !0, !1)
    }, _.prototype.isPaused = function() {
      return !1 === this._readableState.flowing
    }, _.prototype.setEncoding = function(e) {
      return g || (g = require("string_decoder/").StringDecoder), this._readableState.decoder = new g(e), this._readableState.encoding = e, this
    };
    var R = 8388608;

    function E(e) {
      return e >= R ? e = R : (e--, e |= e >>> 1, e |= e >>> 2, e |= e >>> 4, e |= e >>> 8, e |= e >>> 16, e++), e
    }

    function L(e, t) {
      return e <= 0 || 0 === t.length && t.ended ? 0 : t.objectMode ? 1 : e != e ? t.flowing && t.length ? t.buffer.head.data.length : t.length : (e > t.highWaterMark && (t.highWaterMark = E(e)), e <= t.length ? e : t.ended ? t.length : (t.needReadable = !0, 0))
    }

    function x(e, t) {
      if (!t.ended) {
        if (t.decoder) {
          var n = t.decoder.end();
          n && n.length && (t.buffer.push(n), t.length += t.objectMode ? 1 : n.length)
        }
        t.ended = !0, q(e)
      }
    }

    function q(e) {
      var t = e._readableState;
      t.needReadable = !1, t.emittedReadable || (c("emitReadable", t.flowing), t.emittedReadable = !0, t.sync ? n.nextTick(W, e) : W(e))
    }

    function W(e) {
      c("emit readable"), e.emit("readable"), B(e)
    }

    function C(e, t) {
      t.readingMore || (t.readingMore = !0, n.nextTick(D, e, t))
    }

    function D(e, t) {
      for (var n = t.length; !t.reading && !t.flowing && !t.ended && t.length < t.highWaterMark && (c("maybeReadMore read 0"), e.read(0), n !== t.length);) n = t.length;
      t.readingMore = !1
    }

    function O(e) {
      return function() {
        var t = e._readableState;
        c("pipeOnDrain", t.awaitDrain), t.awaitDrain && t.awaitDrain--, 0 === t.awaitDrain && d(e, "data") && (t.flowing = !0, B(e))
      }
    }

    function T(e) {
      c("readable nexttick read 0"), e.read(0)
    }

    function U(e, t) {
      t.resumeScheduled || (t.resumeScheduled = !0, n.nextTick(P, e, t))
    }

    function P(e, t) {
      t.reading || (c("resume read 0"), e.read(0)), t.resumeScheduled = !1, t.awaitDrain = 0, e.emit("resume"), B(e), t.flowing && !t.reading && e.read(0)
    }

    function B(e) {
      var t = e._readableState;
      for (c("flow", t.flowing); t.flowing && null !== e.read(););
    }

    function H(e, t) {
      return 0 === t.length ? null : (t.objectMode ? n = t.buffer.shift() : !e || e >= t.length ? (n = t.decoder ? t.buffer.join("") : 1 === t.buffer.length ? t.buffer.head.data : t.buffer.concat(t.length), t.buffer.clear()) : n = I(e, t.buffer, t.decoder), n);
      var n
    }

    function I(e, t, n) {
      var r;
      return e < t.head.data.length ? (r = t.head.data.slice(0, e), t.head.data = t.head.data.slice(e)) : r = e === t.head.data.length ? t.shift() : n ? A(e, t) : F(e, t), r
    }

    function A(e, t) {
      var n = t.head,
        r = 1,
        i = n.data;
      for (e -= i.length; n = n.next;) {
        var a = n.data,
          d = e > a.length ? a.length : e;
        if (d === a.length ? i += a : i += a.slice(0, e), 0 === (e -= d)) {
          d === a.length ? (++r, n.next ? t.head = n.next : t.head = t.tail = null) : (t.head = n, n.data = a.slice(d));
          break
        }++r
      }
      return t.length -= r, i
    }

    function F(e, t) {
      var n = s.allocUnsafe(e),
        r = t.head,
        i = 1;
      for (r.data.copy(n), e -= r.data.length; r = r.next;) {
        var a = r.data,
          d = e > a.length ? a.length : e;
        if (a.copy(n, n.length - e, 0, d), 0 === (e -= d)) {
          d === a.length ? (++i, r.next ? t.head = r.next : t.head = t.tail = null) : (t.head = r, r.data = a.slice(d));
          break
        }++i
      }
      return t.length -= i, n
    }

    function z(e) {
      var t = e._readableState;
      if (t.length > 0) throw new Error('"endReadable()" called on non-empty stream');
      t.endEmitted || (t.ended = !0, n.nextTick(G, t, e))
    }

    function G(e, t) {
      e.endEmitted || 0 !== e.length || (e.endEmitted = !0, t.readable = !1, t.emit("end"))
    }

    function J(e, t) {
      for (var n = 0, r = e.length; n < r; n++)
        if (e[n] === t) return n;
      return -1
    }
    _.prototype.read = function(e) {
      c("read", e), e = parseInt(e, 10);
      var t = this._readableState,
        n = e;
      if (0 !== e && (t.emittedReadable = !1), 0 === e && t.needReadable && (t.length >= t.highWaterMark || t.ended)) return c("read: emitReadable", t.length, t.ended), 0 === t.length && t.ended ? z(this) : q(this), null;
      if (0 === (e = L(e, t)) && t.ended) return 0 === t.length && z(this), null;
      var r, i = t.needReadable;
      return c("need readable", i), (0 === t.length || t.length - e < t.highWaterMark) && c("length less than watermark", i = !0), t.ended || t.reading ? c("reading or ended", i = !1) : i && (c("do read"), t.reading = !0, t.sync = !0, 0 === t.length && (t.needReadable = !0), this._read(t.highWaterMark), t.sync = !1, t.reading || (e = L(n, t))), null === (r = e > 0 ? H(e, t) : null) ? (t.needReadable = !0, e = 0) : t.length -= e, 0 === t.length && (t.ended || (t.needReadable = !0), n !== e && t.ended && z(this)), null !== r && this.emit("data", r), r
    }, _.prototype._read = function(e) {
      this.emit("error", new Error("_read() is not implemented"))
    }, _.prototype.pipe = function(e, r) {
      var i = this,
        a = this._readableState;
      switch (a.pipesCount) {
        case 0:
          a.pipes = e;
          break;
        case 1:
          a.pipes = [a.pipes, e];
          break;
        default:
          a.pipes.push(e)
      }
      a.pipesCount += 1, c("pipe count=%d opts=%j", a.pipesCount, r);
      var o = (!r || !1 !== r.end) && e !== t.stdout && e !== t.stderr ? u : v;

      function s(t, n) {
        c("onunpipe"), t === i && n && !1 === n.hasUnpiped && (n.hasUnpiped = !0, c("cleanup"), e.removeListener("close", b), e.removeListener("finish", m), e.removeListener("drain", l), e.removeListener("error", g), e.removeListener("unpipe", s), i.removeListener("end", u), i.removeListener("end", v), i.removeListener("data", f), h = !0, !a.awaitDrain || e._writableState && !e._writableState.needDrain || l())
      }

      function u() {
        c("onend"), e.end()
      }
      a.endEmitted ? n.nextTick(o) : i.once("end", o), e.on("unpipe", s);
      var l = O(i);
      e.on("drain", l);
      var h = !1;
      var p = !1;

      function f(t) {
        c("ondata"), p = !1, !1 !== e.write(t) || p || ((1 === a.pipesCount && a.pipes === e || a.pipesCount > 1 && -1 !== J(a.pipes, e)) && !h && (c("false write response, pause", i._readableState.awaitDrain), i._readableState.awaitDrain++, p = !0), i.pause())
      }

      function g(t) {
        c("onerror", t), v(), e.removeListener("error", g), 0 === d(e, "error") && e.emit("error", t)
      }

      function b() {
        e.removeListener("finish", m), v()
      }

      function m() {
        c("onfinish"), e.removeListener("close", b), v()
      }

      function v() {
        c("unpipe"), i.unpipe(e)
      }
      return i.on("data", f), y(e, "error", g), e.once("close", b), e.once("finish", m), e.emit("pipe", i), a.flowing || (c("pipe resume"), i.resume()), e
    }, _.prototype.unpipe = function(e) {
      var t = this._readableState,
        n = {
          hasUnpiped: !1
        };
      if (0 === t.pipesCount) return this;
      if (1 === t.pipesCount) return e && e !== t.pipes ? this : (e || (e = t.pipes), t.pipes = null, t.pipesCount = 0, t.flowing = !1, e && e.emit("unpipe", this, n), this);
      if (!e) {
        var r = t.pipes,
          i = t.pipesCount;
        t.pipes = null, t.pipesCount = 0, t.flowing = !1;
        for (var a = 0; a < i; a++) r[a].emit("unpipe", this, n);
        return this
      }
      var d = J(t.pipes, e);
      return -1 === d ? this : (t.pipes.splice(d, 1), t.pipesCount -= 1, 1 === t.pipesCount && (t.pipes = t.pipes[0]), e.emit("unpipe", this, n), this)
    }, _.prototype.on = function(e, t) {
      var r = o.prototype.on.call(this, e, t);
      if ("data" === e) !1 !== this._readableState.flowing && this.resume();
      else if ("readable" === e) {
        var i = this._readableState;
        i.endEmitted || i.readableListening || (i.readableListening = i.needReadable = !0, i.emittedReadable = !1, i.reading ? i.length && q(this) : n.nextTick(T, this))
      }
      return r
    }, _.prototype.addListener = _.prototype.on, _.prototype.resume = function() {
      var e = this._readableState;
      return e.flowing || (c("resume"), e.flowing = !0, U(this, e)), this
    }, _.prototype.pause = function() {
      return c("call pause flowing=%j", this._readableState.flowing), !1 !== this._readableState.flowing && (c("pause"), this._readableState.flowing = !1, this.emit("pause")), this
    }, _.prototype.wrap = function(e) {
      var t = this,
        n = this._readableState,
        r = !1;
      for (var i in e.on("end", function() {
          if (c("wrapped end"), n.decoder && !n.ended) {
            var e = n.decoder.end();
            e && e.length && t.push(e)
          }
          t.push(null)
        }), e.on("data", function(i) {
          (c("wrapped data"), n.decoder && (i = n.decoder.write(i)), n.objectMode && null == i) || (n.objectMode || i && i.length) && (t.push(i) || (r = !0, e.pause()))
        }), e) void 0 === this[i] && "function" == typeof e[i] && (this[i] = function(t) {
        return function() {
          return e[t].apply(e, arguments)
        }
      }(i));
      for (var a = 0; a < v.length; a++) e.on(v[a], this.emit.bind(this, v[a]));
      return this._read = function(t) {
        c("wrapped _read", t), r && (r = !1, e.resume())
      }, this
    }, Object.defineProperty(_.prototype, "readableHighWaterMark", {
      enumerable: !1,
      get: function() {
        return this._readableState.highWaterMark
      }
    }), _._fromList = H;
  }, {
    "process-nextick-args": "Yj0v",
    "isarray": "REa7",
    "events": "FRpO",
    "./internal/streams/stream": "ExO1",
    "safe-buffer": "Wugr",
    "core-util-is": "Q14w",
    "inherits": "Bm0n",
    "util": "rDCW",
    "./internal/streams/BufferList": "wlMe",
    "./internal/streams/destroy": "GRUB",
    "./_stream_duplex": "Hba0",
    "string_decoder/": "BUbk",
    "process": "pBGv"
  }],
  "tlBz": [function(require, module, exports) {
    "use strict";
    module.exports = n;
    var t = require("./_stream_duplex"),
      r = Object.create(require("core-util-is"));

    function e(t, r) {
      var e = this._transformState;
      e.transforming = !1;
      var n = e.writecb;
      if (!n) return this.emit("error", new Error("write callback called multiple times"));
      e.writechunk = null, e.writecb = null, null != r && this.push(r), n(t);
      var i = this._readableState;
      i.reading = !1, (i.needReadable || i.length < i.highWaterMark) && this._read(i.highWaterMark)
    }

    function n(r) {
      if (!(this instanceof n)) return new n(r);
      t.call(this, r), this._transformState = {
        afterTransform: e.bind(this),
        needTransform: !1,
        transforming: !1,
        writecb: null,
        writechunk: null,
        writeencoding: null
      }, this._readableState.needReadable = !0, this._readableState.sync = !1, r && ("function" == typeof r.transform && (this._transform = r.transform), "function" == typeof r.flush && (this._flush = r.flush)), this.on("prefinish", i)
    }

    function i() {
      var t = this;
      "function" == typeof this._flush ? this._flush(function(r, e) {
        a(t, r, e)
      }) : a(this, null, null)
    }

    function a(t, r, e) {
      if (r) return t.emit("error", r);
      if (null != e && t.push(e), t._writableState.length) throw new Error("Calling transform done when ws.length != 0");
      if (t._transformState.transforming) throw new Error("Calling transform done when still transforming");
      return t.push(null)
    }
    r.inherits = require("inherits"), r.inherits(n, t), n.prototype.push = function(r, e) {
      return this._transformState.needTransform = !1, t.prototype.push.call(this, r, e)
    }, n.prototype._transform = function(t, r, e) {
      throw new Error("_transform() is not implemented")
    }, n.prototype._write = function(t, r, e) {
      var n = this._transformState;
      if (n.writecb = e, n.writechunk = t, n.writeencoding = r, !n.transforming) {
        var i = this._readableState;
        (n.needTransform || i.needReadable || i.length < i.highWaterMark) && this._read(i.highWaterMark)
      }
    }, n.prototype._read = function(t) {
      var r = this._transformState;
      null !== r.writechunk && r.writecb && !r.transforming ? (r.transforming = !0, this._transform(r.writechunk, r.writeencoding, r.afterTransform)) : r.needTransform = !0
    }, n.prototype._destroy = function(r, e) {
      var n = this;
      t.prototype._destroy.call(this, r, function(t) {
        e(t), n.emit("close")
      })
    };
  }, {
    "./_stream_duplex": "Hba0",
    "core-util-is": "Q14w",
    "inherits": "Bm0n"
  }],
  "nwyA": [function(require, module, exports) {
    "use strict";
    module.exports = t;
    var r = require("./_stream_transform"),
      e = Object.create(require("core-util-is"));

    function t(e) {
      if (!(this instanceof t)) return new t(e);
      r.call(this, e)
    }
    e.inherits = require("inherits"), e.inherits(t, r), t.prototype._transform = function(r, e, t) {
      t(null, r)
    };
  }, {
    "./_stream_transform": "tlBz",
    "core-util-is": "Q14w",
    "inherits": "Bm0n"
  }],
  "tzeh": [function(require, module, exports) {
    exports = module.exports = require("./lib/_stream_readable.js"), exports.Stream = exports, exports.Readable = exports, exports.Writable = require("./lib/_stream_writable.js"), exports.Duplex = require("./lib/_stream_duplex.js"), exports.Transform = require("./lib/_stream_transform.js"), exports.PassThrough = require("./lib/_stream_passthrough.js");
  }, {
    "./lib/_stream_readable.js": "DHrQ",
    "./lib/_stream_writable.js": "WSyY",
    "./lib/_stream_duplex.js": "Hba0",
    "./lib/_stream_transform.js": "tlBz",
    "./lib/_stream_passthrough.js": "nwyA"
  }],
  "UxIR": [function(require, module, exports) {
    var process = require("process");
    var Buffer = require("buffer").Buffer;
    var global = arguments[3];
    var e = require("process"),
      r = require("buffer").Buffer,
      t = arguments[3],
      s = require("./capability"),
      a = require("inherits"),
      o = require("readable-stream"),
      n = exports.readyStates = {
        UNSENT: 0,
        OPENED: 1,
        HEADERS_RECEIVED: 2,
        LOADING: 3,
        DONE: 4
      },
      u = exports.IncomingMessage = function(a, n, u, i) {
        var c = this;
        if (o.Readable.call(c), c._mode = u, c.headers = {}, c.rawHeaders = [], c.trailers = {}, c.rawTrailers = [], c.on("end", function() {
            e.nextTick(function() {
              c.emit("close")
            })
          }), "fetch" === u) {
          if (c._fetchResponse = n, c.url = n.url, c.statusCode = n.status, c.statusMessage = n.statusText, n.headers.forEach(function(e, r) {
              c.headers[r.toLowerCase()] = e, c.rawHeaders.push(r, e)
            }), s.writableStream) {
            var d = new WritableStream({
              write: function(e) {
                return new Promise(function(t, s) {
                  c._destroyed ? s() : c.push(new r(e)) ? t() : c._resumeFetch = t
                })
              },
              close: function() {
                t.clearTimeout(i), c._destroyed || c.push(null)
              },
              abort: function(e) {
                c._destroyed || c.emit("error", e)
              }
            });
            try {
              return void n.body.pipeTo(d).catch(function(e) {
                t.clearTimeout(i), c._destroyed || c.emit("error", e)
              })
            } catch (p) {}
          }
          var h = n.body.getReader();
          ! function e() {
            h.read().then(function(s) {
              if (!c._destroyed) {
                if (s.done) return t.clearTimeout(i), void c.push(null);
                c.push(new r(s.value)), e()
              }
            }).catch(function(e) {
              t.clearTimeout(i), c._destroyed || c.emit("error", e)
            })
          }()
        } else {
          if (c._xhr = a, c._pos = 0, c.url = a.responseURL, c.statusCode = a.status, c.statusMessage = a.statusText, a.getAllResponseHeaders().split(/\r?\n/).forEach(function(e) {
              var r = e.match(/^([^:]+):\s*(.*)/);
              if (r) {
                var t = r[1].toLowerCase();
                "set-cookie" === t ? (void 0 === c.headers[t] && (c.headers[t] = []), c.headers[t].push(r[2])) : void 0 !== c.headers[t] ? c.headers[t] += ", " + r[2] : c.headers[t] = r[2], c.rawHeaders.push(r[1], r[2])
              }
            }), c._charset = "x-user-defined", !s.overrideMimeType) {
            var f = c.rawHeaders["mime-type"];
            if (f) {
              var l = f.match(/;\s*charset=([^;])(;|$)/);
              l && (c._charset = l[1].toLowerCase())
            }
            c._charset || (c._charset = "utf-8")
          }
        }
      };
    a(u, o.Readable), u.prototype._read = function() {
      var e = this._resumeFetch;
      e && (this._resumeFetch = null, e())
    }, u.prototype._onXHRProgress = function() {
      var e = this,
        s = e._xhr,
        a = null;
      switch (e._mode) {
        case "text:vbarray":
          if (s.readyState !== n.DONE) break;
          try {
            a = new t.VBArray(s.responseBody).toArray()
          } catch (d) {}
          if (null !== a) {
            e.push(new r(a));
            break
          }
          case "text":
            try {
              a = s.responseText
            } catch (d) {
              e._mode = "text:vbarray";
              break
            }
            if (a.length > e._pos) {
              var o = a.substr(e._pos);
              if ("x-user-defined" === e._charset) {
                for (var u = new r(o.length), i = 0; i < o.length; i++) u[i] = 255 & o.charCodeAt(i);
                e.push(u)
              } else e.push(o, e._charset);
              e._pos = a.length
            }
            break;
          case "arraybuffer":
            if (s.readyState !== n.DONE || !s.response) break;
            a = s.response, e.push(new r(new Uint8Array(a)));
            break;
          case "moz-chunked-arraybuffer":
            if (a = s.response, s.readyState !== n.LOADING || !a) break;
            e.push(new r(new Uint8Array(a)));
            break;
          case "ms-stream":
            if (a = s.response, s.readyState !== n.LOADING) break;
            var c = new t.MSStreamReader;
            c.onprogress = function() {
              c.result.byteLength > e._pos && (e.push(new r(new Uint8Array(c.result.slice(e._pos)))), e._pos = c.result.byteLength)
            }, c.onload = function() {
              e.push(null)
            }, c.readAsArrayBuffer(a)
      }
      e._xhr.readyState === n.DONE && "ms-stream" !== e._mode && e.push(null)
    };
  }, {
    "./capability": "p5a1",
    "inherits": "Bm0n",
    "readable-stream": "tzeh",
    "process": "pBGv",
    "buffer": "dskh"
  }],
  "AH4k": [function(require, module, exports) {

    var e = require("buffer").Buffer;
    module.exports = function(f) {
      if (f instanceof Uint8Array) {
        if (0 === f.byteOffset && f.byteLength === f.buffer.byteLength) return f.buffer;
        if ("function" == typeof f.buffer.slice) return f.buffer.slice(f.byteOffset, f.byteOffset + f.byteLength)
      }
      if (e.isBuffer(f)) {
        for (var r = new Uint8Array(f.length), t = f.length, n = 0; n < t; n++) r[n] = f[n];
        return r.buffer
      }
      throw new Error("Argument must be a Buffer")
    };
  }, {
    "buffer": "dskh"
  }],
  "yL7F": [function(require, module, exports) {
    var Buffer = require("buffer").Buffer;
    var global = arguments[3];
    var process = require("process");
    var e = require("buffer").Buffer,
      t = arguments[3],
      r = require("process"),
      o = require("./capability"),
      n = require("inherits"),
      i = require("./response"),
      s = require("readable-stream"),
      a = require("to-arraybuffer"),
      c = i.IncomingMessage,
      u = i.readyStates;

    function d(e, t) {
      return o.fetch && t ? "fetch" : o.mozchunkedarraybuffer ? "moz-chunked-arraybuffer" : o.msstream ? "ms-stream" : o.arraybuffer && e ? "arraybuffer" : o.vbArray && e ? "text:vbarray" : "text"
    }
    var f = module.exports = function(t) {
      var r, n = this;
      s.Writable.call(n), n._opts = t, n._body = [], n._headers = {}, t.auth && n.setHeader("Authorization", "Basic " + new e(t.auth).toString("base64")), Object.keys(t.headers).forEach(function(e) {
        n.setHeader(e, t.headers[e])
      });
      var i = !0;
      if ("disable-fetch" === t.mode || "requestTimeout" in t && !o.abortController) i = !1, r = !0;
      else if ("prefer-streaming" === t.mode) r = !1;
      else if ("allow-wrong-content-type" === t.mode) r = !o.overrideMimeType;
      else {
        if (t.mode && "default" !== t.mode && "prefer-fast" !== t.mode) throw new Error("Invalid value for opts.mode");
        r = !0
      }
      n._mode = d(r, i), n._fetchTimer = null, n.on("finish", function() {
        n._onFinish()
      })
    };

    function h(e) {
      try {
        var t = e.status;
        return null !== t && 0 !== t
      } catch (r) {
        return !1
      }
    }
    n(f, s.Writable), f.prototype.setHeader = function(e, t) {
      var r = e.toLowerCase(); - 1 === p.indexOf(r) && (this._headers[r] = {
        name: e,
        value: t
      })
    }, f.prototype.getHeader = function(e) {
      var t = this._headers[e.toLowerCase()];
      return t ? t.value : null
    }, f.prototype.removeHeader = function(e) {
      delete this._headers[e.toLowerCase()]
    }, f.prototype._onFinish = function() {
      var n = this;
      if (!n._destroyed) {
        var i = n._opts,
          s = n._headers,
          c = null;
        "GET" !== i.method && "HEAD" !== i.method && (c = o.arraybuffer ? a(e.concat(n._body)) : o.blobConstructor ? new t.Blob(n._body.map(function(e) {
          return a(e)
        }), {
          type: (s["content-type"] || {}).value || ""
        }) : e.concat(n._body).toString());
        var d = [];
        if (Object.keys(s).forEach(function(e) {
            var t = s[e].name,
              r = s[e].value;
            Array.isArray(r) ? r.forEach(function(e) {
              d.push([t, e])
            }) : d.push([t, r])
          }), "fetch" === n._mode) {
          var f = null;
          if (o.abortController) {
            var h = new AbortController;
            f = h.signal, n._fetchAbortController = h, "requestTimeout" in i && 0 !== i.requestTimeout && (n._fetchTimer = t.setTimeout(function() {
              n.emit("requestTimeout"), n._fetchAbortController && n._fetchAbortController.abort()
            }, i.requestTimeout))
          }
          t.fetch(n._opts.url, {
            method: n._opts.method,
            headers: d,
            body: c || void 0,
            mode: "cors",
            credentials: i.withCredentials ? "include" : "same-origin",
            signal: f
          }).then(function(e) {
            n._fetchResponse = e, n._connect()
          }, function(e) {
            t.clearTimeout(n._fetchTimer), n._destroyed || n.emit("error", e)
          })
        } else {
          var p = n._xhr = new t.XMLHttpRequest;
          try {
            p.open(n._opts.method, n._opts.url, !0)
          } catch (l) {
            return void r.nextTick(function() {
              n.emit("error", l)
            })
          }
          "responseType" in p && (p.responseType = n._mode.split(":")[0]), "withCredentials" in p && (p.withCredentials = !!i.withCredentials), "text" === n._mode && "overrideMimeType" in p && p.overrideMimeType("text/plain; charset=x-user-defined"), "requestTimeout" in i && (p.timeout = i.requestTimeout, p.ontimeout = function() {
            n.emit("requestTimeout")
          }), d.forEach(function(e) {
            p.setRequestHeader(e[0], e[1])
          }), n._response = null, p.onreadystatechange = function() {
            switch (p.readyState) {
              case u.LOADING:
              case u.DONE:
                n._onXHRProgress()
            }
          }, "moz-chunked-arraybuffer" === n._mode && (p.onprogress = function() {
            n._onXHRProgress()
          }), p.onerror = function() {
            n._destroyed || n.emit("error", new Error("XHR error"))
          };
          try {
            p.send(c)
          } catch (l) {
            return void r.nextTick(function() {
              n.emit("error", l)
            })
          }
        }
      }
    }, f.prototype._onXHRProgress = function() {
      h(this._xhr) && !this._destroyed && (this._response || this._connect(), this._response._onXHRProgress())
    }, f.prototype._connect = function() {
      var e = this;
      e._destroyed || (e._response = new c(e._xhr, e._fetchResponse, e._mode, e._fetchTimer), e._response.on("error", function(t) {
        e.emit("error", t)
      }), e.emit("response", e._response))
    }, f.prototype._write = function(e, t, r) {
      this._body.push(e), r()
    }, f.prototype.abort = f.prototype.destroy = function() {
      this._destroyed = !0, t.clearTimeout(this._fetchTimer), this._response && (this._response._destroyed = !0), this._xhr ? this._xhr.abort() : this._fetchAbortController && this._fetchAbortController.abort()
    }, f.prototype.end = function(e, t, r) {
      "function" == typeof e && (r = e, e = void 0), s.Writable.prototype.end.call(this, e, t, r)
    }, f.prototype.flushHeaders = function() {}, f.prototype.setTimeout = function() {}, f.prototype.setNoDelay = function() {}, f.prototype.setSocketKeepAlive = function() {};
    var p = ["accept-charset", "accept-encoding", "access-control-request-headers", "access-control-request-method", "connection", "content-length", "cookie", "cookie2", "date", "dnt", "expect", "host", "keep-alive", "origin", "referer", "te", "trailer", "transfer-encoding", "upgrade", "via"];
  }, {
    "./capability": "p5a1",
    "inherits": "Bm0n",
    "./response": "UxIR",
    "readable-stream": "tzeh",
    "to-arraybuffer": "AH4k",
    "buffer": "dskh",
    "process": "pBGv"
  }],
  "K5Tb": [function(require, module, exports) {
    module.exports = o;
    var r = Object.prototype.hasOwnProperty;

    function o() {
      for (var o = {}, t = 0; t < arguments.length; t++) {
        var e = arguments[t];
        for (var a in e) r.call(e, a) && (o[a] = e[a])
      }
      return o
    }
  }, {}],
  "OpTI": [function(require, module, exports) {
    module.exports = {
      100: "Continue",
      101: "Switching Protocols",
      102: "Processing",
      200: "OK",
      201: "Created",
      202: "Accepted",
      203: "Non-Authoritative Information",
      204: "No Content",
      205: "Reset Content",
      206: "Partial Content",
      207: "Multi-Status",
      208: "Already Reported",
      226: "IM Used",
      300: "Multiple Choices",
      301: "Moved Permanently",
      302: "Found",
      303: "See Other",
      304: "Not Modified",
      305: "Use Proxy",
      307: "Temporary Redirect",
      308: "Permanent Redirect",
      400: "Bad Request",
      401: "Unauthorized",
      402: "Payment Required",
      403: "Forbidden",
      404: "Not Found",
      405: "Method Not Allowed",
      406: "Not Acceptable",
      407: "Proxy Authentication Required",
      408: "Request Timeout",
      409: "Conflict",
      410: "Gone",
      411: "Length Required",
      412: "Precondition Failed",
      413: "Payload Too Large",
      414: "URI Too Long",
      415: "Unsupported Media Type",
      416: "Range Not Satisfiable",
      417: "Expectation Failed",
      418: "I'm a teapot",
      421: "Misdirected Request",
      422: "Unprocessable Entity",
      423: "Locked",
      424: "Failed Dependency",
      425: "Unordered Collection",
      426: "Upgrade Required",
      428: "Precondition Required",
      429: "Too Many Requests",
      431: "Request Header Fields Too Large",
      451: "Unavailable For Legal Reasons",
      500: "Internal Server Error",
      501: "Not Implemented",
      502: "Bad Gateway",
      503: "Service Unavailable",
      504: "Gateway Timeout",
      505: "HTTP Version Not Supported",
      506: "Variant Also Negotiates",
      507: "Insufficient Storage",
      508: "Loop Detected",
      509: "Bandwidth Limit Exceeded",
      510: "Not Extended",
      511: "Network Authentication Required"
    };
  }, {}],
  "KKrj": [function(require, module, exports) {
    var global = arguments[3];
    var e = arguments[3],
      t = require("./lib/request"),
      r = require("./lib/response"),
      n = require("xtend"),
      o = require("builtin-status-codes"),
      s = require("url"),
      u = exports;
    u.request = function(r, o) {
      r = "string" == typeof r ? s.parse(r) : n(r);
      var u = -1 === e.location.protocol.search(/^https?:$/) ? "http:" : "",
        E = r.protocol || u,
        a = r.hostname || r.host,
        C = r.port,
        i = r.path || "/";
      a && -1 !== a.indexOf(":") && (a = "[" + a + "]"), r.url = (a ? E + "//" + a : "") + (C ? ":" + C : "") + i, r.method = (r.method || "GET").toUpperCase(), r.headers = r.headers || {};
      var T = new t(r);
      return o && T.on("response", o), T
    }, u.get = function(e, t) {
      var r = u.request(e, t);
      return r.end(), r
    }, u.ClientRequest = t, u.IncomingMessage = r.IncomingMessage, u.Agent = function() {}, u.Agent.defaultMaxSockets = 4, u.globalAgent = new u.Agent, u.STATUS_CODES = o, u.METHODS = ["CHECKOUT", "CONNECT", "COPY", "DELETE", "GET", "HEAD", "LOCK", "M-SEARCH", "MERGE", "MKACTIVITY", "MKCOL", "MOVE", "NOTIFY", "OPTIONS", "PATCH", "POST", "PROPFIND", "PROPPATCH", "PURGE", "PUT", "REPORT", "SEARCH", "SUBSCRIBE", "TRACE", "UNLOCK", "UNSUBSCRIBE"];
  }, {
    "./lib/request": "yL7F",
    "./lib/response": "UxIR",
    "xtend": "K5Tb",
    "builtin-status-codes": "OpTI",
    "url": "Mej7"
  }],
  "wVMl": [function(require, module, exports) {
    var t = require("http"),
      r = require("url"),
      o = module.exports;
    for (var e in t) t.hasOwnProperty(e) && (o[e] = t[e]);

    function p(t) {
      if ("string" == typeof t && (t = r.parse(t)), t.protocol || (t.protocol = "https:"), "https:" !== t.protocol) throw new Error('Protocol "' + t.protocol + '" not supported. Expected "https:"');
      return t
    }
    o.request = function(r, o) {
      return r = p(r), t.request.call(this, r, o)
    }, o.get = function(r, o) {
      return r = p(r), t.get.call(this, r, o)
    };
  }, {
    "http": "KKrj",
    "url": "Mej7"
  }],
  "zv8z": [function(require, module, exports) {
    exports.endianness = function() {
      return "LE"
    }, exports.hostname = function() {
      return "undefined" != typeof location ? location.hostname : ""
    }, exports.loadavg = function() {
      return []
    }, exports.uptime = function() {
      return 0
    }, exports.freemem = function() {
      return Number.MAX_VALUE
    }, exports.totalmem = function() {
      return Number.MAX_VALUE
    }, exports.cpus = function() {
      return []
    }, exports.type = function() {
      return "Browser"
    }, exports.release = function() {
      return "undefined" != typeof navigator ? navigator.appVersion : ""
    }, exports.networkInterfaces = exports.getNetworkInterfaces = function() {
      return {}
    }, exports.arch = function() {
      return "javascript"
    }, exports.platform = function() {
      return "browser"
    }, exports.tmpdir = exports.tmpDir = function() {
      return "/tmp"
    }, exports.EOL = "\n", exports.homedir = function() {
      return "/"
    };
  }, {}],
  "peDO": [function(require, module, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    var t = function() {
      return function(t) {
        this.type = t, this.bubbles = !1, this.cancelable = !1, this.loaded = 0, this.lengthComputable = !1, this.total = 0
      }
    }();
    exports.ProgressEvent = t;
  }, {}],
  "vKeV": [function(require, module, exports) {
    "use strict";
    var r = this && this.__extends || function() {
      var r = Object.setPrototypeOf || {
        __proto__: []
      }
      instanceof Array && function(r, t) {
        r.__proto__ = t
      } || function(r, t) {
        for (var n in t) t.hasOwnProperty(n) && (r[n] = t[n])
      };
      return function(t, n) {
        function o() {
          this.constructor = t
        }
        r(t, n), t.prototype = null === n ? Object.create(n) : (o.prototype = n.prototype, new o)
      }
    }();
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    var t = function(t) {
      function n() {
        return null !== t && t.apply(this, arguments) || this
      }
      return r(n, t), n
    }(Error);
    exports.SecurityError = t;
    var n = function(t) {
      function n() {
        return null !== t && t.apply(this, arguments) || this
      }
      return r(n, t), n
    }(Error);
    exports.InvalidStateError = n;
    var o = function(t) {
      function n() {
        return null !== t && t.apply(this, arguments) || this
      }
      return r(n, t), n
    }(Error);
    exports.NetworkError = o;
    var e = function(t) {
      function n() {
        return null !== t && t.apply(this, arguments) || this
      }
      return r(n, t), n
    }(Error);
    exports.SyntaxError = e;
  }, {}],
  "YFCS": [function(require, module, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    var e = function() {
      function e() {
        this.listeners = {}
      }
      return e.prototype.addEventListener = function(e, t) {
        e = e.toLowerCase(), this.listeners[e] = this.listeners[e] || [], this.listeners[e].push(t.handleEvent || t)
      }, e.prototype.removeEventListener = function(e, t) {
        if (e = e.toLowerCase(), this.listeners[e]) {
          var s = this.listeners[e].indexOf(t.handleEvent || t);
          s < 0 || this.listeners[e].splice(s, 1)
        }
      }, e.prototype.dispatchEvent = function(e) {
        var t = e.type.toLowerCase();
        if (e.target = this, this.listeners[t])
          for (var s = 0, i = this.listeners[t]; s < i.length; s++) {
            i[s].call(this, e)
          }
        var n = this["on" + t];
        return n && n.call(this, e), !0
      }, e
    }();
    exports.XMLHttpRequestEventTarget = e;
  }, {}],
  "umrI": [function(require, module, exports) {
    var Buffer = require("buffer").Buffer;
    var t = require("buffer").Buffer,
      e = this && this.__extends || function() {
        var t = Object.setPrototypeOf || {
          __proto__: []
        }
        instanceof Array && function(t, e) {
          t.__proto__ = e
        } || function(t, e) {
          for (var n in e) e.hasOwnProperty(n) && (t[n] = e[n])
        };
        return function(e, n) {
          function r() {
            this.constructor = e
          }
          t(e, n), e.prototype = null === n ? Object.create(n) : (r.prototype = n.prototype, new r)
        }
      }();
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    var n = require("./xml-http-request-event-target"),
      r = function(n) {
        function r() {
          var t = n.call(this) || this;
          return t._contentType = null, t._body = null, t._reset(), t
        }
        return e(r, n), r.prototype._reset = function() {
          this._contentType = null, this._body = null
        }, r.prototype._setData = function(e) {
          if (null != e)
            if ("string" == typeof e) 0 !== e.length && (this._contentType = "text/plain;charset=UTF-8"), this._body = new t(e, "utf-8");
            else if (t.isBuffer(e)) this._body = e;
          else if (e instanceof ArrayBuffer) {
            for (var n = new t(e.byteLength), r = new Uint8Array(e), o = 0; o < e.byteLength; o++) n[o] = r[o];
            this._body = n
          } else {
            if (!(e.buffer && e.buffer instanceof ArrayBuffer)) throw new Error("Unsupported send() data " + e);
            n = new t(e.byteLength);
            var i = e.byteOffset;
            for (r = new Uint8Array(e.buffer), o = 0; o < e.byteLength; o++) n[o] = r[o + i];
            this._body = n
          }
        }, r.prototype._finalizeHeaders = function(t, e) {
          this._contentType && !e["content-type"] && (t["Content-Type"] = this._contentType), this._body && (t["Content-Length"] = this._body.length.toString())
        }, r.prototype._startUpload = function(t) {
          this._body && t.write(this._body), t.end()
        }, r
      }(n.XMLHttpRequestEventTarget);
    exports.XMLHttpRequestUpload = r;
  }, {
    "./xml-http-request-event-target": "YFCS",
    "buffer": "dskh"
  }],
  "WOY7": [function(require, module, exports) {
    ! function() {
      "use strict";

      function t(i, e, n, r) {
        return this instanceof t ? (this.domain = i || void 0, this.path = e || "/", this.secure = !!n, this.script = !!r, this) : new t(i, e, n, r)
      }

      function i(t, e, n) {
        return t instanceof i ? t : this instanceof i ? (this.name = null, this.value = null, this.expiration_date = 1 / 0, this.path = String(n || "/"), this.explicit_path = !1, this.domain = e || null, this.explicit_domain = !1, this.secure = !1, this.noscript = !1, t && this.parse(t, e, n), this) : new i(t, e, n)
      }
      t.All = Object.freeze(Object.create(null)), exports.CookieAccessInfo = t, exports.Cookie = i, i.prototype.toString = function() {
        var t = [this.name + "=" + this.value];
        return this.expiration_date !== 1 / 0 && t.push("expires=" + new Date(this.expiration_date).toGMTString()), this.domain && t.push("domain=" + this.domain), this.path && t.push("path=" + this.path), this.secure && t.push("secure"), this.noscript && t.push("httponly"), t.join("; ")
      }, i.prototype.toValueString = function() {
        return this.name + "=" + this.value
      };
      var e = /[:](?=\s*[a-zA-Z0-9_\-]+\s*[=])/g;

      function n() {
        var t, e;
        return this instanceof n ? (t = Object.create(null), this.setCookie = function(n, r, s) {
          var o, a;
          if (o = (n = new i(n, r, s)).expiration_date <= Date.now(), void 0 !== t[n.name]) {
            for (e = t[n.name], a = 0; a < e.length; a += 1)
              if (e[a].collidesWith(n)) return o ? (e.splice(a, 1), 0 === e.length && delete t[n.name], !1) : (e[a] = n, n);
            return !o && (e.push(n), n)
          }
          return !o && (t[n.name] = [n], t[n.name])
        }, this.getCookie = function(i, n) {
          var r, s;
          if (e = t[i])
            for (s = 0; s < e.length; s += 1)
              if ((r = e[s]).expiration_date <= Date.now()) 0 === e.length && delete t[r.name];
              else if (r.matches(n)) return r
        }, this.getCookies = function(i) {
          var e, n, r = [];
          for (e in t)(n = this.getCookie(e, i)) && r.push(n);
          return r.toString = function() {
            return r.join(":")
          }, r.toValueString = function() {
            return r.map(function(t) {
              return t.toValueString()
            }).join(";")
          }, r
        }, this) : new n
      }
      i.prototype.parse = function(t, e, n) {
        if (this instanceof i) {
          var r, s = t.split(";").filter(function(t) {
              return !!t
            }),
            o = s[0].match(/([^=]+)=([\s\S]*)/);
          if (!o) return void console.warn("Invalid cookie header encountered. Header: '" + t + "'");
          var a = o[1],
            h = o[2];
          if ("string" != typeof a || 0 === a.length || "string" != typeof h) return void console.warn("Unable to extract values from cookie header. Cookie: '" + t + "'");
          for (this.name = a, this.value = h, r = 1; r < s.length; r += 1) switch (a = (o = s[r].match(/([^=]+)(?:=([\s\S]*))?/))[1].trim().toLowerCase(), h = o[2], a) {
            case "httponly":
              this.noscript = !0;
              break;
            case "expires":
              this.expiration_date = h ? Number(Date.parse(h)) : 1 / 0;
              break;
            case "path":
              this.path = h ? h.trim() : "", this.explicit_path = !0;
              break;
            case "domain":
              this.domain = h ? h.trim() : "", this.explicit_domain = !!this.domain;
              break;
            case "secure":
              this.secure = !0
          }
          return this.explicit_path || (this.path = n || "/"), this.explicit_domain || (this.domain = e), this
        }
        return (new i).parse(t, e, n)
      }, i.prototype.matches = function(i) {
        return i === t.All || !(this.noscript && i.script || this.secure && !i.secure || !this.collidesWith(i))
      }, i.prototype.collidesWith = function(t) {
        if (this.path && !t.path || this.domain && !t.domain) return !1;
        if (this.path && 0 !== t.path.indexOf(this.path)) return !1;
        if (this.explicit_path && 0 !== t.path.indexOf(this.path)) return !1;
        var i = t.domain && t.domain.replace(/^[\.]/, ""),
          e = this.domain && this.domain.replace(/^[\.]/, "");
        if (e === i) return !0;
        if (e) {
          if (!this.explicit_domain) return !1;
          var n = i.indexOf(e);
          return -1 !== n && n === i.length - e.length
        }
        return !0
      }, exports.CookieJar = n, n.prototype.setCookies = function(t, n, r) {
        var s, o, a = [];
        for (t = (t = Array.isArray(t) ? t : t.split(e)).map(function(t) {
            return new i(t, n, r)
          }), s = 0; s < t.length; s += 1) o = t[s], this.setCookie(o, n, r) && a.push(o);
        return a
      }
    }();
  }, {}],
  "ogMQ": [function(require, module, exports) {
    var process = require("process");
    var Buffer = require("buffer").Buffer;
    var e = require("process"),
      t = require("buffer").Buffer,
      s = this && this.__extends || function() {
        var e = Object.setPrototypeOf || {
          __proto__: []
        }
        instanceof Array && function(e, t) {
          e.__proto__ = t
        } || function(e, t) {
          for (var s in t) t.hasOwnProperty(s) && (e[s] = t[s])
        };
        return function(t, s) {
          function r() {
            this.constructor = t
          }
          e(t, s), t.prototype = null === s ? Object.create(s) : (r.prototype = s.prototype, new r)
        }
      }(),
      r = this && this.__assign || Object.assign || function(e) {
        for (var t, s = 1, r = arguments.length; s < r; s++)
          for (var o in t = arguments[s]) Object.prototype.hasOwnProperty.call(t, o) && (e[o] = t[o]);
        return e
      };
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    var o = require("http"),
      n = require("https"),
      i = require("os"),
      a = require("url"),
      h = require("./progress-event"),
      p = require("./errors"),
      l = require("./xml-http-request-event-target"),
      d = require("./xml-http-request-upload"),
      u = require("cookiejar"),
      _ = function(l) {
        function _(t) {
          void 0 === t && (t = {});
          var s = l.call(this) || this;
          return s.UNSENT = _.UNSENT, s.OPENED = _.OPENED, s.HEADERS_RECEIVED = _.HEADERS_RECEIVED, s.LOADING = _.LOADING, s.DONE = _.DONE, s.onreadystatechange = null, s.readyState = _.UNSENT, s.response = null, s.responseText = "", s.responseType = "", s.status = 0, s.statusText = "", s.timeout = 0, s.upload = new d.XMLHttpRequestUpload, s.responseUrl = "", s.withCredentials = !1, s._method = null, s._url = null, s._sync = !1, s._headers = {}, s._loweredHeaders = {}, s._mimeOverride = null, s._request = null, s._response = null, s._responseParts = null, s._responseHeaders = null, s._aborting = null, s._error = null, s._loadedBytes = 0, s._totalBytes = 0, s._lengthComputable = !1, s._restrictedMethods = {
            CONNECT: !0,
            TRACE: !0,
            TRACK: !0
          }, s._restrictedHeaders = {
            "accept-charset": !0,
            "accept-encoding": !0,
            "access-control-request-headers": !0,
            "access-control-request-method": !0,
            connection: !0,
            "content-length": !0,
            cookie: !0,
            cookie2: !0,
            date: !0,
            dnt: !0,
            expect: !0,
            host: !0,
            "keep-alive": !0,
            origin: !0,
            referer: !0,
            te: !0,
            trailer: !0,
            "transfer-encoding": !0,
            upgrade: !0,
            "user-agent": !0,
            via: !0
          }, s._privateHeaders = {
            "set-cookie": !0,
            "set-cookie2": !0
          }, s._userAgent = "Mozilla/5.0 (" + i.type() + " " + i.arch() + ") node.js/" + e.versions.node + " v8/" + e.versions.v8, s._anonymous = t.anon || !1, s
        }
        return s(_, l), _.prototype.open = function(e, t, s, r, o) {
          if (void 0 === s && (s = !0), e = e.toUpperCase(), this._restrictedMethods[e]) throw new _.SecurityError("HTTP method " + e + " is not allowed in XHR");
          var n = this._parseUrl(t, r, o);
          this.readyState === _.HEADERS_RECEIVED || (this.readyState, _.LOADING), this._method = e, this._url = n, this._sync = !s, this._headers = {}, this._loweredHeaders = {}, this._mimeOverride = null, this._setReadyState(_.OPENED), this._request = null, this._response = null, this.status = 0, this.statusText = "", this._responseParts = [], this._responseHeaders = null, this._loadedBytes = 0, this._totalBytes = 0, this._lengthComputable = !1
        }, _.prototype.setRequestHeader = function(e, t) {
          if (this.readyState !== _.OPENED) throw new _.InvalidStateError("XHR readyState must be OPENED");
          var s = e.toLowerCase();
          this._restrictedHeaders[s] || /^sec-/.test(s) || /^proxy-/.test(s) ? console.warn('Refused to set unsafe header "' + e + '"') : (t = t.toString(), null != this._loweredHeaders[s] ? (e = this._loweredHeaders[s], this._headers[e] = this._headers[e] + ", " + t) : (this._loweredHeaders[s] = e, this._headers[e] = t))
        }, _.prototype.send = function(e) {
          if (this.readyState !== _.OPENED) throw new _.InvalidStateError("XHR readyState must be OPENED");
          if (this._request) throw new _.InvalidStateError("send() already called");
          switch (this._url.protocol) {
            case "file:":
              return this._sendFile(e);
            case "http:":
            case "https:":
              return this._sendHttp(e);
            default:
              throw new _.NetworkError("Unsupported protocol " + this._url.protocol)
          }
        }, _.prototype.abort = function() {
          null != this._request && (this._request.abort(), this._setError(), this._dispatchProgress("abort"), this._dispatchProgress("loadend"))
        }, _.prototype.getResponseHeader = function(e) {
          if (null == this._responseHeaders || null == e) return null;
          var t = e.toLowerCase();
          return this._responseHeaders.hasOwnProperty(t) ? this._responseHeaders[e.toLowerCase()] : null
        }, _.prototype.getAllResponseHeaders = function() {
          var e = this;
          return null == this._responseHeaders ? "" : Object.keys(this._responseHeaders).map(function(t) {
            return t + ": " + e._responseHeaders[t]
          }).join("\r\n")
        }, _.prototype.overrideMimeType = function(e) {
          if (this.readyState === _.LOADING || this.readyState === _.DONE) throw new _.InvalidStateError("overrideMimeType() not allowed in LOADING or DONE");
          this._mimeOverride = e.toLowerCase()
        }, _.prototype.nodejsSet = function(e) {
          if (this.nodejsHttpAgent = e.httpAgent || this.nodejsHttpAgent, this.nodejsHttpsAgent = e.httpsAgent || this.nodejsHttpsAgent, e.hasOwnProperty("baseUrl")) {
            if (null != e.baseUrl)
              if (!a.parse(e.baseUrl, !1, !0).protocol) throw new _.SyntaxError("baseUrl must be an absolute URL");
            this.nodejsBaseUrl = e.baseUrl
          }
        }, _.nodejsSet = function(e) {
          _.prototype.nodejsSet(e)
        }, _.prototype._setReadyState = function(e) {
          this.readyState = e, this.dispatchEvent(new h.ProgressEvent("readystatechange"))
        }, _.prototype._sendFile = function(e) {
          throw new Error("Protocol file: not implemented")
        }, _.prototype._sendHttp = function(e) {
          if (this._sync) throw new Error("Synchronous XHR processing not implemented");
          !e || "GET" !== this._method && "HEAD" !== this._method ? e = e || "" : (console.warn("Discarding entity body for " + this._method + " requests"), e = null), this.upload._setData(e), this._finalizeHeaders(), this._sendHxxpRequest()
        }, _.prototype._sendHxxpRequest = function() {
          var e = this;
          if (this.withCredentials) {
            var t = _.cookieJar.getCookies(u.CookieAccessInfo(this._url.hostname, this._url.pathname, "https:" === this._url.protocol)).toValueString();
            this._headers.cookie = this._headers.cookie2 = t
          }
          var s = "http:" === this._url.protocol ? [o, this.nodejsHttpAgent] : [n, this.nodejsHttpsAgent],
            r = s[0],
            i = s[1],
            a = r.request.bind(r)({
              hostname: this._url.hostname,
              port: +this._url.port,
              path: this._url.path,
              auth: this._url.auth,
              method: this._method,
              headers: this._headers,
              agent: i
            });
          this._request = a, this.timeout && a.setTimeout(this.timeout, function() {
            return e._onHttpTimeout(a)
          }), a.on("response", function(t) {
            return e._onHttpResponse(a, t)
          }), a.on("error", function(t) {
            return e._onHttpRequestError(a, t)
          }), this.upload._startUpload(a), this._request === a && this._dispatchProgress("loadstart")
        }, _.prototype._finalizeHeaders = function() {
          this._headers = r({}, this._headers, {
            Connection: "keep-alive",
            Host: this._url.host,
            "User-Agent": this._userAgent
          }, this._anonymous ? {
            Referer: "about:blank"
          } : {}), this.upload._finalizeHeaders(this._headers, this._loweredHeaders)
        }, _.prototype._onHttpResponse = function(e, t) {
          var s = this;
          if (this._request === e) {
            if (this.withCredentials && (t.headers["set-cookie"] || t.headers["set-cookie2"]) && _.cookieJar.setCookies(t.headers["set-cookie"] || t.headers["set-cookie2"]), [301, 302, 303, 307, 308].indexOf(t.statusCode) >= 0) return this._url = this._parseUrl(t.headers.location), this._method = "GET", this._loweredHeaders["content-type"] && (delete this._headers[this._loweredHeaders["content-type"]], delete this._loweredHeaders["content-type"]), null != this._headers["Content-Type"] && delete this._headers["Content-Type"], delete this._headers["Content-Length"], this.upload._reset(), this._finalizeHeaders(), void this._sendHxxpRequest();
            this._response = t, this._response.on("data", function(e) {
              return s._onHttpResponseData(t, e)
            }), this._response.on("end", function() {
              return s._onHttpResponseEnd(t)
            }), this._response.on("close", function() {
              return s._onHttpResponseClose(t)
            }), this.responseUrl = this._url.href.split("#")[0], this.status = t.statusCode, this.statusText = o.STATUS_CODES[this.status], this._parseResponseHeaders(t);
            var r = this._responseHeaders["content-length"] || "";
            this._totalBytes = +r, this._lengthComputable = !!r, this._setReadyState(_.HEADERS_RECEIVED)
          }
        }, _.prototype._onHttpResponseData = function(e, s) {
          this._response === e && (this._responseParts.push(new t(s)), this._loadedBytes += s.length, this.readyState !== _.LOADING && this._setReadyState(_.LOADING), this._dispatchProgress("progress"))
        }, _.prototype._onHttpResponseEnd = function(e) {
          this._response === e && (this._parseResponse(), this._request = null, this._response = null, this._setReadyState(_.DONE), this._dispatchProgress("load"), this._dispatchProgress("loadend"))
        }, _.prototype._onHttpResponseClose = function(e) {
          if (this._response === e) {
            var t = this._request;
            this._setError(), t.abort(), this._setReadyState(_.DONE), this._dispatchProgress("error"), this._dispatchProgress("loadend")
          }
        }, _.prototype._onHttpTimeout = function(e) {
          this._request === e && (this._setError(), e.abort(), this._setReadyState(_.DONE), this._dispatchProgress("timeout"), this._dispatchProgress("loadend"))
        }, _.prototype._onHttpRequestError = function(e, t) {
          this._request === e && (this._setError(), e.abort(), this._setReadyState(_.DONE), this._dispatchProgress("error"), this._dispatchProgress("loadend"))
        }, _.prototype._dispatchProgress = function(e) {
          var t = new _.ProgressEvent(e);
          t.lengthComputable = this._lengthComputable, t.loaded = this._loadedBytes, t.total = this._totalBytes, this.dispatchEvent(t)
        }, _.prototype._setError = function() {
          this._request = null, this._response = null, this._responseHeaders = null, this._responseParts = null
        }, _.prototype._parseUrl = function(e, t, s) {
          var r = null == this.nodejsBaseUrl ? e : a.resolve(this.nodejsBaseUrl, e),
            o = a.parse(r, !1, !0);
          o.hash = null;
          var n = (o.auth || "").split(":"),
            i = n[0],
            h = n[1];
          return (i || h || t || s) && (o.auth = (t || i || "") + ":" + (s || h || "")), o
        }, _.prototype._parseResponseHeaders = function(e) {
          for (var t in this._responseHeaders = {}, e.headers) {
            var s = t.toLowerCase();
            this._privateHeaders[s] || (this._responseHeaders[s] = e.headers[t])
          }
          null != this._mimeOverride && (this._responseHeaders["content-type"] = this._mimeOverride)
        }, _.prototype._parseResponse = function() {
          var e = t.concat(this._responseParts);
          switch (this._responseParts = null, this.responseType) {
            case "json":
              this.responseText = null;
              try {
                this.response = JSON.parse(e.toString("utf-8"))
              } catch (n) {
                this.response = null
              }
              return;
            case "buffer":
              return this.responseText = null, void(this.response = e);
            case "arraybuffer":
              this.responseText = null;
              for (var s = new ArrayBuffer(e.length), r = new Uint8Array(s), o = 0; o < e.length; o++) r[o] = e[o];
              return void(this.response = s);
            case "text":
            default:
              try {
                this.responseText = e.toString(this._parseResponseEncoding())
              } catch (i) {
                this.responseText = e.toString("binary")
              }
              this.response = this.responseText
          }
        }, _.prototype._parseResponseEncoding = function() {
          return /;\s*charset=(.*)$/.exec(this._responseHeaders["content-type"] || "")[1] || "utf-8"
        }, _.ProgressEvent = h.ProgressEvent, _.InvalidStateError = p.InvalidStateError, _.NetworkError = p.NetworkError, _.SecurityError = p.SecurityError, _.SyntaxError = p.SyntaxError, _.XMLHttpRequestUpload = d.XMLHttpRequestUpload, _.UNSENT = 0, _.OPENED = 1, _.HEADERS_RECEIVED = 2, _.LOADING = 3, _.DONE = 4, _.cookieJar = u.CookieJar(), _
      }(l.XMLHttpRequestEventTarget);
    exports.XMLHttpRequest = _, _.prototype.nodejsHttpAgent = o.globalAgent, _.prototype.nodejsHttpsAgent = n.globalAgent, _.prototype.nodejsBaseUrl = null;
  }, {
    "http": "KKrj",
    "https": "wVMl",
    "os": "zv8z",
    "url": "Mej7",
    "./progress-event": "peDO",
    "./errors": "vKeV",
    "./xml-http-request-event-target": "YFCS",
    "./xml-http-request-upload": "umrI",
    "cookiejar": "WOY7",
    "process": "pBGv",
    "buffer": "dskh"
  }],
  "yOap": [function(require, module, exports) {
    "use strict";

    function e(e) {
      for (var t in e) exports.hasOwnProperty(t) || (exports[t] = e[t])
    }
    Object.defineProperty(exports, "__esModule", {
      value: !0
    }), e(require("./xml-http-request"));
    var t = require("./xml-http-request-event-target");
    exports.XMLHttpRequestEventTarget = t.XMLHttpRequestEventTarget;
  }, {
    "./xml-http-request": "ogMQ",
    "./xml-http-request-event-target": "YFCS"
  }],
  "LRTp": [function(require, module, exports) {
    var t = require("web3-core-helpers").errors,
      e = require("xhr2-cookies").XMLHttpRequest,
      s = require("http"),
      n = require("https"),
      i = function(t, e) {
        e = e || {}, this.withCredentials = e.withCredentials || !1, this.timeout = e.timeout || 0, this.headers = e.headers, this.agent = e.agent, this.connected = !1;
        var i = !1 !== e.keepAlive;
        this.host = t || "http://localhost:8545", this.agent || ("https" === this.host.substring(0, 5) ? this.httpsAgent = new n.Agent({
          keepAlive: i
        }) : this.httpAgent = new s.Agent({
          keepAlive: i
        }))
      };
    i.prototype._prepareRequest = function() {
      var t;
      if ("undefined" != typeof XMLHttpRequest) t = new XMLHttpRequest;
      else {
        t = new e;
        var s = {
          httpsAgent: this.httpsAgent,
          httpAgent: this.httpAgent,
          baseUrl: this.baseUrl
        };
        this.agent && (s.httpsAgent = this.agent.https, s.httpAgent = this.agent.http, s.baseUrl = this.agent.baseUrl), t.nodejsSet(s)
      }
      return t.open("POST", this.host, !0), t.setRequestHeader("Content-Type", "application/json"), t.timeout = this.timeout, t.withCredentials = this.withCredentials, this.headers && this.headers.forEach(function(e) {
        t.setRequestHeader(e.name, e.value)
      }), t
    }, i.prototype.send = function(e, s) {
      var n = this,
        i = this._prepareRequest();
      i.onreadystatechange = function() {
        if (4 === i.readyState && 1 !== i.timeout) {
          var e = i.responseText,
            h = null;
          try {
            e = JSON.parse(e)
          } catch (o) {
            h = t.InvalidResponse(i.responseText)
          }
          n.connected = !0, s(h, e)
        }
      }, i.ontimeout = function() {
        n.connected = !1, s(t.ConnectionTimeout(this.timeout))
      };
      try {
        i.send(JSON.stringify(e))
      } catch (h) {
        this.connected = !1, s(t.InvalidConnection(this.host))
      }
    }, i.prototype.disconnect = function() {}, i.prototype.supportsSubscriptions = function() {
      return !1
    }, module.exports = i;
  }, {
    "web3-core-helpers": "EoeS",
    "xhr2-cookies": "yOap",
    "http": "KKrj",
    "https": "wVMl"
  }],
  "KxVU": [function(require, module, exports) {
    var define;
    var n;
    ! function(t, e) {
      "object" == typeof exports && "object" == typeof module ? module.exports = e() : "function" == typeof n && n.amd ? n("oboe", [], e) : "object" == typeof exports ? exports.oboe = e() : t.oboe = e()
    }("undefined" != typeof self ? self : this, function() {
      return function(n) {
        var t = {};

        function e(r) {
          if (t[r]) return t[r].exports;
          var u = t[r] = {
            i: r,
            l: !1,
            exports: {}
          };
          return n[r].call(u.exports, u, u.exports, e), u.l = !0, u.exports
        }
        return e.m = n, e.c = t, e.d = function(n, t, r) {
          e.o(n, t) || Object.defineProperty(n, t, {
            configurable: !1,
            enumerable: !0,
            get: r
          })
        }, e.n = function(n) {
          var t = n && n.__esModule ? function() {
            return n.default
          } : function() {
            return n
          };
          return e.d(t, "a", t), t
        }, e.o = function(n, t) {
          return Object.prototype.hasOwnProperty.call(n, t)
        }, e.p = "", e(e.s = 7)
      }([function(n, t, e) {
        "use strict";
        e.d(t, "j", function() {
          return u
        }), e.d(t, "d", function() {
          return i
        }), e.d(t, "c", function() {
          return c
        }), e.d(t, "h", function() {
          return o
        }), e.d(t, "b", function() {
          return f
        }), e.d(t, "k", function() {
          return a
        }), e.d(t, "e", function() {
          return s
        }), e.d(t, "g", function() {
          return d
        }), e.d(t, "i", function() {
          return b
        }), e.d(t, "a", function() {
          return l
        }), e.d(t, "f", function() {
          return j
        });
        var r = e(1),
          u = a(function(n, t) {
            var e = t.length;
            return a(function(r) {
              for (var u = 0; u < r.length; u++) t[e + u] = r[u];
              return t.length = e + r.length, n.apply(this, t)
            })
          });
        a(function(n) {
          var t = Object(r.c)(n);

          function e(n, t) {
            return [f(n, t)]
          }
          return a(function(n) {
            return Object(r.f)(e, n, t)[0]
          })
        });

        function i(n, t) {
          return function() {
            return n.call(this, t.apply(this, arguments))
          }
        }

        function c(n) {
          return function(t) {
            return t[n]
          }
        }
        var o = a(function(n) {
          return a(function(t) {
            for (var e, r = 0; r < c("length")(n); r++)
              if (e = f(t, n[r])) return e
          })
        });

        function f(n, t) {
          return t.apply(void 0, n)
        }

        function a(n) {
          var t = n.length - 1,
            e = Array.prototype.slice;
          if (0 === t) return function() {
            return n.call(this, e.call(arguments))
          };
          if (1 === t) return function() {
            return n.call(this, arguments[0], e.call(arguments, 1))
          };
          var r = Array(n.length);
          return function() {
            for (var u = 0; u < t; u++) r[u] = arguments[u];
            return r[t] = e.call(arguments, t), n.apply(this, r)
          }
        }

        function s(n) {
          return function(t, e) {
            return n(e, t)
          }
        }

        function d(n, t) {
          return function(e) {
            return n(e) && t(e)
          }
        }

        function b() {}

        function l() {
          return !0
        }

        function j(n) {
          return function() {
            return n
          }
        }
      }, function(n, t, e) {
        "use strict";
        e.d(t, "d", function() {
          return u
        }), e.d(t, "g", function() {
          return c
        }), e.d(t, "l", function() {
          return o
        }), e.d(t, "c", function() {
          return f
        }), e.d(t, "h", function() {
          return a
        }), e.d(t, "i", function() {
          return s
        }), e.d(t, "j", function() {
          return d
        }), e.d(t, "f", function() {
          return b
        }), e.d(t, "m", function() {
          return l
        }), e.d(t, "a", function() {
          return j
        }), e.d(t, "b", function() {
          return v
        }), e.d(t, "k", function() {
          return O
        }), e.d(t, "e", function() {
          return h
        });
        var r = e(0);

        function u(n, t) {
          return [n, t]
        }
        var i = null,
          c = Object(r.c)(0),
          o = Object(r.c)(1);

        function f(n) {
          return O(n.reduce(Object(r.e)(u), i))
        }
        var a = Object(r.k)(f);

        function s(n) {
          return b(function(n, t) {
            return n.unshift(t), n
          }, [], n)
        }

        function d(n, t) {
          return t ? u(n(c(t)), d(n, o(t))) : i
        }

        function b(n, t, e) {
          return e ? n(b(n, t, o(e)), c(e)) : t
        }

        function l(n, t, e) {
          return function n(e, r) {
            return e ? t(c(e)) ? (r(c(e)), o(e)) : u(c(e), n(o(e), r)) : i
          }(n, e || r.i)
        }

        function j(n, t) {
          return !t || n(c(t)) && j(n, o(t))
        }

        function v(n, t) {
          n && (c(n).apply(null, t), v(o(n), t))
        }

        function O(n) {
          return function n(t, e) {
            return t ? n(o(t), u(c(t), e)) : e
          }(n, i)
        }

        function h(n, t) {
          return t && (n(c(t)) ? c(t) : h(n, o(t)))
        }
      }, function(n, t, e) {
        "use strict";
        e.d(t, "c", function() {
          return i
        }), e.d(t, "e", function() {
          return c
        }), e.d(t, "d", function() {
          return o
        }), e.d(t, "a", function() {
          return f
        }), e.d(t, "b", function() {
          return a
        });
        var r = e(1),
          u = e(0);

        function i(n, t) {
          return t && t.constructor === n
        }
        var c = Object(u.c)("length"),
          o = Object(u.j)(i, String);

        function f(n) {
          return void 0 !== n
        }

        function a(n, t) {
          return t instanceof Object && Object(r.a)(function(n) {
            return n in t
          }, n)
        }
      }, function(n, t, e) {
        "use strict";
        e.d(t, "f", function() {
          return u
        }), e.d(t, "d", function() {
          return i
        }), e.d(t, "g", function() {
          return c
        }), e.d(t, "e", function() {
          return o
        }), e.d(t, "b", function() {
          return f
        }), e.d(t, "h", function() {
          return a
        }), e.d(t, "i", function() {
          return s
        }), e.d(t, "c", function() {
          return d
        }), e.d(t, "m", function() {
          return b
        }), e.d(t, "n", function() {
          return l
        }), e.d(t, "a", function() {
          return j
        }), e.d(t, "j", function() {
          return v
        }), e.d(t, "l", function() {
          return O
        }), e.d(t, "k", function() {
          return h
        }), e.d(t, "o", function() {
          return p
        });
        var r = 1,
          u = r++,
          i = r++,
          c = r++,
          o = r++,
          f = "fail",
          a = r++,
          s = r++,
          d = "start",
          b = "data",
          l = "end",
          j = r++,
          v = r++,
          O = r++,
          h = r++;

        function p(n, t, e) {
          try {
            var r = JSON.parse(t)
          } catch (u) {}
          return {
            statusCode: n,
            body: t,
            jsonBody: r,
            thrown: e
          }
        }
      }, function(n, t, e) {
        "use strict";
        e.d(t, "b", function() {
          return u
        }), e.d(t, "a", function() {
          return i
        }), e.d(t, "c", function() {
          return c
        });
        var r = e(0);

        function u(n, t) {
          return {
            key: n,
            node: t
          }
        }
        var i = Object(r.c)("key"),
          c = Object(r.c)("node")
      }, function(n, t, e) {
        "use strict";
        e.d(t, "a", function() {
          return f
        });
        var r = e(1),
          u = e(0),
          i = e(2),
          c = e(8),
          o = e(9);

        function f(n) {
          var t = Object(r.h)("resume", "pause", "pipe"),
            e = Object(u.j)(i.b, t);
          return n ? e(n) || Object(i.d)(n) ? Object(c.a)(o.a, n) : Object(c.a)(o.a, n.url, n.method, n.body, n.headers, n.withCredentials, n.cached) : Object(o.a)()
        }
        f.drop = function() {
          return f.drop
        }
      }, function(n, t, e) {
        "use strict";
        e.d(t, "b", function() {
          return f
        }), e.d(t, "a", function() {
          return o
        });
        var r = e(3),
          u = e(4),
          i = e(2),
          c = e(1),
          o = {};

        function f(n) {
          var t = n(r.f).emit,
            e = n(r.d).emit,
            f = n(r.i).emit,
            a = n(r.h).emit;

          function s(n, t, e) {
            Object(u.c)(Object(c.g)(n))[t] = e
          }

          function d(n, e, r) {
            n && s(n, e, r);
            var i = Object(c.d)(Object(u.b)(e, r), n);
            return t(i), i
          }
          var b = {};
          return b[r.l] = function(n, t) {
            if (!n) return f(t), d(n, o, t);
            var e = function(n, t) {
                var e = Object(u.c)(Object(c.g)(n));
                return Object(i.c)(Array, e) ? d(n, Object(i.e)(e), t) : n
              }(n, t),
              r = Object(c.l)(e),
              a = Object(u.a)(Object(c.g)(e));
            return s(r, a, t), Object(c.d)(Object(u.b)(a, t), r)
          }, b[r.k] = function(n) {
            return e(n), Object(c.l)(n) || a(Object(u.c)(Object(c.g)(n)))
          }, b[r.j] = d, b
        }
      }, function(n, t, e) {
        "use strict";
        Object.defineProperty(t, "__esModule", {
          value: !0
        });
        var r = e(5);
        t.default = r.a
      }, function(n, t, e) {
        "use strict";
        e.d(t, "a", function() {
          return u
        });
        var r = e(2);

        function u(n, t, e, u, i, c, o) {
          return i = i ? JSON.parse(JSON.stringify(i)) : {}, u ? (Object(r.d)(u) || (u = JSON.stringify(u), i["Content-Type"] = i["Content-Type"] || "application/json"), i["Content-Length"] = i["Content-Length"] || u.length) : u = null, n(e || "GET", function(n, t) {
            return !1 === t && (-1 === n.indexOf("?") ? n += "?" : n += "&", n += "_=" + (new Date).getTime()), n
          }(t, o), u, i, c || !1)
        }
      }, function(n, t, e) {
        "use strict";
        e.d(t, "a", function() {
          return d
        });
        var r = e(10),
          u = e(12),
          i = e(6),
          c = e(13),
          o = e(14),
          f = e(16),
          a = e(17),
          s = e(18);

        function d(n, t, e, d, b) {
          var l = Object(r.a)();
          return t && Object(s.b)(l, Object(s.a)(), n, t, e, d, b), Object(a.a)(l), Object(u.a)(l, Object(i.b)(l)), Object(c.a)(l, o.a), Object(f.a)(l, t)
        }
      }, function(n, t, e) {
        "use strict";
        e.d(t, "a", function() {
          return i
        });
        var r = e(11),
          u = e(0);

        function i() {
          var n = {},
            t = i("newListener"),
            e = i("removeListener");

          function i(u) {
            return n[u] = Object(r.a)(u, t, e), n[u]
          }

          function c(t) {
            return n[t] || i(t)
          }
          return ["emit", "on", "un"].forEach(function(n) {
            c[n] = Object(u.k)(function(t, e) {
              Object(u.b)(e, c(t)[n])
            })
          }), c
        }
      }, function(n, t, e) {
        "use strict";
        e.d(t, "a", function() {
          return c
        });
        var r = e(1),
          u = e(2),
          i = e(0);

        function c(n, t, e) {
          var c, o;

          function f(n) {
            return function(t) {
              return t.id === n
            }
          }
          return {
            on: function(e, u) {
              var i = {
                listener: e,
                id: u || e
              };
              return t && t.emit(n, e, i.id), c = Object(r.d)(i, c), o = Object(r.d)(e, o), this
            },
            emit: function() {
              Object(r.b)(o, arguments)
            },
            un: function(t) {
              var u;
              c = Object(r.m)(c, f(t), function(n) {
                u = n
              }), u && (o = Object(r.m)(o, function(n) {
                return n === u.listener
              }), e && e.emit(n, u.listener, u.id))
            },
            listeners: function() {
              return o
            },
            hasListener: function(n) {
              var t = n ? f(n) : i.a;
              return Object(u.a)(Object(r.e)(t, c))
            }
          }
        }
      }, function(n, t, e) {
        "use strict";
        e.d(t, "a", function() {
          return c
        });
        var r = e(4),
          u = e(3),
          i = e(1);

        function c(n, t) {
          var e, c = {};

          function o(n) {
            return function(t) {
              e = n(e, t)
            }
          }
          for (var f in t) n(f).on(o(t[f]), c);
          n(u.g).on(function(n) {
            var t = Object(i.g)(e),
              u = Object(r.a)(t),
              c = Object(i.l)(e);
            c && (Object(r.c)(Object(i.g)(c))[u] = n)
          }), n(u.e).on(function() {
            var n = Object(i.g)(e),
              t = Object(r.a)(n),
              u = Object(i.l)(e);
            u && delete Object(r.c)(Object(i.g)(u))[t]
          }), n(u.a).on(function() {
            for (var e in t) n(e).un(c)
          })
        }
      }, function(n, t, e) {
        "use strict";
        e.d(t, "a", function() {
          return c
        });
        var r = e(3),
          u = e(1),
          i = e(4);

        function c(n, t) {
          var e = {
            node: n(r.d),
            path: n(r.f)
          };

          function c(t, e, r) {
            var c = n(t).emit;
            e.on(function(n) {
              var t = r(n);
              !1 !== t && function(n, t, e) {
                var r = Object(u.k)(e);
                n(t, Object(u.i)(Object(u.l)(Object(u.j)(i.a, r))), Object(u.i)(Object(u.j)(i.c, r)))
              }(c, Object(i.c)(t), n)
            }, t), n("removeListener").on(function(r) {
              r === t && (n(r).listeners() || e.un(t))
            })
          }
          n("newListener").on(function(n) {
            var r = /(node|path):(.*)/.exec(n);
            if (r) {
              var u = e[r[1]];
              u.hasListener(n) || c(n, u, t(r[2]))
            }
          })
        }
      }, function(n, t, e) {
        "use strict";
        e.d(t, "a", function() {
          return a
        });
        var r = e(0),
          u = e(1),
          i = e(4),
          c = e(2),
          o = e(6),
          f = e(15),
          a = Object(f.a)(function(n, t, e, f, a) {
            var s = 1,
              d = 2,
              b = 3,
              l = Object(r.d)(i.a, u.g),
              j = Object(r.d)(i.c, u.g);

            function v(n, t) {
              return !!t[s] ? Object(r.g)(n, u.g) : n
            }

            function O(n) {
              if (n === r.a) return r.a;
              return Object(r.g)(function(n) {
                return l(n) !== o.a
              }, Object(r.d)(n, u.l))
            }

            function h() {
              return function(n) {
                return l(n) === o.a
              }
            }

            function p(n, t, e, r, i) {
              var o = n(e);
              if (o) {
                var f = function(n, t, e) {
                  return Object(u.f)(function(n, t) {
                    return t(n, e)
                  }, t, n)
                }(t, r, o);
                return i(e.substr(Object(c.e)(o[0])), f)
              }
            }

            function g(n, t) {
              return Object(r.j)(p, n, t)
            }
            var m = Object(r.h)(g(n, Object(u.h)(v, function(n, t) {
              var e = t[b];
              if (!e) return n;
              var i = Object(r.j)(c.b, Object(u.c)(e.split(/\W+/))),
                o = Object(r.d)(i, j);
              return Object(r.g)(o, n)
            }, function(n, t) {
              var e = t[d],
                u = e && "*" !== e ? function(n) {
                  return String(l(n)) === e
                } : r.a;
              return Object(r.g)(u, n)
            }, O)), g(t, Object(u.h)(function(n) {
              if (n === r.a) return r.a;
              var t = h(),
                e = n,
                u = O(function(n) {
                  return i(n)
                }),
                i = Object(r.h)(t, e, u);
              return i
            })), g(e, Object(u.h)()), g(f, Object(u.h)(v, h)), g(a, Object(u.h)(function(n) {
              return function(t) {
                var e = n(t);
                return !0 === e ? Object(u.g)(t) : e
              }
            })), function(n) {
              throw Error('"' + n + '" could not be tokenised')
            });

            function y(n, t) {
              return t
            }

            function w(n, t) {
              return m(n, t, n ? w : y)
            }
            return function(n) {
              try {
                return w(n, r.a)
              } catch (t) {
                throw Error('Could not compile "' + n + '" because ' + t.message)
              }
            }
          })
      }, function(n, t, e) {
        "use strict";
        e.d(t, "a", function() {
          return v
        });
        var r, u, i, c, o, f, a, s, d, b, l, j = e(0),
          v = (r = Object(j.k)(function(n) {
            return n.unshift(/^/), (t = RegExp(n.map(Object(j.c)("source")).join(""))).exec.bind(t);
            var t
          }), c = r(u = /(\$?)/, /([\w-_]+|\*)/, i = /(?:{([\w ]*?)})?/), o = r(u, /\["([^"]+)"\]/, i), f = r(u, /\[(\d+|\*)\]/, i), a = r(u, /()/, /{([\w ]*?)}/), s = r(/\.\./), d = r(/\./), b = r(u, /!/), l = r(/$/), function(n) {
            return n(Object(j.h)(c, o, f, a), s, d, b, l)
          })
      }, function(n, t, e) {
        "use strict";
        e.d(t, "a", function() {
          return o
        });
        var r = e(3),
          u = e(0),
          i = e(2),
          c = e(5);

        function o(n, t) {
          var e, o = /^(node|path):./,
            f = n(r.h),
            a = n(r.e).emit,
            s = n(r.g).emit,
            d = Object(u.k)(function(t, r) {
              if (e[t]) Object(u.b)(r, e[t]);
              else {
                var i = n(t),
                  c = r[0];
                o.test(t) ? b(i, j(c)) : i.on(c)
              }
              return e
            });

          function b(n, t, r) {
            r = r || t;
            var i = l(t);
            return n.on(function() {
              var t = !1;
              e.forget = function() {
                t = !0
              }, Object(u.b)(arguments, i), delete e.forget, t && n.un(r)
            }, r), e
          }

          function l(n) {
            return function() {
              try {
                return n.apply(e, arguments)
              } catch (t) {
                setTimeout(function() {
                  throw new Error(t.message)
                })
              }
            }
          }

          function j(n) {
            return function() {
              var t = n.apply(this, arguments);
              Object(i.a)(t) && (t === c.a.drop ? a() : s(t))
            }
          }

          function v(t, e, r) {
            var u;
            u = "node" === t ? j(r) : r, b(function(t, e) {
              return n(t + ":" + e)
            }(t, e), u, r)
          }

          function O(n, t, r) {
            return Object(i.d)(t) ? v(n, t, r) : function(n, t) {
              for (var e in t) v(n, e, t[e])
            }(n, t), e
          }
          return n(r.i).on(function(n) {
            e.root = Object(u.f)(n)
          }), n(r.c).on(function(n, t) {
            e.header = function(n) {
              return n ? t[n] : t
            }
          }), e = {
            on: d,
            addListener: d,
            removeListener: function(t, r, u) {
              if ("done" === t) f.un(r);
              else if ("node" === t || "path" === t) n.un(t + ":" + r, u);
              else {
                var i = r;
                n(t).un(i)
              }
              return e
            },
            emit: n.emit,
            node: Object(u.j)(O, "node"),
            path: Object(u.j)(O, "path"),
            done: Object(u.j)(b, f),
            start: Object(u.j)(function(t, r) {
              return n(t).on(l(r), r), e
            }, r.c),
            fail: n(r.b).on,
            abort: n(r.a).emit,
            header: u.i,
            root: u.i,
            source: t
          }
        }
      }, function(n, t, e) {
        "use strict";
        e.d(t, "a", function() {
          return u
        });
        var r = e(3);

        function u(n) {
          var t, e, u, i, c = n(r.j).emit,
            o = n(r.l).emit,
            f = n(r.k).emit,
            a = n(r.b).emit,
            s = 65536,
            d = /[\\"\n]/g,
            b = 0,
            l = b++,
            j = b++,
            v = b++,
            O = b++,
            h = b++,
            p = b++,
            g = b++,
            m = b++,
            y = b++,
            w = b++,
            x = b++,
            k = b++,
            I = b++,
            L = b++,
            C = b++,
            E = b++,
            S = b++,
            M = b++,
            A = b++,
            T = b++,
            N = 20,
            R = s,
            _ = "",
            q = !1,
            H = !1,
            B = l,
            J = [],
            P = null,
            X = 0,
            U = 0,
            W = 0,
            $ = 0,
            z = 1;

          function D(n) {
            void 0 !== i && (o(i), f(), i = void 0), t = Error(n + "\nLn: " + z + "\nCol: " + $ + "\nChr: " + e), a(Object(r.o)(void 0, void 0, t))
          }

          function F(n) {
            return "\r" === n || "\n" === n || " " === n || "\t" === n
          }
          n(r.m).on(function(n) {
            if (t) return;
            if (H) return D("Cannot write after close");
            var r = 0;
            e = n[0];
            for (; e && (r > 0 && (u = e), e = n[r++]);) switch (W++, "\n" === e ? (z++, $ = 0) : $++, B) {
              case l:
                if ("{" === e) B = v;
                else if ("[" === e) B = h;
                else if (!F(e)) return D("Non-whitespace before {[.");
                continue;
              case m:
              case v:
                if (F(e)) continue;
                if (B === m) J.push(y);
                else {
                  if ("}" === e) {
                    o({}), f(), B = J.pop() || j;
                    continue
                  }
                  J.push(O)
                }
                if ('"' !== e) return D('Malformed object key should start with " ');
                B = g;
                continue;
              case y:
              case O:
                if (F(e)) continue;
                if (":" === e) B === O ? (J.push(O), void 0 !== i && (o({}), c(i), i = void 0), U++) : void 0 !== i && (c(i), i = void 0), B = j;
                else if ("}" === e) void 0 !== i && (o(i), f(), i = void 0), f(), U--, B = J.pop() || j;
                else {
                  if ("," !== e) return D("Bad object");
                  B === O && J.push(O), void 0 !== i && (o(i), f(), i = void 0), B = m
                }
                continue;
              case h:
              case j:
                if (F(e)) continue;
                if (B === h) {
                  if (o([]), U++, B = j, "]" === e) {
                    f(), U--, B = J.pop() || j;
                    continue
                  }
                  J.push(p)
                }
                if ('"' === e) B = g;
                else if ("{" === e) B = v;
                else if ("[" === e) B = h;
                else if ("t" === e) B = w;
                else if ("f" === e) B = I;
                else if ("n" === e) B = S;
                else if ("-" === e) _ += e;
                else if ("0" === e) _ += e, B = N;
                else {
                  if (-1 === "123456789".indexOf(e)) return D("Bad value");
                  _ += e, B = N
                }
                continue;
              case p:
                if ("," === e) J.push(p), void 0 !== i && (o(i), f(), i = void 0), B = j;
                else {
                  if ("]" !== e) {
                    if (F(e)) continue;
                    return D("Bad array")
                  }
                  void 0 !== i && (o(i), f(), i = void 0), f(), U--, B = J.pop() || j
                }
                continue;
              case g:
                void 0 === i && (i = "");
                var a = r - 1;
                n: for (;;) {
                  for (; X > 0;)
                    if (P += e, e = n.charAt(r++), 4 === X ? (i += String.fromCharCode(parseInt(P, 16)), X = 0, a = r - 1) : X++, !e) break n;
                  if ('"' === e && !q) {
                    B = J.pop() || j, i += n.substring(a, r - 1);
                    break
                  }
                  if (!("\\" !== e || q || (q = !0, i += n.substring(a, r - 1), e = n.charAt(r++)))) break;
                  if (q) {
                    if (q = !1, "n" === e ? i += "\n" : "r" === e ? i += "\r" : "t" === e ? i += "\t" : "f" === e ? i += "\f" : "b" === e ? i += "\b" : "u" === e ? (X = 1, P = "") : i += e, e = n.charAt(r++), a = r - 1, e) continue;
                    break
                  }
                  d.lastIndex = r;
                  var b = d.exec(n);
                  if (!b) {
                    r = n.length + 1, i += n.substring(a, r - 1);
                    break
                  }
                  if (r = b.index + 1, !(e = n.charAt(b.index))) {
                    i += n.substring(a, r - 1);
                    break
                  }
                }
                continue;
              case w:
                if (!e) continue;
                if ("r" !== e) return D("Invalid true started with t" + e);
                B = x;
                continue;
              case x:
                if (!e) continue;
                if ("u" !== e) return D("Invalid true started with tr" + e);
                B = k;
                continue;
              case k:
                if (!e) continue;
                if ("e" !== e) return D("Invalid true started with tru" + e);
                o(!0), f(), B = J.pop() || j;
                continue;
              case I:
                if (!e) continue;
                if ("a" !== e) return D("Invalid false started with f" + e);
                B = L;
                continue;
              case L:
                if (!e) continue;
                if ("l" !== e) return D("Invalid false started with fa" + e);
                B = C;
                continue;
              case C:
                if (!e) continue;
                if ("s" !== e) return D("Invalid false started with fal" + e);
                B = E;
                continue;
              case E:
                if (!e) continue;
                if ("e" !== e) return D("Invalid false started with fals" + e);
                o(!1), f(), B = J.pop() || j;
                continue;
              case S:
                if (!e) continue;
                if ("u" !== e) return D("Invalid null started with n" + e);
                B = M;
                continue;
              case M:
                if (!e) continue;
                if ("l" !== e) return D("Invalid null started with nu" + e);
                B = A;
                continue;
              case A:
                if (!e) continue;
                if ("l" !== e) return D("Invalid null started with nul" + e);
                o(null), f(), B = J.pop() || j;
                continue;
              case T:
                if ("." !== e) return D("Leading zero not followed by .");
                _ += e, B = N;
                continue;
              case N:
                if (-1 !== "0123456789".indexOf(e)) _ += e;
                else if ("." === e) {
                  if (-1 !== _.indexOf(".")) return D("Invalid number has two dots");
                  _ += e
                } else if ("e" === e || "E" === e) {
                  if (-1 !== _.indexOf("e") || -1 !== _.indexOf("E")) return D("Invalid number has two exponential");
                  _ += e
                } else if ("+" === e || "-" === e) {
                  if ("e" !== u && "E" !== u) return D("Invalid symbol in number");
                  _ += e
                } else _ && (o(parseFloat(_)), f(), _ = ""), r--, B = J.pop() || j;
                continue;
              default:
                return D("Unknown state: " + B)
            }
            W >= R && (G = 0, void 0 !== i && i.length > s && (D("Max buffer length exceeded: textNode"), G = Math.max(G, i.length)), _.length > s && (D("Max buffer length exceeded: numberNode"), G = Math.max(G, _.length)), R = s - G + W);
            var G
          }), n(r.n).on(function() {
            if (B === l) return o({}), f(), void(H = !0);
            B === j && 0 === U || D("Unexpected end");
            void 0 !== i && (o(i), f(), i = void 0);
            H = !0
          })
        }
      }, function(n, t, e) {
        "use strict";
        e.d(t, "a", function() {
          return f
        }), e.d(t, "b", function() {
          return a
        });
        var r = e(19),
          u = e(3),
          i = e(2),
          c = e(20),
          o = e(0);

        function f() {
          return new XMLHttpRequest
        }

        function a(n, t, e, f, a, s, d) {
          var b = n(u.m).emit,
            l = n(u.b).emit,
            j = 0,
            v = !0;

          function O() {
            if ("2" === String(t.status)[0]) {
              var n = t.responseText,
                e = (" " + n.substr(j)).substr(1);
              e && b(e), j = Object(i.e)(n)
            }
          }

          function h(t) {
            try {
              v && n(u.c).emit(t.status, Object(c.a)(t.getAllResponseHeaders())), v = !1
            } catch (e) {}
          }
          n(u.a).on(function() {
            t.onreadystatechange = null, t.abort()
          }), "onprogress" in t && (t.onprogress = O), t.onreadystatechange = function() {
            switch (t.readyState) {
              case 2:
              case 3:
                return h(t);
              case 4:
                h(t), "2" === String(t.status)[0] ? (O(), n(u.n).emit()) : l(Object(u.o)(t.status, t.responseText))
            }
          };
          try {
            for (var p in t.open(e, f, !0), s) t.setRequestHeader(p, s[p]);
            Object(r.a)(window.location, Object(r.b)(f)) || t.setRequestHeader("X-Requested-With", "XMLHttpRequest"), t.withCredentials = d, t.send(a)
          } catch (g) {
            window.setTimeout(Object(o.j)(l, Object(u.o)(void 0, void 0, g)), 0)
          }
        }
      }, function(n, t, e) {
        "use strict";

        function r(n, t) {
          function e(t) {
            return String(t.port || {
              "http:": 80,
              "https:": 443
            } [t.protocol || n.protocol])
          }
          return !!(t.protocol && t.protocol !== n.protocol || t.host && t.host !== n.host || t.host && e(t) !== e(n))
        }

        function u(n) {
          var t = /(\w+:)?(?:\/\/)([\w.-]+)?(?::(\d+))?\/?/.exec(n) || [];
          return {
            protocol: t[1] || "",
            host: t[2] || "",
            port: t[3] || ""
          }
        }
        e.d(t, "a", function() {
          return r
        }), e.d(t, "b", function() {
          return u
        })
      }, function(n, t, e) {
        "use strict";

        function r(n) {
          var t = {};
          return n && n.split("\r\n").forEach(function(n) {
            var e = n.indexOf(": ");
            t[n.substring(0, e)] = n.substring(e + 2)
          }), t
        }
        e.d(t, "a", function() {
          return r
        })
      }]).default
    });
  }, {}],
  "uUlo": [function(require, module, exports) {
    "use strict";
    var t = require("underscore"),
      n = require("web3-core-helpers").errors,
      e = require("oboe"),
      o = function(n, o) {
        var i = this;
        this.responseCallbacks = {}, this.notificationCallbacks = [], this.path = n, this.connected = !1, this.connection = o.connect({
          path: this.path
        }), this.addDefaultEvents();
        var s = function(n) {
          var e = null;
          t.isArray(n) ? n.forEach(function(t) {
            i.responseCallbacks[t.id] && (e = t.id)
          }) : e = n.id, e || -1 === n.method.indexOf("_subscription") ? i.responseCallbacks[e] && (i.responseCallbacks[e](null, n), delete i.responseCallbacks[e]) : i.notificationCallbacks.forEach(function(e) {
            t.isFunction(e) && e(n)
          })
        };
        "Socket" === o.constructor.name ? e(this.connection).done(s) : this.connection.on("data", function(t) {
          i._parseResponse(t.toString()).forEach(s)
        })
      };
    o.prototype.addDefaultEvents = function() {
      var t = this;
      this.connection.on("connect", function() {
        t.connected = !0
      }), this.connection.on("close", function() {
        t.connected = !1
      }), this.connection.on("error", function() {
        t._timeout()
      }), this.connection.on("end", function() {
        t._timeout()
      }), this.connection.on("timeout", function() {
        t._timeout()
      })
    }, o.prototype._parseResponse = function(t) {
      var e = this,
        o = [];
      return t.replace(/\}[\n\r]?\{/g, "}|--|{").replace(/\}\][\n\r]?\[\{/g, "}]|--|[{").replace(/\}[\n\r]?\[\{/g, "}|--|[{").replace(/\}\][\n\r]?\{/g, "}]|--|{").split("|--|").forEach(function(t) {
        e.lastChunk && (t = e.lastChunk + t);
        var i = null;
        try {
          i = JSON.parse(t)
        } catch (s) {
          return e.lastChunk = t, clearTimeout(e.lastChunkTimeout), void(e.lastChunkTimeout = setTimeout(function() {
            throw e._timeout(), n.InvalidResponse(t)
          }, 15e3))
        }
        clearTimeout(e.lastChunkTimeout), e.lastChunk = null, i && o.push(i)
      }), o
    }, o.prototype._addResponseCallback = function(t, n) {
      var e = t.id || t[0].id,
        o = t.method || t[0].method;
      this.responseCallbacks[e] = n, this.responseCallbacks[e].method = o
    }, o.prototype._timeout = function() {
      for (var t in this.responseCallbacks) this.responseCallbacks.hasOwnProperty(t) && (this.responseCallbacks[t](n.InvalidConnection("on IPC")), delete this.responseCallbacks[t])
    }, o.prototype.reconnect = function() {
      this.connection.connect({
        path: this.path
      })
    }, o.prototype.send = function(t, n) {
      this.connection.writable || this.connection.connect({
        path: this.path
      }), this.connection.write(JSON.stringify(t)), this._addResponseCallback(t, n)
    }, o.prototype.on = function(t, n) {
      if ("function" != typeof n) throw new Error("The second parameter callback must be a function.");
      switch (t) {
        case "data":
          this.notificationCallbacks.push(n);
          break;
        default:
          this.connection.on(t, n)
      }
    }, o.prototype.once = function(t, n) {
      if ("function" != typeof n) throw new Error("The second parameter callback must be a function.");
      this.connection.once(t, n)
    }, o.prototype.removeListener = function(t, n) {
      var e = this;
      switch (t) {
        case "data":
          this.notificationCallbacks.forEach(function(t, o) {
            t === n && e.notificationCallbacks.splice(o, 1)
          });
          break;
        default:
          this.connection.removeListener(t, n)
      }
    }, o.prototype.removeAllListeners = function(t) {
      switch (t) {
        case "data":
          this.notificationCallbacks = [];
          break;
        default:
          this.connection.removeAllListeners(t)
      }
    }, o.prototype.reset = function() {
      this._timeout(), this.notificationCallbacks = [], this.connection.removeAllListeners("error"), this.connection.removeAllListeners("end"), this.connection.removeAllListeners("timeout"), this.addDefaultEvents()
    }, o.prototype.supportsSubscriptions = function() {
      return !0
    }, module.exports = o;
  }, {
    "underscore": "h15N",
    "web3-core-helpers": "EoeS",
    "oboe": "KxVU"
  }],
  "cnad": [function(require, module, exports) {
    "use strict";

    function r(i) {
      return (r = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(r) {
        return typeof r
      } : function(r) {
        return r && "function" == typeof Symbol && r.constructor === Symbol && r !== Symbol.prototype ? "symbol" : typeof r
      })(i)
    }
    var i = require("util"),
      e = i.callbackify,
      o = require("underscore"),
      t = require("web3-core-helpers").errors,
      s = require("./jsonrpc.js"),
      n = require("./batch.js"),
      p = require("./givenProvider.js"),
      c = function r(i, e) {
        this.provider = null, this.providers = r.providers, this.setProvider(i, e), this.subscriptions = new Map
      };
    c.givenProvider = p, c.providers = {
      WebsocketProvider: require("web3-providers-ws"),
      HttpProvider: require("web3-providers-http"),
      IpcProvider: require("web3-providers-ipc")
    }, c.prototype.setProvider = function(i, e) {
      var o = this;
      if (i && "string" == typeof i && this.providers)
        if (/^http(s)?:\/\//i.test(i)) i = new this.providers.HttpProvider(i);
        else if (/^ws(s)?:\/\//i.test(i)) i = new this.providers.WebsocketProvider(i);
      else if (i && "object" === r(e) && "function" == typeof e.connect) i = new this.providers.IpcProvider(i, e);
      else if (i) throw new Error("Can't autodetect provider for \"" + i + '"');
      if (this.provider && this.provider.connected && this.clearSubscriptions(), this.provider = i || null, this.provider && this.provider.on) {
        "function" == typeof i.request ? this.provider.on("message", function(r) {
          if (r && "eth_subscription" === r.type && r.data) {
            var i = r.data;
            i.subscription && o.subscriptions.has(i.subscription) && o.subscriptions.get(i.subscription).callback(null, i.result)
          }
        }) : this.provider.on("data", function(r, i) {
          (r = r || i).method && r.params && r.params.subscription && o.subscriptions.has(r.params.subscription) && o.subscriptions.get(r.params.subscription).callback(null, r.params.result)
        }), this.provider.on("connect", function() {
          o.subscriptions.forEach(function(r) {
            r.subscription.resubscribe()
          })
        }), this.provider.on("error", function(r) {
          o.subscriptions.forEach(function(i) {
            i.callback(r)
          })
        });
        var s = function(r) {
          o._isCleanCloseEvent(r) && !o._isIpcCloseError(r) || (o.subscriptions.forEach(function(i) {
            i.callback(t.ConnectionCloseError(r)), o.subscriptions.delete(i.subscription.id)
          }), o.provider && o.provider.emit && o.provider.emit("error", t.ConnectionCloseError(r))), o.provider && o.provider.emit && o.provider.emit("end", r)
        };
        this.provider.on("close", s), this.provider.on("disconnect", s)
      }
    }, c.prototype.send = function(r, i) {
      if (i = i || function() {}, !this.provider) return i(t.InvalidProvider());
      var o = r.method,
        n = r.params,
        p = s.toPayload(o, n),
        c = this._jsonrpcResultCallback(i, p);
      if (this.provider.request) e(this.provider.request.bind(this.provider))({
        method: o,
        params: n
      }, i);
      else if (this.provider.sendAsync) this.provider.sendAsync(p, c);
      else {
        if (!this.provider.send) throw new Error("Provider does not have a request or send method to use.");
        this.provider.send(p, c)
      }
    }, c.prototype.sendBatch = function(r, i) {
      if (!this.provider) return i(t.InvalidProvider());
      var e = s.toBatchPayload(r);
      this.provider[this.provider.sendAsync ? "sendAsync" : "send"](e, function(r, e) {
        return r ? i(r) : o.isArray(e) ? void i(null, e) : i(t.InvalidResponse(e))
      })
    }, c.prototype.addSubscription = function(r, i) {
      if (!this.provider.on) throw new Error("The provider doesn't support subscriptions: " + this.provider.constructor.name);
      this.subscriptions.set(r.id, {
        callback: i,
        subscription: r
      })
    }, c.prototype.removeSubscription = function(r, i) {
      if (this.subscriptions.has(r)) {
        var e = this.subscriptions.get(r).subscription.options.type;
        return this.subscriptions.delete(r), void this.send({
          method: e + "_unsubscribe",
          params: [r]
        }, i)
      }
      "function" == typeof i && i(null)
    }, c.prototype.clearSubscriptions = function(r) {
      try {
        var i = this;
        return this.subscriptions.size > 0 && this.subscriptions.forEach(function(e, o) {
          r && "syncing" === e.name || i.removeSubscription(o)
        }), this.provider.reset && this.provider.reset(), !0
      } catch (e) {
        throw new Error("Error while clearing subscriptions: ".concat(e))
      }
    }, c.prototype._isCleanCloseEvent = function(i) {
      return "object" === r(i) && ([1e3].includes(i.code) || !0 === i.wasClean)
    }, c.prototype._isIpcCloseError = function(r) {
      return "boolean" == typeof r && r
    }, c.prototype._jsonrpcResultCallback = function(r, i) {
      return function(e, o) {
        return o && o.id && i.id !== o.id ? r(new Error("Wrong response id ".concat(o.id, " (expected: ").concat(i.id, ") in ").concat(JSON.stringify(i)))) : e ? r(e) : o && o.error ? r(t.ErrorResponse(o)) : s.isValidResponse(o) ? void r(null, o.result) : r(t.InvalidResponse(o))
      }
    }, module.exports = {
      Manager: c,
      BatchManager: n
    };
  }, {
    "util": "gfUn",
    "underscore": "h15N",
    "web3-core-helpers": "EoeS",
    "./jsonrpc.js": "sE12",
    "./batch.js": "eTNq",
    "./givenProvider.js": "IMA1",
    "web3-providers-ws": "OPSa",
    "web3-providers-http": "LRTp",
    "web3-providers-ipc": "uUlo"
  }],
  "J2II": [function(require, module, exports) {
    "use strict";
    var e = require("eventemitter3"),
      r = function(r) {
        var t, n, s = new Promise(function() {
          t = arguments[0], n = arguments[1]
        });
        if (r) return {
          resolve: t,
          reject: n,
          eventEmitter: s
        };
        var i = new e;
        return s._events = i._events, s.emit = i.emit, s.on = i.on, s.once = i.once, s.off = i.off, s.listeners = i.listeners, s.addListener = i.addListener, s.removeListener = i.removeListener, s.removeAllListeners = i.removeAllListeners, {
          resolve: t,
          reject: n,
          eventEmitter: s
        }
      };
    r.resolve = function(e) {
      var t = r(!0);
      return t.resolve(e), t.eventEmitter
    }, module.exports = r;
  }, {
    "eventemitter3": "JJlS"
  }],
  "P0ah": [function(require, module, exports) {
    "use strict";

    function t(r) {
      return (t = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t) {
        return typeof t
      } : function(t) {
        return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
      })(r)
    }
    var r = require("underscore"),
      o = require("web3-core-helpers").errors,
      i = require("eventemitter3"),
      s = require("web3-core-helpers").formatters;

    function e(t) {
      i.call(this), this.id = null, this.callback = r.identity, this.arguments = null, this.lastBlock = null, this.options = {
        subscription: t.subscription,
        type: t.type,
        requestManager: t.requestManager
      }
    }
    e.prototype = Object.create(i.prototype), e.prototype.constructor = e, e.prototype._extractCallback = function(t) {
      if (r.isFunction(t[t.length - 1])) return t.pop()
    }, e.prototype._validateArgs = function(t) {
      var r = this.options.subscription;
      if (r || (r = {}), r.params || (r.params = 0), t.length !== r.params) throw o.InvalidNumberOfParams(t.length, r.params, r.subscriptionName)
    }, e.prototype._formatInput = function(t) {
      var r = this.options.subscription;
      return r && r.inputFormatter ? r.inputFormatter.map(function(r, o) {
        return r ? r(t[o]) : t[o]
      }) : t
    }, e.prototype._formatOutput = function(t) {
      var r = this.options.subscription;
      return r && r.outputFormatter && t ? r.outputFormatter(t) : t
    }, e.prototype._toPayload = function(t) {
      var o = [];
      if (this.callback = this._extractCallback(t) || r.identity, this.subscriptionMethod || (this.subscriptionMethod = t.shift(), this.options.subscription.subscriptionName && (this.subscriptionMethod = this.options.subscription.subscriptionName)), this.arguments || (this.arguments = this._formatInput(t), this._validateArgs(this.arguments), t = []), o.push(this.subscriptionMethod), o = o.concat(this.arguments), t.length) throw new Error("Only a callback is allowed as parameter on an already instantiated subscription.");
      return {
        method: this.options.type + "_subscribe",
        params: o
      }
    }, e.prototype.unsubscribe = function(t) {
      this.options.requestManager.removeSubscription(this.id, t), this.id = null, this.lastBlock = null, this.removeAllListeners()
    }, e.prototype.subscribe = function() {
      var o = this,
        i = Array.prototype.slice.call(arguments),
        e = this._toPayload(i);
      if (!e) return this;
      if (!this.options.requestManager.provider) return setTimeout(function() {
        var t = new Error("No provider set.");
        o.callback(t, null, o), o.emit("error", t)
      }, 0), this;
      if (!this.options.requestManager.provider.on) return setTimeout(function() {
        var t = new Error("The current provider doesn't support subscriptions: " + o.options.requestManager.provider.constructor.name);
        o.callback(t, null, o), o.emit("error", t)
      }, 0), this;
      if (this.lastBlock && r.isObject(this.options.params) && (e.params[1] = this.options.params, e.params[1].fromBlock = s.inputBlockNumberFormatter(this.lastBlock + 1)), this.id && this.unsubscribe(), this.options.params = e.params[1], "logs" === e.params[0] && r.isObject(e.params[1]) && e.params[1].hasOwnProperty("fromBlock") && isFinite(e.params[1].fromBlock)) {
        var n = Object.assign({}, e.params[1]);
        this.options.requestManager.send({
          method: "eth_getLogs",
          params: [n]
        }, function(t, r) {
          t ? setTimeout(function() {
            o.callback(t, null, o), o.emit("error", t)
          }, 0) : r.forEach(function(t) {
            var r = o._formatOutput(t);
            o.callback(null, r, o), o.emit("data", r)
          })
        })
      }
      return "object" === t(e.params[1]) && delete e.params[1].fromBlock, this.options.requestManager.send(e, function(t, i) {
        !t && i ? (o.id = i, o.method = e.params[0], o.emit("connected", i), o.options.requestManager.addSubscription(o, function(t, i) {
          t ? (o.callback(t, !1, o), o.emit("error", t)) : (r.isArray(i) || (i = [i]), i.forEach(function(t) {
            var i = o._formatOutput(t);
            if (o.lastBlock = r.isObject(i) ? i.blockNumber : null, r.isFunction(o.options.subscription.subscriptionHandler)) return o.options.subscription.subscriptionHandler.call(o, i);
            o.emit("data", i), o.callback(null, i, o)
          }))
        })) : setTimeout(function() {
          o.callback(t, !1, o), o.emit("error", t)
        }, 0)
      }), this
    }, e.prototype.resubscribe = function() {
      this.options.requestManager.removeSubscription(this.id), this.id = null, this.subscribe(this.callback)
    }, module.exports = e;
  }, {
    "underscore": "h15N",
    "web3-core-helpers": "EoeS",
    "eventemitter3": "JJlS"
  }],
  "Sn3u": [function(require, module, exports) {
    "use strict";
    var t = require("./subscription.js"),
      s = function(t) {
        this.name = t.name, this.type = t.type, this.subscriptions = t.subscriptions || {}, this.requestManager = null
      };
    s.prototype.setRequestManager = function(t) {
      this.requestManager = t
    }, s.prototype.attachToObject = function(t) {
      var s = this.buildCall(),
        i = this.name.split(".");
      i.length > 1 ? (t[i[0]] = t[i[0]] || {}, t[i[0]][i[1]] = s) : t[i[0]] = s
    }, s.prototype.buildCall = function() {
      var s = this;
      return function() {
        s.subscriptions[arguments[0]] || console.warn("Subscription " + JSON.stringify(arguments[0]) + " doesn't exist. Subscribing anyway.");
        var i = new t({
          subscription: s.subscriptions[arguments[0]] || {},
          requestManager: s.requestManager,
          type: s.type
        });
        return i.subscribe.apply(i, arguments)
      }
    }, module.exports = {
      subscriptions: s,
      subscription: t
    };
  }, {
    "./subscription.js": "P0ah"
  }],
  "nF9z": [function(require, module, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    }), exports.version = void 0;
    const e = "logger/5.1.0";
    exports.version = e;
  }, {}],
  "M3zR": [function(require, module, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    }), exports.Logger = exports.ErrorCode = exports.LogLevel = void 0;
    var r = require("./_version");
    let e = !1,
      o = !1;
    const t = {
      debug: 1,
      default: 2,
      info: 2,
      warning: 3,
      error: 4,
      off: 5
    };
    let n = t.default,
      s = null;

    function E() {
      try {
        const e = [];
        if (["NFD", "NFC", "NFKD", "NFKC"].forEach(r => {
            try {
              if ("test" !== "test".normalize(r)) throw new Error("bad normalize")
            } catch (o) {
              e.push(r)
            }
          }), e.length) throw new Error("missing " + e.join(", "));
        if (String.fromCharCode(233).normalize("NFD") !== String.fromCharCode(101, 769)) throw new Error("broken implementation")
      } catch (r) {
        return r.message
      }
      return null
    }
    const i = E();
    var N, a;
    exports.LogLevel = N,
      function(r) {
        r.DEBUG = "DEBUG", r.INFO = "INFO", r.WARNING = "WARNING", r.ERROR = "ERROR", r.OFF = "OFF"
      }(N || (exports.LogLevel = N = {})), exports.ErrorCode = a,
      function(r) {
        r.UNKNOWN_ERROR = "UNKNOWN_ERROR", r.NOT_IMPLEMENTED = "NOT_IMPLEMENTED", r.UNSUPPORTED_OPERATION = "UNSUPPORTED_OPERATION", r.NETWORK_ERROR = "NETWORK_ERROR", r.SERVER_ERROR = "SERVER_ERROR", r.TIMEOUT = "TIMEOUT", r.BUFFER_OVERRUN = "BUFFER_OVERRUN", r.NUMERIC_FAULT = "NUMERIC_FAULT", r.MISSING_NEW = "MISSING_NEW", r.INVALID_ARGUMENT = "INVALID_ARGUMENT", r.MISSING_ARGUMENT = "MISSING_ARGUMENT", r.UNEXPECTED_ARGUMENT = "UNEXPECTED_ARGUMENT", r.CALL_EXCEPTION = "CALL_EXCEPTION", r.INSUFFICIENT_FUNDS = "INSUFFICIENT_FUNDS", r.NONCE_EXPIRED = "NONCE_EXPIRED", r.REPLACEMENT_UNDERPRICED = "REPLACEMENT_UNDERPRICED", r.UNPREDICTABLE_GAS_LIMIT = "UNPREDICTABLE_GAS_LIMIT"
      }(a || (exports.ErrorCode = a = {}));
    class l {
      constructor(r) {
        Object.defineProperty(this, "version", {
          enumerable: !0,
          value: r,
          writable: !1
        })
      }
      _log(r, e) {
        const o = r.toLowerCase();
        null == t[o] && this.throwArgumentError("invalid log level name", "logLevel", r), n > t[o] || console.log.apply(console, e)
      }
      debug(...r) {
        this._log(l.levels.DEBUG, r)
      }
      info(...r) {
        this._log(l.levels.INFO, r)
      }
      warn(...r) {
        this._log(l.levels.WARNING, r)
      }
      makeError(r, e, t) {
        if (o) return this.makeError("censored error", e, {});
        e || (e = l.errors.UNKNOWN_ERROR), t || (t = {});
        const n = [];
        Object.keys(t).forEach(r => {
          try {
            n.push(r + "=" + JSON.stringify(t[r]))
          } catch (E) {
            n.push(r + "=" + JSON.stringify(t[r].toString()))
          }
        }), n.push(`code=${e}`), n.push(`version=${this.version}`);
        const s = r;
        n.length && (r += " (" + n.join(", ") + ")");
        const E = new Error(r);
        return E.reason = s, E.code = e, Object.keys(t).forEach(function(r) {
          E[r] = t[r]
        }), E
      }
      throwError(r, e, o) {
        throw this.makeError(r, e, o)
      }
      throwArgumentError(r, e, o) {
        return this.throwError(r, l.errors.INVALID_ARGUMENT, {
          argument: e,
          value: o
        })
      }
      assert(r, e, o, t) {
        r || this.throwError(e, o, t)
      }
      assertArgument(r, e, o, t) {
        r || this.throwArgumentError(e, o, t)
      }
      checkNormalize(r) {
        null == r && (r = "platform missing String.prototype.normalize"), i && this.throwError("platform missing String.prototype.normalize", l.errors.UNSUPPORTED_OPERATION, {
          operation: "String.prototype.normalize",
          form: i
        })
      }
      checkSafeUint53(r, e) {
        "number" == typeof r && (null == e && (e = "value not safe"), (r < 0 || r >= 9007199254740991) && this.throwError(e, l.errors.NUMERIC_FAULT, {
          operation: "checkSafeInteger",
          fault: "out-of-safe-range",
          value: r
        }), r % 1 && this.throwError(e, l.errors.NUMERIC_FAULT, {
          operation: "checkSafeInteger",
          fault: "non-integer",
          value: r
        }))
      }
      checkArgumentCount(r, e, o) {
        o = o ? ": " + o : "", r < e && this.throwError("missing argument" + o, l.errors.MISSING_ARGUMENT, {
          count: r,
          expectedCount: e
        }), r > e && this.throwError("too many arguments" + o, l.errors.UNEXPECTED_ARGUMENT, {
          count: r,
          expectedCount: e
        })
      }
      checkNew(r, e) {
        r !== Object && null != r || this.throwError("missing new", l.errors.MISSING_NEW, {
          name: e.name
        })
      }
      checkAbstract(r, e) {
        r === e ? this.throwError("cannot instantiate abstract class " + JSON.stringify(e.name) + " directly; use a sub-class", l.errors.UNSUPPORTED_OPERATION, {
          name: r.name,
          operation: "new"
        }) : r !== Object && null != r || this.throwError("missing new", l.errors.MISSING_NEW, {
          name: e.name
        })
      }
      static globalLogger() {
        return s || (s = new l(r.version)), s
      }
      static setCensorship(r, t) {
        if (!r && t && this.globalLogger().throwError("cannot permanently disable censorship", l.errors.UNSUPPORTED_OPERATION, {
            operation: "setCensorship"
          }), e) {
          if (!r) return;
          this.globalLogger().throwError("error censorship permanent", l.errors.UNSUPPORTED_OPERATION, {
            operation: "setCensorship"
          })
        }
        o = !!r, e = !!t
      }
      static setLogLevel(r) {
        const e = t[r.toLowerCase()];
        null != e ? n = e : l.globalLogger().warn("invalid log level - " + r)
      }
      static from(r) {
        return new l(r)
      }
    }
    exports.Logger = l, l.errors = a, l.levels = N;
  }, {
    "./_version": "nF9z"
  }],
  "tSz0": [function(require, module, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    }), exports.version = void 0;
    const e = "bytes/5.1.0";
    exports.version = e;
  }, {}],
  "kHJk": [function(require, module, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    }), exports.isBytesLike = i, exports.isBytes = o, exports.arrayify = u, exports.concat = a, exports.stripZeros = l, exports.zeroPad = g, exports.isHexString = v, exports.hexlify = h, exports.hexDataLength = f, exports.hexDataSlice = x, exports.hexConcat = m, exports.hexValue = y, exports.hexStripZeros = p, exports.hexZeroPad = d, exports.splitSignature = w, exports.joinSignature = A;
    var r = require("@ethersproject/logger"),
      e = require("./_version");
    const t = new r.Logger(e.version);

    function n(r) {
      return !!r.toHexString
    }

    function s(r) {
      return r.slice ? r : (r.slice = function() {
        const e = Array.prototype.slice.call(arguments);
        return s(new Uint8Array(Array.prototype.slice.apply(r, e)))
      }, r)
    }

    function i(r) {
      return v(r) && !(r.length % 2) || o(r)
    }

    function o(r) {
      if (null == r) return !1;
      if (r.constructor === Uint8Array) return !0;
      if ("string" == typeof r) return !1;
      if (null == r.length) return !1;
      for (let e = 0; e < r.length; e++) {
        const t = r[e];
        if ("number" != typeof t || t < 0 || t >= 256 || t % 1) return !1
      }
      return !0
    }

    function u(r, e) {
      if (e || (e = {}), "number" == typeof r) {
        t.checkSafeUint53(r, "invalid arrayify value");
        const e = [];
        for (; r;) e.unshift(255 & r), r = parseInt(String(r / 256));
        return 0 === e.length && e.push(0), s(new Uint8Array(e))
      }
      if (e.allowMissingPrefix && "string" == typeof r && "0x" !== r.substring(0, 2) && (r = "0x" + r), n(r) && (r = r.toHexString()), v(r)) {
        let n = r.substring(2);
        n.length % 2 && ("left" === e.hexPad ? n = "0x0" + n.substring(2) : "right" === e.hexPad ? n += "0" : t.throwArgumentError("hex data is odd-length", "value", r));
        const i = [];
        for (let r = 0; r < n.length; r += 2) i.push(parseInt(n.substring(r, r + 2), 16));
        return s(new Uint8Array(i))
      }
      return o(r) ? s(new Uint8Array(r)) : t.throwArgumentError("invalid arrayify value", "value", r)
    }

    function a(r) {
      const e = r.map(r => u(r)),
        t = e.reduce((r, e) => r + e.length, 0),
        n = new Uint8Array(t);
      return e.reduce((r, e) => (n.set(e, r), r + e.length), 0), s(n)
    }

    function l(r) {
      let e = u(r);
      if (0 === e.length) return e;
      let t = 0;
      for (; t < e.length && 0 === e[t];) t++;
      return t && (e = e.slice(t)), e
    }

    function g(r, e) {
      (r = u(r)).length > e && t.throwArgumentError("value out of range", "value", arguments[0]);
      const n = new Uint8Array(e);
      return n.set(r, e - r.length), s(n)
    }

    function v(r, e) {
      return !("string" != typeof r || !r.match(/^0x[0-9A-Fa-f]*$/)) && (!e || r.length === 2 + 2 * e)
    }
    const c = "0123456789abcdef";

    function h(r, e) {
      if (e || (e = {}), "number" == typeof r) {
        t.checkSafeUint53(r, "invalid hexlify value");
        let e = "";
        for (; r;) e = c[15 & r] + e, r = Math.floor(r / 16);
        return e.length ? (e.length % 2 && (e = "0" + e), "0x" + e) : "0x00"
      }
      if (e.allowMissingPrefix && "string" == typeof r && "0x" !== r.substring(0, 2) && (r = "0x" + r), n(r)) return r.toHexString();
      if (v(r)) return r.length % 2 && ("left" === e.hexPad ? r = "0x0" + r.substring(2) : "right" === e.hexPad ? r += "0" : t.throwArgumentError("hex data is odd-length", "value", r)), r.toLowerCase();
      if (o(r)) {
        let e = "0x";
        for (let t = 0; t < r.length; t++) {
          let n = r[t];
          e += c[(240 & n) >> 4] + c[15 & n]
        }
        return e
      }
      return t.throwArgumentError("invalid hexlify value", "value", r)
    }

    function f(r) {
      if ("string" != typeof r) r = h(r);
      else if (!v(r) || r.length % 2) return null;
      return (r.length - 2) / 2
    }

    function x(r, e, n) {
      return "string" != typeof r ? r = h(r) : (!v(r) || r.length % 2) && t.throwArgumentError("invalid hexData", "value", r), e = 2 + 2 * e, null != n ? "0x" + r.substring(e, 2 + 2 * n) : "0x" + r.substring(e)
    }

    function m(r) {
      let e = "0x";
      return r.forEach(r => {
        e += h(r).substring(2)
      }), e
    }

    function y(r) {
      const e = p(h(r, {
        hexPad: "left"
      }));
      return "0x" === e ? "0x0" : e
    }

    function p(r) {
      "string" != typeof r && (r = h(r)), v(r) || t.throwArgumentError("invalid hex string", "value", r), r = r.substring(2);
      let e = 0;
      for (; e < r.length && "0" === r[e];) e++;
      return "0x" + r.substring(e)
    }

    function d(r, e) {
      for ("string" != typeof r ? r = h(r) : v(r) || t.throwArgumentError("invalid hex string", "value", r), r.length > 2 * e + 2 && t.throwArgumentError("value out of range", "value", arguments[1]); r.length < 2 * e + 2;) r = "0x0" + r.substring(2);
      return r
    }

    function w(r) {
      const e = {
        r: "0x",
        s: "0x",
        _vs: "0x",
        recoveryParam: 0,
        v: 0
      };
      if (i(r)) {
        const n = u(r);
        65 !== n.length && t.throwArgumentError("invalid signature string; must be 65 bytes", "signature", r), e.r = h(n.slice(0, 32)), e.s = h(n.slice(32, 64)), e.v = n[64], e.v < 27 && (0 === e.v || 1 === e.v ? e.v += 27 : t.throwArgumentError("signature invalid v byte", "signature", r)), e.recoveryParam = 1 - e.v % 2, e.recoveryParam && (n[32] |= 128), e._vs = h(n.slice(32, 64))
      } else {
        if (e.r = r.r, e.s = r.s, e.v = r.v, e.recoveryParam = r.recoveryParam, e._vs = r._vs, null != e._vs) {
          const n = g(u(e._vs), 32);
          e._vs = h(n);
          const s = n[0] >= 128 ? 1 : 0;
          null == e.recoveryParam ? e.recoveryParam = s : e.recoveryParam !== s && t.throwArgumentError("signature recoveryParam mismatch _vs", "signature", r), n[0] &= 127;
          const i = h(n);
          null == e.s ? e.s = i : e.s !== i && t.throwArgumentError("signature v mismatch _vs", "signature", r)
        }
        null == e.recoveryParam ? null == e.v ? t.throwArgumentError("signature missing v and recoveryParam", "signature", r) : 0 === e.v || 1 === e.v ? e.recoveryParam = e.v : e.recoveryParam = 1 - e.v % 2 : null == e.v ? e.v = 27 + e.recoveryParam : e.recoveryParam !== 1 - e.v % 2 && t.throwArgumentError("signature recoveryParam mismatch v", "signature", r), null != e.r && v(e.r) ? e.r = d(e.r, 32) : t.throwArgumentError("signature missing or invalid r", "signature", r), null != e.s && v(e.s) ? e.s = d(e.s, 32) : t.throwArgumentError("signature missing or invalid s", "signature", r);
        const n = u(e.s);
        n[0] >= 128 && t.throwArgumentError("signature s out of range", "signature", r), e.recoveryParam && (n[0] |= 128);
        const s = h(n);
        e._vs && (v(e._vs) || t.throwArgumentError("signature invalid _vs", "signature", r), e._vs = d(e._vs, 32)), null == e._vs ? e._vs = s : e._vs !== s && t.throwArgumentError("signature _vs mismatch v and s", "signature", r)
      }
      return e
    }

    function A(r) {
      return h(a([(r = w(r)).r, r.s, r.recoveryParam ? "0x1c" : "0x1b"]))
    }
  }, {
    "@ethersproject/logger": "M3zR",
    "./_version": "tSz0"
  }],
  "HSYM": [function(require, module, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    }), exports.version = void 0;
    const e = "bignumber/5.1.1";
    exports.version = e;
  }, {}],
  "FrcK": [function(require, module, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    }), exports.isBigNumberish = a, exports._base36To16 = N, exports._base16To36 = v, exports.BigNumber = void 0;
    var r = n(require("bn.js")),
      t = require("@ethersproject/bytes"),
      e = require("@ethersproject/logger"),
      i = require("./_version");

    function n(r) {
      return r && r.__esModule ? r : {
        default: r
      }
    }
    var s = r.default.BN;
    const o = new e.Logger(i.version),
      u = {},
      g = 9007199254740991;

    function a(r) {
      return null != r && (m.isBigNumber(r) || "number" == typeof r && r % 1 == 0 || "string" == typeof r && !!r.match(/^-?[0-9]+$/) || (0, t.isHexString)(r) || "bigint" == typeof r || (0, t.isBytes)(r))
    }
    let h = !1;
    class m {
      constructor(r, t) {
        o.checkNew(new.target, m), r !== u && o.throwError("cannot call constructor directly; use BigNumber.from", e.Logger.errors.UNSUPPORTED_OPERATION, {
          operation: "new (BigNumber)"
        }), this._hex = t, this._isBigNumber = !0, Object.freeze(this)
      }
      fromTwos(r) {
        return c(l(this).fromTwos(r))
      }
      toTwos(r) {
        return c(l(this).toTwos(r))
      }
      abs() {
        return "-" === this._hex[0] ? m.from(this._hex.substring(1)) : this
      }
      add(r) {
        return c(l(this).add(l(r)))
      }
      sub(r) {
        return c(l(this).sub(l(r)))
      }
      div(r) {
        return m.from(r).isZero() && b("division by zero", "div"), c(l(this).div(l(r)))
      }
      mul(r) {
        return c(l(this).mul(l(r)))
      }
      mod(r) {
        const t = l(r);
        return t.isNeg() && b("cannot modulo negative values", "mod"), c(l(this).umod(t))
      }
      pow(r) {
        const t = l(r);
        return t.isNeg() && b("cannot raise to negative values", "pow"), c(l(this).pow(t))
      }
      and(r) {
        const t = l(r);
        return (this.isNegative() || t.isNeg()) && b("cannot 'and' negative values", "and"), c(l(this).and(t))
      }
      or(r) {
        const t = l(r);
        return (this.isNegative() || t.isNeg()) && b("cannot 'or' negative values", "or"), c(l(this).or(t))
      }
      xor(r) {
        const t = l(r);
        return (this.isNegative() || t.isNeg()) && b("cannot 'xor' negative values", "xor"), c(l(this).xor(t))
      }
      mask(r) {
        return (this.isNegative() || r < 0) && b("cannot mask negative values", "mask"), c(l(this).maskn(r))
      }
      shl(r) {
        return (this.isNegative() || r < 0) && b("cannot shift negative values", "shl"), c(l(this).shln(r))
      }
      shr(r) {
        return (this.isNegative() || r < 0) && b("cannot shift negative values", "shr"), c(l(this).shrn(r))
      }
      eq(r) {
        return l(this).eq(l(r))
      }
      lt(r) {
        return l(this).lt(l(r))
      }
      lte(r) {
        return l(this).lte(l(r))
      }
      gt(r) {
        return l(this).gt(l(r))
      }
      gte(r) {
        return l(this).gte(l(r))
      }
      isNegative() {
        return "-" === this._hex[0]
      }
      isZero() {
        return l(this).isZero()
      }
      toNumber() {
        try {
          return l(this).toNumber()
        } catch (r) {
          b("overflow", "toNumber", this.toString())
        }
        return null
      }
      toBigInt() {
        try {
          return BigInt(this.toString())
        } catch (r) {}
        return o.throwError("this platform does not support BigInt", e.Logger.errors.UNSUPPORTED_OPERATION, {
          value: this.toString()
        })
      }
      toString() {
        return arguments.length > 0 && (10 === arguments[0] ? h || (h = !0, o.warn("BigNumber.toString does not accept any parameters; base-10 is assumed")) : 16 === arguments[0] ? o.throwError("BigNumber.toString does not accept any parameters; use bigNumber.toHexString()", e.Logger.errors.UNEXPECTED_ARGUMENT, {}) : o.throwError("BigNumber.toString does not accept parameters", e.Logger.errors.UNEXPECTED_ARGUMENT, {})), l(this).toString(10)
      }
      toHexString() {
        return this._hex
      }
      toJSON(r) {
        return {
          type: "BigNumber",
          hex: this.toHexString()
        }
      }
      static from(r) {
        if (r instanceof m) return r;
        if ("string" == typeof r) return r.match(/^-?0x[0-9a-f]+$/i) ? new m(u, f(r)) : r.match(/^-?[0-9]+$/) ? new m(u, f(new s(r))) : o.throwArgumentError("invalid BigNumber string", "value", r);
        if ("number" == typeof r) return r % 1 && b("underflow", "BigNumber.from", r), (r >= g || r <= -g) && b("overflow", "BigNumber.from", r), m.from(String(r));
        const e = r;
        if ("bigint" == typeof e) return m.from(e.toString());
        if ((0, t.isBytes)(e)) return m.from((0, t.hexlify)(e));
        if (e)
          if (e.toHexString) {
            const r = e.toHexString();
            if ("string" == typeof r) return m.from(r)
          } else {
            let r = e._hex;
            if (null == r && "BigNumber" === e.type && (r = e.hex), "string" == typeof r && ((0, t.isHexString)(r) || "-" === r[0] && (0, t.isHexString)(r.substring(1)))) return m.from(r)
          } return o.throwArgumentError("invalid BigNumber value", "value", r)
      }
      static isBigNumber(r) {
        return !(!r || !r._isBigNumber)
      }
    }

    function f(r) {
      if ("string" != typeof r) return f(r.toString(16));
      if ("-" === r[0]) return "-" === (r = r.substring(1))[0] && o.throwArgumentError("invalid hex", "value", r), "0x00" === (r = f(r)) ? r : "-" + r;
      if ("0x" !== r.substring(0, 2) && (r = "0x" + r), "0x" === r) return "0x00";
      for (r.length % 2 && (r = "0x0" + r.substring(2)); r.length > 4 && "0x00" === r.substring(0, 4);) r = "0x" + r.substring(4);
      return r
    }

    function c(r) {
      return m.from(f(r))
    }

    function l(r) {
      const t = m.from(r).toHexString();
      return "-" === t[0] ? new s("-" + t.substring(3), 16) : new s(t.substring(2), 16)
    }

    function b(r, t, i) {
      const n = {
        fault: r,
        operation: t
      };
      return null != i && (n.value = i), o.throwError(r, e.Logger.errors.NUMERIC_FAULT, n)
    }

    function N(r) {
      return new s(r, 36).toString(16)
    }

    function v(r) {
      return new s(r, 16).toString(36)
    }
    exports.BigNumber = m;
  }, {
    "bn.js": "AGD1",
    "@ethersproject/bytes": "kHJk",
    "@ethersproject/logger": "M3zR",
    "./_version": "HSYM"
  }],
  "C4mR": [function(require, module, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    }), exports.formatFixed = f, exports.parseFixed = h, exports.FixedNumber = exports.FixedFormat = void 0;
    var t = require("@ethersproject/bytes"),
      r = require("@ethersproject/logger"),
      e = require("./_version"),
      i = require("./bignumber");
    const o = new r.Logger(e.version),
      n = {},
      s = i.BigNumber.from(0),
      a = i.BigNumber.from(-1);

    function m(t, e, i, n) {
      const s = {
        fault: e,
        operation: i
      };
      return void 0 !== n && (s.value = n), o.throwError(t, r.Logger.errors.NUMERIC_FAULT, s)
    }
    let u = "0";
    for (; u.length < 256;) u += u;

    function l(t) {
      if ("number" != typeof t) try {
        t = i.BigNumber.from(t).toNumber()
      } catch (r) {}
      return "number" == typeof t && t >= 0 && t <= 256 && !(t % 1) ? "1" + u.substring(0, t) : o.throwArgumentError("invalid decimal size", "decimals", t)
    }

    function f(t, r) {
      null == r && (r = 0);
      const e = l(r),
        o = (t = i.BigNumber.from(t)).lt(s);
      o && (t = t.mul(a));
      let n = t.mod(e).toString();
      for (; n.length < e.length - 1;) n = "0" + n;
      n = n.match(/^([0-9]*[1-9]|0)(0*)/)[1];
      const m = t.div(e).toString();
      return t = m + "." + n, o && (t = "-" + t), t
    }

    function h(t, r) {
      null == r && (r = 0);
      const e = l(r);
      if ("string" == typeof t && t.match(/^-?[0-9.,]+$/) || o.throwArgumentError("invalid decimal value", "value", t), e.length - 1 == 0) return i.BigNumber.from(t);
      const n = "-" === t.substring(0, 1);
      n && (t = t.substring(1)), "." === t && o.throwArgumentError("missing value", "value", t);
      const s = t.split(".");
      s.length > 2 && o.throwArgumentError("too many decimal points", "value", t);
      let u = s[0],
        f = s[1];
      for (u || (u = "0"), f || (f = "0"), f.length > e.length - 1 && m("fractional component exceeds decimals", "underflow", "parseFixed"); f.length < e.length - 1;) f += "0";
      const h = i.BigNumber.from(u),
        d = i.BigNumber.from(f);
      let c = h.mul(e).add(d);
      return n && (c = c.mul(a)), c
    }
    class d {
      constructor(t, e, i, s) {
        t !== n && o.throwError("cannot use FixedFormat constructor; use FixedFormat.from", r.Logger.errors.UNSUPPORTED_OPERATION, {
          operation: "new FixedFormat"
        }), this.signed = e, this.width = i, this.decimals = s, this.name = (e ? "" : "u") + "fixed" + String(i) + "x" + String(s), this._multiplier = l(s), Object.freeze(this)
      }
      static from(t) {
        if (t instanceof d) return t;
        let r = !0,
          e = 128,
          i = 18;
        if ("string" == typeof t) {
          if ("fixed" === t);
          else if ("ufixed" === t) r = !1;
          else if (null != t) {
            const n = t.match(/^(u?)fixed([0-9]+)x([0-9]+)$/);
            n || o.throwArgumentError("invalid fixed format", "format", t), r = "u" !== n[1], e = parseInt(n[2]), i = parseInt(n[3])
          }
        } else if (t) {
          const n = (r, e, i) => null == t[r] ? i : (typeof t[r] !== e && o.throwArgumentError("invalid fixed format (" + r + " not " + e + ")", "format." + r, t[r]), t[r]);
          r = n("signed", "boolean", r), e = n("width", "number", e), i = n("decimals", "number", i)
        }
        return e % 8 && o.throwArgumentError("invalid fixed format width (not byte aligned)", "format.width", e), i > 80 && o.throwArgumentError("invalid fixed format (decimals too large)", "format.decimals", i), new d(n, r, e, i)
      }
    }
    exports.FixedFormat = d;
    class c {
      constructor(t, e, i, s) {
        o.checkNew(new.target, c), t !== n && o.throwError("cannot use FixedNumber constructor; use FixedNumber.from", r.Logger.errors.UNSUPPORTED_OPERATION, {
          operation: "new FixedFormat"
        }), this.format = s, this._hex = e, this._value = i, this._isFixedNumber = !0, Object.freeze(this)
      }
      _checkFormat(t) {
        this.format.name !== t.format.name && o.throwArgumentError("incompatible format; use fixedNumber.toFormat", "other", t)
      }
      addUnsafe(t) {
        this._checkFormat(t);
        const r = h(this._value, this.format.decimals),
          e = h(t._value, t.format.decimals);
        return c.fromValue(r.add(e), this.format.decimals, this.format)
      }
      subUnsafe(t) {
        this._checkFormat(t);
        const r = h(this._value, this.format.decimals),
          e = h(t._value, t.format.decimals);
        return c.fromValue(r.sub(e), this.format.decimals, this.format)
      }
      mulUnsafe(t) {
        this._checkFormat(t);
        const r = h(this._value, this.format.decimals),
          e = h(t._value, t.format.decimals);
        return c.fromValue(r.mul(e).div(this.format._multiplier), this.format.decimals, this.format)
      }
      divUnsafe(t) {
        this._checkFormat(t);
        const r = h(this._value, this.format.decimals),
          e = h(t._value, t.format.decimals);
        return c.fromValue(r.mul(this.format._multiplier).div(e), this.format.decimals, this.format)
      }
      floor() {
        let t = this.toString().split("."),
          r = c.from(t[0], this.format);
        const e = !t[1].match(/^(0*)$/);
        return this.isNegative() && e && (r = r.subUnsafe(g)), r
      }
      ceiling() {
        let t = this.toString().split("."),
          r = c.from(t[0], this.format);
        const e = !t[1].match(/^(0*)$/);
        return !this.isNegative() && e && (r = r.addUnsafe(g)), r
      }
      round(t) {
        null == t && (t = 0);
        let r = this.toString().split(".");
        if ((t < 0 || t > 80 || t % 1) && o.throwArgumentError("invalid decimal count", "decimals", t), r[1].length <= t) return this;
        const e = c.from("1" + u.substring(0, t));
        return this.mulUnsafe(e).addUnsafe(v).floor().divUnsafe(e)
      }
      isZero() {
        return "0.0" === this._value
      }
      isNegative() {
        return "-" === this._value[0]
      }
      toString() {
        return this._value
      }
      toHexString(r) {
        if (null == r) return this._hex;
        r % 8 && o.throwArgumentError("invalid byte width", "width", r);
        const e = i.BigNumber.from(this._hex).fromTwos(this.format.width).toTwos(r).toHexString();
        return (0, t.hexZeroPad)(e, r / 8)
      }
      toUnsafeFloat() {
        return parseFloat(this.toString())
      }
      toFormat(t) {
        return c.fromString(this._value, t)
      }
      static fromValue(t, r, e) {
        return null != e || null == r || (0, i.isBigNumberish)(r) || (e = r, r = null), null == r && (r = 0), null == e && (e = "fixed"), c.fromString(f(t, r), d.from(e))
      }
      static fromString(r, e) {
        null == e && (e = "fixed");
        const i = d.from(e),
          o = h(r, i.decimals);
        !i.signed && o.lt(s) && m("unsigned value cannot be negative", "overflow", "value", r);
        let a = null;
        i.signed ? a = o.toTwos(i.width).toHexString() : (a = o.toHexString(), a = (0, t.hexZeroPad)(a, i.width / 8));
        const u = f(o, i.decimals);
        return new c(n, a, u, i)
      }
      static fromBytes(r, e) {
        null == e && (e = "fixed");
        const o = d.from(e);
        if ((0, t.arrayify)(r).length > o.width / 8) throw new Error("overflow");
        let s = i.BigNumber.from(r);
        o.signed && (s = s.fromTwos(o.width));
        const a = s.toTwos((o.signed ? 0 : 1) + o.width).toHexString(),
          m = f(s, o.decimals);
        return new c(n, a, m, o)
      }
      static from(e, i) {
        if ("string" == typeof e) return c.fromString(e, i);
        if ((0, t.isBytes)(e)) return c.fromBytes(e, i);
        try {
          return c.fromValue(e, 0, i)
        } catch (n) {
          if (n.code !== r.Logger.errors.INVALID_ARGUMENT) throw n
        }
        return o.throwArgumentError("invalid FixedNumber value", "value", e)
      }
      static isFixedNumber(t) {
        return !(!t || !t._isFixedNumber)
      }
    }
    exports.FixedNumber = c;
    const g = c.from(1),
      v = c.from("0.5");
  }, {
    "@ethersproject/bytes": "kHJk",
    "@ethersproject/logger": "M3zR",
    "./_version": "HSYM",
    "./bignumber": "FrcK"
  }],
  "BWdp": [function(require, module, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    }), Object.defineProperty(exports, "BigNumber", {
      enumerable: !0,
      get: function() {
        return e.BigNumber
      }
    }), Object.defineProperty(exports, "_base16To36", {
      enumerable: !0,
      get: function() {
        return e._base16To36
      }
    }), Object.defineProperty(exports, "_base36To16", {
      enumerable: !0,
      get: function() {
        return e._base36To16
      }
    }), Object.defineProperty(exports, "formatFixed", {
      enumerable: !0,
      get: function() {
        return r.formatFixed
      }
    }), Object.defineProperty(exports, "FixedFormat", {
      enumerable: !0,
      get: function() {
        return r.FixedFormat
      }
    }), Object.defineProperty(exports, "FixedNumber", {
      enumerable: !0,
      get: function() {
        return r.FixedNumber
      }
    }), Object.defineProperty(exports, "parseFixed", {
      enumerable: !0,
      get: function() {
        return r.parseFixed
      }
    });
    var e = require("./bignumber"),
      r = require("./fixednumber");
  }, {
    "./bignumber": "FrcK",
    "./fixednumber": "C4mR"
  }],
  "hT6R": [function(require, module, exports) {
    var process = require("process");
    var global = arguments[3];
    var t = require("process"),
      e = arguments[3];
    ! function() {
      "use strict";
      var r = "object" == typeof window ? window : {};
      !r.JS_SHA3_NO_NODE_JS && "object" == typeof t && t.versions && t.versions.node && (r = e);
      for (var o = !r.JS_SHA3_NO_COMMON_JS && "object" == typeof module && module.exports, s = "0123456789abcdef".split(""), i = [0, 8, 16, 24], n = [1, 0, 32898, 0, 32906, 2147483648, 2147516416, 2147483648, 32907, 0, 2147483649, 0, 2147516545, 2147483648, 32777, 2147483648, 138, 0, 136, 0, 2147516425, 0, 2147483658, 0, 2147516555, 0, 139, 2147483648, 32905, 2147483648, 32771, 2147483648, 32770, 2147483648, 128, 2147483648, 32778, 0, 2147483658, 2147483648, 2147516545, 2147483648, 32896, 2147483648, 2147483649, 0, 2147516424, 2147483648], a = [224, 256, 384, 512], u = ["hex", "buffer", "arrayBuffer", "array"], h = function(t, e, r) {
          return function(o) {
            return new g(t, e, t).update(o)[r]()
          }
        }, f = function(t, e, r) {
          return function(o, s) {
            return new g(t, e, s).update(o)[r]()
          }
        }, c = function(t, e) {
          var r = h(t, e, "hex");
          r.create = function() {
            return new g(t, e, t)
          }, r.update = function(t) {
            return r.create().update(t)
          };
          for (var o = 0; o < u.length; ++o) {
            var s = u[o];
            r[s] = h(t, e, s)
          }
          return r
        }, p = [{
          name: "keccak",
          padding: [1, 256, 65536, 16777216],
          bits: a,
          createMethod: c
        }, {
          name: "sha3",
          padding: [6, 1536, 393216, 100663296],
          bits: a,
          createMethod: c
        }, {
          name: "shake",
          padding: [31, 7936, 2031616, 520093696],
          bits: [128, 256],
          createMethod: function(t, e) {
            var r = f(t, e, "hex");
            r.create = function(r) {
              return new g(t, e, r)
            }, r.update = function(t, e) {
              return r.create(e).update(t)
            };
            for (var o = 0; o < u.length; ++o) {
              var s = u[o];
              r[s] = f(t, e, s)
            }
            return r
          }
        }], l = {}, d = [], y = 0; y < p.length; ++y)
        for (var b = p[y], v = b.bits, k = 0; k < v.length; ++k) {
          var B = b.name + "_" + v[k];
          d.push(B), l[B] = b.createMethod(v[k], b.padding)
        }

      function g(t, e, r) {
        this.blocks = [], this.s = [], this.padding = e, this.outputBits = r, this.reset = !0, this.block = 0, this.start = 0, this.blockCount = 1600 - (t << 1) >> 5, this.byteCount = this.blockCount << 2, this.outputBlocks = r >> 5, this.extraBytes = (31 & r) >> 3;
        for (var o = 0; o < 50; ++o) this.s[o] = 0
      }
      g.prototype.update = function(t) {
        var e = "string" != typeof t;
        e && t.constructor === ArrayBuffer && (t = new Uint8Array(t));
        for (var r, o, s = t.length, n = this.blocks, a = this.byteCount, u = this.blockCount, h = 0, f = this.s; h < s;) {
          if (this.reset)
            for (this.reset = !1, n[0] = this.block, r = 1; r < u + 1; ++r) n[r] = 0;
          if (e)
            for (r = this.start; h < s && r < a; ++h) n[r >> 2] |= t[h] << i[3 & r++];
          else
            for (r = this.start; h < s && r < a; ++h)(o = t.charCodeAt(h)) < 128 ? n[r >> 2] |= o << i[3 & r++] : o < 2048 ? (n[r >> 2] |= (192 | o >> 6) << i[3 & r++], n[r >> 2] |= (128 | 63 & o) << i[3 & r++]) : o < 55296 || o >= 57344 ? (n[r >> 2] |= (224 | o >> 12) << i[3 & r++], n[r >> 2] |= (128 | o >> 6 & 63) << i[3 & r++], n[r >> 2] |= (128 | 63 & o) << i[3 & r++]) : (o = 65536 + ((1023 & o) << 10 | 1023 & t.charCodeAt(++h)), n[r >> 2] |= (240 | o >> 18) << i[3 & r++], n[r >> 2] |= (128 | o >> 12 & 63) << i[3 & r++], n[r >> 2] |= (128 | o >> 6 & 63) << i[3 & r++], n[r >> 2] |= (128 | 63 & o) << i[3 & r++]);
          if (this.lastByteIndex = r, r >= a) {
            for (this.start = r - a, this.block = n[u], r = 0; r < u; ++r) f[r] ^= n[r];
            x(f), this.reset = !0
          } else this.start = r
        }
        return this
      }, g.prototype.finalize = function() {
        var t = this.blocks,
          e = this.lastByteIndex,
          r = this.blockCount,
          o = this.s;
        if (t[e >> 2] |= this.padding[3 & e], this.lastByteIndex === this.byteCount)
          for (t[0] = t[r], e = 1; e < r + 1; ++e) t[e] = 0;
        for (t[r - 1] |= 2147483648, e = 0; e < r; ++e) o[e] ^= t[e];
        x(o)
      }, g.prototype.toString = g.prototype.hex = function() {
        this.finalize();
        for (var t, e = this.blockCount, r = this.s, o = this.outputBlocks, i = this.extraBytes, n = 0, a = 0, u = ""; a < o;) {
          for (n = 0; n < e && a < o; ++n, ++a) t = r[n], u += s[t >> 4 & 15] + s[15 & t] + s[t >> 12 & 15] + s[t >> 8 & 15] + s[t >> 20 & 15] + s[t >> 16 & 15] + s[t >> 28 & 15] + s[t >> 24 & 15];
          a % e == 0 && (x(r), n = 0)
        }
        return i && (t = r[n], i > 0 && (u += s[t >> 4 & 15] + s[15 & t]), i > 1 && (u += s[t >> 12 & 15] + s[t >> 8 & 15]), i > 2 && (u += s[t >> 20 & 15] + s[t >> 16 & 15])), u
      }, g.prototype.arrayBuffer = function() {
        this.finalize();
        var t, e = this.blockCount,
          r = this.s,
          o = this.outputBlocks,
          s = this.extraBytes,
          i = 0,
          n = 0,
          a = this.outputBits >> 3;
        t = s ? new ArrayBuffer(o + 1 << 2) : new ArrayBuffer(a);
        for (var u = new Uint32Array(t); n < o;) {
          for (i = 0; i < e && n < o; ++i, ++n) u[n] = r[i];
          n % e == 0 && x(r)
        }
        return s && (u[i] = r[i], t = t.slice(0, a)), t
      }, g.prototype.buffer = g.prototype.arrayBuffer, g.prototype.digest = g.prototype.array = function() {
        this.finalize();
        for (var t, e, r = this.blockCount, o = this.s, s = this.outputBlocks, i = this.extraBytes, n = 0, a = 0, u = []; a < s;) {
          for (n = 0; n < r && a < s; ++n, ++a) t = a << 2, e = o[n], u[t] = 255 & e, u[t + 1] = e >> 8 & 255, u[t + 2] = e >> 16 & 255, u[t + 3] = e >> 24 & 255;
          a % r == 0 && x(o)
        }
        return i && (t = a << 2, e = o[n], i > 0 && (u[t] = 255 & e), i > 1 && (u[t + 1] = e >> 8 & 255), i > 2 && (u[t + 2] = e >> 16 & 255)), u
      };
      var x = function(t) {
        var e, r, o, s, i, a, u, h, f, c, p, l, d, y, b, v, k, B, g, x, C, w, A, _, m, S, M, O, z, J, N, j, I, H, U, q, D, E, F, G, K, L, P, Q, R, T, V, W, X, Y, Z, $, tt, et, rt, ot, st, it, nt, at, ut, ht, ft;
        for (o = 0; o < 48; o += 2) s = t[0] ^ t[10] ^ t[20] ^ t[30] ^ t[40], i = t[1] ^ t[11] ^ t[21] ^ t[31] ^ t[41], a = t[2] ^ t[12] ^ t[22] ^ t[32] ^ t[42], u = t[3] ^ t[13] ^ t[23] ^ t[33] ^ t[43], h = t[4] ^ t[14] ^ t[24] ^ t[34] ^ t[44], f = t[5] ^ t[15] ^ t[25] ^ t[35] ^ t[45], c = t[6] ^ t[16] ^ t[26] ^ t[36] ^ t[46], p = t[7] ^ t[17] ^ t[27] ^ t[37] ^ t[47], e = (l = t[8] ^ t[18] ^ t[28] ^ t[38] ^ t[48]) ^ (a << 1 | u >>> 31), r = (d = t[9] ^ t[19] ^ t[29] ^ t[39] ^ t[49]) ^ (u << 1 | a >>> 31), t[0] ^= e, t[1] ^= r, t[10] ^= e, t[11] ^= r, t[20] ^= e, t[21] ^= r, t[30] ^= e, t[31] ^= r, t[40] ^= e, t[41] ^= r, e = s ^ (h << 1 | f >>> 31), r = i ^ (f << 1 | h >>> 31), t[2] ^= e, t[3] ^= r, t[12] ^= e, t[13] ^= r, t[22] ^= e, t[23] ^= r, t[32] ^= e, t[33] ^= r, t[42] ^= e, t[43] ^= r, e = a ^ (c << 1 | p >>> 31), r = u ^ (p << 1 | c >>> 31), t[4] ^= e, t[5] ^= r, t[14] ^= e, t[15] ^= r, t[24] ^= e, t[25] ^= r, t[34] ^= e, t[35] ^= r, t[44] ^= e, t[45] ^= r, e = h ^ (l << 1 | d >>> 31), r = f ^ (d << 1 | l >>> 31), t[6] ^= e, t[7] ^= r, t[16] ^= e, t[17] ^= r, t[26] ^= e, t[27] ^= r, t[36] ^= e, t[37] ^= r, t[46] ^= e, t[47] ^= r, e = c ^ (s << 1 | i >>> 31), r = p ^ (i << 1 | s >>> 31), t[8] ^= e, t[9] ^= r, t[18] ^= e, t[19] ^= r, t[28] ^= e, t[29] ^= r, t[38] ^= e, t[39] ^= r, t[48] ^= e, t[49] ^= r, y = t[0], b = t[1], T = t[11] << 4 | t[10] >>> 28, V = t[10] << 4 | t[11] >>> 28, O = t[20] << 3 | t[21] >>> 29, z = t[21] << 3 | t[20] >>> 29, at = t[31] << 9 | t[30] >>> 23, ut = t[30] << 9 | t[31] >>> 23, L = t[40] << 18 | t[41] >>> 14, P = t[41] << 18 | t[40] >>> 14, H = t[2] << 1 | t[3] >>> 31, U = t[3] << 1 | t[2] >>> 31, v = t[13] << 12 | t[12] >>> 20, k = t[12] << 12 | t[13] >>> 20, W = t[22] << 10 | t[23] >>> 22, X = t[23] << 10 | t[22] >>> 22, J = t[33] << 13 | t[32] >>> 19, N = t[32] << 13 | t[33] >>> 19, ht = t[42] << 2 | t[43] >>> 30, ft = t[43] << 2 | t[42] >>> 30, et = t[5] << 30 | t[4] >>> 2, rt = t[4] << 30 | t[5] >>> 2, q = t[14] << 6 | t[15] >>> 26, D = t[15] << 6 | t[14] >>> 26, B = t[25] << 11 | t[24] >>> 21, g = t[24] << 11 | t[25] >>> 21, Y = t[34] << 15 | t[35] >>> 17, Z = t[35] << 15 | t[34] >>> 17, j = t[45] << 29 | t[44] >>> 3, I = t[44] << 29 | t[45] >>> 3, _ = t[6] << 28 | t[7] >>> 4, m = t[7] << 28 | t[6] >>> 4, ot = t[17] << 23 | t[16] >>> 9, st = t[16] << 23 | t[17] >>> 9, E = t[26] << 25 | t[27] >>> 7, F = t[27] << 25 | t[26] >>> 7, x = t[36] << 21 | t[37] >>> 11, C = t[37] << 21 | t[36] >>> 11, $ = t[47] << 24 | t[46] >>> 8, tt = t[46] << 24 | t[47] >>> 8, Q = t[8] << 27 | t[9] >>> 5, R = t[9] << 27 | t[8] >>> 5, S = t[18] << 20 | t[19] >>> 12, M = t[19] << 20 | t[18] >>> 12, it = t[29] << 7 | t[28] >>> 25, nt = t[28] << 7 | t[29] >>> 25, G = t[38] << 8 | t[39] >>> 24, K = t[39] << 8 | t[38] >>> 24, w = t[48] << 14 | t[49] >>> 18, A = t[49] << 14 | t[48] >>> 18, t[0] = y ^ ~v & B, t[1] = b ^ ~k & g, t[10] = _ ^ ~S & O, t[11] = m ^ ~M & z, t[20] = H ^ ~q & E, t[21] = U ^ ~D & F, t[30] = Q ^ ~T & W, t[31] = R ^ ~V & X, t[40] = et ^ ~ot & it, t[41] = rt ^ ~st & nt, t[2] = v ^ ~B & x, t[3] = k ^ ~g & C, t[12] = S ^ ~O & J, t[13] = M ^ ~z & N, t[22] = q ^ ~E & G, t[23] = D ^ ~F & K, t[32] = T ^ ~W & Y, t[33] = V ^ ~X & Z, t[42] = ot ^ ~it & at, t[43] = st ^ ~nt & ut, t[4] = B ^ ~x & w, t[5] = g ^ ~C & A, t[14] = O ^ ~J & j, t[15] = z ^ ~N & I, t[24] = E ^ ~G & L, t[25] = F ^ ~K & P, t[34] = W ^ ~Y & $, t[35] = X ^ ~Z & tt, t[44] = it ^ ~at & ht, t[45] = nt ^ ~ut & ft, t[6] = x ^ ~w & y, t[7] = C ^ ~A & b, t[16] = J ^ ~j & _, t[17] = N ^ ~I & m, t[26] = G ^ ~L & H, t[27] = K ^ ~P & U, t[36] = Y ^ ~$ & Q, t[37] = Z ^ ~tt & R, t[46] = at ^ ~ht & et, t[47] = ut ^ ~ft & rt, t[8] = w ^ ~y & v, t[9] = A ^ ~b & k, t[18] = j ^ ~_ & S, t[19] = I ^ ~m & M, t[28] = L ^ ~H & q, t[29] = P ^ ~U & D, t[38] = $ ^ ~Q & T, t[39] = tt ^ ~R & V, t[48] = ht ^ ~et & ot, t[49] = ft ^ ~rt & st, t[0] ^= n[o], t[1] ^= n[o + 1]
      };
      if (o) module.exports = l;
      else
        for (y = 0; y < d.length; ++y) r[d[y]] = l[d[y]]
    }();
  }, {
    "process": "pBGv"
  }],
  "Ko0x": [function(require, module, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    }), exports.keccak256 = u;
    var e = t(require("js-sha3")),
      r = require("@ethersproject/bytes");

    function t(e) {
      return e && e.__esModule ? e : {
        default: e
      }
    }

    function u(t) {
      return "0x" + e.default.keccak_256((0, r.arrayify)(t))
    }
  }, {
    "js-sha3": "hT6R",
    "@ethersproject/bytes": "kHJk"
  }],
  "qu6H": [function(require, module, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    }), exports.version = void 0;
    const e = "rlp/5.1.0";
    exports.version = e;
  }, {}],
  "Rh5m": [function(require, module, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    }), exports.encode = u, exports.decode = g;
    var r = require("@ethersproject/bytes"),
      t = require("@ethersproject/logger"),
      e = require("./_version");
    const o = new t.Logger(e.version);

    function n(r) {
      const t = [];
      for (; r;) t.unshift(255 & r), r >>= 8;
      return t
    }

    function s(r, t, e) {
      let o = 0;
      for (let n = 0; n < e; n++) o = 256 * o + r[t + n];
      return o
    }

    function h(t) {
      if (Array.isArray(t)) {
        let r = [];
        if (t.forEach(function(t) {
            r = r.concat(h(t))
          }), r.length <= 55) return r.unshift(192 + r.length), r;
        const e = n(r.length);
        return e.unshift(247 + e.length), e.concat(r)
      }(0, r.isBytesLike)(t) || o.throwArgumentError("RLP object must be BytesLike", "object", t);
      const e = Array.prototype.slice.call((0, r.arrayify)(t));
      if (1 === e.length && e[0] <= 127) return e;
      if (e.length <= 55) return e.unshift(128 + e.length), e;
      const s = n(e.length);
      return s.unshift(183 + s.length), s.concat(e)
    }

    function u(t) {
      return (0, r.hexlify)(h(t))
    }

    function c(r, e, n, s) {
      const h = [];
      for (; n < e + 1 + s;) {
        const u = i(r, n);
        h.push(u.result), (n += u.consumed) > e + 1 + s && o.throwError("child data too short", t.Logger.errors.BUFFER_OVERRUN, {})
      }
      return {
        consumed: 1 + s,
        result: h
      }
    }

    function i(e, n) {
      if (0 === e.length && o.throwError("data too short", t.Logger.errors.BUFFER_OVERRUN, {}), e[n] >= 248) {
        const r = e[n] - 247;
        n + 1 + r > e.length && o.throwError("data short segment too short", t.Logger.errors.BUFFER_OVERRUN, {});
        const h = s(e, n + 1, r);
        return n + 1 + r + h > e.length && o.throwError("data long segment too short", t.Logger.errors.BUFFER_OVERRUN, {}), c(e, n, n + 1 + r, r + h)
      }
      if (e[n] >= 192) {
        const r = e[n] - 192;
        return n + 1 + r > e.length && o.throwError("data array too short", t.Logger.errors.BUFFER_OVERRUN, {}), c(e, n, n + 1, r)
      }
      if (e[n] >= 184) {
        const h = e[n] - 183;
        n + 1 + h > e.length && o.throwError("data array too short", t.Logger.errors.BUFFER_OVERRUN, {});
        const u = s(e, n + 1, h);
        return n + 1 + h + u > e.length && o.throwError("data array too short", t.Logger.errors.BUFFER_OVERRUN, {}), {
          consumed: 1 + h + u,
          result: (0, r.hexlify)(e.slice(n + 1 + h, n + 1 + h + u))
        }
      }
      if (e[n] >= 128) {
        const s = e[n] - 128;
        return n + 1 + s > e.length && o.throwError("data too short", t.Logger.errors.BUFFER_OVERRUN, {}), {
          consumed: 1 + s,
          result: (0, r.hexlify)(e.slice(n + 1, n + 1 + s))
        }
      }
      return {
        consumed: 1,
        result: (0, r.hexlify)(e[n])
      }
    }

    function g(t) {
      const e = (0, r.arrayify)(t),
        n = i(e, 0);
      return n.consumed !== e.length && o.throwArgumentError("invalid rlp data", "data", t), n.result
    }
  }, {
    "@ethersproject/bytes": "kHJk",
    "@ethersproject/logger": "M3zR",
    "./_version": "qu6H"
  }],
  "zS5w": [function(require, module, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    }), exports.version = void 0;
    const e = "address/5.1.0";
    exports.version = e;
  }, {}],
  "v33u": [function(require, module, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    }), exports.getAddress = l, exports.isAddress = f, exports.getIcapAddress = p, exports.getContractAddress = m, exports.getCreate2Address = b;
    var r = require("@ethersproject/bytes"),
      e = require("@ethersproject/bignumber"),
      t = require("@ethersproject/keccak256"),
      s = require("@ethersproject/rlp"),
      n = require("@ethersproject/logger"),
      o = require("./_version");
    const a = new n.Logger(o.version);

    function i(e) {
      (0, r.isHexString)(e, 20) || a.throwArgumentError("invalid address", "address", e);
      const s = (e = e.toLowerCase()).substring(2).split(""),
        n = new Uint8Array(40);
      for (let r = 0; r < 40; r++) n[r] = s[r].charCodeAt(0);
      const o = (0, r.arrayify)((0, t.keccak256)(n));
      for (let r = 0; r < 40; r += 2) o[r >> 1] >> 4 >= 8 && (s[r] = s[r].toUpperCase()), (15 & o[r >> 1]) >= 8 && (s[r + 1] = s[r + 1].toUpperCase());
      return "0x" + s.join("")
    }
    const c = 9007199254740991;

    function u(r) {
      return Math.log10 ? Math.log10(r) : Math.log(r) / Math.LN10
    }
    const g = {};
    for (let A = 0; A < 10; A++) g[String(A)] = String(A);
    for (let A = 0; A < 26; A++) g[String.fromCharCode(65 + A)] = String(10 + A);
    const d = Math.floor(u(9007199254740991));

    function h(r) {
      let e = (r = (r = r.toUpperCase()).substring(4) + r.substring(0, 2) + "00").split("").map(r => g[r]).join("");
      for (; e.length >= d;) {
        let r = e.substring(0, d);
        e = parseInt(r, 10) % 97 + e.substring(r.length)
      }
      let t = String(98 - parseInt(e, 10) % 97);
      for (; t.length < 2;) t = "0" + t;
      return t
    }

    function l(r) {
      let t = null;
      if ("string" != typeof r && a.throwArgumentError("invalid address", "address", r), r.match(/^(0x)?[0-9a-fA-F]{40}$/)) "0x" !== r.substring(0, 2) && (r = "0x" + r), t = i(r), r.match(/([A-F].*[a-f])|([a-f].*[A-F])/) && t !== r && a.throwArgumentError("bad address checksum", "address", r);
      else if (r.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {
        for (r.substring(2, 4) !== h(r) && a.throwArgumentError("bad icap checksum", "address", r), t = (0, e._base36To16)(r.substring(4)); t.length < 40;) t = "0" + t;
        t = i("0x" + t)
      } else a.throwArgumentError("invalid address", "address", r);
      return t
    }

    function f(r) {
      try {
        return l(r), !0
      } catch (e) {}
      return !1
    }

    function p(r) {
      let t = (0, e._base16To36)(l(r).substring(2)).toUpperCase();
      for (; t.length < 30;) t = "0" + t;
      return "XE" + h("XE00" + t) + t
    }

    function m(n) {
      let o = null;
      try {
        o = l(n.from)
      } catch (c) {
        a.throwArgumentError("missing from address", "transaction", n)
      }
      const i = (0, r.stripZeros)((0, r.arrayify)(e.BigNumber.from(n.nonce).toHexString()));
      return l((0, r.hexDataSlice)((0, t.keccak256)((0, s.encode)([o, i])), 12))
    }

    function b(e, s, n) {
      return 32 !== (0, r.hexDataLength)(s) && a.throwArgumentError("salt must be 32 bytes", "salt", s), 32 !== (0, r.hexDataLength)(n) && a.throwArgumentError("initCodeHash must be 32 bytes", "initCodeHash", n), l((0, r.hexDataSlice)((0, t.keccak256)((0, r.concat)(["0xff", l(e), s, n])), 12))
    }
  }, {
    "@ethersproject/bytes": "kHJk",
    "@ethersproject/bignumber": "BWdp",
    "@ethersproject/keccak256": "Ko0x",
    "@ethersproject/rlp": "Rh5m",
    "@ethersproject/logger": "M3zR",
    "./_version": "zS5w"
  }],
  "P2MJ": [function(require, module, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    }), exports.AddressZero = void 0;
    const e = "0x0000000000000000000000000000000000000000";
    exports.AddressZero = e;
  }, {}],
  "MqBK": [function(require, module, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    }), exports.MaxUint256 = exports.WeiPerEther = exports.Two = exports.One = exports.Zero = exports.NegativeOne = void 0;
    var f = require("@ethersproject/bignumber");
    const e = f.BigNumber.from(-1);
    exports.NegativeOne = e;
    const r = f.BigNumber.from(0);
    exports.Zero = r;
    const o = f.BigNumber.from(1);
    exports.One = o;
    const t = f.BigNumber.from(2);
    exports.Two = t;
    const s = f.BigNumber.from("1000000000000000000");
    exports.WeiPerEther = s;
    const i = f.BigNumber.from("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
    exports.MaxUint256 = i;
  }, {
    "@ethersproject/bignumber": "BWdp"
  }],
  "ganX": [function(require, module, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    }), exports.HashZero = void 0;
    const e = "0x0000000000000000000000000000000000000000000000000000000000000000";
    exports.HashZero = e;
  }, {}],
  "b0Ik": [function(require, module, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    }), exports.EtherSymbol = void 0;
    const e = "";
    exports.EtherSymbol = "";
  }, {}],
  "inUu": [function(require, module, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    }), Object.defineProperty(exports, "AddressZero", {
      enumerable: !0,
      get: function() {
        return e.AddressZero
      }
    }), Object.defineProperty(exports, "NegativeOne", {
      enumerable: !0,
      get: function() {
        return r.NegativeOne
      }
    }), Object.defineProperty(exports, "Zero", {
      enumerable: !0,
      get: function() {
        return r.Zero
      }
    }), Object.defineProperty(exports, "One", {
      enumerable: !0,
      get: function() {
        return r.One
      }
    }), Object.defineProperty(exports, "Two", {
      enumerable: !0,
      get: function() {
        return r.Two
      }
    }), Object.defineProperty(exports, "WeiPerEther", {
      enumerable: !0,
      get: function() {
        return r.WeiPerEther
      }
    }), Object.defineProperty(exports, "MaxUint256", {
      enumerable: !0,
      get: function() {
        return r.MaxUint256
      }
    }), Object.defineProperty(exports, "HashZero", {
      enumerable: !0,
      get: function() {
        return t.HashZero
      }
    }), Object.defineProperty(exports, "EtherSymbol", {
      enumerable: !0,
      get: function() {
        return n.EtherSymbol
      }
    });
    var e = require("./addresses"),
      r = require("./bignumbers"),
      t = require("./hashes"),
      n = require("./strings");
  }, {
    "./addresses": "P2MJ",
    "./bignumbers": "MqBK",
    "./hashes": "ganX",
    "./strings": "b0Ik"
  }],
  "OdU5": [function(require, module, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    }), exports.version = void 0;
    const e = "properties/5.1.0";
    exports.version = e;
  }, {}],
  "miZX": [function(require, module, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    }), exports.defineReadOnly = n, exports.getStatic = i, exports.resolveProperties = c, exports.checkProperties = u, exports.shallowCopy = s, exports.deepCopy = y, exports.Description = void 0;
    var e = require("@ethersproject/logger"),
      t = require("./_version"),
      r = function(e, t, r, o) {
        return new(r || (r = Promise))(function(n, i) {
          function c(e) {
            try {
              s(o.next(e))
            } catch (t) {
              i(t)
            }
          }

          function u(e) {
            try {
              s(o.throw(e))
            } catch (t) {
              i(t)
            }
          }

          function s(e) {
            var t;
            e.done ? n(e.value) : (t = e.value, t instanceof r ? t : new r(function(e) {
              e(t)
            })).then(c, u)
          }
          s((o = o.apply(e, t || [])).next())
        })
      };
    const o = new e.Logger(t.version);

    function n(e, t, r) {
      Object.defineProperty(e, t, {
        enumerable: !0,
        value: r,
        writable: !1
      })
    }

    function i(e, t) {
      for (let r = 0; r < 32; r++) {
        if (e[t]) return e[t];
        if (!e.prototype || "object" != typeof e.prototype) break;
        e = Object.getPrototypeOf(e.prototype).constructor
      }
      return null
    }

    function c(e) {
      return r(this, void 0, void 0, function*() {
        const t = Object.keys(e).map(t => {
          const r = e[t];
          return Promise.resolve(r).then(e => ({
            key: t,
            value: e
          }))
        });
        return (yield Promise.all(t)).reduce((e, t) => (e[t.key] = t.value, e), {})
      })
    }

    function u(e, t) {
      e && "object" == typeof e || o.throwArgumentError("invalid object", "object", e), Object.keys(e).forEach(r => {
        t[r] || o.throwArgumentError("invalid object key - " + r, "transaction:" + r, e)
      })
    }

    function s(e) {
      const t = {};
      for (const r in e) t[r] = e[r];
      return t
    }
    const f = {
      bigint: !0,
      boolean: !0,
      function: !0,
      number: !0,
      string: !0
    };

    function p(e) {
      if (null == e || f[typeof e]) return !0;
      if (Array.isArray(e) || "object" == typeof e) {
        if (!Object.isFrozen(e)) return !1;
        const t = Object.keys(e);
        for (let r = 0; r < t.length; r++)
          if (!p(e[t[r]])) return !1;
        return !0
      }
      return o.throwArgumentError(`Cannot deepCopy ${typeof e}`, "object", e)
    }

    function a(e) {
      if (p(e)) return e;
      if (Array.isArray(e)) return Object.freeze(e.map(e => y(e)));
      if ("object" == typeof e) {
        const t = {};
        for (const r in e) {
          const o = e[r];
          void 0 !== o && n(t, r, y(o))
        }
        return t
      }
      return o.throwArgumentError(`Cannot deepCopy ${typeof e}`, "object", e)
    }

    function y(e) {
      return a(e)
    }
    class l {
      constructor(e) {
        for (const t in e) this[t] = y(e[t])
      }
    }
    exports.Description = l;
  }, {
    "@ethersproject/logger": "M3zR",
    "./_version": "OdU5"
  }],
  "MpuC": [function(require, module, exports) {
    function r(r, o) {
      if (!r) throw new Error(o || "Assertion failed")
    }
    module.exports = r, r.equal = function(r, o, e) {
      if (r != o) throw new Error(e || "Assertion failed: " + r + " != " + o)
    };
  }, {}],
  "eeOV": [function(require, module, exports) {
    "use strict";
    var r = require("minimalistic-assert"),
      t = require("inherits");

    function n(r, t) {
      return 55296 == (64512 & r.charCodeAt(t)) && (!(t < 0 || t + 1 >= r.length) && 56320 == (64512 & r.charCodeAt(t + 1)))
    }

    function e(r, t) {
      if (Array.isArray(r)) return r.slice();
      if (!r) return [];
      var e = [];
      if ("string" == typeof r)
        if (t) {
          if ("hex" === t)
            for ((r = r.replace(/[^a-z0-9]+/gi, "")).length % 2 != 0 && (r = "0" + r), u = 0; u < r.length; u += 2) e.push(parseInt(r[u] + r[u + 1], 16))
        } else
          for (var o = 0, u = 0; u < r.length; u++) {
            var i = r.charCodeAt(u);
            i < 128 ? e[o++] = i : i < 2048 ? (e[o++] = i >> 6 | 192, e[o++] = 63 & i | 128) : n(r, u) ? (i = 65536 + ((1023 & i) << 10) + (1023 & r.charCodeAt(++u)), e[o++] = i >> 18 | 240, e[o++] = i >> 12 & 63 | 128, e[o++] = i >> 6 & 63 | 128, e[o++] = 63 & i | 128) : (e[o++] = i >> 12 | 224, e[o++] = i >> 6 & 63 | 128, e[o++] = 63 & i | 128)
          } else
            for (u = 0; u < r.length; u++) e[u] = 0 | r[u];
      return e
    }

    function o(r) {
      for (var t = "", n = 0; n < r.length; n++) t += s(r[n].toString(16));
      return t
    }

    function u(r) {
      return (r >>> 24 | r >>> 8 & 65280 | r << 8 & 16711680 | (255 & r) << 24) >>> 0
    }

    function i(r, t) {
      for (var n = "", e = 0; e < r.length; e++) {
        var o = r[e];
        "little" === t && (o = u(o)), n += f(o.toString(16))
      }
      return n
    }

    function s(r) {
      return 1 === r.length ? "0" + r : r
    }

    function f(r) {
      return 7 === r.length ? "0" + r : 6 === r.length ? "00" + r : 5 === r.length ? "000" + r : 4 === r.length ? "0000" + r : 3 === r.length ? "00000" + r : 2 === r.length ? "000000" + r : 1 === r.length ? "0000000" + r : r
    }

    function c(t, n, e, o) {
      var u = e - n;
      r(u % 4 == 0);
      for (var i = new Array(u / 4), s = 0, f = n; s < i.length; s++, f += 4) {
        var c;
        c = "big" === o ? t[f] << 24 | t[f + 1] << 16 | t[f + 2] << 8 | t[f + 3] : t[f + 3] << 24 | t[f + 2] << 16 | t[f + 1] << 8 | t[f], i[s] = c >>> 0
      }
      return i
    }

    function h(r, t) {
      for (var n = new Array(4 * r.length), e = 0, o = 0; e < r.length; e++, o += 4) {
        var u = r[e];
        "big" === t ? (n[o] = u >>> 24, n[o + 1] = u >>> 16 & 255, n[o + 2] = u >>> 8 & 255, n[o + 3] = 255 & u) : (n[o + 3] = u >>> 24, n[o + 2] = u >>> 16 & 255, n[o + 1] = u >>> 8 & 255, n[o] = 255 & u)
      }
      return n
    }

    function l(r, t) {
      return r >>> t | r << 32 - t
    }

    function p(r, t) {
      return r << t | r >>> 32 - t
    }

    function a(r, t) {
      return r + t >>> 0
    }

    function x(r, t, n) {
      return r + t + n >>> 0
    }

    function g(r, t, n, e) {
      return r + t + n + e >>> 0
    }

    function _(r, t, n, e, o) {
      return r + t + n + e + o >>> 0
    }

    function v(r, t, n, e) {
      var o = r[t],
        u = e + r[t + 1] >>> 0,
        i = (u < e ? 1 : 0) + n + o;
      r[t] = i >>> 0, r[t + 1] = u
    }

    function m(r, t, n, e) {
      return (t + e >>> 0 < t ? 1 : 0) + r + n >>> 0
    }

    function A(r, t, n, e) {
      return t + e >>> 0
    }

    function y(r, t, n, e, o, u, i, s) {
      var f = 0,
        c = t;
      return f += (c = c + e >>> 0) < t ? 1 : 0, f += (c = c + u >>> 0) < u ? 1 : 0, r + n + o + i + (f += (c = c + s >>> 0) < s ? 1 : 0) >>> 0
    }

    function d(r, t, n, e, o, u, i, s) {
      return t + e + u + s >>> 0
    }

    function C(r, t, n, e, o, u, i, s, f, c) {
      var h = 0,
        l = t;
      return h += (l = l + e >>> 0) < t ? 1 : 0, h += (l = l + u >>> 0) < u ? 1 : 0, h += (l = l + s >>> 0) < s ? 1 : 0, r + n + o + i + f + (h += (l = l + c >>> 0) < c ? 1 : 0) >>> 0
    }

    function z(r, t, n, e, o, u, i, s, f, c) {
      return t + e + u + s + c >>> 0
    }

    function b(r, t, n) {
      return (t << 32 - n | r >>> n) >>> 0
    }

    function q(r, t, n) {
      return (r << 32 - n | t >>> n) >>> 0
    }

    function w(r, t, n) {
      return r >>> n
    }

    function H(r, t, n) {
      return (r << 32 - n | t >>> n) >>> 0
    }
    exports.inherits = t, exports.toArray = e, exports.toHex = o, exports.htonl = u, exports.toHex32 = i, exports.zero2 = s, exports.zero8 = f, exports.join32 = c, exports.split32 = h, exports.rotr32 = l, exports.rotl32 = p, exports.sum32 = a, exports.sum32_3 = x, exports.sum32_4 = g, exports.sum32_5 = _, exports.sum64 = v, exports.sum64_hi = m, exports.sum64_lo = A, exports.sum64_4_hi = y, exports.sum64_4_lo = d, exports.sum64_5_hi = C, exports.sum64_5_lo = z, exports.rotr64_hi = b, exports.rotr64_lo = q, exports.shr64_hi = w, exports.shr64_lo = H;
  }, {
    "minimalistic-assert": "MpuC",
    "inherits": "Bm0n"
  }],
  "p0gz": [function(require, module, exports) {
    "use strict";
    var t = require("./utils"),
      i = require("minimalistic-assert");

    function n() {
      this.pending = null, this.pendingTotal = 0, this.blockSize = this.constructor.blockSize, this.outSize = this.constructor.outSize, this.hmacStrength = this.constructor.hmacStrength, this.padLength = this.constructor.padLength / 8, this.endian = "big", this._delta8 = this.blockSize / 8, this._delta32 = this.blockSize / 32
    }
    exports.BlockHash = n, n.prototype.update = function(i, n) {
      if (i = t.toArray(i, n), this.pending ? this.pending = this.pending.concat(i) : this.pending = i, this.pendingTotal += i.length, this.pending.length >= this._delta8) {
        var e = (i = this.pending).length % this._delta8;
        this.pending = i.slice(i.length - e, i.length), 0 === this.pending.length && (this.pending = null), i = t.join32(i, 0, i.length - e, this.endian);
        for (var h = 0; h < i.length; h += this._delta32) this._update(i, h, h + this._delta32)
      }
      return this
    }, n.prototype.digest = function(t) {
      return this.update(this._pad()), i(null === this.pending), this._digest(t)
    }, n.prototype._pad = function() {
      var t = this.pendingTotal,
        i = this._delta8,
        n = i - (t + this.padLength) % i,
        e = new Array(n + this.padLength);
      e[0] = 128;
      for (var h = 1; h < n; h++) e[h] = 0;
      if (t <<= 3, "big" === this.endian) {
        for (var s = 8; s < this.padLength; s++) e[h++] = 0;
        e[h++] = 0, e[h++] = 0, e[h++] = 0, e[h++] = 0, e[h++] = t >>> 24 & 255, e[h++] = t >>> 16 & 255, e[h++] = t >>> 8 & 255, e[h++] = 255 & t
      } else
        for (e[h++] = 255 & t, e[h++] = t >>> 8 & 255, e[h++] = t >>> 16 & 255, e[h++] = t >>> 24 & 255, e[h++] = 0, e[h++] = 0, e[h++] = 0, e[h++] = 0, s = 8; s < this.padLength; s++) e[h++] = 0;
      return e
    };
  }, {
    "./utils": "eeOV",
    "minimalistic-assert": "MpuC"
  }],
  "qR4i": [function(require, module, exports) {
    "use strict";
    var r = require("../utils"),
      t = r.rotr32;

    function n(r, t, n, s) {
      return 0 === r ? e(t, n, s) : 1 === r || 3 === r ? o(t, n, s) : 2 === r ? u(t, n, s) : void 0
    }

    function e(r, t, n) {
      return r & t ^ ~r & n
    }

    function u(r, t, n) {
      return r & t ^ r & n ^ t & n
    }

    function o(r, t, n) {
      return r ^ t ^ n
    }

    function s(r) {
      return t(r, 2) ^ t(r, 13) ^ t(r, 22)
    }

    function i(r) {
      return t(r, 6) ^ t(r, 11) ^ t(r, 25)
    }

    function c(r) {
      return t(r, 7) ^ t(r, 18) ^ r >>> 3
    }

    function f(r) {
      return t(r, 17) ^ t(r, 19) ^ r >>> 10
    }
    exports.ft_1 = n, exports.ch32 = e, exports.maj32 = u, exports.p32 = o, exports.s0_256 = s, exports.s1_256 = i, exports.g0_256 = c, exports.g1_256 = f;
  }, {
    "../utils": "eeOV"
  }],
  "rIEX": [function(require, module, exports) {
    "use strict";
    var t = require("../utils"),
      h = require("../common"),
      i = require("./common"),
      s = t.rotl32,
      e = t.sum32,
      r = t.sum32_5,
      o = i.ft_1,
      n = h.BlockHash,
      u = [1518500249, 1859775393, 2400959708, 3395469782];

    function a() {
      if (!(this instanceof a)) return new a;
      n.call(this), this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520], this.W = new Array(80)
    }
    t.inherits(a, n), module.exports = a, a.blockSize = 512, a.outSize = 160, a.hmacStrength = 80, a.padLength = 64, a.prototype._update = function(t, h) {
      for (var i = this.W, n = 0; n < 16; n++) i[n] = t[h + n];
      for (; n < i.length; n++) i[n] = s(i[n - 3] ^ i[n - 8] ^ i[n - 14] ^ i[n - 16], 1);
      var a = this.h[0],
        c = this.h[1],
        l = this.h[2],
        f = this.h[3],
        m = this.h[4];
      for (n = 0; n < i.length; n++) {
        var p = ~~(n / 20),
          g = r(s(a, 5), o(p, c, l, f), m, i[n], u[p]);
        m = f, f = l, l = s(c, 30), c = a, a = g
      }
      this.h[0] = e(this.h[0], a), this.h[1] = e(this.h[1], c), this.h[2] = e(this.h[2], l), this.h[3] = e(this.h[3], f), this.h[4] = e(this.h[4], m)
    }, a.prototype._digest = function(h) {
      return "hex" === h ? t.toHex32(this.h, "big") : t.split32(this.h, "big")
    };
  }, {
    "../utils": "eeOV",
    "../common": "p0gz",
    "./common": "qR4i"
  }],
  "iJWs": [function(require, module, exports) {
    "use strict";
    var h = require("../utils"),
      t = require("../common"),
      i = require("./common"),
      s = require("minimalistic-assert"),
      e = h.sum32,
      r = h.sum32_4,
      n = h.sum32_5,
      o = i.ch32,
      u = i.maj32,
      a = i.s0_256,
      c = i.s1_256,
      l = i.g0_256,
      m = i.g1_256,
      g = t.BlockHash,
      f = [1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298];

    function p() {
      if (!(this instanceof p)) return new p;
      g.call(this), this.h = [1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225], this.k = f, this.W = new Array(64)
    }
    h.inherits(p, g), module.exports = p, p.blockSize = 512, p.outSize = 256, p.hmacStrength = 192, p.padLength = 64, p.prototype._update = function(h, t) {
      for (var i = this.W, g = 0; g < 16; g++) i[g] = h[t + g];
      for (; g < i.length; g++) i[g] = r(m(i[g - 2]), i[g - 7], l(i[g - 15]), i[g - 16]);
      var f = this.h[0],
        p = this.h[1],
        _ = this.h[2],
        k = this.h[3],
        d = this.h[4],
        q = this.h[5],
        v = this.h[6],
        b = this.h[7];
      for (s(this.k.length === i.length), g = 0; g < i.length; g++) {
        var x = n(b, c(d), o(d, q, v), this.k[g], i[g]),
          y = e(a(f), u(f, p, _));
        b = v, v = q, q = d, d = e(k, x), k = _, _ = p, p = f, f = e(x, y)
      }
      this.h[0] = e(this.h[0], f), this.h[1] = e(this.h[1], p), this.h[2] = e(this.h[2], _), this.h[3] = e(this.h[3], k), this.h[4] = e(this.h[4], d), this.h[5] = e(this.h[5], q), this.h[6] = e(this.h[6], v), this.h[7] = e(this.h[7], b)
    }, p.prototype._digest = function(t) {
      return "hex" === t ? h.toHex32(this.h, "big") : h.split32(this.h, "big")
    };
  }, {
    "../utils": "eeOV",
    "../common": "p0gz",
    "./common": "qR4i",
    "minimalistic-assert": "MpuC"
  }],
  "NwVK": [function(require, module, exports) {
    "use strict";
    var t = require("../utils"),
      i = require("./256");

    function e() {
      if (!(this instanceof e)) return new e;
      i.call(this), this.h = [3238371032, 914150663, 812702999, 4144912697, 4290775857, 1750603025, 1694076839, 3204075428]
    }
    t.inherits(e, i), module.exports = e, e.blockSize = 512, e.outSize = 224, e.hmacStrength = 192, e.padLength = 64, e.prototype._digest = function(i) {
      return "hex" === i ? t.toHex32(this.h.slice(0, 7), "big") : t.split32(this.h.slice(0, 7), "big")
    };
  }, {
    "../utils": "eeOV",
    "./256": "iJWs"
  }],
  "CY40": [function(require, module, exports) {
    "use strict";
    var t = require("../utils"),
      h = require("../common"),
      i = require("minimalistic-assert"),
      r = t.rotr64_hi,
      n = t.rotr64_lo,
      s = t.shr64_hi,
      e = t.shr64_lo,
      u = t.sum64,
      o = t.sum64_hi,
      a = t.sum64_lo,
      c = t.sum64_4_hi,
      f = t.sum64_4_lo,
      l = t.sum64_5_hi,
      v = t.sum64_5_lo,
      _ = h.BlockHash,
      p = [1116352408, 3609767458, 1899447441, 602891725, 3049323471, 3964484399, 3921009573, 2173295548, 961987163, 4081628472, 1508970993, 3053834265, 2453635748, 2937671579, 2870763221, 3664609560, 3624381080, 2734883394, 310598401, 1164996542, 607225278, 1323610764, 1426881987, 3590304994, 1925078388, 4068182383, 2162078206, 991336113, 2614888103, 633803317, 3248222580, 3479774868, 3835390401, 2666613458, 4022224774, 944711139, 264347078, 2341262773, 604807628, 2007800933, 770255983, 1495990901, 1249150122, 1856431235, 1555081692, 3175218132, 1996064986, 2198950837, 2554220882, 3999719339, 2821834349, 766784016, 2952996808, 2566594879, 3210313671, 3203337956, 3336571891, 1034457026, 3584528711, 2466948901, 113926993, 3758326383, 338241895, 168717936, 666307205, 1188179964, 773529912, 1546045734, 1294757372, 1522805485, 1396182291, 2643833823, 1695183700, 2343527390, 1986661051, 1014477480, 2177026350, 1206759142, 2456956037, 344077627, 2730485921, 1290863460, 2820302411, 3158454273, 3259730800, 3505952657, 3345764771, 106217008, 3516065817, 3606008344, 3600352804, 1432725776, 4094571909, 1467031594, 275423344, 851169720, 430227734, 3100823752, 506948616, 1363258195, 659060556, 3750685593, 883997877, 3785050280, 958139571, 3318307427, 1322822218, 3812723403, 1537002063, 2003034995, 1747873779, 3602036899, 1955562222, 1575990012, 2024104815, 1125592928, 2227730452, 2716904306, 2361852424, 442776044, 2428436474, 593698344, 2756734187, 3733110249, 3204031479, 2999351573, 3329325298, 3815920427, 3391569614, 3928383900, 3515267271, 566280711, 3940187606, 3454069534, 4118630271, 4000239992, 116418474, 1914138554, 174292421, 2731055270, 289380356, 3203993006, 460393269, 320620315, 685471733, 587496836, 852142971, 1086792851, 1017036298, 365543100, 1126000580, 2618297676, 1288033470, 3409855158, 1501505948, 4234509866, 1607167915, 987167468, 1816402316, 1246189591];

    function m() {
      if (!(this instanceof m)) return new m;
      _.call(this), this.h = [1779033703, 4089235720, 3144134277, 2227873595, 1013904242, 4271175723, 2773480762, 1595750129, 1359893119, 2917565137, 2600822924, 725511199, 528734635, 4215389547, 1541459225, 327033209], this.k = p, this.W = new Array(160)
    }

    function g(t, h, i, r, n) {
      var s = t & i ^ ~t & n;
      return s < 0 && (s += 4294967296), s
    }

    function k(t, h, i, r, n, s) {
      var e = h & r ^ ~h & s;
      return e < 0 && (e += 4294967296), e
    }

    function d(t, h, i, r, n) {
      var s = t & i ^ t & n ^ i & n;
      return s < 0 && (s += 4294967296), s
    }

    function y(t, h, i, r, n, s) {
      var e = h & r ^ h & s ^ r & s;
      return e < 0 && (e += 4294967296), e
    }

    function b(t, h) {
      var i = r(t, h, 28) ^ r(h, t, 2) ^ r(h, t, 7);
      return i < 0 && (i += 4294967296), i
    }

    function q(t, h) {
      var i = n(t, h, 28) ^ n(h, t, 2) ^ n(h, t, 7);
      return i < 0 && (i += 4294967296), i
    }

    function x(t, h) {
      var i = r(t, h, 14) ^ r(t, h, 18) ^ r(h, t, 9);
      return i < 0 && (i += 4294967296), i
    }

    function B(t, h) {
      var i = n(t, h, 14) ^ n(t, h, 18) ^ n(h, t, 9);
      return i < 0 && (i += 4294967296), i
    }

    function S(t, h) {
      var i = r(t, h, 1) ^ r(t, h, 8) ^ s(t, h, 7);
      return i < 0 && (i += 4294967296), i
    }

    function W(t, h) {
      var i = n(t, h, 1) ^ n(t, h, 8) ^ e(t, h, 7);
      return i < 0 && (i += 4294967296), i
    }

    function w(t, h) {
      var i = r(t, h, 19) ^ r(h, t, 29) ^ s(t, h, 6);
      return i < 0 && (i += 4294967296), i
    }

    function z(t, h) {
      var i = n(t, h, 19) ^ n(h, t, 29) ^ e(t, h, 6);
      return i < 0 && (i += 4294967296), i
    }
    t.inherits(m, _), module.exports = m, m.blockSize = 1024, m.outSize = 512, m.hmacStrength = 192, m.padLength = 128, m.prototype._prepareBlock = function(t, h) {
      for (var i = this.W, r = 0; r < 32; r++) i[r] = t[h + r];
      for (; r < i.length; r += 2) {
        var n = w(i[r - 4], i[r - 3]),
          s = z(i[r - 4], i[r - 3]),
          e = i[r - 14],
          u = i[r - 13],
          o = S(i[r - 30], i[r - 29]),
          a = W(i[r - 30], i[r - 29]),
          l = i[r - 32],
          v = i[r - 31];
        i[r] = c(n, s, e, u, o, a, l, v), i[r + 1] = f(n, s, e, u, o, a, l, v)
      }
    }, m.prototype._update = function(t, h) {
      this._prepareBlock(t, h);
      var r = this.W,
        n = this.h[0],
        s = this.h[1],
        e = this.h[2],
        c = this.h[3],
        f = this.h[4],
        _ = this.h[5],
        p = this.h[6],
        m = this.h[7],
        S = this.h[8],
        W = this.h[9],
        w = this.h[10],
        z = this.h[11],
        H = this.h[12],
        A = this.h[13],
        L = this.h[14],
        j = this.h[15];
      i(this.k.length === r.length);
      for (var C = 0; C < r.length; C += 2) {
        var D = L,
          E = j,
          F = x(S, W),
          G = B(S, W),
          I = g(S, W, w, z, H, A),
          J = k(S, W, w, z, H, A),
          K = this.k[C],
          M = this.k[C + 1],
          N = r[C],
          O = r[C + 1],
          P = l(D, E, F, G, I, J, K, M, N, O),
          Q = v(D, E, F, G, I, J, K, M, N, O);
        D = b(n, s), E = q(n, s), F = d(n, s, e, c, f, _), G = y(n, s, e, c, f, _);
        var R = o(D, E, F, G),
          T = a(D, E, F, G);
        L = H, j = A, H = w, A = z, w = S, z = W, S = o(p, m, P, Q), W = a(m, m, P, Q), p = f, m = _, f = e, _ = c, e = n, c = s, n = o(P, Q, R, T), s = a(P, Q, R, T)
      }
      u(this.h, 0, n, s), u(this.h, 2, e, c), u(this.h, 4, f, _), u(this.h, 6, p, m), u(this.h, 8, S, W), u(this.h, 10, w, z), u(this.h, 12, H, A), u(this.h, 14, L, j)
    }, m.prototype._digest = function(h) {
      return "hex" === h ? t.toHex32(this.h, "big") : t.split32(this.h, "big")
    };
  }, {
    "../utils": "eeOV",
    "../common": "p0gz",
    "minimalistic-assert": "MpuC"
  }],
  "sAVb": [function(require, module, exports) {
    "use strict";
    var t = require("../utils"),
      i = require("./512");

    function e() {
      if (!(this instanceof e)) return new e;
      i.call(this), this.h = [3418070365, 3238371032, 1654270250, 914150663, 2438529370, 812702999, 355462360, 4144912697, 1731405415, 4290775857, 2394180231, 1750603025, 3675008525, 1694076839, 1203062813, 3204075428]
    }
    t.inherits(e, i), module.exports = e, e.blockSize = 1024, e.outSize = 384, e.hmacStrength = 192, e.padLength = 128, e.prototype._digest = function(i) {
      return "hex" === i ? t.toHex32(this.h.slice(0, 12), "big") : t.split32(this.h.slice(0, 12), "big")
    };
  }, {
    "../utils": "eeOV",
    "./512": "CY40"
  }],
  "BhcK": [function(require, module, exports) {
    "use strict";
    exports.sha1 = require("./sha/1"), exports.sha224 = require("./sha/224"), exports.sha256 = require("./sha/256"), exports.sha384 = require("./sha/384"), exports.sha512 = require("./sha/512");
  }, {
    "./sha/1": "rIEX",
    "./sha/224": "NwVK",
    "./sha/256": "iJWs",
    "./sha/384": "sAVb",
    "./sha/512": "CY40"
  }],
  "tE3w": [function(require, module, exports) {
    "use strict";
    var t = require("./utils"),
      h = require("./common"),
      i = t.rotl32,
      s = t.sum32,
      e = t.sum32_3,
      r = t.sum32_4,
      n = h.BlockHash;

    function o() {
      if (!(this instanceof o)) return new o;
      n.call(this), this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520], this.endian = "little"
    }

    function u(t, h, i, s) {
      return t <= 15 ? h ^ i ^ s : t <= 31 ? h & i | ~h & s : t <= 47 ? (h | ~i) ^ s : t <= 63 ? h & s | i & ~s : h ^ (i | ~s)
    }

    function c(t) {
      return t <= 15 ? 0 : t <= 31 ? 1518500249 : t <= 47 ? 1859775393 : t <= 63 ? 2400959708 : 2840853838
    }

    function l(t) {
      return t <= 15 ? 1352829926 : t <= 31 ? 1548603684 : t <= 47 ? 1836072691 : t <= 63 ? 2053994217 : 0
    }
    t.inherits(o, n), exports.ripemd160 = o, o.blockSize = 512, o.outSize = 160, o.hmacStrength = 192, o.padLength = 64, o.prototype._update = function(t, h) {
      for (var n = this.h[0], o = this.h[1], d = this.h[2], v = this.h[3], _ = this.h[4], g = n, x = o, S = d, k = v, q = _, y = 0; y < 80; y++) {
        var z = s(i(r(n, u(y, o, d, v), t[a[y] + h], c(y)), p[y]), _);
        n = _, _ = v, v = i(d, 10), d = o, o = z, z = s(i(r(g, u(79 - y, x, S, k), t[f[y] + h], l(y)), m[y]), q), g = q, q = k, k = i(S, 10), S = x, x = z
      }
      z = e(this.h[1], d, k), this.h[1] = e(this.h[2], v, q), this.h[2] = e(this.h[3], _, g), this.h[3] = e(this.h[4], n, x), this.h[4] = e(this.h[0], o, S), this.h[0] = z
    }, o.prototype._digest = function(h) {
      return "hex" === h ? t.toHex32(this.h, "little") : t.split32(this.h, "little")
    };
    var a = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8, 3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12, 1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2, 4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13],
      f = [5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12, 6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2, 15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13, 8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14, 12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11],
      p = [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8, 7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12, 11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5, 11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12, 9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6],
      m = [8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6, 9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11, 9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5, 15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8, 8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11];
  }, {
    "./utils": "eeOV",
    "./common": "p0gz"
  }],
  "AA3E": [function(require, module, exports) {
    "use strict";
    var t = require("./utils"),
      i = require("minimalistic-assert");

    function e(i, s, n) {
      if (!(this instanceof e)) return new e(i, s, n);
      this.Hash = i, this.blockSize = i.blockSize / 8, this.outSize = i.outSize / 8, this.inner = null, this.outer = null, this._init(t.toArray(s, n))
    }
    module.exports = e, e.prototype._init = function(t) {
      t.length > this.blockSize && (t = (new this.Hash).update(t).digest()), i(t.length <= this.blockSize);
      for (var e = t.length; e < this.blockSize; e++) t.push(0);
      for (e = 0; e < t.length; e++) t[e] ^= 54;
      for (this.inner = (new this.Hash).update(t), e = 0; e < t.length; e++) t[e] ^= 106;
      this.outer = (new this.Hash).update(t)
    }, e.prototype.update = function(t, i) {
      return this.inner.update(t, i), this
    }, e.prototype.digest = function(t) {
      return this.outer.update(this.inner.digest()), this.outer.digest(t)
    };
  }, {
    "./utils": "eeOV",
    "minimalistic-assert": "MpuC"
  }],
  "fVGI": [function(require, module, exports) {
    var h = exports;
    h.utils = require("./hash/utils"), h.common = require("./hash/common"), h.sha = require("./hash/sha"), h.ripemd = require("./hash/ripemd"), h.hmac = require("./hash/hmac"), h.sha1 = h.sha.sha1, h.sha256 = h.sha.sha256, h.sha224 = h.sha.sha224, h.sha384 = h.sha.sha384, h.sha512 = h.sha.sha512, h.ripemd160 = h.ripemd.ripemd160;
  }, {
    "./hash/utils": "eeOV",
    "./hash/common": "p0gz",
    "./hash/sha": "BhcK",
    "./hash/ripemd": "tE3w",
    "./hash/hmac": "AA3E"
  }],
  "OF6o": [function(require, module, exports) {
    var global = arguments[3];
    var e = arguments[3];
    Object.defineProperty(exports, "__esModule", {
      value: !0
    }), exports.EC = void 0;
    var t = r(require("bn.js")),
      f = r(require("hash.js"));

    function r(e) {
      return e && e.__esModule ? e : {
        default: e
      }
    }
    var n = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof window ? window : void 0 !== e ? e : "undefined" != typeof self ? self : {};

    function i(e) {
      return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e
    }

    function d(e, t, f) {
      return e(f = {
        path: t,
        exports: {},
        require: function(e, t) {
          return a(e, null == t ? f.path : t)
        }
      }, f.exports), f.exports
    }

    function s(e) {
      return e && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e
    }

    function u(e) {
      return e && Object.prototype.hasOwnProperty.call(e, "default") && 1 === Object.keys(e).length ? e.default : e
    }

    function o(e) {
      if (e.__esModule) return e;
      var t = Object.defineProperty({}, "__esModule", {
        value: !0
      });
      return Object.keys(e).forEach(function(f) {
        var r = Object.getOwnPropertyDescriptor(e, f);
        Object.defineProperty(t, f, r.get ? r : {
          enumerable: !0,
          get: function() {
            return e[f]
          }
        })
      }), t
    }

    function a() {
      throw new Error("Dynamic requires are not currently supported by @rollup/plugin-commonjs")
    }
    var h = c;

    function c(e, t) {
      if (!e) throw new Error(t || "Assertion failed")
    }
    c.equal = function(e, t, f) {
      if (e != t) throw new Error(f || "Assertion failed: " + e + " != " + t)
    };
    var p = d(function(e, t) {
        "use strict";
        var f = t;

        function r(e) {
          return 1 === e.length ? "0" + e : e
        }

        function n(e) {
          for (var t = "", f = 0; f < e.length; f++) t += r(e[f].toString(16));
          return t
        }
        f.toArray = function(e, t) {
          if (Array.isArray(e)) return e.slice();
          if (!e) return [];
          var f = [];
          if ("string" != typeof e) {
            for (var r = 0; r < e.length; r++) f[r] = 0 | e[r];
            return f
          }
          if ("hex" === t)
            for ((e = e.replace(/[^a-z0-9]+/gi, "")).length % 2 != 0 && (e = "0" + e), r = 0; r < e.length; r += 2) f.push(parseInt(e[r] + e[r + 1], 16));
          else
            for (r = 0; r < e.length; r++) {
              var n = e.charCodeAt(r),
                i = n >> 8,
                d = 255 & n;
              i ? f.push(i, d) : f.push(d)
            }
          return f
        }, f.zero2 = r, f.toHex = n, f.encode = function(e, t) {
          return "hex" === t ? n(e) : e
        }
      }),
      l = d(function(e, f) {
        "use strict";
        var r = f;
        r.assert = h, r.toArray = p.toArray, r.zero2 = p.zero2, r.toHex = p.toHex, r.encode = p.encode, r.getNAF = function(e, t, f) {
          var r = new Array(Math.max(e.bitLength(), f) + 1);
          r.fill(0);
          for (var n = 1 << t + 1, i = e.clone(), d = 0; d < r.length; d++) {
            var s, u = i.andln(n - 1);
            i.isOdd() ? (s = u > (n >> 1) - 1 ? (n >> 1) - u : u, i.isubn(s)) : s = 0, r[d] = s, i.iushrn(1)
          }
          return r
        }, r.getJSF = function(e, t) {
          var f = [
            [],
            []
          ];
          e = e.clone(), t = t.clone();
          for (var r, n = 0, i = 0; e.cmpn(-n) > 0 || t.cmpn(-i) > 0;) {
            var d, s, u = e.andln(3) + n & 3,
              o = t.andln(3) + i & 3;
            3 === u && (u = -1), 3 === o && (o = -1), d = 0 == (1 & u) ? 0 : 3 != (r = e.andln(7) + n & 7) && 5 !== r || 2 !== o ? u : -u, f[0].push(d), s = 0 == (1 & o) ? 0 : 3 != (r = t.andln(7) + i & 7) && 5 !== r || 2 !== u ? o : -o, f[1].push(s), 2 * n === d + 1 && (n = 1 - n), 2 * i === s + 1 && (i = 1 - i), e.iushrn(1), t.iushrn(1)
          }
          return f
        }, r.cachedProperty = function(e, t, f) {
          var r = "_" + t;
          e.prototype[t] = function() {
            return void 0 !== this[r] ? this[r] : this[r] = f.call(this)
          }
        }, r.parseBytes = function(e) {
          return "string" == typeof e ? r.toArray(e, "hex") : e
        }, r.intFromLE = function(e) {
          return new t.default(e, "hex", "le")
        }
      }),
      b = l.getNAF,
      v = l.getJSF,
      y = l.assert;

    function m(e, f) {
      this.type = e, this.p = new t.default(f.p, 16), this.red = f.prime ? t.default.red(f.prime) : t.default.mont(this.p), this.zero = new t.default(0).toRed(this.red), this.one = new t.default(1).toRed(this.red), this.two = new t.default(2).toRed(this.red), this.n = f.n && new t.default(f.n, 16), this.g = f.g && this.pointFromJSON(f.g, f.gRed), this._wnafT1 = new Array(4), this._wnafT2 = new Array(4), this._wnafT3 = new Array(4), this._wnafT4 = new Array(4), this._bitLength = this.n ? this.n.bitLength() : 0;
      var r = this.n && this.p.div(this.n);
      !r || r.cmpn(100) > 0 ? this.redN = null : (this._maxwellTrick = !0, this.redN = this.n.toRed(this.red))
    }
    var g = m;

    function A(e, t) {
      this.curve = e, this.type = t, this.precomputed = null
    }
    m.prototype.point = function() {
      throw new Error("Not implemented")
    }, m.prototype.validate = function() {
      throw new Error("Not implemented")
    }, m.prototype._fixedNafMul = function(e, t) {
      y(e.precomputed);
      var f = e._getDoubles(),
        r = b(t, 1, this._bitLength),
        n = (1 << f.step + 1) - (f.step % 2 == 0 ? 2 : 1);
      n /= 3;
      var i, d, s = [];
      for (i = 0; i < r.length; i += f.step) {
        d = 0;
        for (var u = i + f.step - 1; u >= i; u--) d = (d << 1) + r[u];
        s.push(d)
      }
      for (var o = this.jpoint(null, null, null), a = this.jpoint(null, null, null), h = n; h > 0; h--) {
        for (i = 0; i < s.length; i++)(d = s[i]) === h ? a = a.mixedAdd(f.points[i]) : d === -h && (a = a.mixedAdd(f.points[i].neg()));
        o = o.add(a)
      }
      return o.toP()
    }, m.prototype._wnafMul = function(e, t) {
      var f = 4,
        r = e._getNAFPoints(f);
      f = r.wnd;
      for (var n = r.points, i = b(t, f, this._bitLength), d = this.jpoint(null, null, null), s = i.length - 1; s >= 0; s--) {
        for (var u = 0; s >= 0 && 0 === i[s]; s--) u++;
        if (s >= 0 && u++, d = d.dblp(u), s < 0) break;
        var o = i[s];
        y(0 !== o), d = "affine" === e.type ? o > 0 ? d.mixedAdd(n[o - 1 >> 1]) : d.mixedAdd(n[-o - 1 >> 1].neg()) : o > 0 ? d.add(n[o - 1 >> 1]) : d.add(n[-o - 1 >> 1].neg())
      }
      return "affine" === e.type ? d.toP() : d
    }, m.prototype._wnafMulAdd = function(e, t, f, r, n) {
      var i, d, s, u = this._wnafT1,
        o = this._wnafT2,
        a = this._wnafT3,
        h = 0;
      for (i = 0; i < r; i++) {
        var c = (s = t[i])._getNAFPoints(e);
        u[i] = c.wnd, o[i] = c.points
      }
      for (i = r - 1; i >= 1; i -= 2) {
        var p = i - 1,
          l = i;
        if (1 === u[p] && 1 === u[l]) {
          var y = [t[p], null, null, t[l]];
          0 === t[p].y.cmp(t[l].y) ? (y[1] = t[p].add(t[l]), y[2] = t[p].toJ().mixedAdd(t[l].neg())) : 0 === t[p].y.cmp(t[l].y.redNeg()) ? (y[1] = t[p].toJ().mixedAdd(t[l]), y[2] = t[p].add(t[l].neg())) : (y[1] = t[p].toJ().mixedAdd(t[l]), y[2] = t[p].toJ().mixedAdd(t[l].neg()));
          var m = [-3, -1, -5, -7, 0, 7, 5, 1, 3],
            g = v(f[p], f[l]);
          for (h = Math.max(g[0].length, h), a[p] = new Array(h), a[l] = new Array(h), d = 0; d < h; d++) {
            var A = 0 | g[0][d],
              S = 0 | g[1][d];
            a[p][d] = m[3 * (A + 1) + (S + 1)], a[l][d] = 0, o[p] = y
          }
        } else a[p] = b(f[p], u[p], this._bitLength), a[l] = b(f[l], u[l], this._bitLength), h = Math.max(a[p].length, h), h = Math.max(a[l].length, h)
      }
      var w = this.jpoint(null, null, null),
        I = this._wnafT4;
      for (i = h; i >= 0; i--) {
        for (var x = 0; i >= 0;) {
          var _ = !0;
          for (d = 0; d < r; d++) I[d] = 0 | a[d][i], 0 !== I[d] && (_ = !1);
          if (!_) break;
          x++, i--
        }
        if (i >= 0 && x++, w = w.dblp(x), i < 0) break;
        for (d = 0; d < r; d++) {
          var M = I[d];
          0 !== M && (M > 0 ? s = o[d][M - 1 >> 1] : M < 0 && (s = o[d][-M - 1 >> 1].neg()), w = "affine" === s.type ? w.mixedAdd(s) : w.add(s))
        }
      }
      for (i = 0; i < r; i++) o[i] = null;
      return n ? w : w.toP()
    }, m.BasePoint = A, A.prototype.eq = function() {
      throw new Error("Not implemented")
    }, A.prototype.validate = function() {
      return this.curve.validate(this)
    }, m.prototype.decodePoint = function(e, t) {
      e = l.toArray(e, t);
      var f = this.p.byteLength();
      if ((4 === e[0] || 6 === e[0] || 7 === e[0]) && e.length - 1 == 2 * f) return 6 === e[0] ? y(e[e.length - 1] % 2 == 0) : 7 === e[0] && y(e[e.length - 1] % 2 == 1), this.point(e.slice(1, 1 + f), e.slice(1 + f, 1 + 2 * f));
      if ((2 === e[0] || 3 === e[0]) && e.length - 1 === f) return this.pointFromX(e.slice(1, 1 + f), 3 === e[0]);
      throw new Error("Unknown point format")
    }, A.prototype.encodeCompressed = function(e) {
      return this.encode(e, !0)
    }, A.prototype._encode = function(e) {
      var t = this.curve.p.byteLength(),
        f = this.getX().toArray("be", t);
      return e ? [this.getY().isEven() ? 2 : 3].concat(f) : [4].concat(f, this.getY().toArray("be", t))
    }, A.prototype.encode = function(e, t) {
      return l.encode(this._encode(t), e)
    }, A.prototype.precompute = function(e) {
      if (this.precomputed) return this;
      var t = {
        doubles: null,
        naf: null,
        beta: null
      };
      return t.naf = this._getNAFPoints(8), t.doubles = this._getDoubles(4, e), t.beta = this._getBeta(), this.precomputed = t, this
    }, A.prototype._hasDoubles = function(e) {
      if (!this.precomputed) return !1;
      var t = this.precomputed.doubles;
      return !!t && t.points.length >= Math.ceil((e.bitLength() + 1) / t.step)
    }, A.prototype._getDoubles = function(e, t) {
      if (this.precomputed && this.precomputed.doubles) return this.precomputed.doubles;
      for (var f = [this], r = this, n = 0; n < t; n += e) {
        for (var i = 0; i < e; i++) r = r.dbl();
        f.push(r)
      }
      return {
        step: e,
        points: f
      }
    }, A.prototype._getNAFPoints = function(e) {
      if (this.precomputed && this.precomputed.naf) return this.precomputed.naf;
      for (var t = [this], f = (1 << e) - 1, r = 1 === f ? null : this.dbl(), n = 1; n < f; n++) t[n] = t[n - 1].add(r);
      return {
        wnd: e,
        points: t
      }
    }, A.prototype._getBeta = function() {
      return null
    }, A.prototype.dblp = function(e) {
      for (var t = this, f = 0; f < e; f++) t = t.dbl();
      return t
    };
    var S = d(function(e) {
        "function" == typeof Object.create ? e.exports = function(e, t) {
          t && (e.super_ = t, e.prototype = Object.create(t.prototype, {
            constructor: {
              value: e,
              enumerable: !1,
              writable: !0,
              configurable: !0
            }
          }))
        } : e.exports = function(e, t) {
          if (t) {
            e.super_ = t;
            var f = function() {};
            f.prototype = t.prototype, e.prototype = new f, e.prototype.constructor = e
          }
        }
      }),
      w = l.assert;

    function I(e) {
      g.call(this, "short", e), this.a = new t.default(e.a, 16).toRed(this.red), this.b = new t.default(e.b, 16).toRed(this.red), this.tinv = this.two.redInvm(), this.zeroA = 0 === this.a.fromRed().cmpn(0), this.threeA = 0 === this.a.fromRed().sub(this.p).cmpn(-3), this.endo = this._getEndomorphism(e), this._endoWnafT1 = new Array(4), this._endoWnafT2 = new Array(4)
    }
    S(I, g);
    var x = I;

    function _(e, f, r, n) {
      g.BasePoint.call(this, e, "affine"), null === f && null === r ? (this.x = null, this.y = null, this.inf = !0) : (this.x = new t.default(f, 16), this.y = new t.default(r, 16), n && (this.x.forceRed(this.curve.red), this.y.forceRed(this.curve.red)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.inf = !1)
    }

    function M(e, f, r, n) {
      g.BasePoint.call(this, e, "jacobian"), null === f && null === r && null === n ? (this.x = this.curve.one, this.y = this.curve.one, this.z = new t.default(0)) : (this.x = new t.default(f, 16), this.y = new t.default(r, 16), this.z = new t.default(n, 16)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)), this.zOne = this.z === this.curve.one
    }
    I.prototype._getEndomorphism = function(e) {
      if (this.zeroA && this.g && this.n && 1 === this.p.modn(3)) {
        var f, r;
        if (e.beta) f = new t.default(e.beta, 16).toRed(this.red);
        else {
          var n = this._getEndoRoots(this.p);
          f = (f = n[0].cmp(n[1]) < 0 ? n[0] : n[1]).toRed(this.red)
        }
        if (e.lambda) r = new t.default(e.lambda, 16);
        else {
          var i = this._getEndoRoots(this.n);
          0 === this.g.mul(i[0]).x.cmp(this.g.x.redMul(f)) ? r = i[0] : (r = i[1], w(0 === this.g.mul(r).x.cmp(this.g.x.redMul(f))))
        }
        return {
          beta: f,
          lambda: r,
          basis: e.basis ? e.basis.map(function(e) {
            return {
              a: new t.default(e.a, 16),
              b: new t.default(e.b, 16)
            }
          }) : this._getEndoBasis(r)
        }
      }
    }, I.prototype._getEndoRoots = function(e) {
      var f = e === this.p ? this.red : t.default.mont(e),
        r = new t.default(2).toRed(f).redInvm(),
        n = r.redNeg(),
        i = new t.default(3).toRed(f).redNeg().redSqrt().redMul(r);
      return [n.redAdd(i).fromRed(), n.redSub(i).fromRed()]
    }, I.prototype._getEndoBasis = function(e) {
      for (var f, r, n, i, d, s, u, o, a, h = this.n.ushrn(Math.floor(this.n.bitLength() / 2)), c = e, p = this.n.clone(), l = new t.default(1), b = new t.default(0), v = new t.default(0), y = new t.default(1), m = 0; 0 !== c.cmpn(0);) {
        var g = p.div(c);
        o = p.sub(g.mul(c)), a = v.sub(g.mul(l));
        var A = y.sub(g.mul(b));
        if (!n && o.cmp(h) < 0) f = u.neg(), r = l, n = o.neg(), i = a;
        else if (n && 2 == ++m) break;
        u = o, p = c, c = o, v = l, l = a, y = b, b = A
      }
      d = o.neg(), s = a;
      var S = n.sqr().add(i.sqr());
      return d.sqr().add(s.sqr()).cmp(S) >= 0 && (d = f, s = r), n.negative && (n = n.neg(), i = i.neg()), d.negative && (d = d.neg(), s = s.neg()), [{
        a: n,
        b: i
      }, {
        a: d,
        b: s
      }]
    }, I.prototype._endoSplit = function(e) {
      var t = this.endo.basis,
        f = t[0],
        r = t[1],
        n = r.b.mul(e).divRound(this.n),
        i = f.b.neg().mul(e).divRound(this.n),
        d = n.mul(f.a),
        s = i.mul(r.a),
        u = n.mul(f.b),
        o = i.mul(r.b);
      return {
        k1: e.sub(d).sub(s),
        k2: u.add(o).neg()
      }
    }, I.prototype.pointFromX = function(e, f) {
      (e = new t.default(e, 16)).red || (e = e.toRed(this.red));
      var r = e.redSqr().redMul(e).redIAdd(e.redMul(this.a)).redIAdd(this.b),
        n = r.redSqrt();
      if (0 !== n.redSqr().redSub(r).cmp(this.zero)) throw new Error("invalid point");
      var i = n.fromRed().isOdd();
      return (f && !i || !f && i) && (n = n.redNeg()), this.point(e, n)
    }, I.prototype.validate = function(e) {
      if (e.inf) return !0;
      var t = e.x,
        f = e.y,
        r = this.a.redMul(t),
        n = t.redSqr().redMul(t).redIAdd(r).redIAdd(this.b);
      return 0 === f.redSqr().redISub(n).cmpn(0)
    }, I.prototype._endoWnafMulAdd = function(e, t, f) {
      for (var r = this._endoWnafT1, n = this._endoWnafT2, i = 0; i < e.length; i++) {
        var d = this._endoSplit(t[i]),
          s = e[i],
          u = s._getBeta();
        d.k1.negative && (d.k1.ineg(), s = s.neg(!0)), d.k2.negative && (d.k2.ineg(), u = u.neg(!0)), r[2 * i] = s, r[2 * i + 1] = u, n[2 * i] = d.k1, n[2 * i + 1] = d.k2
      }
      for (var o = this._wnafMulAdd(1, r, n, 2 * i, f), a = 0; a < 2 * i; a++) r[a] = null, n[a] = null;
      return o
    }, S(_, g.BasePoint), I.prototype.point = function(e, t, f) {
      return new _(this, e, t, f)
    }, I.prototype.pointFromJSON = function(e, t) {
      return _.fromJSON(this, e, t)
    }, _.prototype._getBeta = function() {
      if (this.curve.endo) {
        var e = this.precomputed;
        if (e && e.beta) return e.beta;
        var t = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
        if (e) {
          var f = this.curve,
            r = function(e) {
              return f.point(e.x.redMul(f.endo.beta), e.y)
            };
          e.beta = t, t.precomputed = {
            beta: null,
            naf: e.naf && {
              wnd: e.naf.wnd,
              points: e.naf.points.map(r)
            },
            doubles: e.doubles && {
              step: e.doubles.step,
              points: e.doubles.points.map(r)
            }
          }
        }
        return t
      }
    }, _.prototype.toJSON = function() {
      return this.precomputed ? [this.x, this.y, this.precomputed && {
        doubles: this.precomputed.doubles && {
          step: this.precomputed.doubles.step,
          points: this.precomputed.doubles.points.slice(1)
        },
        naf: this.precomputed.naf && {
          wnd: this.precomputed.naf.wnd,
          points: this.precomputed.naf.points.slice(1)
        }
      }] : [this.x, this.y]
    }, _.fromJSON = function(e, t, f) {
      "string" == typeof t && (t = JSON.parse(t));
      var r = e.point(t[0], t[1], f);
      if (!t[2]) return r;

      function n(t) {
        return e.point(t[0], t[1], f)
      }
      var i = t[2];
      return r.precomputed = {
        beta: null,
        doubles: i.doubles && {
          step: i.doubles.step,
          points: [r].concat(i.doubles.points.map(n))
        },
        naf: i.naf && {
          wnd: i.naf.wnd,
          points: [r].concat(i.naf.points.map(n))
        }
      }, r
    }, _.prototype.inspect = function() {
      return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + ">"
    }, _.prototype.isInfinity = function() {
      return this.inf
    }, _.prototype.add = function(e) {
      if (this.inf) return e;
      if (e.inf) return this;
      if (this.eq(e)) return this.dbl();
      if (this.neg().eq(e)) return this.curve.point(null, null);
      if (0 === this.x.cmp(e.x)) return this.curve.point(null, null);
      var t = this.y.redSub(e.y);
      0 !== t.cmpn(0) && (t = t.redMul(this.x.redSub(e.x).redInvm()));
      var f = t.redSqr().redISub(this.x).redISub(e.x),
        r = t.redMul(this.x.redSub(f)).redISub(this.y);
      return this.curve.point(f, r)
    }, _.prototype.dbl = function() {
      if (this.inf) return this;
      var e = this.y.redAdd(this.y);
      if (0 === e.cmpn(0)) return this.curve.point(null, null);
      var t = this.curve.a,
        f = this.x.redSqr(),
        r = e.redInvm(),
        n = f.redAdd(f).redIAdd(f).redIAdd(t).redMul(r),
        i = n.redSqr().redISub(this.x.redAdd(this.x)),
        d = n.redMul(this.x.redSub(i)).redISub(this.y);
      return this.curve.point(i, d)
    }, _.prototype.getX = function() {
      return this.x.fromRed()
    }, _.prototype.getY = function() {
      return this.y.fromRed()
    }, _.prototype.mul = function(e) {
      return e = new t.default(e, 16), this.isInfinity() ? this : this._hasDoubles(e) ? this.curve._fixedNafMul(this, e) : this.curve.endo ? this.curve._endoWnafMulAdd([this], [e]) : this.curve._wnafMul(this, e)
    }, _.prototype.mulAdd = function(e, t, f) {
      var r = [this, t],
        n = [e, f];
      return this.curve.endo ? this.curve._endoWnafMulAdd(r, n) : this.curve._wnafMulAdd(1, r, n, 2)
    }, _.prototype.jmulAdd = function(e, t, f) {
      var r = [this, t],
        n = [e, f];
      return this.curve.endo ? this.curve._endoWnafMulAdd(r, n, !0) : this.curve._wnafMulAdd(1, r, n, 2, !0)
    }, _.prototype.eq = function(e) {
      return this === e || this.inf === e.inf && (this.inf || 0 === this.x.cmp(e.x) && 0 === this.y.cmp(e.y))
    }, _.prototype.neg = function(e) {
      if (this.inf) return this;
      var t = this.curve.point(this.x, this.y.redNeg());
      if (e && this.precomputed) {
        var f = this.precomputed,
          r = function(e) {
            return e.neg()
          };
        t.precomputed = {
          naf: f.naf && {
            wnd: f.naf.wnd,
            points: f.naf.points.map(r)
          },
          doubles: f.doubles && {
            step: f.doubles.step,
            points: f.doubles.points.map(r)
          }
        }
      }
      return t
    }, _.prototype.toJ = function() {
      return this.inf ? this.curve.jpoint(null, null, null) : this.curve.jpoint(this.x, this.y, this.curve.one)
    }, S(M, g.BasePoint), I.prototype.jpoint = function(e, t, f) {
      return new M(this, e, t, f)
    }, M.prototype.toP = function() {
      if (this.isInfinity()) return this.curve.point(null, null);
      var e = this.z.redInvm(),
        t = e.redSqr(),
        f = this.x.redMul(t),
        r = this.y.redMul(t).redMul(e);
      return this.curve.point(f, r)
    }, M.prototype.neg = function() {
      return this.curve.jpoint(this.x, this.y.redNeg(), this.z)
    }, M.prototype.add = function(e) {
      if (this.isInfinity()) return e;
      if (e.isInfinity()) return this;
      var t = e.z.redSqr(),
        f = this.z.redSqr(),
        r = this.x.redMul(t),
        n = e.x.redMul(f),
        i = this.y.redMul(t.redMul(e.z)),
        d = e.y.redMul(f.redMul(this.z)),
        s = r.redSub(n),
        u = i.redSub(d);
      if (0 === s.cmpn(0)) return 0 !== u.cmpn(0) ? this.curve.jpoint(null, null, null) : this.dbl();
      var o = s.redSqr(),
        a = o.redMul(s),
        h = r.redMul(o),
        c = u.redSqr().redIAdd(a).redISub(h).redISub(h),
        p = u.redMul(h.redISub(c)).redISub(i.redMul(a)),
        l = this.z.redMul(e.z).redMul(s);
      return this.curve.jpoint(c, p, l)
    }, M.prototype.mixedAdd = function(e) {
      if (this.isInfinity()) return e.toJ();
      if (e.isInfinity()) return this;
      var t = this.z.redSqr(),
        f = this.x,
        r = e.x.redMul(t),
        n = this.y,
        i = e.y.redMul(t).redMul(this.z),
        d = f.redSub(r),
        s = n.redSub(i);
      if (0 === d.cmpn(0)) return 0 !== s.cmpn(0) ? this.curve.jpoint(null, null, null) : this.dbl();
      var u = d.redSqr(),
        o = u.redMul(d),
        a = f.redMul(u),
        h = s.redSqr().redIAdd(o).redISub(a).redISub(a),
        c = s.redMul(a.redISub(h)).redISub(n.redMul(o)),
        p = this.z.redMul(d);
      return this.curve.jpoint(h, c, p)
    }, M.prototype.dblp = function(e) {
      if (0 === e) return this;
      if (this.isInfinity()) return this;
      if (!e) return this.dbl();
      var t;
      if (this.curve.zeroA || this.curve.threeA) {
        var f = this;
        for (t = 0; t < e; t++) f = f.dbl();
        return f
      }
      var r = this.curve.a,
        n = this.curve.tinv,
        i = this.x,
        d = this.y,
        s = this.z,
        u = s.redSqr().redSqr(),
        o = d.redAdd(d);
      for (t = 0; t < e; t++) {
        var a = i.redSqr(),
          h = o.redSqr(),
          c = h.redSqr(),
          p = a.redAdd(a).redIAdd(a).redIAdd(r.redMul(u)),
          l = i.redMul(h),
          b = p.redSqr().redISub(l.redAdd(l)),
          v = l.redISub(b),
          y = p.redMul(v);
        y = y.redIAdd(y).redISub(c);
        var m = o.redMul(s);
        t + 1 < e && (u = u.redMul(c)), i = b, s = m, o = y
      }
      return this.curve.jpoint(i, o.redMul(n), s)
    }, M.prototype.dbl = function() {
      return this.isInfinity() ? this : this.curve.zeroA ? this._zeroDbl() : this.curve.threeA ? this._threeDbl() : this._dbl()
    }, M.prototype._zeroDbl = function() {
      var e, t, f;
      if (this.zOne) {
        var r = this.x.redSqr(),
          n = this.y.redSqr(),
          i = n.redSqr(),
          d = this.x.redAdd(n).redSqr().redISub(r).redISub(i);
        d = d.redIAdd(d);
        var s = r.redAdd(r).redIAdd(r),
          u = s.redSqr().redISub(d).redISub(d),
          o = i.redIAdd(i);
        o = (o = o.redIAdd(o)).redIAdd(o), e = u, t = s.redMul(d.redISub(u)).redISub(o), f = this.y.redAdd(this.y)
      } else {
        var a = this.x.redSqr(),
          h = this.y.redSqr(),
          c = h.redSqr(),
          p = this.x.redAdd(h).redSqr().redISub(a).redISub(c);
        p = p.redIAdd(p);
        var l = a.redAdd(a).redIAdd(a),
          b = l.redSqr(),
          v = c.redIAdd(c);
        v = (v = v.redIAdd(v)).redIAdd(v), e = b.redISub(p).redISub(p), t = l.redMul(p.redISub(e)).redISub(v), f = (f = this.y.redMul(this.z)).redIAdd(f)
      }
      return this.curve.jpoint(e, t, f)
    }, M.prototype._threeDbl = function() {
      var e, t, f;
      if (this.zOne) {
        var r = this.x.redSqr(),
          n = this.y.redSqr(),
          i = n.redSqr(),
          d = this.x.redAdd(n).redSqr().redISub(r).redISub(i);
        d = d.redIAdd(d);
        var s = r.redAdd(r).redIAdd(r).redIAdd(this.curve.a),
          u = s.redSqr().redISub(d).redISub(d);
        e = u;
        var o = i.redIAdd(i);
        o = (o = o.redIAdd(o)).redIAdd(o), t = s.redMul(d.redISub(u)).redISub(o), f = this.y.redAdd(this.y)
      } else {
        var a = this.z.redSqr(),
          h = this.y.redSqr(),
          c = this.x.redMul(h),
          p = this.x.redSub(a).redMul(this.x.redAdd(a));
        p = p.redAdd(p).redIAdd(p);
        var l = c.redIAdd(c),
          b = (l = l.redIAdd(l)).redAdd(l);
        e = p.redSqr().redISub(b), f = this.y.redAdd(this.z).redSqr().redISub(h).redISub(a);
        var v = h.redSqr();
        v = (v = (v = v.redIAdd(v)).redIAdd(v)).redIAdd(v), t = p.redMul(l.redISub(e)).redISub(v)
      }
      return this.curve.jpoint(e, t, f)
    }, M.prototype._dbl = function() {
      var e = this.curve.a,
        t = this.x,
        f = this.y,
        r = this.z,
        n = r.redSqr().redSqr(),
        i = t.redSqr(),
        d = f.redSqr(),
        s = i.redAdd(i).redIAdd(i).redIAdd(e.redMul(n)),
        u = t.redAdd(t),
        o = (u = u.redIAdd(u)).redMul(d),
        a = s.redSqr().redISub(o.redAdd(o)),
        h = o.redISub(a),
        c = d.redSqr();
      c = (c = (c = c.redIAdd(c)).redIAdd(c)).redIAdd(c);
      var p = s.redMul(h).redISub(c),
        l = f.redAdd(f).redMul(r);
      return this.curve.jpoint(a, p, l)
    }, M.prototype.trpl = function() {
      if (!this.curve.zeroA) return this.dbl().add(this);
      var e = this.x.redSqr(),
        t = this.y.redSqr(),
        f = this.z.redSqr(),
        r = t.redSqr(),
        n = e.redAdd(e).redIAdd(e),
        i = n.redSqr(),
        d = this.x.redAdd(t).redSqr().redISub(e).redISub(r),
        s = (d = (d = (d = d.redIAdd(d)).redAdd(d).redIAdd(d)).redISub(i)).redSqr(),
        u = r.redIAdd(r);
      u = (u = (u = u.redIAdd(u)).redIAdd(u)).redIAdd(u);
      var o = n.redIAdd(d).redSqr().redISub(i).redISub(s).redISub(u),
        a = t.redMul(o);
      a = (a = a.redIAdd(a)).redIAdd(a);
      var h = this.x.redMul(s).redISub(a);
      h = (h = h.redIAdd(h)).redIAdd(h);
      var c = this.y.redMul(o.redMul(u.redISub(o)).redISub(d.redMul(s)));
      c = (c = (c = c.redIAdd(c)).redIAdd(c)).redIAdd(c);
      var p = this.z.redAdd(d).redSqr().redISub(f).redISub(s);
      return this.curve.jpoint(h, c, p)
    }, M.prototype.mul = function(e, f) {
      return e = new t.default(e, f), this.curve._wnafMul(this, e)
    }, M.prototype.eq = function(e) {
      if ("affine" === e.type) return this.eq(e.toJ());
      if (this === e) return !0;
      var t = this.z.redSqr(),
        f = e.z.redSqr();
      if (0 !== this.x.redMul(f).redISub(e.x.redMul(t)).cmpn(0)) return !1;
      var r = t.redMul(this.z),
        n = f.redMul(e.z);
      return 0 === this.y.redMul(n).redISub(e.y.redMul(r)).cmpn(0)
    }, M.prototype.eqXToP = function(e) {
      var t = this.z.redSqr(),
        f = e.toRed(this.curve.red).redMul(t);
      if (0 === this.x.cmp(f)) return !0;
      for (var r = e.clone(), n = this.curve.redN.redMul(t);;) {
        if (r.iadd(this.curve.n), r.cmp(this.curve.p) >= 0) return !1;
        if (f.redIAdd(n), 0 === this.x.cmp(f)) return !0
      }
    }, M.prototype.inspect = function() {
      return this.isInfinity() ? "<EC JPoint Infinity>" : "<EC JPoint x: " + this.x.toString(16, 2) + " y: " + this.y.toString(16, 2) + " z: " + this.z.toString(16, 2) + ">"
    }, M.prototype.isInfinity = function() {
      return 0 === this.z.cmpn(0)
    };
    var q = d(function(e, t) {
        "use strict";
        var f = t;
        f.base = g, f.short = x, f.mont = null, f.edwards = null
      }),
      P = d(function(e, t) {
        "use strict";
        var r, n = t,
          i = l.assert;

        function d(e) {
          "short" === e.type ? this.curve = new q.short(e) : "edwards" === e.type ? this.curve = new q.edwards(e) : this.curve = new q.mont(e), this.g = this.curve.g, this.n = this.curve.n, this.hash = e.hash, i(this.g.validate(), "Invalid curve"), i(this.g.mul(this.n).isInfinity(), "Invalid curve, G*N != O")
        }

        function s(e, t) {
          Object.defineProperty(n, e, {
            configurable: !0,
            enumerable: !0,
            get: function() {
              var f = new d(t);
              return Object.defineProperty(n, e, {
                configurable: !0,
                enumerable: !0,
                value: f
              }), f
            }
          })
        }
        n.PresetCurve = d, s("p192", {
          type: "short",
          prime: "p192",
          p: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff",
          a: "ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc",
          b: "64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1",
          n: "ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831",
          hash: f.default.sha256,
          gRed: !1,
          g: ["188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012", "07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811"]
        }), s("p224", {
          type: "short",
          prime: "p224",
          p: "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001",
          a: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe",
          b: "b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4",
          n: "ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d",
          hash: f.default.sha256,
          gRed: !1,
          g: ["b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21", "bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34"]
        }), s("p256", {
          type: "short",
          prime: null,
          p: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff",
          a: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc",
          b: "5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b",
          n: "ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551",
          hash: f.default.sha256,
          gRed: !1,
          g: ["6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296", "4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5"]
        }), s("p384", {
          type: "short",
          prime: null,
          p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff",
          a: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc",
          b: "b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef",
          n: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973",
          hash: f.default.sha384,
          gRed: !1,
          g: ["aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7", "3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f"]
        }), s("p521", {
          type: "short",
          prime: null,
          p: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff",
          a: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc",
          b: "00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00",
          n: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409",
          hash: f.default.sha512,
          gRed: !1,
          g: ["000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66", "00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650"]
        }), s("curve25519", {
          type: "mont",
          prime: "p25519",
          p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
          a: "76d06",
          b: "1",
          n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
          hash: f.default.sha256,
          gRed: !1,
          g: ["9"]
        }), s("ed25519", {
          type: "edwards",
          prime: "p25519",
          p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
          a: "-1",
          c: "1",
          d: "52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3",
          n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
          hash: f.default.sha256,
          gRed: !1,
          g: ["216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a", "6666666666666666666666666666666666666666666666666666666666666658"]
        });
        try {
          r = null.crash()
        } catch (u) {
          r = void 0
        }
        s("secp256k1", {
          type: "short",
          prime: "k256",
          p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f",
          a: "0",
          b: "7",
          n: "ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141",
          h: "1",
          hash: f.default.sha256,
          beta: "7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee",
          lambda: "5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72",
          basis: [{
            a: "3086d221a7d46bcde86c90e49284eb15",
            b: "-e4437ed6010e88286f547fa90abfe4c3"
          }, {
            a: "114ca50f7a8e2f3f657c1108d9d44cfd8",
            b: "3086d221a7d46bcde86c90e49284eb15"
          }],
          gRed: !1,
          g: ["79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798", "483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8", r]
        })
      });

    function E(e) {
      if (!(this instanceof E)) return new E(e);
      this.hash = e.hash, this.predResist = !!e.predResist, this.outLen = this.hash.outSize, this.minEntropy = e.minEntropy || this.hash.hmacStrength, this._reseed = null, this.reseedInterval = null, this.K = null, this.V = null;
      var t = p.toArray(e.entropy, e.entropyEnc || "hex"),
        f = p.toArray(e.nonce, e.nonceEnc || "hex"),
        r = p.toArray(e.pers, e.persEnc || "hex");
      h(t.length >= this.minEntropy / 8, "Not enough entropy. Minimum is: " + this.minEntropy + " bits"), this._init(t, f, r)
    }
    var z = E;
    E.prototype._init = function(e, t, f) {
      var r = e.concat(t).concat(f);
      this.K = new Array(this.outLen / 8), this.V = new Array(this.outLen / 8);
      for (var n = 0; n < this.V.length; n++) this.K[n] = 0, this.V[n] = 1;
      this._update(r), this._reseed = 1, this.reseedInterval = 281474976710656
    }, E.prototype._hmac = function() {
      return new f.default.hmac(this.hash, this.K)
    }, E.prototype._update = function(e) {
      var t = this._hmac().update(this.V).update([0]);
      e && (t = t.update(e)), this.K = t.digest(), this.V = this._hmac().update(this.V).digest(), e && (this.K = this._hmac().update(this.V).update([1]).update(e).digest(), this.V = this._hmac().update(this.V).digest())
    }, E.prototype.reseed = function(e, t, f, r) {
      "string" != typeof t && (r = f, f = t, t = null), e = p.toArray(e, t), f = p.toArray(f, r), h(e.length >= this.minEntropy / 8, "Not enough entropy. Minimum is: " + this.minEntropy + " bits"), this._update(e.concat(f || [])), this._reseed = 1
    }, E.prototype.generate = function(e, t, f, r) {
      if (this._reseed > this.reseedInterval) throw new Error("Reseed is required");
      "string" != typeof t && (r = f, f = t, t = null), f && (f = p.toArray(f, r || "hex"), this._update(f));
      for (var n = []; n.length < e;) this.V = this._hmac().update(this.V).digest(), n = n.concat(this.V);
      var i = n.slice(0, e);
      return this._update(f), this._reseed++, p.encode(i, t)
    };
    var R = l.assert;

    function j(e, t) {
      this.ec = e, this.priv = null, this.pub = null, t.priv && this._importPrivate(t.priv, t.privEnc), t.pub && this._importPublic(t.pub, t.pubEnc)
    }
    var N = j;
    j.fromPublic = function(e, t, f) {
      return t instanceof j ? t : new j(e, {
        pub: t,
        pubEnc: f
      })
    }, j.fromPrivate = function(e, t, f) {
      return t instanceof j ? t : new j(e, {
        priv: t,
        privEnc: f
      })
    }, j.prototype.validate = function() {
      var e = this.getPublic();
      return e.isInfinity() ? {
        result: !1,
        reason: "Invalid public key"
      } : e.validate() ? e.mul(this.ec.curve.n).isInfinity() ? {
        result: !0,
        reason: null
      } : {
        result: !1,
        reason: "Public key * N != O"
      } : {
        result: !1,
        reason: "Public key is not a point"
      }
    }, j.prototype.getPublic = function(e, t) {
      return "string" == typeof e && (t = e, e = null), this.pub || (this.pub = this.ec.g.mul(this.priv)), t ? this.pub.encode(t, e) : this.pub
    }, j.prototype.getPrivate = function(e) {
      return "hex" === e ? this.priv.toString(16, 2) : this.priv
    }, j.prototype._importPrivate = function(e, f) {
      this.priv = new t.default(e, f || 16), this.priv = this.priv.umod(this.ec.curve.n)
    }, j.prototype._importPublic = function(e, t) {
      if (e.x || e.y) return "mont" === this.ec.curve.type ? R(e.x, "Need x coordinate") : "short" !== this.ec.curve.type && "edwards" !== this.ec.curve.type || R(e.x && e.y, "Need both x and y coordinate"), void(this.pub = this.ec.curve.point(e.x, e.y));
      this.pub = this.ec.curve.decodePoint(e, t)
    }, j.prototype.derive = function(e) {
      return e.validate() || R(e.validate(), "public point not validated"), e.mul(this.priv).getX()
    }, j.prototype.sign = function(e, t, f) {
      return this.ec.sign(e, this, t, f)
    }, j.prototype.verify = function(e, t) {
      return this.ec.verify(e, t, this)
    }, j.prototype.inspect = function() {
      return "<Key priv: " + (this.priv && this.priv.toString(16, 2)) + " pub: " + (this.pub && this.pub.inspect()) + " >"
    };
    var O = l.assert;

    function k(e, f) {
      if (e instanceof k) return e;
      this._importDER(e, f) || (O(e.r && e.s, "Signature without r or s"), this.r = new t.default(e.r, 16), this.s = new t.default(e.s, 16), void 0 === e.recoveryParam ? this.recoveryParam = null : this.recoveryParam = e.recoveryParam)
    }
    var T = k;

    function L() {
      this.place = 0
    }

    function F(e, t) {
      var f = e[t.place++];
      if (!(128 & f)) return f;
      var r = 15 & f;
      if (0 === r || r > 4) return !1;
      for (var n = 0, i = 0, d = t.place; i < r; i++, d++) n <<= 8, n |= e[d], n >>>= 0;
      return !(n <= 127) && (t.place = d, n)
    }

    function J(e) {
      for (var t = 0, f = e.length - 1; !e[t] && !(128 & e[t + 1]) && t < f;) t++;
      return 0 === t ? e : e.slice(t)
    }

    function D(e, t) {
      if (t < 128) e.push(t);
      else {
        var f = 1 + (Math.log(t) / Math.LN2 >>> 3);
        for (e.push(128 | f); --f;) e.push(t >>> (f << 3) & 255);
        e.push(t)
      }
    }
    k.prototype._importDER = function(e, f) {
      e = l.toArray(e, f);
      var r = new L;
      if (48 !== e[r.place++]) return !1;
      var n = F(e, r);
      if (!1 === n) return !1;
      if (n + r.place !== e.length) return !1;
      if (2 !== e[r.place++]) return !1;
      var i = F(e, r);
      if (!1 === i) return !1;
      var d = e.slice(r.place, i + r.place);
      if (r.place += i, 2 !== e[r.place++]) return !1;
      var s = F(e, r);
      if (!1 === s) return !1;
      if (e.length !== s + r.place) return !1;
      var u = e.slice(r.place, s + r.place);
      if (0 === d[0]) {
        if (!(128 & d[1])) return !1;
        d = d.slice(1)
      }
      if (0 === u[0]) {
        if (!(128 & u[1])) return !1;
        u = u.slice(1)
      }
      return this.r = new t.default(d), this.s = new t.default(u), this.recoveryParam = null, !0
    }, k.prototype.toDER = function(e) {
      var t = this.r.toArray(),
        f = this.s.toArray();
      for (128 & t[0] && (t = [0].concat(t)), 128 & f[0] && (f = [0].concat(f)), t = J(t), f = J(f); !(f[0] || 128 & f[1]);) f = f.slice(1);
      var r = [2];
      D(r, t.length), (r = r.concat(t)).push(2), D(r, f.length);
      var n = r.concat(f),
        i = [48];
      return D(i, n.length), i = i.concat(n), l.encode(i, e)
    };
    var V = function() {
        throw new Error("unsupported")
      },
      B = l.assert;

    function K(e) {
      if (!(this instanceof K)) return new K(e);
      "string" == typeof e && (B(Object.prototype.hasOwnProperty.call(P, e), "Unknown curve " + e), e = P[e]), e instanceof P.PresetCurve && (e = {
        curve: e
      }), this.curve = e.curve.curve, this.n = this.curve.n, this.nh = this.n.ushrn(1), this.g = this.curve.g, this.g = e.curve.g, this.g.precompute(e.curve.n.bitLength() + 1), this.hash = e.hash || e.curve.hash
    }
    var X = K;
    K.prototype.keyPair = function(e) {
      return new N(this, e)
    }, K.prototype.keyFromPrivate = function(e, t) {
      return N.fromPrivate(this, e, t)
    }, K.prototype.keyFromPublic = function(e, t) {
      return N.fromPublic(this, e, t)
    }, K.prototype.genKeyPair = function(e) {
      e || (e = {});
      for (var f = new z({
          hash: this.hash,
          pers: e.pers,
          persEnc: e.persEnc || "utf8",
          entropy: e.entropy || V(this.hash.hmacStrength),
          entropyEnc: e.entropy && e.entropyEnc || "utf8",
          nonce: this.n.toArray()
        }), r = this.n.byteLength(), n = this.n.sub(new t.default(2));;) {
        var i = new t.default(f.generate(r));
        if (!(i.cmp(n) > 0)) return i.iaddn(1), this.keyFromPrivate(i)
      }
    }, K.prototype._truncateToN = function(e, t) {
      var f = 8 * e.byteLength() - this.n.bitLength();
      return f > 0 && (e = e.ushrn(f)), !t && e.cmp(this.n) >= 0 ? e.sub(this.n) : e
    }, K.prototype.sign = function(e, f, r, n) {
      "object" == typeof r && (n = r, r = null), n || (n = {}), f = this.keyFromPrivate(f, r), e = this._truncateToN(new t.default(e, 16));
      for (var i = this.n.byteLength(), d = f.getPrivate().toArray("be", i), s = e.toArray("be", i), u = new z({
          hash: this.hash,
          entropy: d,
          nonce: s,
          pers: n.pers,
          persEnc: n.persEnc || "utf8"
        }), o = this.n.sub(new t.default(1)), a = 0;; a++) {
        var h = n.k ? n.k(a) : new t.default(u.generate(this.n.byteLength()));
        if (!((h = this._truncateToN(h, !0)).cmpn(1) <= 0 || h.cmp(o) >= 0)) {
          var c = this.g.mul(h);
          if (!c.isInfinity()) {
            var p = c.getX(),
              l = p.umod(this.n);
            if (0 !== l.cmpn(0)) {
              var b = h.invm(this.n).mul(l.mul(f.getPrivate()).iadd(e));
              if (0 !== (b = b.umod(this.n)).cmpn(0)) {
                var v = (c.getY().isOdd() ? 1 : 0) | (0 !== p.cmp(l) ? 2 : 0);
                return n.canonical && b.cmp(this.nh) > 0 && (b = this.n.sub(b), v ^= 1), new T({
                  r: l,
                  s: b,
                  recoveryParam: v
                })
              }
            }
          }
        }
      }
    }, K.prototype.verify = function(e, f, r, n) {
      e = this._truncateToN(new t.default(e, 16)), r = this.keyFromPublic(r, n);
      var i = (f = new T(f, "hex")).r,
        d = f.s;
      if (i.cmpn(1) < 0 || i.cmp(this.n) >= 0) return !1;
      if (d.cmpn(1) < 0 || d.cmp(this.n) >= 0) return !1;
      var s, u = d.invm(this.n),
        o = u.mul(e).umod(this.n),
        a = u.mul(i).umod(this.n);
      return this.curve._maxwellTrick ? !(s = this.g.jmulAdd(o, r.getPublic(), a)).isInfinity() && s.eqXToP(i) : !(s = this.g.mulAdd(o, r.getPublic(), a)).isInfinity() && 0 === s.getX().umod(this.n).cmp(i)
    }, K.prototype.recoverPubKey = function(e, f, r, n) {
      B((3 & r) === r, "The recovery param is more than two bits"), f = new T(f, n);
      var i = this.n,
        d = new t.default(e),
        s = f.r,
        u = f.s,
        o = 1 & r,
        a = r >> 1;
      if (s.cmp(this.curve.p.umod(this.curve.n)) >= 0 && a) throw new Error("Unable to find sencond key candinate");
      s = a ? this.curve.pointFromX(s.add(this.curve.n), o) : this.curve.pointFromX(s, o);
      var h = f.r.invm(i),
        c = i.sub(d).mul(h).umod(i),
        p = u.mul(h).umod(i);
      return this.g.mulAdd(c, s, p)
    }, K.prototype.getKeyRecoveryParam = function(e, t, f, r) {
      if (null !== (t = new T(t, r)).recoveryParam) return t.recoveryParam;
      for (var n = 0; n < 4; n++) {
        var i;
        try {
          i = this.recoverPubKey(e, t, n)
        } catch (e) {
          continue
        }
        if (i.eq(f)) return n
      }
      throw new Error("Unable to find valid recovery factor")
    };
    var C = d(function(e, t) {
        "use strict";
        var f = t;
        f.version = "6.5.4", f.utils = l, f.rand = function() {
          throw new Error("unsupported")
        }, f.curve = q, f.curves = P, f.ec = X, f.eddsa = null
      }),
      W = C.ec;
    exports.EC = W;
  }, {
    "bn.js": "AGD1",
    "hash.js": "fVGI"
  }],
  "iW44": [function(require, module, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    }), exports.version = void 0;
    const e = "signing-key/5.1.0";
    exports.version = e;
  }, {}],
  "KLKb": [function(require, module, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    }), exports.recoverPublicKey = c, exports.computePublicKey = u, exports.SigningKey = void 0;
    var e = require("./elliptic"),
      r = require("@ethersproject/bytes"),
      i = require("@ethersproject/properties"),
      t = require("@ethersproject/logger"),
      n = require("./_version");
    const o = new t.Logger(n.version);
    let y = null;

    function a() {
      return y || (y = new e.EC("secp256k1")), y
    }
    class s {
      constructor(e) {
        (0, i.defineReadOnly)(this, "curve", "secp256k1"), (0, i.defineReadOnly)(this, "privateKey", (0, r.hexlify)(e));
        const t = a().keyFromPrivate((0, r.arrayify)(this.privateKey));
        (0, i.defineReadOnly)(this, "publicKey", "0x" + t.getPublic(!1, "hex")), (0, i.defineReadOnly)(this, "compressedPublicKey", "0x" + t.getPublic(!0, "hex")), (0, i.defineReadOnly)(this, "_isSigningKey", !0)
      }
      _addPoint(e) {
        const i = a().keyFromPublic((0, r.arrayify)(this.publicKey)),
          t = a().keyFromPublic((0, r.arrayify)(e));
        return "0x" + i.pub.add(t.pub).encodeCompressed("hex")
      }
      signDigest(e) {
        const i = a().keyFromPrivate((0, r.arrayify)(this.privateKey)),
          t = (0, r.arrayify)(e);
        32 !== t.length && o.throwArgumentError("bad digest length", "digest", e);
        const n = i.sign(t, {
          canonical: !0
        });
        return (0, r.splitSignature)({
          recoveryParam: n.recoveryParam,
          r: (0, r.hexZeroPad)("0x" + n.r.toString(16), 32),
          s: (0, r.hexZeroPad)("0x" + n.s.toString(16), 32)
        })
      }
      computeSharedSecret(e) {
        const i = a().keyFromPrivate((0, r.arrayify)(this.privateKey)),
          t = a().keyFromPublic((0, r.arrayify)(u(e)));
        return (0, r.hexZeroPad)("0x" + i.derive(t.getPublic()).toString(16), 32)
      }
      static isSigningKey(e) {
        return !(!e || !e._isSigningKey)
      }
    }

    function c(e, i) {
      const t = (0, r.splitSignature)(i),
        n = {
          r: (0, r.arrayify)(t.r),
          s: (0, r.arrayify)(t.s)
        };
      return "0x" + a().recoverPubKey((0, r.arrayify)(e), n, t.recoveryParam).encode("hex", !1)
    }

    function u(e, i) {
      const t = (0, r.arrayify)(e);
      if (32 === t.length) {
        const e = new s(t);
        return i ? "0x" + a().keyFromPrivate(t).getPublic(!0, "hex") : e.publicKey
      }
      return 33 === t.length ? i ? (0, r.hexlify)(t) : "0x" + a().keyFromPublic(t).getPublic(!1, "hex") : 65 === t.length ? i ? "0x" + a().keyFromPublic(t).getPublic(!0, "hex") : (0, r.hexlify)(t) : o.throwArgumentError("invalid public or private key", "key", "[REDACTED]")
    }
    exports.SigningKey = s;
  }, {
    "./elliptic": "OF6o",
    "@ethersproject/bytes": "kHJk",
    "@ethersproject/properties": "miZX",
    "@ethersproject/logger": "M3zR",
    "./_version": "iW44"
  }],
  "eWFV": [function(require, module, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    }), exports.version = void 0;
    const e = "transactions/5.1.1";
    exports.version = e;
  }, {}],
  "LNEr": [function(require, module, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    }), exports.computeAddress = y, exports.recoverAddress = v, exports.accessListify = b, exports.serialize = k, exports.parse = j;
    var e = require("@ethersproject/address"),
      r = require("@ethersproject/bignumber"),
      t = require("@ethersproject/bytes"),
      n = require("@ethersproject/constants"),
      o = require("@ethersproject/keccak256"),
      a = require("@ethersproject/properties"),
      s = l(require("@ethersproject/rlp")),
      i = require("@ethersproject/signing-key"),
      c = require("@ethersproject/logger"),
      u = require("./_version");

    function h(e) {
      if ("function" != typeof WeakMap) return null;
      var r = new WeakMap,
        t = new WeakMap;
      return (h = function(e) {
        return e ? t : r
      })(e)
    }

    function l(e, r) {
      if (!r && e && e.__esModule) return e;
      if (null === e || "object" != typeof e && "function" != typeof e) return {
        default: e
      };
      var t = h(r);
      if (t && t.has(e)) return t.get(e);
      var n = {},
        o = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var a in e)
        if ("default" !== a && Object.prototype.hasOwnProperty.call(e, a)) {
          var s = o ? Object.getOwnPropertyDescriptor(e, a) : null;
          s && (s.get || s.set) ? Object.defineProperty(n, a, s) : n[a] = e[a]
        } return n.default = e, t && t.set(e, n), n
    }
    const p = new c.Logger(u.version);

    function d(r) {
      return "0x" === r ? null : (0, e.getAddress)(r)
    }

    function g(e) {
      return "0x" === e ? n.Zero : r.BigNumber.from(e)
    }
    const m = [{
        name: "nonce",
        maxLength: 32,
        numeric: !0
      }, {
        name: "gasPrice",
        maxLength: 32,
        numeric: !0
      }, {
        name: "gasLimit",
        maxLength: 32,
        numeric: !0
      }, {
        name: "to",
        length: 20
      }, {
        name: "value",
        maxLength: 32,
        numeric: !0
      }, {
        name: "data"
      }],
      f = {
        chainId: !0,
        data: !0,
        gasLimit: !0,
        gasPrice: !0,
        nonce: !0,
        to: !0,
        value: !0
      };

    function y(r) {
      const n = (0, i.computePublicKey)(r);
      return (0, e.getAddress)((0, t.hexDataSlice)((0, o.keccak256)((0, t.hexDataSlice)(n, 1)), 12))
    }

    function v(e, r) {
      return y((0, i.recoverPublicKey)((0, t.arrayify)(e), r))
    }

    function x(e, n) {
      const o = (0, t.stripZeros)(r.BigNumber.from(e).toHexString());
      return o.length > 32 && p.throwArgumentError("invalid length for " + n, "transaction:" + n, e), o
    }

    function P(r, n) {
      return {
        address: (0, e.getAddress)(r),
        storageKeys: (n || []).map((e, n) => (32 !== (0, t.hexDataLength)(e) && p.throwArgumentError("invalid access list storageKey", `accessList[${r}:${n}]`, e), e.toLowerCase()))
      }
    }

    function b(e) {
      if (Array.isArray(e)) return e.map((e, r) => Array.isArray(e) ? (e.length > 2 && p.throwArgumentError("access list expected to be [ address, storageKeys[] ]", `value[${r}]`, e), P(e[0], e[1])) : P(e.address, e.storageKeys));
      const r = Object.keys(e).map(r => {
        const t = e[r].reduce((e, r) => (e[r] = !0, e), {});
        return P(r, Object.keys(t).sort())
      });
      return r.sort((e, r) => e.address.localeCompare(r.address)), r
    }

    function w(e) {
      return b(e).map(e => [e.address, e.storageKeys])
    }

    function A(r, n) {
      const o = [x(r.chainId || 0, "chainId"), x(r.nonce || 0, "nonce"), x(r.gasPrice || 0, "gasPrice"), x(r.gasLimit || 0, "gasLimit"), null != r.to ? (0, e.getAddress)(r.to) : "0x", x(r.value || 0, "value"), r.data || "0x", w(r.accessList || [])];
      if (n) {
        const e = (0, t.splitSignature)(n);
        o.push(x(e.recoveryParam, "recoveryParam")), o.push((0, t.stripZeros)(e.r)), o.push((0, t.stripZeros)(e.s))
      }
      return (0, t.hexConcat)(["0x01", s.encode(o)])
    }

    function L(e, r) {
      (0, a.checkProperties)(e, f);
      const n = [];
      m.forEach(function(r) {
        let o = e[r.name] || [];
        const a = {};
        r.numeric && (a.hexPad = "left"), o = (0, t.arrayify)((0, t.hexlify)(o, a)), r.length && o.length !== r.length && o.length > 0 && p.throwArgumentError("invalid length for " + r.name, "transaction:" + r.name, o), r.maxLength && (o = (0, t.stripZeros)(o)).length > r.maxLength && p.throwArgumentError("invalid length for " + r.name, "transaction:" + r.name, o), n.push((0, t.hexlify)(o))
      });
      let o = 0;
      if (null != e.chainId ? "number" != typeof(o = e.chainId) && p.throwArgumentError("invalid transaction.chainId", "transaction", e) : r && !(0, t.isBytesLike)(r) && r.v > 28 && (o = Math.floor((r.v - 35) / 2)), 0 !== o && (n.push((0, t.hexlify)(o)), n.push("0x"), n.push("0x")), !r) return s.encode(n);
      const i = (0, t.splitSignature)(r);
      let c = 27 + i.recoveryParam;
      return 0 !== o ? (n.pop(), n.pop(), n.pop(), c += 2 * o + 8, i.v > 28 && i.v !== c && p.throwArgumentError("transaction.chainId/signature.v mismatch", "signature", r)) : i.v !== c && p.throwArgumentError("transaction.chainId/signature.v mismatch", "signature", r), n.push((0, t.hexlify)(c)), n.push((0, t.stripZeros)((0, t.arrayify)(i.r))), n.push((0, t.stripZeros)((0, t.arrayify)(i.s))), s.encode(n)
    }

    function k(e, r) {
      if (null == e.type) return null != e.accessList && p.throwArgumentError("untyped transactions do not support accessList; include type: 1", "transaction", e), L(e, r);
      switch (e.type) {
        case 1:
          return A(e, r)
      }
      return p.throwError(`unsupported transaction type: ${e.type}`, c.Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "serializeTransaction",
        transactionType: e.type
      })
    }

    function E(e) {
      const r = s.decode(e.slice(1));
      8 !== r.length && 11 !== r.length && p.throwArgumentError("invalid component count for transaction type: 1", "payload", (0, t.hexlify)(e));
      const n = {
        type: 1,
        chainId: g(r[0]).toNumber(),
        nonce: g(r[1]).toNumber(),
        gasPrice: g(r[2]),
        gasLimit: g(r[3]),
        to: d(r[4]),
        value: g(r[5]),
        data: r[6],
        accessList: b(r[7])
      };
      if (8 === r.length) return n;
      try {
        const e = g(r[8]).toNumber();
        if (0 !== e && 1 !== e) throw new Error("bad recid");
        n.v = e
      } catch (a) {
        p.throwArgumentError("invalid v for transaction type: 1", "v", r[8])
      }
      n.r = (0, t.hexZeroPad)(r[9], 32), n.s = (0, t.hexZeroPad)(r[10], 32);
      try {
        const e = (0, o.keccak256)(A(n));
        n.from = v(e, {
          r: n.r,
          s: n.s,
          recoveryParam: n.v
        })
      } catch (a) {
        console.log(a)
      }
      return n.hash = (0, o.keccak256)(e), n
    }

    function I(e) {
      const n = s.decode(e);
      9 !== n.length && 6 !== n.length && p.throwArgumentError("invalid raw transaction", "rawTransaction", e);
      const a = {
        nonce: g(n[0]).toNumber(),
        gasPrice: g(n[1]),
        gasLimit: g(n[2]),
        to: d(n[3]),
        value: g(n[4]),
        data: n[5],
        chainId: 0
      };
      if (6 === n.length) return a;
      try {
        a.v = r.BigNumber.from(n[6]).toNumber()
      } catch (i) {
        return console.log(i), a
      }
      if (a.r = (0, t.hexZeroPad)(n[7], 32), a.s = (0, t.hexZeroPad)(n[8], 32), r.BigNumber.from(a.r).isZero() && r.BigNumber.from(a.s).isZero()) a.chainId = a.v, a.v = 0;
      else {
        a.chainId = Math.floor((a.v - 35) / 2), a.chainId < 0 && (a.chainId = 0);
        let r = a.v - 27;
        const c = n.slice(0, 6);
        0 !== a.chainId && (c.push((0, t.hexlify)(a.chainId)), c.push("0x"), c.push("0x"), r -= 2 * a.chainId + 8);
        const u = (0, o.keccak256)(s.encode(c));
        try {
          a.from = v(u, {
            r: (0, t.hexlify)(a.r),
            s: (0, t.hexlify)(a.s),
            recoveryParam: r
          })
        } catch (i) {
          console.log(i)
        }
        a.hash = (0, o.keccak256)(e)
      }
      return a.type = null, a
    }

    function j(e) {
      const r = (0, t.arrayify)(e);
      if (r[0] > 127) return I(r);
      switch (r[0]) {
        case 1:
          return E(r)
      }
      return p.throwError(`unsupported transaction type: ${r[0]}`, c.Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "parseTransaction",
        transactionType: r[0]
      })
    }
  }, {
    "@ethersproject/address": "v33u",
    "@ethersproject/bignumber": "BWdp",
    "@ethersproject/bytes": "kHJk",
    "@ethersproject/constants": "inUu",
    "@ethersproject/keccak256": "Ko0x",
    "@ethersproject/properties": "miZX",
    "@ethersproject/rlp": "Rh5m",
    "@ethersproject/signing-key": "KLKb",
    "@ethersproject/logger": "M3zR",
    "./_version": "eWFV"
  }],
  "pw7F": [function(require, module, exports) {
    "use strict";

    function t(t, e, r, a, n, o, i) {
      try {
        var s = t[o](i),
          c = s.value
      } catch (u) {
        return void r(u)
      }
      s.done ? e(c) : Promise.resolve(c).then(a, n)
    }

    function e(e) {
      return function() {
        var r = this,
          a = arguments;
        return new Promise(function(n, o) {
          var i = e.apply(r, a);

          function s(e) {
            t(i, n, o, s, c, "next", e)
          }

          function c(e) {
            t(i, n, o, s, c, "throw", e)
          }
          s(void 0)
        })
      }
    }
    var r = require("underscore"),
      a = require("web3-core-helpers").errors,
      n = require("web3-core-helpers").formatters,
      o = require("web3-utils"),
      i = require("web3-core-promievent"),
      s = require("web3-core-subscriptions").subscriptions,
      c = require("@ethersproject/transactions"),
      u = function(t) {
        if (!t.call || !t.name) throw new Error('When creating a method you need to provide at least the "name" and "call" property.');
        this.name = t.name, this.call = t.call, this.params = t.params || 0, this.inputFormatter = t.inputFormatter, this.outputFormatter = t.outputFormatter, this.transformPayload = t.transformPayload, this.extraFormatters = t.extraFormatters, this.abiCoder = t.abiCoder, this.requestManager = t.requestManager, this.accounts = t.accounts, this.defaultBlock = t.defaultBlock || "latest", this.defaultAccount = t.defaultAccount || null, this.transactionBlockTimeout = t.transactionBlockTimeout || 50, this.transactionConfirmationBlocks = t.transactionConfirmationBlocks || 24, this.transactionPollingTimeout = t.transactionPollingTimeout || 750, this.defaultCommon = t.defaultCommon, this.defaultChain = t.defaultChain, this.defaultHardfork = t.defaultHardfork, this.handleRevert = t.handleRevert
      };
    u.prototype.setRequestManager = function(t, e) {
      this.requestManager = t, e && (this.accounts = e)
    }, u.prototype.createFunction = function(t, e) {
      var r = this.buildCall();
      return r.call = this.call, this.setRequestManager(t || this.requestManager, e || this.accounts), r
    }, u.prototype.attachToObject = function(t) {
      var e = this.buildCall();
      e.call = this.call;
      var r = this.name.split(".");
      r.length > 1 ? (t[r[0]] = t[r[0]] || {}, t[r[0]][r[1]] = e) : t[r[0]] = e
    }, u.prototype.getCall = function(t) {
      return r.isFunction(this.call) ? this.call(t) : this.call
    }, u.prototype.extractCallback = function(t) {
      if (r.isFunction(t[t.length - 1])) return t.pop()
    }, u.prototype.validateArgs = function(t) {
      if (t.length !== this.params) throw a.InvalidNumberOfParams(t.length, this.params, this.name)
    }, u.prototype.formatInput = function(t) {
      var e = this;
      return this.inputFormatter ? this.inputFormatter.map(function(r, a) {
        return r ? r.call(e, t[a]) : t[a]
      }) : t
    }, u.prototype.formatOutput = function(t) {
      var e = this;
      return r.isArray(t) ? t.map(function(t) {
        return e.outputFormatter && t ? e.outputFormatter(t) : t
      }) : this.outputFormatter && t ? this.outputFormatter(t) : t
    }, u.prototype.toPayload = function(t) {
      var e = this.getCall(t),
        r = this.extractCallback(t),
        a = this.formatInput(t);
      this.validateArgs(a);
      var n = {
        method: e,
        params: a,
        callback: r
      };
      return this.transformPayload && (n = this.transformPayload(n)), n
    }, u.prototype._confirmTransaction = function(t, l, m) {
      var p = this,
        h = !1,
        f = !0,
        d = 0,
        v = 0,
        b = null,
        g = null,
        k = r.isObject(m.params[0]) && m.params[0].gas ? m.params[0].gas : null,
        y = r.isObject(m.params[0]) && m.params[0].data && m.params[0].from && !m.params[0].to,
        E = y && m.params[0].data.length > 2,
        w = [new u({
          name: "getBlockByNumber",
          call: "eth_getBlockByNumber",
          params: 2,
          inputFormatter: [n.inputBlockNumberFormatter, function(t) {
            return !!t
          }],
          outputFormatter: n.outputBlockFormatter
        }), new u({
          name: "getTransactionReceipt",
          call: "eth_getTransactionReceipt",
          params: 1,
          inputFormatter: [null],
          outputFormatter: n.outputTransactionReceiptFormatter
        }), new u({
          name: "getCode",
          call: "eth_getCode",
          params: 2,
          inputFormatter: [n.inputAddressFormatter, n.inputDefaultBlockNumberFormatter]
        }), new u({
          name: "getTransactionByHash",
          call: "eth_getTransactionByHash",
          params: 1,
          inputFormatter: [null],
          outputFormatter: n.outputTransactionFormatter
        }), new s({
          name: "subscribe",
          type: "eth",
          subscriptions: {
            newBlockHeaders: {
              subscriptionName: "newHeads",
              params: 0,
              outputFormatter: n.outputBlockFormatter
            }
          }
        })],
        x = {};
      r.each(w, function(t) {
        t.attachToObject(x), t.requestManager = p.requestManager
      });
      var F = function(r, s, u, w, F) {
          if (!u) return F || (F = {
            unsubscribe: function() {
              clearInterval(b)
            }
          }), (r ? i.resolve(r) : x.getTransactionReceipt(l)).catch(function(e) {
            F.unsubscribe(), h = !0, o._fireError({
              message: "Failed to check for transaction receipt:",
              data: e
            }, t.eventEmitter, t.reject)
          }).then(function() {
            var a = e(regeneratorRuntime.mark(function e(a) {
              var n, o, i;
              return regeneratorRuntime.wrap(function(e) {
                for (;;) switch (e.prev = e.next) {
                  case 0:
                    if (a && a.blockHash) {
                      e.next = 2;
                      break
                    }
                    throw new Error("Receipt missing or blockHash null");
                  case 2:
                    if (p.extraFormatters && p.extraFormatters.receiptFormatter && (a = p.extraFormatters.receiptFormatter(a)), !(t.eventEmitter.listeners("confirmation").length > 0)) {
                      e.next = 28;
                      break
                    }
                    if (void 0 !== r && 0 === v) {
                      e.next = 25;
                      break
                    }
                    return e.next = 7, x.getBlockByNumber("latest");
                  case 7:
                    if (o = e.sent, i = o ? o.hash : null, !s) {
                      e.next = 24;
                      break
                    }
                    if (!g) {
                      e.next = 17;
                      break
                    }
                    return e.next = 13, x.getBlockByNumber(g.number + 1);
                  case 13:
                    (n = e.sent) && (g = n, t.eventEmitter.emit("confirmation", v, a, i)), e.next = 22;
                    break;
                  case 17:
                    return e.next = 19, x.getBlockByNumber(a.blockNumber);
                  case 19:
                    n = e.sent, g = n, t.eventEmitter.emit("confirmation", v, a, i);
                  case 22:
                    e.next = 25;
                    break;
                  case 24:
                    t.eventEmitter.emit("confirmation", v, a, i);
                  case 25:
                    (s && n || !s) && v++, f = !1, v === p.transactionConfirmationBlocks + 1 && (F.unsubscribe(), t.eventEmitter.removeAllListeners());
                  case 28:
                    return e.abrupt("return", a);
                  case 29:
                  case "end":
                    return e.stop()
                }
              }, e)
            }));
            return function(t) {
              return a.apply(this, arguments)
            }
          }()).then(function() {
            var r = e(regeneratorRuntime.mark(function e(r) {
              var n;
              return regeneratorRuntime.wrap(function(e) {
                for (;;) switch (e.prev = e.next) {
                  case 0:
                    if (!y || h) {
                      e.next = 19;
                      break
                    }
                    if (r.contractAddress) {
                      e.next = 5;
                      break
                    }
                    return f && (F.unsubscribe(), h = !0), o._fireError(a.NoContractAddressFoundError(r), t.eventEmitter, t.reject, null, r), e.abrupt("return");
                  case 5:
                    return e.prev = 5, e.next = 8, x.getCode(r.contractAddress);
                  case 8:
                    n = e.sent, e.next = 13;
                    break;
                  case 11:
                    e.prev = 11, e.t0 = e.catch(5);
                  case 13:
                    if (n) {
                      e.next = 15;
                      break
                    }
                    return e.abrupt("return");
                  case 15:
                    !0 === r.status && E || n.length > 2 ? (t.eventEmitter.emit("receipt", r), p.extraFormatters && p.extraFormatters.contractDeployFormatter ? t.resolve(p.extraFormatters.contractDeployFormatter(r)) : t.resolve(r), f && t.eventEmitter.removeAllListeners()) : o._fireError(a.ContractCodeNotStoredError(r), t.eventEmitter, t.reject, null, r), f && F.unsubscribe(), h = !0;
                  case 19:
                    return e.abrupt("return", r);
                  case 20:
                  case "end":
                    return e.stop()
                }
              }, e, null, [
                [5, 11]
              ])
            }));
            return function(t) {
              return r.apply(this, arguments)
            }
          }()).then(function() {
            var r = e(regeneratorRuntime.mark(function e(r) {
              var i, s, u, l;
              return regeneratorRuntime.wrap(function(e) {
                for (;;) switch (e.prev = e.next) {
                  case 0:
                    if (y || h) {
                      e.next = 35;
                      break
                    }
                    if (r.outOfGas || k && k === r.gasUsed || !0 !== r.status && "0x1" !== r.status && void 0 !== r.status) {
                      e.next = 7;
                      break
                    }
                    t.eventEmitter.emit("receipt", r), t.resolve(r), f && t.eventEmitter.removeAllListeners(), e.next = 33;
                    break;
                  case 7:
                    if (JSON.stringify(r, null, 2), !1 !== r.status && "0x0" !== r.status) {
                      e.next = 32;
                      break
                    }
                    if (e.prev = 9, i = null, !p.handleRevert || "eth_sendTransaction" !== p.call && "eth_sendRawTransaction" !== p.call) {
                      e.next = 24;
                      break
                    }
                    return s = m.params[0], "eth_sendRawTransaction" === p.call && (u = m.params[0], l = c.parse(u), s = n.inputTransactionFormatter({
                      data: l.data,
                      to: l.to,
                      from: l.from,
                      gas: l.gasLimit.toHexString(),
                      gasPrice: l.gasPrice.toHexString(),
                      value: l.value.toHexString()
                    })), e.next = 16, p.getRevertReason(s, r.blockNumber);
                  case 16:
                    if (!(i = e.sent)) {
                      e.next = 21;
                      break
                    }
                    o._fireError(a.TransactionRevertInstructionError(i.reason, i.signature, r), t.eventEmitter, t.reject, null, r), e.next = 22;
                    break;
                  case 21:
                    throw !1;
                  case 22:
                    e.next = 25;
                    break;
                  case 24:
                    throw !1;
                  case 25:
                    e.next = 30;
                    break;
                  case 27:
                    e.prev = 27, e.t0 = e.catch(9), o._fireError(a.TransactionRevertedWithoutReasonError(r), t.eventEmitter, t.reject, null, r);
                  case 30:
                    e.next = 33;
                    break;
                  case 32:
                    o._fireError(a.TransactionOutOfGasError(r), t.eventEmitter, t.reject, null, r);
                  case 33:
                    f && F.unsubscribe(), h = !0;
                  case 35:
                  case "end":
                    return e.stop()
                }
              }, e, null, [
                [9, 27]
              ])
            }));
            return function(t) {
              return r.apply(this, arguments)
            }
          }()).catch(function() {
            d++, s ? d - 1 >= p.transactionPollingTimeout && (F.unsubscribe(), h = !0, o._fireError(a.TransactionError("Transaction was not mined within " + p.transactionPollingTimeout + " seconds, please make sure your transaction was properly sent. Be aware that it might still be mined!"), t.eventEmitter, t.reject)) : d - 1 >= p.transactionBlockTimeout && (F.unsubscribe(), h = !0, o._fireError(a.TransactionError("Transaction was not mined within " + p.transactionBlockTimeout + " blocks, please make sure your transaction was properly sent. Be aware that it might still be mined!"), t.eventEmitter, t.reject))
          });
          F.unsubscribe(), h = !0, o._fireError({
            message: "Failed to subscribe to new newBlockHeaders to confirm the transaction receipts.",
            data: u
          }, t.eventEmitter, t.reject)
        },
        T = function(t) {
          var e = function() {
            b = setInterval(F.bind(null, t, !0), 1e3)
          };
          this.requestManager.provider.on ? x.subscribe("newBlockHeaders", function(r, a, n) {
            r || !a ? e() : F(t, !1, r, 0, n)
          }) : e()
        }.bind(this);
      x.getTransactionReceipt(l).then(function(e) {
        e && e.blockHash ? (t.eventEmitter.listeners("confirmation").length > 0 && T(e), F(e, !1)) : h || T()
      }).catch(function() {
        h || T()
      })
    };
    var l = function(t, e) {
      return r.isNumber(t) ? e.wallet[t] : r.isObject(t) && t.address && t.privateKey ? t : e.wallet[t.toLowerCase()]
    };
    u.prototype.buildCall = function() {
      var t = this,
        e = "eth_sendTransaction" === t.call || "eth_sendRawTransaction" === t.call,
        n = "eth_call" === t.call,
        s = function() {
          var s = i(!e),
            c = t.toPayload(Array.prototype.slice.call(arguments)),
            m = function(r, i) {
              var u;
              if (t.handleRevert && n && t.abiCoder && (!r && t.isRevertReasonString(i) ? u = i.substring(10) : r && r.data && (u = r.data.substring(10)), u)) {
                var l = t.abiCoder.decodeParameter("string", "0x" + u);
                return void o._fireError(a.RevertInstructionError(l, "Error(String)"), s.eventEmitter, s.reject, c.callback, {
                  reason: l,
                  signature: "Error(String)"
                })
              }
              try {
                i = t.formatOutput(i)
              } catch (m) {
                r = m
              }
              if (i instanceof Error && (r = i), r) return r.error && (r = r.error), o._fireError(r, s.eventEmitter, s.reject, c.callback);
              c.callback && c.callback(null, i), e ? (s.eventEmitter.emit("transactionHash", i), t._confirmTransaction(s, i, c)) : r || s.resolve(i)
            },
            p = function(e) {
              var a = r.extend({}, c, {
                method: "eth_sendRawTransaction",
                params: [e.rawTransaction]
              });
              t.requestManager.send(a, m)
            },
            h = function(t, e) {
              var a;
              if (e && e.accounts && e.accounts.wallet && e.accounts.wallet.length)
                if ("eth_sendTransaction" === t.method) {
                  var n = t.params[0];
                  if ((a = l(r.isObject(n) ? n.from : null, e.accounts)) && a.privateKey) {
                    var o = r.omit(n, "from");
                    return e.defaultChain && !o.chain && (o.chain = e.defaultChain), e.defaultHardfork && !o.hardfork && (o.hardfork = e.defaultHardfork), e.defaultCommon && !o.common && (o.common = e.defaultCommon), void e.accounts.signTransaction(o, a.privateKey).then(p).catch(function(t) {
                      if (r.isFunction(s.eventEmitter.listeners) && s.eventEmitter.listeners("error").length) {
                        try {
                          s.eventEmitter.emit("error", t)
                        } catch (t) {}
                        s.eventEmitter.removeAllListeners(), s.eventEmitter.catch(function() {})
                      }
                      s.reject(t)
                    })
                  }
                } else if ("eth_sign" === t.method) {
                var i = t.params[1];
                if ((a = l(t.params[0], e.accounts)) && a.privateKey) {
                  var c = e.accounts.sign(i, a.privateKey);
                  return t.callback && t.callback(null, c.signature), void s.resolve(c.signature)
                }
              }
              return e.requestManager.send(t, m)
            };
          e && r.isObject(c.params[0]) && void 0 === c.params[0].gasPrice ? new u({
            name: "getGasPrice",
            call: "eth_gasPrice",
            params: 0
          }).createFunction(t.requestManager)(function(r, a) {
            a && (c.params[0].gasPrice = a), e && setTimeout(function() {
              s.eventEmitter.emit("sending", c)
            }, 0), h(c, t)
          }) : (e && setTimeout(function() {
            s.eventEmitter.emit("sending", c)
          }, 0), h(c, t));
          return e && setTimeout(function() {
            s.eventEmitter.emit("sent", c)
          }, 0), s.eventEmitter
        };
      return s.method = t, s.request = this.request.bind(this), s
    }, u.prototype.getRevertReason = function(t, e) {
      var r = this;
      return new Promise(function(a, n) {
        new u({
          name: "call",
          call: "eth_call",
          params: 2,
          abiCoder: r.abiCoder,
          handleRevert: !0
        }).createFunction(r.requestManager)(t, o.numberToHex(e)).then(function() {
          a(!1)
        }).catch(function(t) {
          t.reason ? a({
            reason: t.reason,
            signature: t.signature
          }) : n(t)
        })
      })
    }, u.prototype.isRevertReasonString = function(t) {
      return r.isString(t) && (t.length - 2) / 2 % 32 == 4 && "0x08c379a0" === t.substring(0, 10)
    }, u.prototype.request = function() {
      var t = this.toPayload(Array.prototype.slice.call(arguments));
      return t.format = this.formatOutput.bind(this), t
    }, module.exports = u;
  }, {
    "underscore": "h15N",
    "web3-core-helpers": "EoeS",
    "web3-utils": "uckD",
    "web3-core-promievent": "J2II",
    "web3-core-subscriptions": "Sn3u",
    "@ethersproject/transactions": "LNEr"
  }],
  "vRVW": [function(require, module, exports) {
    "use strict";
    var e = require("web3-core-helpers").formatters,
      r = require("web3-core-method"),
      t = require("web3-utils"),
      o = function(o) {
        var s = function(e) {
          var t;
          return e.property ? (o[e.property] || (o[e.property] = {}), t = o[e.property]) : t = o, e.methods && e.methods.forEach(function(e) {
            e instanceof r || (e = new r(e)), e.attachToObject(t), e.setRequestManager(o._requestManager)
          }), o
        };
        return s.formatters = e, s.utils = t, s.Method = r, s
      };
    module.exports = o;
  }, {
    "web3-core-helpers": "EoeS",
    "web3-core-method": "pw7F",
    "web3-utils": "uckD"
  }],
  "KUai": [function(require, module, exports) {
    var e = require("web3-core-requestmanager"),
      r = require("./extend"),
      n = function(n, a) {
        if (a = Array.prototype.slice.call(a), !n) throw new Error('You need to instantiate using the "new" keyword.');
        Object.defineProperty(n, "currentProvider", {
          get: function() {
            return n._provider
          },
          set: function(e) {
            return n.setProvider(e)
          },
          enumerable: !0,
          configurable: !0
        }), a[0] && a[0]._requestManager ? n._requestManager = a[0]._requestManager : n._requestManager = new e.Manager(a[0], a[1]), n.givenProvider = e.Manager.givenProvider, n.providers = e.Manager.providers, n._provider = n._requestManager.provider, n.setProvider || (n.setProvider = function(e, r) {
          return n._requestManager.setProvider(e, r), n._provider = n._requestManager.provider, !0
        }), n.setRequestManager = function(e) {
          n._requestManager = e, n._provider = e.provider
        }, n.BatchRequest = e.BatchManager.bind(null, n._requestManager), n.extend = r(n)
      },
      a = function(r) {
        r.givenProvider = e.Manager.givenProvider, r.providers = e.Manager.providers
      };
    module.exports = {
      packageInit: n,
      addProviders: a
    };
  }, {
    "web3-core-requestmanager": "cnad",
    "./extend": "vRVW"
  }],
  "SwGM": [function(require, module, exports) {
    "use strict";
    var e = require("web3-core"),
      t = require("web3-core-method"),
      r = require("web3-utils"),
      a = function() {
        var a = this;
        e.packageInit(this, arguments), [new t({
          name: "getId",
          call: "net_version",
          params: 0,
          outputFormatter: parseInt
        }), new t({
          name: "isListening",
          call: "net_listening",
          params: 0
        }), new t({
          name: "getPeerCount",
          call: "net_peerCount",
          params: 0,
          outputFormatter: r.hexToNumber
        })].forEach(function(e) {
          e.attachToObject(a), e.setRequestManager(a._requestManager)
        })
      };
    e.addProviders(a), module.exports = a;
  }, {
    "web3-core": "KUai",
    "web3-core-method": "pw7F",
    "web3-utils": "uckD"
  }],
  "jgOf": [function(require, module, exports) {
    "use strict";
    var e = {
      addresses: {
        main: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
        ropsten: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
        rinkeby: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
        goerli: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e"
      },
      interfaceIds: {
        addr: "0x3b3b57de",
        setAddr: "0x3b3b57de",
        pubkey: "0xc8690233",
        setPubkey: "0xc8690233",
        contenthash: "0xbc1c58d1",
        setContenthash: "0xbc1c58d1",
        content: "0xd8389dc5",
        setContent: "0xd8389dc5"
      }
    };
    module.exports = e;
  }, {}],
  "Vg5D": [function(require, module, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    }), exports.version = void 0;
    const e = "abi/5.0.7";
    exports.version = e;
  }, {}],
  "DSjm": [function(require, module, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    }), exports.FunctionFragment = exports.ConstructorFragment = exports.EventFragment = exports.Fragment = exports.ParamType = exports.FormatTypes = void 0;
    var t = require("@ethersproject/bignumber"),
      e = require("@ethersproject/properties"),
      a = require("@ethersproject/logger"),
      r = require("./_version");
    const n = new a.Logger(r.version),
      s = {};
    let i = {
        calldata: !0,
        memory: !0,
        storage: !0
      },
      o = {
        calldata: !0,
        memory: !0
      };

    function l(t, e) {
      if ("bytes" === t || "string" === t) {
        if (i[e]) return !0
      } else if ("address" === t) {
        if ("payable" === e) return !0
      } else if ((t.indexOf("[") >= 0 || "tuple" === t) && o[e]) return !0;
      return (i[e] || "payable" === e) && n.throwArgumentError("invalid modifier", "name", e), !1
    }

    function u(t, e) {
      let a = t;

      function r(e) {
        n.throwArgumentError(`unexpected character at position ${e}`, "param", t)
      }

      function s(t) {
        let a = {
          type: "",
          name: "",
          parent: t,
          state: {
            allowType: !0
          }
        };
        return e && (a.indexed = !1), a
      }
      t = t.replace(/\s/g, " ");
      let i = {
          type: "",
          name: "",
          state: {
            allowType: !0
          }
        },
        o = i;
      for (let n = 0; n < t.length; n++) {
        let a = t[n];
        switch (a) {
          case "(":
            o.state.allowType && "" === o.type ? o.type = "tuple" : o.state.allowParams || r(n), o.state.allowType = !1, o.type = j(o.type), o.components = [s(o)], o = o.components[0];
            break;
          case ")":
            delete o.state, "indexed" === o.name && (e || r(n), o.indexed = !0, o.name = ""), l(o.type, o.name) && (o.name = ""), o.type = j(o.type);
            let t = o;
            (o = o.parent) || r(n), delete t.parent, o.state.allowParams = !1, o.state.allowName = !0, o.state.allowArray = !0;
            break;
          case ",":
            delete o.state, "indexed" === o.name && (e || r(n), o.indexed = !0, o.name = ""), l(o.type, o.name) && (o.name = ""), o.type = j(o.type);
            let i = s(o.parent);
            o.parent.components.push(i), delete o.parent, o = i;
            break;
          case " ":
            o.state.allowType && "" !== o.type && (o.type = j(o.type), delete o.state.allowType, o.state.allowName = !0, o.state.allowParams = !0), o.state.allowName && "" !== o.name && ("indexed" === o.name ? (e || r(n), o.indexed && r(n), o.indexed = !0, o.name = "") : l(o.type, o.name) ? o.name = "" : o.state.allowName = !1);
            break;
          case "[":
            o.state.allowArray || r(n), o.type += a, o.state.allowArray = !1, o.state.allowName = !1, o.state.readArray = !0;
            break;
          case "]":
            o.state.readArray || r(n), o.type += a, o.state.readArray = !1, o.state.allowArray = !0, o.state.allowName = !0;
            break;
          default:
            o.state.allowType ? (o.type += a, o.state.allowParams = !0, o.state.allowArray = !0) : o.state.allowName ? (o.name += a, delete o.state.allowArray) : o.state.readArray ? o.type += a : r(n)
        }
      }
      return o.parent && n.throwArgumentError("unexpected eof", "param", t), delete i.state, "indexed" === o.name ? (e || r(a.length - 7), o.indexed && r(a.length - 7), o.indexed = !0, o.name = "") : l(o.type, o.name) && (o.name = ""), i.type = j(i.type), i
    }

    function m(t, a) {
      for (let r in a)(0, e.defineReadOnly)(t, r, a[r])
    }
    const p = Object.freeze({
      sighash: "sighash",
      minimal: "minimal",
      full: "full",
      json: "json"
    });
    exports.FormatTypes = p;
    const c = new RegExp(/^(.*)\[([0-9]*)\]$/);
    class y {
      constructor(t, e) {
        t !== s && n.throwError("use fromString", a.Logger.errors.UNSUPPORTED_OPERATION, {
          operation: "new ParamType()"
        }), m(this, e);
        let r = this.type.match(c);
        m(this, r ? {
          arrayLength: parseInt(r[2] || "-1"),
          arrayChildren: y.fromObject({
            type: r[1],
            components: this.components
          }),
          baseType: "array"
        } : {
          arrayLength: null,
          arrayChildren: null,
          baseType: null != this.components ? "tuple" : this.type
        }), this._isParamType = !0, Object.freeze(this)
      }
      format(t) {
        if (t || (t = p.sighash), p[t] || n.throwArgumentError("invalid format type", "format", t), t === p.json) {
          let e = {
            type: "tuple" === this.baseType ? "tuple" : this.type,
            name: this.name || void 0
          };
          return "boolean" == typeof this.indexed && (e.indexed = this.indexed), this.components && (e.components = this.components.map(e => JSON.parse(e.format(t)))), JSON.stringify(e)
        }
        let e = "";
        return "array" === this.baseType ? (e += this.arrayChildren.format(t), e += "[" + (this.arrayLength < 0 ? "" : String(this.arrayLength)) + "]") : "tuple" === this.baseType ? (t !== p.sighash && (e += this.type), e += "(" + this.components.map(e => e.format(t)).join(t === p.full ? ", " : ",") + ")") : e += this.type, t !== p.sighash && (!0 === this.indexed && (e += " indexed"), t === p.full && this.name && (e += " " + this.name)), e
      }
      static from(t, e) {
        return "string" == typeof t ? y.fromString(t, e) : y.fromObject(t)
      }
      static fromObject(t) {
        return y.isParamType(t) ? t : new y(s, {
          name: t.name || null,
          type: j(t.type),
          indexed: null == t.indexed ? null : !!t.indexed,
          components: t.components ? t.components.map(y.fromObject) : null
        })
      }
      static fromString(t, e) {
        return a = u(t, !!e), y.fromObject({
          name: a.name,
          type: a.type,
          indexed: a.indexed,
          components: a.components
        });
        var a
      }
      static isParamType(t) {
        return !(null == t || !t._isParamType)
      }
    }

    function h(t, e) {
      return M(t).map(t => y.fromString(t, e))
    }
    exports.ParamType = y;
    class g {
      constructor(t, e) {
        t !== s && n.throwError("use a static from method", a.Logger.errors.UNSUPPORTED_OPERATION, {
          operation: "new Fragment()"
        }), m(this, e), this._isFragment = !0, Object.freeze(this)
      }
      static from(t) {
        return g.isFragment(t) ? t : "string" == typeof t ? g.fromString(t) : g.fromObject(t)
      }
      static fromObject(t) {
        if (g.isFragment(t)) return t;
        switch (t.type) {
          case "function":
            return O.fromObject(t);
          case "event":
            return f.fromObject(t);
          case "constructor":
            return v.fromObject(t);
          case "fallback":
          case "receive":
            return null
        }
        return n.throwArgumentError("invalid fragment object", "value", t)
      }
      static fromString(t) {
        return "event" === (t = (t = (t = t.replace(/\s/g, " ")).replace(/\(/g, " (").replace(/\)/g, ") ").replace(/\s+/g, " ")).trim()).split(" ")[0] ? f.fromString(t.substring(5).trim()) : "function" === t.split(" ")[0] ? O.fromString(t.substring(8).trim()) : "constructor" === t.split("(")[0].trim() ? v.fromString(t.trim()) : n.throwArgumentError("unsupported fragment", "value", t)
      }
      static isFragment(t) {
        return !(!t || !t._isFragment)
      }
    }
    exports.Fragment = g;
    class f extends g {
      format(t) {
        if (t || (t = p.sighash), p[t] || n.throwArgumentError("invalid format type", "format", t), t === p.json) return JSON.stringify({
          type: "event",
          anonymous: this.anonymous,
          name: this.name,
          inputs: this.inputs.map(e => JSON.parse(e.format(t)))
        });
        let e = "";
        return t !== p.sighash && (e += "event "), e += this.name + "(" + this.inputs.map(e => e.format(t)).join(t === p.full ? ", " : ",") + ") ", t !== p.sighash && this.anonymous && (e += "anonymous "), e.trim()
      }
      static from(t) {
        return "string" == typeof t ? f.fromString(t) : f.fromObject(t)
      }
      static fromObject(t) {
        if (f.isEventFragment(t)) return t;
        "event" !== t.type && n.throwArgumentError("invalid event object", "value", t);
        const e = {
          name: E(t.name),
          anonymous: t.anonymous,
          inputs: t.inputs ? t.inputs.map(y.fromObject) : [],
          type: "event"
        };
        return new f(s, e)
      }
      static fromString(t) {
        let e = t.match(A);
        e || n.throwArgumentError("invalid event string", "value", t);
        let a = !1;
        return e[3].split(" ").forEach(t => {
          switch (t.trim()) {
            case "anonymous":
              a = !0;
              break;
            case "":
              break;
            default:
              n.warn("unknown modifier: " + t)
          }
        }), f.fromObject({
          name: e[1].trim(),
          anonymous: a,
          inputs: h(e[2], !0),
          type: "event"
        })
      }
      static isEventFragment(t) {
        return t && t._isFragment && "event" === t.type
      }
    }

    function b(e, a) {
      a.gas = null;
      let r = e.split("@");
      return 1 !== r.length ? (r.length > 2 && n.throwArgumentError("invalid human-readable ABI signature", "value", e), r[1].match(/^[0-9]+$/) || n.throwArgumentError("invalid human-readable ABI signature gas", "value", e), a.gas = t.BigNumber.from(r[1]), r[0]) : e
    }

    function d(t, e) {
      e.constant = !1, e.payable = !1, e.stateMutability = "nonpayable", t.split(" ").forEach(t => {
        switch (t.trim()) {
          case "constant":
            e.constant = !0;
            break;
          case "payable":
            e.payable = !0, e.stateMutability = "payable";
            break;
          case "nonpayable":
            e.payable = !1, e.stateMutability = "nonpayable";
            break;
          case "pure":
            e.constant = !0, e.stateMutability = "pure";
            break;
          case "view":
            e.constant = !0, e.stateMutability = "view";
            break;
          case "external":
          case "public":
          case "":
            break;
          default:
            console.log("unknown modifier: " + t)
        }
      })
    }

    function w(t) {
      let e = {
        constant: !1,
        payable: !0,
        stateMutability: "payable"
      };
      return null != t.stateMutability ? (e.stateMutability = t.stateMutability, e.constant = "view" === e.stateMutability || "pure" === e.stateMutability, null != t.constant && !!t.constant !== e.constant && n.throwArgumentError("cannot have constant function with mutability " + e.stateMutability, "value", t), e.payable = "payable" === e.stateMutability, null != t.payable && !!t.payable !== e.payable && n.throwArgumentError("cannot have payable function with mutability " + e.stateMutability, "value", t)) : null != t.payable ? (e.payable = !!t.payable, null != t.constant || e.payable || "constructor" === t.type || n.throwArgumentError("unable to determine stateMutability", "value", t), e.constant = !!t.constant, e.constant ? e.stateMutability = "view" : e.stateMutability = e.payable ? "payable" : "nonpayable", e.payable && e.constant && n.throwArgumentError("cannot have constant payable function", "value", t)) : null != t.constant ? (e.constant = !!t.constant, e.payable = !e.constant, e.stateMutability = e.constant ? "view" : "payable") : "constructor" !== t.type && n.throwArgumentError("unable to determine stateMutability", "value", t), e
    }
    exports.EventFragment = f;
    class v extends g {
      format(t) {
        if (t || (t = p.sighash), p[t] || n.throwArgumentError("invalid format type", "format", t), t === p.json) return JSON.stringify({
          type: "constructor",
          stateMutability: "nonpayable" !== this.stateMutability ? this.stateMutability : void 0,
          payble: this.payable,
          gas: this.gas ? this.gas.toNumber() : void 0,
          inputs: this.inputs.map(e => JSON.parse(e.format(t)))
        });
        t === p.sighash && n.throwError("cannot format a constructor for sighash", a.Logger.errors.UNSUPPORTED_OPERATION, {
          operation: "format(sighash)"
        });
        let e = "constructor(" + this.inputs.map(e => e.format(t)).join(t === p.full ? ", " : ",") + ") ";
        return this.stateMutability && "nonpayable" !== this.stateMutability && (e += this.stateMutability + " "), e.trim()
      }
      static from(t) {
        return "string" == typeof t ? v.fromString(t) : v.fromObject(t)
      }
      static fromObject(e) {
        if (v.isConstructorFragment(e)) return e;
        "constructor" !== e.type && n.throwArgumentError("invalid constructor object", "value", e);
        let a = w(e);
        a.constant && n.throwArgumentError("constructor cannot be constant", "value", e);
        const r = {
          name: null,
          type: e.type,
          inputs: e.inputs ? e.inputs.map(y.fromObject) : [],
          payable: a.payable,
          stateMutability: a.stateMutability,
          gas: e.gas ? t.BigNumber.from(e.gas) : null
        };
        return new v(s, r)
      }
      static fromString(t) {
        let e = {
            type: "constructor"
          },
          a = (t = b(t, e)).match(A);
        return a && "constructor" === a[1].trim() || n.throwArgumentError("invalid constructor string", "value", t), e.inputs = h(a[2].trim(), !1), d(a[3].trim(), e), v.fromObject(e)
      }
      static isConstructorFragment(t) {
        return t && t._isFragment && "constructor" === t.type
      }
    }
    exports.ConstructorFragment = v;
    class O extends v {
      format(t) {
        if (t || (t = p.sighash), p[t] || n.throwArgumentError("invalid format type", "format", t), t === p.json) return JSON.stringify({
          type: "function",
          name: this.name,
          constant: this.constant,
          stateMutability: "nonpayable" !== this.stateMutability ? this.stateMutability : void 0,
          payble: this.payable,
          gas: this.gas ? this.gas.toNumber() : void 0,
          inputs: this.inputs.map(e => JSON.parse(e.format(t))),
          ouputs: this.outputs.map(e => JSON.parse(e.format(t)))
        });
        let e = "";
        return t !== p.sighash && (e += "function "), e += this.name + "(" + this.inputs.map(e => e.format(t)).join(t === p.full ? ", " : ",") + ") ", t !== p.sighash && (this.stateMutability ? "nonpayable" !== this.stateMutability && (e += this.stateMutability + " ") : this.constant && (e += "view "), this.outputs && this.outputs.length && (e += "returns (" + this.outputs.map(e => e.format(t)).join(", ") + ") "), null != this.gas && (e += "@" + this.gas.toString() + " ")), e.trim()
      }
      static from(t) {
        return "string" == typeof t ? O.fromString(t) : O.fromObject(t)
      }
      static fromObject(e) {
        if (O.isFunctionFragment(e)) return e;
        "function" !== e.type && n.throwArgumentError("invalid function object", "value", e);
        let a = w(e);
        const r = {
          type: e.type,
          name: E(e.name),
          constant: a.constant,
          inputs: e.inputs ? e.inputs.map(y.fromObject) : [],
          outputs: e.outputs ? e.outputs.map(y.fromObject) : [],
          payable: a.payable,
          stateMutability: a.stateMutability,
          gas: e.gas ? t.BigNumber.from(e.gas) : null
        };
        return new O(s, r)
      }
      static fromString(t) {
        let e = {
            type: "function"
          },
          a = (t = b(t, e)).split(" returns ");
        a.length > 2 && n.throwArgumentError("invalid function string", "value", t);
        let r = a[0].match(A);
        if (r || n.throwArgumentError("invalid function signature", "value", t), e.name = r[1].trim(), e.name && E(e.name), e.inputs = h(r[2], !1), d(r[3].trim(), e), a.length > 1) {
          let r = a[1].match(A);
          "" == r[1].trim() && "" == r[3].trim() || n.throwArgumentError("unexpected tokens", "value", t), e.outputs = h(r[2], !1)
        } else e.outputs = [];
        return O.fromObject(e)
      }
      static isFunctionFragment(t) {
        return t && t._isFragment && "function" === t.type
      }
    }

    function j(t) {
      return t.match(/^uint($|[^1-9])/) ? t = "uint256" + t.substring(4) : t.match(/^int($|[^1-9])/) && (t = "int256" + t.substring(3)), t
    }
    exports.FunctionFragment = O;
    const x = new RegExp("^[A-Za-z_][A-Za-z0-9_]*$");

    function E(t) {
      return t && t.match(x) || n.throwArgumentError(`invalid identifier "${t}"`, "value", t), t
    }
    const A = new RegExp("^([^)(]*)\\((.*)\\)([^)(]*)$");

    function M(t) {
      t = t.trim();
      let e = [],
        a = "",
        r = 0;
      for (let s = 0; s < t.length; s++) {
        let i = t[s];
        "," === i && 0 === r ? (e.push(a), a = "") : (a += i, "(" === i ? r++ : ")" === i && -1 === --r && n.throwArgumentError("unbalanced parenthesis", "value", t))
      }
      return a && e.push(a), e
    }
  }, {
    "@ethersproject/bignumber": "BWdp",
    "@ethersproject/properties": "miZX",
    "@ethersproject/logger": "M3zR",
    "./_version": "Vg5D"
  }],
  "s6pq": [function(require, module, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    }), exports.checkResultErrors = o, exports.Reader = exports.Writer = exports.Coder = void 0;
    var t = require("@ethersproject/bytes"),
      e = require("@ethersproject/bignumber"),
      r = require("@ethersproject/properties"),
      s = require("@ethersproject/logger"),
      i = require("../_version");
    const a = new s.Logger(i.version);

    function o(t) {
      const e = [],
        r = function(t, s) {
          if (Array.isArray(s))
            for (let a in s) {
              const o = t.slice();
              o.push(a);
              try {
                r(o, s[a])
              } catch (i) {
                e.push({
                  path: o,
                  error: i
                })
              }
            }
        };
      return r([], t), e
    }
    class h {
      constructor(t, e, r, s) {
        this.name = t, this.type = e, this.localName = r, this.dynamic = s
      }
      _throwError(t, e) {
        a.throwArgumentError(t, this.localName, e)
      }
    }
    exports.Coder = h;
    class n {
      constructor(t) {
        (0, r.defineReadOnly)(this, "wordSize", t || 32), this._data = [], this._dataLength = 0, this._padding = new Uint8Array(t)
      }
      get data() {
        return (0, t.hexConcat)(this._data)
      }
      get length() {
        return this._dataLength
      }
      _writeData(t) {
        return this._data.push(t), this._dataLength += t.length, t.length
      }
      appendWriter(e) {
        return this._writeData((0, t.concat)(e._data))
      }
      writeBytes(e) {
        let r = (0, t.arrayify)(e);
        const s = r.length % this.wordSize;
        return s && (r = (0, t.concat)([r, this._padding.slice(s)])), this._writeData(r)
      }
      _getValue(r) {
        let i = (0, t.arrayify)(e.BigNumber.from(r));
        return i.length > this.wordSize && a.throwError("value out-of-bounds", s.Logger.errors.BUFFER_OVERRUN, {
          length: this.wordSize,
          offset: i.length
        }), i.length % this.wordSize && (i = (0, t.concat)([this._padding.slice(i.length % this.wordSize), i])), i
      }
      writeValue(t) {
        return this._writeData(this._getValue(t))
      }
      writeUpdatableValue() {
        const t = this._data.length;
        return this._data.push(this._padding), this._dataLength += this.wordSize, e => {
          this._data[t] = this._getValue(e)
        }
      }
    }
    exports.Writer = n;
    class d {
      constructor(e, s, i, a) {
        (0, r.defineReadOnly)(this, "_data", (0, t.arrayify)(e)), (0, r.defineReadOnly)(this, "wordSize", s || 32), (0, r.defineReadOnly)(this, "_coerceFunc", i), (0, r.defineReadOnly)(this, "allowLoose", a), this._offset = 0
      }
      get data() {
        return (0, t.hexlify)(this._data)
      }
      get consumed() {
        return this._offset
      }
      static coerce(t, e) {
        let r = t.match("^u?int([0-9]+)$");
        return r && parseInt(r[1]) <= 48 && (e = e.toNumber()), e
      }
      coerce(t, e) {
        return this._coerceFunc ? this._coerceFunc(t, e) : d.coerce(t, e)
      }
      _peekBytes(t, e, r) {
        let i = Math.ceil(e / this.wordSize) * this.wordSize;
        return this._offset + i > this._data.length && (this.allowLoose && r && this._offset + e <= this._data.length ? i = e : a.throwError("data out-of-bounds", s.Logger.errors.BUFFER_OVERRUN, {
          length: this._data.length,
          offset: this._offset + i
        })), this._data.slice(this._offset, this._offset + i)
      }
      subReader(t) {
        return new d(this._data.slice(this._offset + t), this.wordSize, this._coerceFunc, this.allowLoose)
      }
      readBytes(t, e) {
        let r = this._peekBytes(0, t, !!e);
        return this._offset += r.length, r.slice(0, t)
      }
      readValue() {
        return e.BigNumber.from(this.readBytes(this.wordSize))
      }
    }
    exports.Reader = d;
  }, {
    "@ethersproject/bytes": "kHJk",
    "@ethersproject/bignumber": "BWdp",
    "@ethersproject/properties": "miZX",
    "@ethersproject/logger": "M3zR",
    "../_version": "Vg5D"
  }],
  "NYbm": [function(require, module, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    }), exports.AddressCoder = void 0;
    var e = require("@ethersproject/address"),
      r = require("@ethersproject/bytes"),
      s = require("./abstract-coder");
    class t extends s.Coder {
      constructor(e) {
        super("address", "address", e, !1)
      }
      encode(r, s) {
        try {
          (0, e.getAddress)(s)
        } catch (t) {
          this._throwError(t.message, s)
        }
        return r.writeValue(s)
      }
      decode(s) {
        return (0, e.getAddress)((0, r.hexZeroPad)(s.readValue().toHexString(), 20))
      }
    }
    exports.AddressCoder = t;
  }, {
    "@ethersproject/address": "v33u",
    "@ethersproject/bytes": "kHJk",
    "./abstract-coder": "s6pq"
  }],
  "n04H": [function(require, module, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    }), exports.AnonymousCoder = void 0;
    var e = require("./abstract-coder");
    class o extends e.Coder {
      constructor(e) {
        super(e.name, e.type, void 0, e.dynamic), this.coder = e
      }
      encode(e, o) {
        return this.coder.encode(e, o)
      }
      decode(e) {
        return this.coder.decode(e)
      }
    }
    exports.AnonymousCoder = o;
  }, {
    "./abstract-coder": "s6pq"
  }],
  "HtVX": [function(require, module, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    }), exports.pack = a, exports.unpack = l, exports.ArrayCoder = void 0;
    var e = require("@ethersproject/logger"),
      r = require("../_version"),
      t = require("./abstract-coder"),
      o = require("./anonymous");
    const n = new e.Logger(r.version);

    function a(r, o, a) {
      let l = null;
      if (Array.isArray(a)) l = a;
      else if (a && "object" == typeof a) {
        let r = {};
        l = o.map(t => {
          const o = t.localName;
          return o || n.throwError("cannot encode object for signature with missing names", e.Logger.errors.INVALID_ARGUMENT, {
            argument: "values",
            coder: t,
            value: a
          }), r[o] && n.throwError("cannot encode object for signature with duplicate names", e.Logger.errors.INVALID_ARGUMENT, {
            argument: "values",
            coder: t,
            value: a
          }), r[o] = !0, a[o]
        })
      } else n.throwArgumentError("invalid tuple value", "tuple", a);
      o.length !== l.length && n.throwArgumentError("types/value length mismatch", "tuple", a);
      let c = new t.Writer(r.wordSize),
        s = new t.Writer(r.wordSize),
        u = [];
      o.forEach((e, r) => {
        let t = l[r];
        if (e.dynamic) {
          let r = s.length;
          e.encode(s, t);
          let o = c.writeUpdatableValue();
          u.push(e => {
            o(e + r)
          })
        } else e.encode(c, t)
      }), u.forEach(e => {
        e(c.length)
      });
      let i = r.appendWriter(c);
      return i += r.appendWriter(s)
    }

    function l(r, t) {
      let o = [],
        n = r.subReader(0);
      t.forEach(t => {
        let a = null;
        if (t.dynamic) {
          let o = r.readValue(),
            c = n.subReader(o.toNumber());
          try {
            a = t.decode(c)
          } catch (l) {
            if (l.code === e.Logger.errors.BUFFER_OVERRUN) throw l;
            (a = l).baseType = t.name, a.name = t.localName, a.type = t.type
          }
        } else try {
          a = t.decode(r)
        } catch (l) {
          if (l.code === e.Logger.errors.BUFFER_OVERRUN) throw l;
          (a = l).baseType = t.name, a.name = t.localName, a.type = t.type
        }
        null != a && o.push(a)
      });
      const a = t.reduce((e, r) => {
        const t = r.localName;
        return t && (e[t] || (e[t] = 0), e[t]++), e
      }, {});
      t.forEach((e, r) => {
        let t = e.localName;
        if (!t || 1 !== a[t]) return;
        if ("length" === t && (t = "_length"), null != o[t]) return;
        const n = o[r];
        n instanceof Error ? Object.defineProperty(o, t, {
          get: () => {
            throw n
          }
        }) : o[t] = n
      });
      for (let e = 0; e < o.length; e++) {
        const r = o[e];
        r instanceof Error && Object.defineProperty(o, e, {
          get: () => {
            throw r
          }
        })
      }
      return Object.freeze(o)
    }
    class c extends t.Coder {
      constructor(e, r, t) {
        super("array", e.type + "[" + (r >= 0 ? r : "") + "]", t, -1 === r || e.dynamic), this.coder = e, this.length = r
      }
      encode(e, r) {
        Array.isArray(r) || this._throwError("expected array value", r);
        let t = this.length; - 1 === t && (t = r.length, e.writeValue(r.length)), n.checkArgumentCount(r.length, t, "coder array" + (this.localName ? " " + this.localName : ""));
        let o = [];
        for (let n = 0; n < r.length; n++) o.push(this.coder);
        return a(e, o, r)
      }
      decode(e) {
        let r = this.length; - 1 === r && (r = e.readValue().toNumber());
        let t = [];
        for (let n = 0; n < r; n++) t.push(new o.AnonymousCoder(this.coder));
        return e.coerce(this.name, l(e, t))
      }
    }
    exports.ArrayCoder = c;
  }, {
    "@ethersproject/logger": "M3zR",
    "../_version": "Vg5D",
    "./abstract-coder": "s6pq",
    "./anonymous": "n04H"
  }],
  "kCzJ": [function(require, module, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    }), exports.BooleanCoder = void 0;
    var e = require("./abstract-coder");
    class r extends e.Coder {
      constructor(e) {
        super("bool", "bool", e, !1)
      }
      encode(e, r) {
        return e.writeValue(r ? 1 : 0)
      }
      decode(e) {
        return e.coerce(this.type, !e.readValue().isZero())
      }
    }
    exports.BooleanCoder = r;
  }, {
    "./abstract-coder": "s6pq"
  }],
  "c7TS": [function(require, module, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    }), exports.BytesCoder = exports.DynamicBytesCoder = void 0;
    var e = require("@ethersproject/bytes"),
      r = require("./abstract-coder");
    class t extends r.Coder {
      constructor(e, r) {
        super(e, e, r, !0)
      }
      encode(r, t) {
        t = (0, e.arrayify)(t);
        let s = r.writeValue(t.length);
        return s += r.writeBytes(t)
      }
      decode(e) {
        return e.readBytes(e.readValue().toNumber(), !0)
      }
    }
    exports.DynamicBytesCoder = t;
    class s extends t {
      constructor(e) {
        super("bytes", e)
      }
      decode(r) {
        return r.coerce(this.name, (0, e.hexlify)(super.decode(r)))
      }
    }
    exports.BytesCoder = s;
  }, {
    "@ethersproject/bytes": "kHJk",
    "./abstract-coder": "s6pq"
  }],
  "Nsfx": [function(require, module, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    }), exports.FixedBytesCoder = void 0;
    var e = require("@ethersproject/bytes"),
      r = require("./abstract-coder");
    class t extends r.Coder {
      constructor(e, r) {
        let t = "bytes" + String(e);
        super(t, t, r, !1), this.size = e
      }
      encode(r, t) {
        let s = (0, e.arrayify)(t);
        return s.length !== this.size && this._throwError("incorrect data length", t), r.writeBytes(s)
      }
      decode(r) {
        return r.coerce(this.name, (0, e.hexlify)(r.readBytes(this.size)))
      }
    }
    exports.FixedBytesCoder = t;
  }, {
    "@ethersproject/bytes": "kHJk",
    "./abstract-coder": "s6pq"
  }],
  "pUNB": [function(require, module, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    }), exports.NullCoder = void 0;
    var e = require("./abstract-coder");
    class r extends e.Coder {
      constructor(e) {
        super("null", "", e, !1)
      }
      encode(e, r) {
        return null != r && this._throwError("not null", r), e.writeBytes([])
      }
      decode(e) {
        return e.readBytes(0), e.coerce(this.name, null)
      }
    }
    exports.NullCoder = r;
  }, {
    "./abstract-coder": "s6pq"
  }],
  "hGGG": [function(require, module, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    }), exports.NumberCoder = void 0;
    var e = require("@ethersproject/bignumber"),
      s = require("@ethersproject/constants"),
      t = require("./abstract-coder");
    class r extends t.Coder {
      constructor(e, s, t) {
        const r = (s ? "int" : "uint") + 8 * e;
        super(r, r, t, !1), this.size = e, this.signed = s
      }
      encode(t, r) {
        let i = e.BigNumber.from(r),
          o = s.MaxUint256.mask(8 * t.wordSize);
        if (this.signed) {
          let e = o.mask(8 * this.size - 1);
          (i.gt(e) || i.lt(e.add(s.One).mul(s.NegativeOne))) && this._throwError("value out-of-bounds", r)
        } else(i.lt(s.Zero) || i.gt(o.mask(8 * this.size))) && this._throwError("value out-of-bounds", r);
        return i = i.toTwos(8 * this.size).mask(8 * this.size), this.signed && (i = i.fromTwos(8 * this.size).toTwos(8 * t.wordSize)), t.writeValue(i)
      }
      decode(e) {
        let s = e.readValue().mask(8 * this.size);
        return this.signed && (s = s.fromTwos(8 * this.size)), e.coerce(this.name, s)
      }
    }
    exports.NumberCoder = r;
  }, {
    "@ethersproject/bignumber": "BWdp",
    "@ethersproject/constants": "inUu",
    "./abstract-coder": "s6pq"
  }],
  "uLY1": [function(require, module, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    }), exports.version = void 0;
    const e = "strings/5.1.0";
    exports.version = e;
  }, {}],
  "pNhS": [function(require, module, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    }), exports.toUtf8Bytes = l, exports._toEscapedUtf8String = E, exports._toUtf8String = N, exports.toUtf8String = h, exports.toUtf8CodePoints = U, exports.Utf8ErrorFuncs = exports.Utf8ErrorReason = exports.UnicodeNormalizationForm = void 0;
    var r = require("@ethersproject/bytes"),
      e = require("@ethersproject/logger"),
      t = require("./_version");
    const n = new e.Logger(t.version);
    var o, i;

    function u(r, e, t, o, i) {
      return n.throwArgumentError(`invalid codepoint at offset ${e}; ${r}`, "bytes", t)
    }

    function s(r, e, t, n, o) {
      if (r === i.BAD_PREFIX || r === i.UNEXPECTED_CONTINUE) {
        let r = 0;
        for (let n = e + 1; n < t.length && t[n] >> 6 == 2; n++) r++;
        return r
      }
      return r === i.OVERRUN ? t.length - e - 1 : 0
    }

    function c(r, e, t, n, o) {
      return r === i.OVERLONG ? (n.push(o), 0) : (n.push(65533), s(r, e, t, n, o))
    }
    exports.UnicodeNormalizationForm = o,
      function(r) {
        r.current = "", r.NFC = "NFC", r.NFD = "NFD", r.NFKC = "NFKC", r.NFKD = "NFKD"
      }(o || (exports.UnicodeNormalizationForm = o = {})), exports.Utf8ErrorReason = i,
      function(r) {
        r.UNEXPECTED_CONTINUE = "unexpected continuation byte", r.BAD_PREFIX = "bad codepoint prefix", r.OVERRUN = "string overrun", r.MISSING_CONTINUE = "missing continuation byte", r.OUT_OF_RANGE = "out of UTF-8 range", r.UTF16_SURROGATE = "UTF-16 surrogate", r.OVERLONG = "overlong representation"
      }(i || (exports.Utf8ErrorReason = i = {}));
    const f = Object.freeze({
      error: u,
      ignore: s,
      replace: c
    });

    function a(e, t) {
      null == t && (t = f.error), e = (0, r.arrayify)(e);
      const n = [];
      let o = 0;
      for (; o < e.length;) {
        const r = e[o++];
        if (r >> 7 == 0) {
          n.push(r);
          continue
        }
        let u = null,
          s = null;
        if (192 == (224 & r)) u = 1, s = 127;
        else if (224 == (240 & r)) u = 2, s = 2047;
        else {
          if (240 != (248 & r)) {
            o += t(128 == (192 & r) ? i.UNEXPECTED_CONTINUE : i.BAD_PREFIX, o - 1, e, n);
            continue
          }
          u = 3, s = 65535
        }
        if (o - 1 + u >= e.length) {
          o += t(i.OVERRUN, o - 1, e, n);
          continue
        }
        let c = r & (1 << 8 - u - 1) - 1;
        for (let f = 0; f < u; f++) {
          let r = e[o];
          if (128 != (192 & r)) {
            o += t(i.MISSING_CONTINUE, o, e, n), c = null;
            break
          }
          c = c << 6 | 63 & r, o++
        }
        null !== c && (c > 1114111 ? o += t(i.OUT_OF_RANGE, o - 1 - u, e, n, c) : c >= 55296 && c <= 57343 ? o += t(i.UTF16_SURROGATE, o - 1 - u, e, n, c) : c <= s ? o += t(i.OVERLONG, o - 1 - u, e, n, c) : n.push(c))
      }
      return n
    }

    function l(e, t = o.current) {
      t != o.current && (n.checkNormalize(), e = e.normalize(t));
      let i = [];
      for (let r = 0; r < e.length; r++) {
        const t = e.charCodeAt(r);
        if (t < 128) i.push(t);
        else if (t < 2048) i.push(t >> 6 | 192), i.push(63 & t | 128);
        else if (55296 == (64512 & t)) {
          r++;
          const n = e.charCodeAt(r);
          if (r >= e.length || 56320 != (64512 & n)) throw new Error("invalid utf-8 string");
          const o = 65536 + ((1023 & t) << 10) + (1023 & n);
          i.push(o >> 18 | 240), i.push(o >> 12 & 63 | 128), i.push(o >> 6 & 63 | 128), i.push(63 & o | 128)
        } else i.push(t >> 12 | 224), i.push(t >> 6 & 63 | 128), i.push(63 & t | 128)
      }
      return (0, r.arrayify)(i)
    }

    function p(r) {
      const e = "0000" + r.toString(16);
      return "\\u" + e.substring(e.length - 4)
    }

    function E(r, e) {
      return '"' + a(r, e).map(r => {
        if (r < 256) {
          switch (r) {
            case 8:
              return "\\b";
            case 9:
              return "\\t";
            case 10:
              return "\\n";
            case 13:
              return "\\r";
            case 34:
              return '\\"';
            case 92:
              return "\\\\"
          }
          if (r >= 32 && r < 127) return String.fromCharCode(r)
        }
        return r <= 65535 ? p(r) : p(55296 + ((r -= 65536) >> 10 & 1023)) + p(56320 + (1023 & r))
      }).join("") + '"'
    }

    function N(r) {
      return r.map(r => r <= 65535 ? String.fromCharCode(r) : (r -= 65536, String.fromCharCode(55296 + (r >> 10 & 1023), 56320 + (1023 & r)))).join("")
    }

    function h(r, e) {
      return N(a(r, e))
    }

    function U(r, e = o.current) {
      return a(l(r, e))
    }
    exports.Utf8ErrorFuncs = f;
  }, {
    "@ethersproject/bytes": "kHJk",
    "@ethersproject/logger": "M3zR",
    "./_version": "uLY1"
  }],
  "LClc": [function(require, module, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    }), exports.formatBytes32String = n, exports.parseBytes32String = s;
    var t = require("@ethersproject/constants"),
      e = require("@ethersproject/bytes"),
      r = require("./utf8");

    function n(n) {
      const s = (0, r.toUtf8Bytes)(n);
      if (s.length > 31) throw new Error("bytes32 string must be less than 32 bytes");
      return (0, e.hexlify)((0, e.concat)([s, t.HashZero]).slice(0, 32))
    }

    function s(t) {
      const n = (0, e.arrayify)(t);
      if (32 !== n.length) throw new Error("invalid bytes32 - not 32 bytes long");
      if (0 !== n[31]) throw new Error("invalid bytes32 string - no null terminator");
      let s = 31;
      for (; 0 === n[s - 1];) s--;
      return (0, r.toUtf8String)(n.slice(0, s))
    }
  }, {
    "@ethersproject/constants": "inUu",
    "@ethersproject/bytes": "kHJk",
    "./utf8": "pNhS"
  }],
  "Ieez": [function(require, module, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    }), exports._nameprepTableA1 = F, exports._nameprepTableB2 = o, exports._nameprepTableC = i, exports.nameprep = u;
    var f = require("./utf8");

    function e(f) {
      if (f.length % 4 != 0) throw new Error("bad data");
      let e = [];
      for (let t = 0; t < f.length; t += 4) e.push(parseInt(f.substring(t, t + 4), 16));
      return e
    }

    function t(f, e) {
      e || (e = function(f) {
        return [parseInt(f, 16)]
      });
      let t = 0,
        B = {};
      return f.split(",").forEach(f => {
        let r = f.split(":");
        t += parseInt(r[0], 16), B[t] = e(r[1])
      }), B
    }

    function B(f) {
      let e = 0;
      return f.split(",").map(f => {
        let t = f.split("-");
        return 1 === t.length ? t[1] = "0" : "" === t[1] && (t[1] = "1"), {
          l: e + parseInt(t[0], 16),
          h: e = parseInt(t[1], 16)
        }
      })
    }

    function r(f, e) {
      let t = 0;
      for (let B = 0; B < e.length; B++) {
        let r = e[B];
        if (f >= (t += r.l) && f <= t + r.h && (f - t) % (r.d || 1) == 0) {
          if (r.e && -1 !== r.e.indexOf(f - t)) continue;
          return r
        }
      }
      return null
    }
    const l = B("221,13-1b,5f-,40-10,51-f,11-3,3-3,2-2,2-4,8,2,15,2d,28-8,88,48,27-,3-5,11-20,27-,8,28,3-5,12,18,b-a,1c-4,6-16,2-d,2-2,2,1b-4,17-9,8f-,10,f,1f-2,1c-34,33-14e,4,36-,13-,6-2,1a-f,4,9-,3-,17,8,2-2,5-,2,8-,3-,4-8,2-3,3,6-,16-6,2-,7-3,3-,17,8,3,3,3-,2,6-3,3-,4-a,5,2-6,10-b,4,8,2,4,17,8,3,6-,b,4,4-,2-e,2-4,b-10,4,9-,3-,17,8,3-,5-,9-2,3-,4-7,3-3,3,4-3,c-10,3,7-2,4,5-2,3,2,3-2,3-2,4-2,9,4-3,6-2,4,5-8,2-e,d-d,4,9,4,18,b,6-3,8,4,5-6,3-8,3-3,b-11,3,9,4,18,b,6-3,8,4,5-6,3-6,2,3-3,b-11,3,9,4,18,11-3,7-,4,5-8,2-7,3-3,b-11,3,13-2,19,a,2-,8-2,2-3,7,2,9-11,4-b,3b-3,1e-24,3,2-,3,2-,2-5,5,8,4,2,2-,3,e,4-,6,2,7-,b-,3-21,49,23-5,1c-3,9,25,10-,2-2f,23,6,3,8-2,5-5,1b-45,27-9,2a-,2-3,5b-4,45-4,53-5,8,40,2,5-,8,2,5-,28,2,5-,20,2,5-,8,2,5-,8,8,18,20,2,5-,8,28,14-5,1d-22,56-b,277-8,1e-2,52-e,e,8-a,18-8,15-b,e,4,3-b,5e-2,b-15,10,b-5,59-7,2b-555,9d-3,5b-5,17-,7-,27-,7-,9,2,2,2,20-,36,10,f-,7,14-,4,a,54-3,2-6,6-5,9-,1c-10,13-1d,1c-14,3c-,10-6,32-b,240-30,28-18,c-14,a0,115-,3,66-,b-76,5,5-,1d,24,2,5-2,2,8-,35-2,19,f-10,1d-3,311-37f,1b,5a-b,d7-19,d-3,41,57-,68-4,29-3,5f,29-37,2e-2,25-c,2c-2,4e-3,30,78-3,64-,20,19b7-49,51a7-59,48e-2,38-738,2ba5-5b,222f-,3c-94,8-b,6-4,1b,6,2,3,3,6d-20,16e-f,41-,37-7,2e-2,11-f,5-b,18-,b,14,5-3,6,88-,2,bf-2,7-,7-,7-,4-2,8,8-9,8-2ff,20,5-b,1c-b4,27-,27-cbb1,f7-9,28-2,b5-221,56,48,3-,2-,3-,5,d,2,5,3,42,5-,9,8,1d,5,6,2-2,8,153-3,123-3,33-27fd,a6da-5128,21f-5df,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3,2-1d,61-ff7d"),
      b = "ad,34f,1806,180b,180c,180d,200b,200c,200d,2060,feff".split(",").map(f => parseInt(f, 16)),
      n = [{
        h: 25,
        s: 32,
        l: 65
      }, {
        h: 30,
        s: 32,
        e: [23],
        l: 127
      }, {
        h: 54,
        s: 1,
        e: [48],
        l: 64,
        d: 2
      }, {
        h: 14,
        s: 1,
        l: 57,
        d: 2
      }, {
        h: 44,
        s: 1,
        l: 17,
        d: 2
      }, {
        h: 10,
        s: 1,
        e: [2, 6, 8],
        l: 61,
        d: 2
      }, {
        h: 16,
        s: 1,
        l: 68,
        d: 2
      }, {
        h: 84,
        s: 1,
        e: [18, 24, 66],
        l: 19,
        d: 2
      }, {
        h: 26,
        s: 32,
        e: [17],
        l: 435
      }, {
        h: 22,
        s: 1,
        l: 71,
        d: 2
      }, {
        h: 15,
        s: 80,
        l: 40
      }, {
        h: 31,
        s: 32,
        l: 16
      }, {
        h: 32,
        s: 1,
        l: 80,
        d: 2
      }, {
        h: 52,
        s: 1,
        l: 42,
        d: 2
      }, {
        h: 12,
        s: 1,
        l: 55,
        d: 2
      }, {
        h: 40,
        s: 1,
        e: [38],
        l: 15,
        d: 2
      }, {
        h: 14,
        s: 1,
        l: 48,
        d: 2
      }, {
        h: 37,
        s: 48,
        l: 49
      }, {
        h: 148,
        s: 1,
        l: 6351,
        d: 2
      }, {
        h: 88,
        s: 1,
        l: 160,
        d: 2
      }, {
        h: 15,
        s: 16,
        l: 704
      }, {
        h: 25,
        s: 26,
        l: 854
      }, {
        h: 25,
        s: 32,
        l: 55915
      }, {
        h: 37,
        s: 40,
        l: 1247
      }, {
        h: 25,
        s: -119711,
        l: 53248
      }, {
        h: 25,
        s: -119763,
        l: 52
      }, {
        h: 25,
        s: -119815,
        l: 52
      }, {
        h: 25,
        s: -119867,
        e: [1, 4, 5, 7, 8, 11, 12, 17],
        l: 52
      }, {
        h: 25,
        s: -119919,
        l: 52
      }, {
        h: 24,
        s: -119971,
        e: [2, 7, 8, 17],
        l: 52
      }, {
        h: 24,
        s: -120023,
        e: [2, 7, 13, 15, 16, 17],
        l: 52
      }, {
        h: 25,
        s: -120075,
        l: 52
      }, {
        h: 25,
        s: -120127,
        l: 52
      }, {
        h: 25,
        s: -120179,
        l: 52
      }, {
        h: 25,
        s: -120231,
        l: 52
      }, {
        h: 25,
        s: -120283,
        l: 52
      }, {
        h: 25,
        s: -120335,
        l: 52
      }, {
        h: 24,
        s: -119543,
        e: [17],
        l: 56
      }, {
        h: 24,
        s: -119601,
        e: [17],
        l: 58
      }, {
        h: 24,
        s: -119659,
        e: [17],
        l: 58
      }, {
        h: 24,
        s: -119717,
        e: [17],
        l: 58
      }, {
        h: 24,
        s: -119775,
        e: [17],
        l: 58
      }],
      s = t("b5:3bc,c3:ff,7:73,2:253,5:254,3:256,1:257,5:259,1:25b,3:260,1:263,2:269,1:268,5:26f,1:272,2:275,7:280,3:283,5:288,3:28a,1:28b,5:292,3f:195,1:1bf,29:19e,125:3b9,8b:3b2,1:3b8,1:3c5,3:3c6,1:3c0,1a:3ba,1:3c1,1:3c3,2:3b8,1:3b5,1bc9:3b9,1c:1f76,1:1f77,f:1f7a,1:1f7b,d:1f78,1:1f79,1:1f7c,1:1f7d,107:63,5:25b,4:68,1:68,1:68,3:69,1:69,1:6c,3:6e,4:70,1:71,1:72,1:72,1:72,7:7a,2:3c9,2:7a,2:6b,1:e5,1:62,1:63,3:65,1:66,2:6d,b:3b3,1:3c0,6:64,1b574:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3"),
      d = t("179:1,2:1,2:1,5:1,2:1,a:4f,a:1,8:1,2:1,2:1,3:1,5:1,3:1,4:1,2:1,3:1,4:1,8:2,1:1,2:2,1:1,2:2,27:2,195:26,2:25,1:25,1:25,2:40,2:3f,1:3f,33:1,11:-6,1:-9,1ac7:-3a,6d:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,b:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,c:-8,2:-8,2:-8,2:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,49:-8,1:-8,1:-4a,1:-4a,d:-56,1:-56,1:-56,1:-56,d:-8,1:-8,f:-8,1:-8,3:-7"),
      a = t("df:00730073,51:00690307,19:02BC006E,a7:006A030C,18a:002003B9,16:03B903080301,20:03C503080301,1d7:05650582,190f:00680331,1:00740308,1:0077030A,1:0079030A,1:006102BE,b6:03C50313,2:03C503130300,2:03C503130301,2:03C503130342,2a:1F0003B9,1:1F0103B9,1:1F0203B9,1:1F0303B9,1:1F0403B9,1:1F0503B9,1:1F0603B9,1:1F0703B9,1:1F0003B9,1:1F0103B9,1:1F0203B9,1:1F0303B9,1:1F0403B9,1:1F0503B9,1:1F0603B9,1:1F0703B9,1:1F2003B9,1:1F2103B9,1:1F2203B9,1:1F2303B9,1:1F2403B9,1:1F2503B9,1:1F2603B9,1:1F2703B9,1:1F2003B9,1:1F2103B9,1:1F2203B9,1:1F2303B9,1:1F2403B9,1:1F2503B9,1:1F2603B9,1:1F2703B9,1:1F6003B9,1:1F6103B9,1:1F6203B9,1:1F6303B9,1:1F6403B9,1:1F6503B9,1:1F6603B9,1:1F6703B9,1:1F6003B9,1:1F6103B9,1:1F6203B9,1:1F6303B9,1:1F6403B9,1:1F6503B9,1:1F6603B9,1:1F6703B9,3:1F7003B9,1:03B103B9,1:03AC03B9,2:03B10342,1:03B1034203B9,5:03B103B9,6:1F7403B9,1:03B703B9,1:03AE03B9,2:03B70342,1:03B7034203B9,5:03B703B9,6:03B903080300,1:03B903080301,3:03B90342,1:03B903080342,b:03C503080300,1:03C503080301,1:03C10313,2:03C50342,1:03C503080342,b:1F7C03B9,1:03C903B9,1:03CE03B9,2:03C90342,1:03C9034203B9,5:03C903B9,ac:00720073,5b:00B00063,6:00B00066,d:006E006F,a:0073006D,1:00740065006C,1:0074006D,124f:006800700061,2:00610075,2:006F0076,b:00700061,1:006E0061,1:03BC0061,1:006D0061,1:006B0061,1:006B0062,1:006D0062,1:00670062,3:00700066,1:006E0066,1:03BC0066,4:0068007A,1:006B0068007A,1:006D0068007A,1:00670068007A,1:00740068007A,15:00700061,1:006B00700061,1:006D00700061,1:006700700061,8:00700076,1:006E0076,1:03BC0076,1:006D0076,1:006B0076,1:006D0076,1:00700077,1:006E0077,1:03BC0077,1:006D0077,1:006B0077,1:006D0077,1:006B03C9,1:006D03C9,2:00620071,3:00632215006B0067,1:0063006F002E,1:00640062,1:00670079,2:00680070,2:006B006B,1:006B006D,9:00700068,2:00700070006D,1:00700072,2:00730076,1:00770062,c723:00660066,1:00660069,1:0066006C,1:006600660069,1:00660066006C,1:00730074,1:00730074,d:05740576,1:05740565,1:0574056B,1:057E0576,1:0574056D", e),
      h = B("80-20,2a0-,39c,32,f71,18e,7f2-f,19-7,30-4,7-5,f81-b,5,a800-20ff,4d1-1f,110,fa-6,d174-7,2e84-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,2,1f-5f,ff7f-20001");

    function c(f) {
      return f.reduce((f, e) => (e.forEach(e => {
        f.push(e)
      }), f), [])
    }

    function F(f) {
      return !!r(f, l)
    }

    function o(f) {
      let e = r(f, n);
      if (e) return [f + e.s];
      let t = s[f];
      if (t) return t;
      let B = d[f];
      if (B) return [f + B[0]];
      let l = a[f];
      return l || null
    }

    function i(f) {
      return !!r(f, h)
    }

    function u(e) {
      if (e.match(/^[a-z0-9-]*$/i) && e.length <= 59) return e.toLowerCase();
      let t = (0, f.toUtf8CodePoints)(e);
      t = c(t.map(f => {
        if (b.indexOf(f) >= 0) return [];
        if (f >= 65024 && f <= 65039) return [];
        let e = o(f);
        return e || [f]
      })), (t = (0, f.toUtf8CodePoints)((0, f._toUtf8String)(t), f.UnicodeNormalizationForm.NFKC)).forEach(f => {
        if (i(f)) throw new Error("STRINGPREP_CONTAINS_PROHIBITED")
      }), t.forEach(f => {
        if (F(f)) throw new Error("STRINGPREP_CONTAINS_UNASSIGNED")
      });
      let B = (0, f._toUtf8String)(t);
      if ("-" === B.substring(0, 1) || "--" === B.substring(2, 4) || "-" === B.substring(B.length - 1)) throw new Error("invalid hyphen");
      if (B.length > 63) throw new Error("too long");
      return B
    }
  }, {
    "./utf8": "pNhS"
  }],
  "MIM0": [function(require, module, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    }), Object.defineProperty(exports, "formatBytes32String", {
      enumerable: !0,
      get: function() {
        return e.formatBytes32String
      }
    }), Object.defineProperty(exports, "parseBytes32String", {
      enumerable: !0,
      get: function() {
        return e.parseBytes32String
      }
    }), Object.defineProperty(exports, "nameprep", {
      enumerable: !0,
      get: function() {
        return t.nameprep
      }
    }), Object.defineProperty(exports, "_toEscapedUtf8String", {
      enumerable: !0,
      get: function() {
        return r._toEscapedUtf8String
      }
    }), Object.defineProperty(exports, "toUtf8Bytes", {
      enumerable: !0,
      get: function() {
        return r.toUtf8Bytes
      }
    }), Object.defineProperty(exports, "toUtf8CodePoints", {
      enumerable: !0,
      get: function() {
        return r.toUtf8CodePoints
      }
    }), Object.defineProperty(exports, "toUtf8String", {
      enumerable: !0,
      get: function() {
        return r.toUtf8String
      }
    }), Object.defineProperty(exports, "UnicodeNormalizationForm", {
      enumerable: !0,
      get: function() {
        return r.UnicodeNormalizationForm
      }
    }), Object.defineProperty(exports, "Utf8ErrorFuncs", {
      enumerable: !0,
      get: function() {
        return r.Utf8ErrorFuncs
      }
    }), Object.defineProperty(exports, "Utf8ErrorReason", {
      enumerable: !0,
      get: function() {
        return r.Utf8ErrorReason
      }
    });
    var e = require("./bytes32"),
      t = require("./idna"),
      r = require("./utf8");
  }, {
    "./bytes32": "LClc",
    "./idna": "Ieez",
    "./utf8": "pNhS"
  }],
  "MUQK": [function(require, module, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    }), exports.StringCoder = void 0;
    var e = require("@ethersproject/strings"),
      r = require("./bytes");
    class t extends r.DynamicBytesCoder {
      constructor(e) {
        super("string", e)
      }
      encode(r, t) {
        return super.encode(r, (0, e.toUtf8Bytes)(t))
      }
      decode(r) {
        return (0, e.toUtf8String)(super.decode(r))
      }
    }
    exports.StringCoder = t;
  }, {
    "@ethersproject/strings": "MIM0",
    "./bytes": "c7TS"
  }],
  "fgkD": [function(require, module, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    }), exports.TupleCoder = void 0;
    var e = require("./abstract-coder"),
      r = require("./array");
    class t extends e.Coder {
      constructor(e, r) {
        let t = !1;
        const o = [];
        e.forEach(e => {
          e.dynamic && (t = !0), o.push(e.type)
        }), super("tuple", "tuple(" + o.join(",") + ")", r, t), this.coders = e
      }
      encode(e, t) {
        return (0, r.pack)(e, this.coders, t)
      }
      decode(e) {
        return e.coerce(this.name, (0, r.unpack)(e, this.coders))
      }
    }
    exports.TupleCoder = t;
  }, {
    "./abstract-coder": "s6pq",
    "./array": "HtVX"
  }],
  "oY9e": [function(require, module, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    }), exports.defaultAbiCoder = exports.AbiCoder = void 0;
    var e = require("@ethersproject/bytes"),
      r = require("@ethersproject/properties"),
      t = require("@ethersproject/logger"),
      n = require("./_version"),
      o = require("./coders/abstract-coder"),
      s = require("./coders/address"),
      a = require("./coders/array"),
      d = require("./coders/boolean"),
      i = require("./coders/bytes"),
      u = require("./coders/fixed-bytes"),
      c = require("./coders/null"),
      l = require("./coders/number"),
      p = require("./coders/string"),
      g = require("./coders/tuple"),
      h = require("./fragments");
    const m = new t.Logger(n.version),
      y = new RegExp(/^bytes([0-9]*)$/),
      w = new RegExp(/^(u?int)([0-9]*)$/);
    class C {
      constructor(e) {
        m.checkNew(new.target, C), (0, r.defineReadOnly)(this, "coerceFunc", e || null)
      }
      _getCoder(e) {
        switch (e.baseType) {
          case "address":
            return new s.AddressCoder(e.name);
          case "bool":
            return new d.BooleanCoder(e.name);
          case "string":
            return new p.StringCoder(e.name);
          case "bytes":
            return new i.BytesCoder(e.name);
          case "array":
            return new a.ArrayCoder(this._getCoder(e.arrayChildren), e.arrayLength, e.name);
          case "tuple":
            return new g.TupleCoder((e.components || []).map(e => this._getCoder(e)), e.name);
          case "":
            return new c.NullCoder(e.name)
        }
        let r = e.type.match(w);
        if (r) {
          let t = parseInt(r[2] || "256");
          return (0 === t || t > 256 || t % 8 != 0) && m.throwArgumentError("invalid " + r[1] + " bit length", "param", e), new l.NumberCoder(t / 8, "int" === r[1], e.name)
        }
        if (r = e.type.match(y)) {
          let t = parseInt(r[1]);
          return (0 === t || t > 32) && m.throwArgumentError("invalid bytes length", "param", e), new u.FixedBytesCoder(t, e.name)
        }
        return m.throwArgumentError("invalid type", "type", e.type)
      }
      _getWordSize() {
        return 32
      }
      _getReader(e, r) {
        return new o.Reader(e, this._getWordSize(), this.coerceFunc, r)
      }
      _getWriter() {
        return new o.Writer(this._getWordSize())
      }
      encode(e, r) {
        e.length !== r.length && m.throwError("types/values length mismatch", t.Logger.errors.INVALID_ARGUMENT, {
          count: {
            types: e.length,
            values: r.length
          },
          value: {
            types: e,
            values: r
          }
        });
        const n = e.map(e => this._getCoder(h.ParamType.from(e))),
          o = new g.TupleCoder(n, "_"),
          s = this._getWriter();
        return o.encode(s, r), s.data
      }
      decode(r, t, n) {
        const o = r.map(e => this._getCoder(h.ParamType.from(e)));
        return new g.TupleCoder(o, "_").decode(this._getReader((0, e.arrayify)(t), n))
      }
    }
    exports.AbiCoder = C;
    const b = new C;
    exports.defaultAbiCoder = b;
  }, {
    "@ethersproject/bytes": "kHJk",
    "@ethersproject/properties": "miZX",
    "@ethersproject/logger": "M3zR",
    "./_version": "Vg5D",
    "./coders/abstract-coder": "s6pq",
    "./coders/address": "NYbm",
    "./coders/array": "HtVX",
    "./coders/boolean": "kCzJ",
    "./coders/bytes": "c7TS",
    "./coders/fixed-bytes": "Nsfx",
    "./coders/null": "pUNB",
    "./coders/number": "hGGG",
    "./coders/string": "MUQK",
    "./coders/tuple": "fgkD",
    "./fragments": "DSjm"
  }],
  "Kms5": [function(require, module, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    }), exports.id = t;
    var e = require("@ethersproject/keccak256"),
      r = require("@ethersproject/strings");

    function t(t) {
      return (0, e.keccak256)((0, r.toUtf8Bytes)(t))
    }
  }, {
    "@ethersproject/keccak256": "Ko0x",
    "@ethersproject/strings": "MIM0"
  }],
  "C9SN": [function(require, module, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    }), exports.version = void 0;
    const e = "hash/5.1.0";
    exports.version = e;
  }, {}],
  "JaTd": [function(require, module, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    }), exports.isValidName = a, exports.namehash = p;
    var e = require("@ethersproject/bytes"),
      r = require("@ethersproject/strings"),
      t = require("@ethersproject/keccak256"),
      n = require("@ethersproject/logger"),
      o = require("./_version");
    const s = new n.Logger(o.version),
      c = new Uint8Array(32);
    c.fill(0);
    const i = new RegExp("^((.*)\\.)?([^.]+)$");

    function a(e) {
      try {
        const n = e.split(".");
        for (let e = 0; e < n.length; e++)
          if (0 === (0, r.nameprep)(n[e]).length) throw new Error("empty");
        return !0
      } catch (t) {}
      return !1
    }

    function p(n) {
      "string" != typeof n && s.throwArgumentError("invalid address - " + String(n), "name", n);
      let o = c;
      for (; n.length;) {
        const s = n.match(i),
          c = (0, r.toUtf8Bytes)((0, r.nameprep)(s[3]));
        o = (0, t.keccak256)((0, e.concat)([o, (0, t.keccak256)(c)])), n = s[2] || ""
      }
      return (0, e.hexlify)(o)
    }
  }, {
    "@ethersproject/bytes": "kHJk",
    "@ethersproject/strings": "MIM0",
    "@ethersproject/keccak256": "Ko0x",
    "@ethersproject/logger": "M3zR",
    "./_version": "C9SN"
  }],
  "ducl": [function(require, module, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    }), exports.hashMessage = o, exports.messagePrefix = void 0;
    var e = require("@ethersproject/bytes"),
      t = require("@ethersproject/keccak256"),
      r = require("@ethersproject/strings");
    const s = "Ethereum Signed Message:\n";

    function o(o) {
      return "string" == typeof o && (o = (0, r.toUtf8Bytes)(o)), (0, t.keccak256)((0, e.concat)([(0, r.toUtf8Bytes)(s), (0, r.toUtf8Bytes)(String(o.length)), o]))
    }
    exports.messagePrefix = s;
  }, {
    "@ethersproject/bytes": "kHJk",
    "@ethersproject/keccak256": "Ko0x",
    "@ethersproject/strings": "MIM0"
  }],
  "MK9m": [function(require, module, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    }), exports.TypedDataEncoder = void 0;
    var r = require("@ethersproject/address"),
      t = require("@ethersproject/bignumber"),
      e = require("@ethersproject/bytes"),
      n = require("@ethersproject/keccak256"),
      i = require("@ethersproject/properties"),
      o = require("@ethersproject/logger"),
      a = require("./_version"),
      s = require("./id"),
      c = function(r, t, e, n) {
        return new(e || (e = Promise))(function(i, o) {
          function a(r) {
            try {
              c(n.next(r))
            } catch (t) {
              o(t)
            }
          }

          function s(r) {
            try {
              c(n.throw(r))
            } catch (t) {
              o(t)
            }
          }

          function c(r) {
            var t;
            r.done ? i(r.value) : (t = r.value, t instanceof e ? t : new e(function(r) {
              r(t)
            })).then(a, s)
          }
          c((n = n.apply(r, t || [])).next())
        })
      };
    const f = new o.Logger(a.version),
      u = new Uint8Array(32);
    u.fill(0);
    const h = t.BigNumber.from(-1),
      y = t.BigNumber.from(0),
      m = t.BigNumber.from(1),
      d = t.BigNumber.from("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");

    function g(r) {
      const t = (0, e.arrayify)(r),
        n = t.length % 32;
      return n ? (0, e.hexConcat)([t, u.slice(n)]) : (0, e.hexlify)(t)
    }
    const p = (0, e.hexZeroPad)(m.toHexString(), 32),
      l = (0, e.hexZeroPad)(y.toHexString(), 32),
      v = {
        name: "string",
        version: "string",
        chainId: "uint256",
        verifyingContract: "address",
        salt: "bytes32"
      },
      w = ["name", "version", "chainId", "verifyingContract", "salt"];

    function E(r) {
      return function(t) {
        return "string" != typeof t && f.throwArgumentError(`invalid domain value for ${JSON.stringify(r)}`, `domain.${r}`, t), t
      }
    }
    const x = {
      name: E("name"),
      version: E("version"),
      chainId: function(r) {
        try {
          return t.BigNumber.from(r).toString()
        } catch (e) {}
        return f.throwArgumentError('invalid domain value for "chainId"', "domain.chainId", r)
      },
      verifyingContract: function(t) {
        try {
          return (0, r.getAddress)(t).toLowerCase()
        } catch (e) {}
        return f.throwArgumentError('invalid domain value "verifyingContract"', "domain.verifyingContract", t)
      },
      salt: function(r) {
        try {
          const n = (0, e.arrayify)(r);
          if (32 !== n.length) throw new Error("bad length");
          return (0, e.hexlify)(n)
        } catch (t) {}
        return f.throwArgumentError('invalid domain value "salt"', "domain.salt", r)
      }
    };

    function b(i) {
      {
        const r = i.match(/^(u?)int(\d*)$/);
        if (r) {
          const n = "" === r[1],
            o = parseInt(r[2] || "256");
          (o % 8 != 0 || o > 256 || r[2] && r[2] !== String(o)) && f.throwArgumentError("invalid numeric width", "type", i);
          const a = d.mask(n ? o - 1 : o),
            s = n ? a.add(m).mul(h) : y;
          return function(r) {
            const n = t.BigNumber.from(r);
            return (n.lt(s) || n.gt(a)) && f.throwArgumentError(`value out-of-bounds for ${i}`, "value", r), (0, e.hexZeroPad)(n.toTwos(256).toHexString(), 32)
          }
        }
      } {
        const r = i.match(/^bytes(\d+)$/);
        if (r) {
          const t = parseInt(r[1]);
          return (0 === t || t > 32 || r[1] !== String(t)) && f.throwArgumentError("invalid bytes width", "type", i),
            function(r) {
              return (0, e.arrayify)(r).length !== t && f.throwArgumentError(`invalid length for ${i}`, "value", r), g(r)
            }
        }
      }
      switch (i) {
        case "address":
          return function(t) {
            return (0, e.hexZeroPad)((0, r.getAddress)(t), 32)
          };
        case "bool":
          return function(r) {
            return r ? p : l
          };
        case "bytes":
          return function(r) {
            return (0, n.keccak256)(r)
          };
        case "string":
          return function(r) {
            return (0, s.id)(r)
          }
      }
      return null
    }

    function A(r, t) {
      return `${r}(${t.map(({name:r,type:t})=>t+" "+r).join(",")})`
    }
    class k {
      constructor(r) {
        (0, i.defineReadOnly)(this, "types", Object.freeze((0, i.deepCopy)(r))), (0, i.defineReadOnly)(this, "_encoderCache", {}), (0, i.defineReadOnly)(this, "_types", {});
        const t = {},
          e = {},
          n = {};
        Object.keys(r).forEach(r => {
          t[r] = {}, e[r] = [], n[r] = {}
        });
        for (const i in r) {
          const n = {};
          r[i].forEach(o => {
            n[o.name] && f.throwArgumentError(`duplicate variable name ${JSON.stringify(o.name)} in ${JSON.stringify(i)}`, "types", r), n[o.name] = !0;
            const a = o.type.match(/^([^\x5b]*)(\x5b|$)/)[1];
            a === i && f.throwArgumentError(`circular type reference to ${JSON.stringify(a)}`, "types", r), b(a) || (e[a] || f.throwArgumentError(`unknown type ${JSON.stringify(a)}`, "types", r), e[a].push(i), t[i][a] = !0)
          })
        }
        const o = Object.keys(e).filter(r => 0 === e[r].length);
        0 === o.length ? f.throwArgumentError("missing primary type", "types", r) : o.length > 1 && f.throwArgumentError(`ambiguous primary types or unused types: ${o.map(r=>JSON.stringify(r)).join(", ")}`, "types", r), (0, i.defineReadOnly)(this, "primaryType", o[0]),
          function i(o, a) {
            a[o] && f.throwArgumentError(`circular type reference to ${JSON.stringify(o)}`, "types", r), a[o] = !0, Object.keys(t[o]).forEach(r => {
              e[r] && (i(r, a), Object.keys(a).forEach(t => {
                n[t][r] = !0
              }))
            }), delete a[o]
          }(this.primaryType, {});
        for (const i in n) {
          const t = Object.keys(n[i]);
          t.sort(), this._types[i] = A(i, r[i]) + t.map(t => A(t, r[t])).join("")
        }
      }
      getEncoder(r) {
        let t = this._encoderCache[r];
        return t || (t = this._encoderCache[r] = this._getEncoder(r)), t
      }
      _getEncoder(r) {
        {
          const t = b(r);
          if (t) return t
        }
        const t = r.match(/^(.*)(\x5b(\d*)\x5d)$/);
        if (t) {
          const r = t[1],
            i = this.getEncoder(r),
            o = parseInt(t[3]);
          return t => {
            o >= 0 && t.length !== o && f.throwArgumentError("array length mismatch; expected length ${ arrayLength }", "value", t);
            let a = t.map(i);
            return this._types[r] && (a = a.map(n.keccak256)), (0, n.keccak256)((0, e.hexConcat)(a))
          }
        }
        const i = this.types[r];
        if (i) {
          const t = (0, s.id)(this._types[r]);
          return r => {
            const o = i.map(({
              name: t,
              type: e
            }) => {
              const i = this.getEncoder(e)(r[t]);
              return this._types[e] ? (0, n.keccak256)(i) : i
            });
            return o.unshift(t), (0, e.hexConcat)(o)
          }
        }
        return f.throwArgumentError(`unknown type: ${r}`, "type", r)
      }
      encodeType(r) {
        const t = this._types[r];
        return t || f.throwArgumentError(`unknown type: ${JSON.stringify(r)}`, "name", r), t
      }
      encodeData(r, t) {
        return this.getEncoder(r)(t)
      }
      hashStruct(r, t) {
        return (0, n.keccak256)(this.encodeData(r, t))
      }
      encode(r) {
        return this.encodeData(this.primaryType, r)
      }
      hash(r) {
        return this.hashStruct(this.primaryType, r)
      }
      _visit(r, t, e) {
        if (b(r)) return e(r, t);
        const n = r.match(/^(.*)(\x5b(\d*)\x5d)$/);
        if (n) {
          const r = n[1],
            i = parseInt(n[3]);
          return i >= 0 && t.length !== i && f.throwArgumentError("array length mismatch; expected length ${ arrayLength }", "value", t), t.map(t => this._visit(r, t, e))
        }
        const i = this.types[r];
        return i ? i.reduce((r, {
          name: n,
          type: i
        }) => (r[n] = this._visit(i, t[n], e), r), {}) : f.throwArgumentError(`unknown type: ${r}`, "type", r)
      }
      visit(r, t) {
        return this._visit(this.primaryType, r, t)
      }
      static from(r) {
        return new k(r)
      }
      static getPrimaryType(r) {
        return k.from(r).primaryType
      }
      static hashStruct(r, t, e) {
        return k.from(t).hashStruct(r, e)
      }
      static hashDomain(r) {
        const t = [];
        for (const e in r) {
          const n = v[e];
          n || f.throwArgumentError(`invalid typed-data domain key: ${JSON.stringify(e)}`, "domain", r), t.push({
            name: e,
            type: n
          })
        }
        return t.sort((r, t) => w.indexOf(r.name) - w.indexOf(t.name)), k.hashStruct("EIP712Domain", {
          EIP712Domain: t
        }, r)
      }
      static encode(r, t, n) {
        return (0, e.hexConcat)(["0x1901", k.hashDomain(r), k.from(t).hash(n)])
      }
      static hash(r, t, e) {
        return (0, n.keccak256)(k.encode(r, t, e))
      }
      static resolveNames(r, t, n, o) {
        return c(this, void 0, void 0, function*() {
          r = (0, i.shallowCopy)(r);
          const a = {};
          r.verifyingContract && !(0, e.isHexString)(r.verifyingContract, 20) && (a[r.verifyingContract] = "0x");
          const s = k.from(t);
          s.visit(n, (r, t) => ("address" !== r || (0, e.isHexString)(t, 20) || (a[t] = "0x"), t));
          for (const r in a) a[r] = yield o(r);
          return r.verifyingContract && a[r.verifyingContract] && (r.verifyingContract = a[r.verifyingContract]), n = s.visit(n, (r, t) => "address" === r && a[t] ? a[t] : t), {
            domain: r,
            value: n
          }
        })
      }
      static getPayload(r, n, o) {
        k.hashDomain(r);
        const a = {},
          s = [];
        w.forEach(t => {
          const e = r[t];
          null != e && (a[t] = x[t](e), s.push({
            name: t,
            type: v[t]
          }))
        });
        const c = k.from(n),
          u = (0, i.shallowCopy)(n);
        return u.EIP712Domain ? f.throwArgumentError("types must not contain EIP712Domain type", "types.EIP712Domain", n) : u.EIP712Domain = s, c.encode(o), {
          types: u,
          domain: a,
          primaryType: c.primaryType,
          message: c.visit(o, (r, n) => {
            if (r.match(/^bytes(\d*)/)) return (0, e.hexlify)((0, e.arrayify)(n));
            if (r.match(/^u?int/)) return t.BigNumber.from(n).toString();
            switch (r) {
              case "address":
                return n.toLowerCase();
              case "bool":
                return !!n;
              case "string":
                return "string" != typeof n && f.throwArgumentError("invalid string", "value", n), n
            }
            return f.throwArgumentError("unsupported type", "type", r)
          })
        }
      }
    }
    exports.TypedDataEncoder = k;
  }, {
    "@ethersproject/address": "v33u",
    "@ethersproject/bignumber": "BWdp",
    "@ethersproject/bytes": "kHJk",
    "@ethersproject/keccak256": "Ko0x",
    "@ethersproject/properties": "miZX",
    "@ethersproject/logger": "M3zR",
    "./_version": "C9SN",
    "./id": "Kms5"
  }],
  "HcFj": [function(require, module, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    }), Object.defineProperty(exports, "id", {
      enumerable: !0,
      get: function() {
        return e.id
      }
    }), Object.defineProperty(exports, "isValidName", {
      enumerable: !0,
      get: function() {
        return r.isValidName
      }
    }), Object.defineProperty(exports, "namehash", {
      enumerable: !0,
      get: function() {
        return r.namehash
      }
    }), Object.defineProperty(exports, "hashMessage", {
      enumerable: !0,
      get: function() {
        return t.hashMessage
      }
    }), Object.defineProperty(exports, "messagePrefix", {
      enumerable: !0,
      get: function() {
        return t.messagePrefix
      }
    }), Object.defineProperty(exports, "_TypedDataEncoder", {
      enumerable: !0,
      get: function() {
        return n.TypedDataEncoder
      }
    });
    var e = require("./id"),
      r = require("./namehash"),
      t = require("./message"),
      n = require("./typed-data");
  }, {
    "./id": "Kms5",
    "./namehash": "JaTd",
    "./message": "ducl",
    "./typed-data": "MK9m"
  }],
  "VX3Y": [function(require, module, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    }), Object.defineProperty(exports, "checkResultErrors", {
      enumerable: !0,
      get: function() {
        return a.checkResultErrors
      }
    }), exports.Interface = exports.Indexed = exports.TransactionDescription = exports.LogDescription = void 0;
    var e = require("@ethersproject/address"),
      t = require("@ethersproject/bignumber"),
      r = require("@ethersproject/bytes"),
      n = require("@ethersproject/hash"),
      s = require("@ethersproject/keccak256"),
      i = require("@ethersproject/properties"),
      o = require("./abi-coder"),
      a = require("./coders/abstract-coder"),
      c = require("./fragments"),
      u = require("@ethersproject/logger"),
      h = require("./_version");
    const g = new u.Logger(h.version);
    class d extends i.Description {}
    exports.LogDescription = d;
    class p extends i.Description {}
    exports.TransactionDescription = p;
    class l extends i.Description {
      static isIndexed(e) {
        return !(!e || !e._isIndexed)
      }
    }

    function f(e, t) {
      const r = new Error(`deferred error during ABI decoding triggered accessing ${e}`);
      return r.error = t, r
    }
    exports.Indexed = l;
    class m {
      constructor(e) {
        g.checkNew(new.target, m);
        let t = [];
        t = "string" == typeof e ? JSON.parse(e) : e, (0, i.defineReadOnly)(this, "fragments", t.map(e => c.Fragment.from(e)).filter(e => null != e)), (0, i.defineReadOnly)(this, "_abiCoder", (0, i.getStatic)(new.target, "getAbiCoder")()), (0, i.defineReadOnly)(this, "functions", {}), (0, i.defineReadOnly)(this, "errors", {}), (0, i.defineReadOnly)(this, "events", {}), (0, i.defineReadOnly)(this, "structs", {}), this.fragments.forEach(e => {
          let t = null;
          switch (e.type) {
            case "constructor":
              return this.deploy ? void g.warn("duplicate definition - constructor") : void(0, i.defineReadOnly)(this, "deploy", e);
            case "function":
              t = this.functions;
              break;
            case "event":
              t = this.events;
              break;
            default:
              return
          }
          let r = e.format();
          t[r] ? g.warn("duplicate definition - " + r) : t[r] = e
        }), this.deploy || (0, i.defineReadOnly)(this, "deploy", c.ConstructorFragment.from({
          payable: !1,
          type: "constructor"
        })), (0, i.defineReadOnly)(this, "_isInterface", !0)
      }
      format(e) {
        e || (e = c.FormatTypes.full), e === c.FormatTypes.sighash && g.throwArgumentError("interface does not support formatting sighash", "format", e);
        const t = this.fragments.map(t => t.format(e));
        return e === c.FormatTypes.json ? JSON.stringify(t.map(e => JSON.parse(e))) : t
      }
      static getAbiCoder() {
        return o.defaultAbiCoder
      }
      static getAddress(t) {
        return (0, e.getAddress)(t)
      }
      static getSighash(e) {
        return (0, r.hexDataSlice)((0, n.id)(e.format()), 0, 4)
      }
      static getEventTopic(e) {
        return (0, n.id)(e.format())
      }
      getFunction(e) {
        if ((0, r.isHexString)(e)) {
          for (const t in this.functions)
            if (e === this.getSighash(t)) return this.functions[t];
          g.throwArgumentError("no matching function", "sighash", e)
        }
        if (-1 === e.indexOf("(")) {
          const t = e.trim(),
            r = Object.keys(this.functions).filter(e => e.split("(")[0] === t);
          return 0 === r.length ? g.throwArgumentError("no matching function", "name", t) : r.length > 1 && g.throwArgumentError("multiple matching functions", "name", t), this.functions[r[0]]
        }
        const t = this.functions[c.FunctionFragment.fromString(e).format()];
        return t || g.throwArgumentError("no matching function", "signature", e), t
      }
      getEvent(e) {
        if ((0, r.isHexString)(e)) {
          const t = e.toLowerCase();
          for (const e in this.events)
            if (t === this.getEventTopic(e)) return this.events[e];
          g.throwArgumentError("no matching event", "topichash", t)
        }
        if (-1 === e.indexOf("(")) {
          const t = e.trim(),
            r = Object.keys(this.events).filter(e => e.split("(")[0] === t);
          return 0 === r.length ? g.throwArgumentError("no matching event", "name", t) : r.length > 1 && g.throwArgumentError("multiple matching events", "name", t), this.events[r[0]]
        }
        const t = this.events[c.EventFragment.fromString(e).format()];
        return t || g.throwArgumentError("no matching event", "signature", e), t
      }
      getSighash(e) {
        return "string" == typeof e && (e = this.getFunction(e)), (0, i.getStatic)(this.constructor, "getSighash")(e)
      }
      getEventTopic(e) {
        return "string" == typeof e && (e = this.getEvent(e)), (0, i.getStatic)(this.constructor, "getEventTopic")(e)
      }
      _decodeParams(e, t) {
        return this._abiCoder.decode(e, t)
      }
      _encodeParams(e, t) {
        return this._abiCoder.encode(e, t)
      }
      encodeDeploy(e) {
        return this._encodeParams(this.deploy.inputs, e || [])
      }
      decodeFunctionData(e, t) {
        "string" == typeof e && (e = this.getFunction(e));
        const n = (0, r.arrayify)(t);
        return (0, r.hexlify)(n.slice(0, 4)) !== this.getSighash(e) && g.throwArgumentError(`data signature does not match function ${e.name}.`, "data", (0, r.hexlify)(n)), this._decodeParams(e.inputs, n.slice(4))
      }
      encodeFunctionData(e, t) {
        return "string" == typeof e && (e = this.getFunction(e)), (0, r.hexlify)((0, r.concat)([this.getSighash(e), this._encodeParams(e.inputs, t || [])]))
      }
      decodeFunctionResult(e, t) {
        "string" == typeof e && (e = this.getFunction(e));
        let n = (0, r.arrayify)(t),
          s = null,
          i = null;
        switch (n.length % this._abiCoder._getWordSize()) {
          case 0:
            try {
              return this._abiCoder.decode(e.outputs, n)
            } catch (o) {}
            break;
          case 4:
            "0x08c379a0" === (0, r.hexlify)(n.slice(0, 4)) && (i = "Error(string)", s = this._abiCoder.decode(["string"], n.slice(4))[0])
        }
        return g.throwError("call revert exception", u.Logger.errors.CALL_EXCEPTION, {
          method: e.format(),
          errorSignature: i,
          errorArgs: [s],
          reason: s
        })
      }
      encodeFunctionResult(e, t) {
        return "string" == typeof e && (e = this.getFunction(e)), (0, r.hexlify)(this._abiCoder.encode(e.outputs, t || []))
      }
      encodeFilterTopics(e, t) {
        "string" == typeof e && (e = this.getEvent(e)), t.length > e.inputs.length && g.throwError("too many arguments for " + e.format(), u.Logger.errors.UNEXPECTED_ARGUMENT, {
          argument: "values",
          value: t
        });
        let i = [];
        e.anonymous || i.push(this.getEventTopic(e));
        const o = (e, t) => "string" === e.type ? (0, n.id)(t) : "bytes" === e.type ? (0, s.keccak256)((0, r.hexlify)(t)) : ("address" === e.type && this._abiCoder.encode(["address"], [t]), (0, r.hexZeroPad)((0, r.hexlify)(t), 32));
        for (t.forEach((t, r) => {
            let n = e.inputs[r];
            n.indexed ? null == t ? i.push(null) : "array" === n.baseType || "tuple" === n.baseType ? g.throwArgumentError("filtering with tuples or arrays not supported", "contract." + n.name, t) : Array.isArray(t) ? i.push(t.map(e => o(n, e))) : i.push(o(n, t)) : null != t && g.throwArgumentError("cannot filter non-indexed parameters; must be null", "contract." + n.name, t)
          }); i.length && null === i[i.length - 1];) i.pop();
        return i
      }
      encodeEventLog(e, t) {
        "string" == typeof e && (e = this.getEvent(e));
        const r = [],
          i = [],
          o = [];
        return e.anonymous || r.push(this.getEventTopic(e)), t.length !== e.inputs.length && g.throwArgumentError("event arguments/values mismatch", "values", t), e.inputs.forEach((e, a) => {
          const c = t[a];
          if (e.indexed)
            if ("string" === e.type) r.push((0, n.id)(c));
            else if ("bytes" === e.type) r.push((0, s.keccak256)(c));
          else {
            if ("tuple" === e.baseType || "array" === e.baseType) throw new Error("not implemented");
            r.push(this._abiCoder.encode([e.type], [c]))
          } else i.push(e), o.push(c)
        }), {
          data: this._abiCoder.encode(i, o),
          topics: r
        }
      }
      decodeEventLog(e, t, n) {
        if ("string" == typeof e && (e = this.getEvent(e)), null != n && !e.anonymous) {
          let t = this.getEventTopic(e);
          (0, r.isHexString)(n[0], 32) && n[0].toLowerCase() === t || g.throwError("fragment/topic mismatch", u.Logger.errors.INVALID_ARGUMENT, {
            argument: "topics[0]",
            expected: t,
            value: n[0]
          }), n = n.slice(1)
        }
        let s = [],
          i = [],
          o = [];
        e.inputs.forEach((e, t) => {
          e.indexed ? "string" === e.type || "bytes" === e.type || "tuple" === e.baseType || "array" === e.baseType ? (s.push(c.ParamType.fromObject({
            type: "bytes32",
            name: e.name
          })), o.push(!0)) : (s.push(e), o.push(!1)) : (i.push(e), o.push(!1))
        });
        let a = null != n ? this._abiCoder.decode(s, (0, r.concat)(n)) : null,
          h = this._abiCoder.decode(i, t, !0),
          d = [],
          p = 0,
          m = 0;
        e.inputs.forEach((e, t) => {
          if (e.indexed)
            if (null == a) d[t] = new l({
              _isIndexed: !0,
              hash: null
            });
            else if (o[t]) d[t] = new l({
            _isIndexed: !0,
            hash: a[m++]
          });
          else try {
            d[t] = a[m++]
          } catch (r) {
            d[t] = r
          } else try {
            d[t] = h[p++]
          } catch (r) {
            d[t] = r
          }
          if (e.name && null == d[e.name]) {
            const r = d[t];
            r instanceof Error ? Object.defineProperty(d, e.name, {
              get: () => {
                throw f(`property ${JSON.stringify(e.name)}`, r)
              }
            }) : d[e.name] = r
          }
        });
        for (let r = 0; r < d.length; r++) {
          const e = d[r];
          e instanceof Error && Object.defineProperty(d, r, {
            get: () => {
              throw f(`index ${r}`, e)
            }
          })
        }
        return Object.freeze(d)
      }
      parseTransaction(e) {
        let r = this.getFunction(e.data.substring(0, 10).toLowerCase());
        return r ? new p({
          args: this._abiCoder.decode(r.inputs, "0x" + e.data.substring(10)),
          functionFragment: r,
          name: r.name,
          signature: r.format(),
          sighash: this.getSighash(r),
          value: t.BigNumber.from(e.value || "0")
        }) : null
      }
      parseLog(e) {
        let t = this.getEvent(e.topics[0]);
        return !t || t.anonymous ? null : new d({
          eventFragment: t,
          name: t.name,
          signature: t.format(),
          topic: this.getEventTopic(t),
          args: this.decodeEventLog(t, e.data, e.topics)
        })
      }
      static isInterface(e) {
        return !(!e || !e._isInterface)
      }
    }
    exports.Interface = m;
  }, {
    "@ethersproject/address": "v33u",
    "@ethersproject/bignumber": "BWdp",
    "@ethersproject/bytes": "kHJk",
    "@ethersproject/hash": "HcFj",
    "@ethersproject/keccak256": "Ko0x",
    "@ethersproject/properties": "miZX",
    "./abi-coder": "oY9e",
    "./coders/abstract-coder": "s6pq",
    "./fragments": "DSjm",
    "@ethersproject/logger": "M3zR",
    "./_version": "Vg5D"
  }],
  "xnoh": [function(require, module, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    }), Object.defineProperty(exports, "ConstructorFragment", {
      enumerable: !0,
      get: function() {
        return e.ConstructorFragment
      }
    }), Object.defineProperty(exports, "EventFragment", {
      enumerable: !0,
      get: function() {
        return e.EventFragment
      }
    }), Object.defineProperty(exports, "FormatTypes", {
      enumerable: !0,
      get: function() {
        return e.FormatTypes
      }
    }), Object.defineProperty(exports, "Fragment", {
      enumerable: !0,
      get: function() {
        return e.Fragment
      }
    }), Object.defineProperty(exports, "FunctionFragment", {
      enumerable: !0,
      get: function() {
        return e.FunctionFragment
      }
    }), Object.defineProperty(exports, "ParamType", {
      enumerable: !0,
      get: function() {
        return e.ParamType
      }
    }), Object.defineProperty(exports, "AbiCoder", {
      enumerable: !0,
      get: function() {
        return r.AbiCoder
      }
    }), Object.defineProperty(exports, "defaultAbiCoder", {
      enumerable: !0,
      get: function() {
        return r.defaultAbiCoder
      }
    }), Object.defineProperty(exports, "checkResultErrors", {
      enumerable: !0,
      get: function() {
        return t.checkResultErrors
      }
    }), Object.defineProperty(exports, "Indexed", {
      enumerable: !0,
      get: function() {
        return t.Indexed
      }
    }), Object.defineProperty(exports, "Interface", {
      enumerable: !0,
      get: function() {
        return t.Interface
      }
    }), Object.defineProperty(exports, "LogDescription", {
      enumerable: !0,
      get: function() {
        return t.LogDescription
      }
    }), Object.defineProperty(exports, "TransactionDescription", {
      enumerable: !0,
      get: function() {
        return t.TransactionDescription
      }
    });
    var e = require("./fragments"),
      r = require("./abi-coder"),
      t = require("./interface");
  }, {
    "./fragments": "DSjm",
    "./abi-coder": "oY9e",
    "./interface": "VX3Y"
  }],
  "TqCA": [function(require, module, exports) {

    function e(t) {
      return (e = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
        return typeof e
      } : function(e) {
        return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
      })(t)
    }
    var t = require("buffer").Buffer,
      r = require("underscore"),
      n = require("web3-utils"),
      o = require("@ethersproject/abi").AbiCoder,
      a = require("@ethersproject/abi").ParamType,
      i = new o(function(e, t) {
        return !e.match(/^u?int/) || r.isArray(t) || r.isObject(t) && "BN" === t.constructor.name ? t : t.toString()
      });

    function u() {}
    var c = function() {};
    c.prototype.encodeFunctionSignature = function(e) {
      return r.isObject(e) && (e = n._jsonInterfaceMethodToString(e)), n.sha3(e).slice(0, 10)
    }, c.prototype.encodeEventSignature = function(e) {
      return r.isObject(e) && (e = n._jsonInterfaceMethodToString(e)), n.sha3(e)
    }, c.prototype.encodeParameter = function(e, t) {
      return this.encodeParameters([e], [t])
    }, c.prototype.encodeParameters = function(t, r) {
      var n = this;
      return t = n.mapTypes(t), r = r.map(function(r, o) {
        var u = t[o];
        if ("object" === e(u) && u.type && (u = u.type), r = n.formatParam(u, r), "string" == typeof u && u.includes("tuple")) {
          ! function e(t, r) {
            if ("array" === t.name) return r.map(function(r) {
              return e(i._getCoder(a.from(t.type.replace("[]", ""))), r)
            });
            t.coders.forEach(function(t, o) {
              "tuple" === t.name ? e(t, r[o]) : r[o] = n.formatParam(t.name, r[o])
            })
          }(i._getCoder(a.from(u)), r)
        }
        return r
      }), i.encode(t, r)
    }, c.prototype.mapTypes = function(t) {
      var r = this,
        n = [];
      return t.forEach(function(t) {
        if ("object" === e(t) && "function" === t.type && (t = Object.assign({}, t, {
            type: "bytes24"
          })), r.isSimplifiedStructFormat(t)) {
          var o = Object.keys(t)[0];
          n.push(Object.assign(r.mapStructNameAndType(o), {
            components: r.mapStructToCoderFormat(t[o])
          }))
        } else n.push(t)
      }), n
    }, c.prototype.isSimplifiedStructFormat = function(t) {
      return "object" === e(t) && void 0 === t.components && void 0 === t.name
    }, c.prototype.mapStructNameAndType = function(e) {
      var t = "tuple";
      return e.indexOf("[]") > -1 && (t = "tuple[]", e = e.slice(0, -2)), {
        type: t,
        name: e
      }
    }, c.prototype.mapStructToCoderFormat = function(t) {
      var r = this,
        n = [];
      return Object.keys(t).forEach(function(o) {
        "object" !== e(t[o]) ? n.push({
          name: o,
          type: t[o]
        }) : n.push(Object.assign(r.mapStructNameAndType(o), {
          components: r.mapStructToCoderFormat(t[o])
        }))
      }), n
    }, c.prototype.formatParam = function(e, r) {
      var o = this,
        a = new RegExp(/^bytes([0-9]*)$/),
        i = new RegExp(/^bytes([0-9]*)\[\]$/),
        u = new RegExp(/^(u?int)([0-9]*)$/),
        c = new RegExp(/^(u?int)([0-9]*)\[\]$/);
      if (n.isBN(r) || n.isBigNumber(r)) return r.toString(10);
      if (e.match(i) || e.match(c)) return r.map(function(t) {
        return o.formatParam(e.replace("[]", ""), t)
      });
      var p = e.match(u);
      if (p) {
        var s = parseInt(p[2] || "256");
        s / 8 < r.length && (r = n.leftPad(r, s))
      }
      if (p = e.match(a)) {
        t.isBuffer(r) && (r = n.toHex(r));
        var f = parseInt(p[1]);
        if (f) {
          var m = 2 * f;
          "0x" === r.substring(0, 2) && (m += 2), r.length < m && (r = n.rightPad(r, 2 * f))
        }
        r.length % 2 == 1 && (r = "0x0" + r.substring(2))
      }
      return r
    }, c.prototype.encodeFunctionCall = function(e, t) {
      return this.encodeFunctionSignature(e) + this.encodeParameters(e.inputs, t).replace("0x", "")
    }, c.prototype.decodeParameter = function(e, t) {
      return this.decodeParameters([e], t)[0]
    }, c.prototype.decodeParameters = function(e, t) {
      return this.decodeParametersWith(e, t, !1)
    }, c.prototype.decodeParametersWith = function(e, t, n) {
      if (e.length > 0 && (!t || "0x" === t || "0X" === t)) throw new Error("Returned values aren't valid, did it run Out of Gas? You might also see this error if you are not using the correct ABI for the contract you are retrieving data from, requesting data from a block number that does not exist, or querying a node which is not fully synced.");
      var o = i.decode(this.mapTypes(e), "0x" + t.replace(/0x/i, ""), n),
        a = new u;
      return a.__length__ = 0, e.forEach(function(e, t) {
        var n = o[a.__length__];
        n = "0x" === n ? null : n, a[t] = n, r.isObject(e) && e.name && (a[e.name] = n), a.__length__++
      }), a
    }, c.prototype.decodeLog = function(e, t, n) {
      var o = this;
      n = r.isArray(n) ? n : [n], t = t || "";
      var a = [],
        i = [],
        c = 0;
      e.forEach(function(e, t) {
        e.indexed ? (i[t] = ["bool", "int", "uint", "address", "fixed", "ufixed"].find(function(t) {
          return -1 !== e.type.indexOf(t)
        }) ? o.decodeParameter(e.type, n[c]) : n[c], c++) : a[t] = e
      });
      var p = t,
        s = p ? this.decodeParametersWith(a, p, !0) : [],
        f = new u;
      return f.__length__ = 0, e.forEach(function(e, t) {
        f[t] = "string" === e.type ? "" : null, void 0 !== s[t] && (f[t] = s[t]), void 0 !== i[t] && (f[t] = i[t]), e.name && (f[e.name] = f[t]), f.__length__++
      }), f
    };
    var p = new c;
    module.exports = p;
  }, {
    "buffer": "dskh",
    "underscore": "h15N",
    "web3-utils": "uckD",
    "@ethersproject/abi": "xnoh"
  }],
  "vrPZ": [function(require, module, exports) {
    "use strict";
    var t = require("underscore"),
      e = require("web3-core"),
      n = require("web3-core-method"),
      r = require("web3-utils"),
      o = require("web3-core-subscriptions").subscription,
      a = require("web3-core-helpers").formatters,
      s = require("web3-core-helpers").errors,
      i = require("web3-core-promievent"),
      c = require("web3-eth-abi"),
      u = function n(o, i, u) {
        var l = this,
          p = Array.prototype.slice.call(arguments);
        if (!(this instanceof n)) throw new Error('Please use the "new" keyword to instantiate a web3.eth.Contract() object!');
        if (this.setProvider = function() {
            e.packageInit(l, arguments), l.clearSubscriptions = l._requestManager.clearSubscriptions
          }, e.packageInit(this, [this.constructor]), this.clearSubscriptions = this._requestManager.clearSubscriptions, !o || !Array.isArray(o)) throw s.ContractMissingABIError();
        this.options = {};
        var d = p[p.length - 1];
        t.isObject(d) && !t.isArray(d) && (u = d, this.options = t.extend(this.options, this._getOrSetDefaultOptions(u)), t.isObject(i) && (i = null)), Object.defineProperty(this.options, "address", {
          set: function(t) {
            t && (l._address = r.toChecksumAddress(a.inputAddressFormatter(t)))
          },
          get: function() {
            return l._address
          },
          enumerable: !0
        }), Object.defineProperty(this.options, "jsonInterface", {
          set: function(t) {
            return l.methods = {}, l.events = {}, l._jsonInterface = t.map(function(t) {
              var e, n;
              if (t.constant = "view" === t.stateMutability || "pure" === t.stateMutability || t.constant, t.payable = "payable" === t.stateMutability || t.payable, t.name && (n = r._jsonInterfaceMethodToString(t)), "function" === t.type) {
                if (t.signature = c.encodeFunctionSignature(n), e = l._createTxObject.bind({
                    method: t,
                    parent: l
                  }), l.methods[t.name]) {
                  var o = l._createTxObject.bind({
                    method: t,
                    parent: l,
                    nextMethod: l.methods[t.name]
                  });
                  l.methods[t.name] = o
                } else l.methods[t.name] = e;
                l.methods[t.signature] = e, l.methods[n] = e
              } else if ("event" === t.type) {
                t.signature = c.encodeEventSignature(n);
                var a = l._on.bind(l, t.signature);
                l.events[t.name] && "bound " !== l.events[t.name].name || (l.events[t.name] = a), l.events[t.signature] = a, l.events[n] = a
              }
              return t
            }), l.events.allEvents = l._on.bind(l, "allevents"), l._jsonInterface
          },
          get: function() {
            return l._jsonInterface
          },
          enumerable: !0
        });
        var h = this.constructor.defaultAccount,
          m = this.constructor.defaultBlock || "latest";
        Object.defineProperty(this, "handleRevert", {
          get: function() {
            return !1 === l.options.handleRevert || !0 === l.options.handleRevert ? l.options.handleRevert : this.constructor.handleRevert
          },
          set: function(t) {
            l.options.handleRevert = t
          },
          enumerable: !0
        }), Object.defineProperty(this, "defaultCommon", {
          get: function() {
            return l.options.common || this.constructor.defaultCommon
          },
          set: function(t) {
            l.options.common = t
          },
          enumerable: !0
        }), Object.defineProperty(this, "defaultHardfork", {
          get: function() {
            return l.options.hardfork || this.constructor.defaultHardfork
          },
          set: function(t) {
            l.options.hardfork = t
          },
          enumerable: !0
        }), Object.defineProperty(this, "defaultChain", {
          get: function() {
            return l.options.chain || this.constructor.defaultChain
          },
          set: function(t) {
            l.options.chain = t
          },
          enumerable: !0
        }), Object.defineProperty(this, "transactionPollingTimeout", {
          get: function() {
            return 0 === l.options.transactionPollingTimeout ? l.options.transactionPollingTimeout : l.options.transactionPollingTimeout || this.constructor.transactionPollingTimeout
          },
          set: function(t) {
            l.options.transactionPollingTimeout = t
          },
          enumerable: !0
        }), Object.defineProperty(this, "transactionConfirmationBlocks", {
          get: function() {
            return 0 === l.options.transactionConfirmationBlocks ? l.options.transactionConfirmationBlocks : l.options.transactionConfirmationBlocks || this.constructor.transactionConfirmationBlocks
          },
          set: function(t) {
            l.options.transactionConfirmationBlocks = t
          },
          enumerable: !0
        }), Object.defineProperty(this, "transactionBlockTimeout", {
          get: function() {
            return 0 === l.options.transactionBlockTimeout ? l.options.transactionBlockTimeout : l.options.transactionBlockTimeout || this.constructor.transactionBlockTimeout
          },
          set: function(t) {
            l.options.transactionBlockTimeout = t
          },
          enumerable: !0
        }), Object.defineProperty(this, "defaultAccount", {
          get: function() {
            return h
          },
          set: function(t) {
            return t && (h = r.toChecksumAddress(a.inputAddressFormatter(t))), t
          },
          enumerable: !0
        }), Object.defineProperty(this, "defaultBlock", {
          get: function() {
            return m
          },
          set: function(t) {
            return m = t, t
          },
          enumerable: !0
        }), this.methods = {}, this.events = {}, this._address = null, this._jsonInterface = [], this.options.address = i, this.options.jsonInterface = o
      };
    u.setProvider = function(t, n) {
      e.packageInit(this, [t]), this._ethAccounts = n
    }, u.prototype._getCallback = function(e) {
      if (e && t.isFunction(e[e.length - 1])) return e.pop()
    }, u.prototype._checkListener = function(t, e) {
      if (e === t) throw s.ContractReservedEventError(t)
    }, u.prototype._getOrSetDefaultOptions = function(t) {
      var e = t.gasPrice ? String(t.gasPrice) : null,
        n = t.from ? r.toChecksumAddress(a.inputAddressFormatter(t.from)) : null;
      return t.data = t.data || this.options.data, t.from = n || this.options.from, t.gasPrice = e || this.options.gasPrice, t.gas = t.gas || t.gasLimit || this.options.gas, delete t.gasLimit, t
    }, u.prototype._encodeEventABI = function(e, n) {
      var r = (n = n || {}).filter || {},
        o = {};
      if (["fromBlock", "toBlock"].filter(function(t) {
          return void 0 !== n[t]
        }).forEach(function(t) {
          o[t] = a.inputBlockNumberFormatter(n[t])
        }), t.isArray(n.topics)) o.topics = n.topics;
      else {
        if (o.topics = [], e && !e.anonymous && "ALLEVENTS" !== e.name && o.topics.push(e.signature), "ALLEVENTS" !== e.name) {
          var s = e.inputs.filter(function(t) {
            return !0 === t.indexed
          }).map(function(e) {
            var n = r[e.name];
            return n ? t.isArray(n) ? n.map(function(t) {
              return c.encodeParameter(e.type, t)
            }) : c.encodeParameter(e.type, n) : null
          });
          o.topics = o.topics.concat(s)
        }
        o.topics.length || delete o.topics
      }
      return this.options.address && (o.address = this.options.address.toLowerCase()), o
    }, u.prototype._decodeEventABI = function(t) {
      var e = this;
      t.data = t.data || "", t.topics = t.topics || [];
      var n = a.outputLogFormatter(t);
      if ("ALLEVENTS" === e.name && (e = e.jsonInterface.find(function(e) {
          return e.signature === t.topics[0]
        }) || {
          anonymous: !0
        }), e.inputs = e.inputs || [], !e.anonymous) {
        var r = 0;
        e.inputs.forEach(function(t) {
          return t.indexed ? r++ : null
        }), r > 0 && t.topics.length !== r + 1 && (e = {
          anonymous: !0,
          inputs: []
        })
      }
      var o = e.anonymous ? t.topics : t.topics.slice(1);
      return n.returnValues = c.decodeLog(e.inputs, t.data, o), delete n.returnValues.__length__, n.event = e.name, n.signature = e.anonymous || !t.topics[0] ? null : t.topics[0], n.raw = {
        data: n.data,
        topics: n.topics
      }, delete n.data, delete n.topics, n
    }, u.prototype._encodeMethodABI = function() {
      var e = this._method.signature,
        n = this.arguments || [],
        r = !1,
        o = this._parent.options.jsonInterface.filter(function(t) {
          return "constructor" === e && t.type === e || (t.signature === e || t.signature === e.replace("0x", "") || t.name === e) && "function" === t.type
        }).map(function(e) {
          var o = t.isArray(e.inputs) ? e.inputs.length : 0;
          if (o !== n.length) throw new Error("The number of arguments is not matching the methods required number. You need to pass " + o + " arguments.");
          return "function" === e.type && (r = e.signature), t.isArray(e.inputs) ? e.inputs : []
        }).map(function(t) {
          return c.encodeParameters(t, n).replace("0x", "")
        })[0] || "";
      if ("constructor" === e) {
        if (!this._deployData) throw new Error("The contract has no contract data option set. This is necessary to append the constructor parameters.");
        return this._deployData.startsWith("0x") || (this._deployData = "0x" + this._deployData), this._deployData + o
      }
      var a = r ? r + o : o;
      if (!a) throw new Error("Couldn't find a matching contract method named \"" + this._method.name + '".');
      return a
    }, u.prototype._decodeMethodReturn = function(t, e) {
      if (!e) return null;
      e = e.length >= 2 ? e.slice(2) : e;
      var n = c.decodeParameters(t, e);
      return 1 === n.__length__ ? n[0] : (delete n.__length__, n)
    }, u.prototype.deploy = function(e, n) {
      if ((e = e || {}).arguments = e.arguments || [], !(e = this._getOrSetDefaultOptions(e)).data) {
        if ("function" == typeof n) return n(s.ContractMissingDeployDataError());
        throw s.ContractMissingDeployDataError()
      }
      var r = t.find(this.options.jsonInterface, function(t) {
        return "constructor" === t.type
      }) || {};
      return r.signature = "constructor", this._createTxObject.apply({
        method: r,
        parent: this,
        deployData: e.data,
        _ethAccounts: this.constructor._ethAccounts
      }, e.arguments)
    }, u.prototype._generateEventOptions = function() {
      var e = Array.prototype.slice.call(arguments),
        n = this._getCallback(e),
        o = t.isObject(e[e.length - 1]) ? e.pop() : {},
        a = t.isString(e[0]) ? e[0] : "allevents",
        i = "allevents" === a.toLowerCase() ? {
          name: "ALLEVENTS",
          jsonInterface: this.options.jsonInterface
        } : this.options.jsonInterface.find(function(t) {
          return "event" === t.type && (t.name === a || t.signature === "0x" + a.replace("0x", ""))
        });
      if (!i) throw s.ContractEventDoesNotExistError(a);
      if (!r.isAddress(this.options.address)) throw s.ContractNoAddressDefinedError();
      return {
        params: this._encodeEventABI(i, o),
        event: i,
        callback: n
      }
    }, u.prototype.clone = function() {
      return new this.constructor(this.options.jsonInterface, this.options.address, this.options)
    }, u.prototype.once = function(e, n, r) {
      var o = Array.prototype.slice.call(arguments);
      if (!(r = this._getCallback(o))) throw s.ContractOnceRequiresCallbackError();
      n && delete n.fromBlock, this._on(e, n, function(e, n, o) {
        o.unsubscribe(), t.isFunction(r) && r(e, n, o)
      })
    }, u.prototype._on = function() {
      var e = this._generateEventOptions.apply(this, arguments);
      e.params && e.params.toBlock && (delete e.params.toBlock, console.warn("Invalid option: toBlock. Use getPastEvents for specific range.")), this._checkListener("newListener", e.event.name), this._checkListener("removeListener", e.event.name);
      var n = new o({
        subscription: {
          params: 1,
          inputFormatter: [a.inputLogFormatter],
          outputFormatter: this._decodeEventABI.bind(e.event),
          subscriptionHandler: function(e) {
            e.removed ? this.emit("changed", e) : this.emit("data", e), t.isFunction(this.callback) && this.callback(null, e, this)
          }
        },
        type: "eth",
        requestManager: this._requestManager
      });
      return n.subscribe("logs", e.params, e.callback || function() {}), n
    }, u.prototype.getPastEvents = function() {
      var t = this._generateEventOptions.apply(this, arguments),
        e = new n({
          name: "getPastLogs",
          call: "eth_getLogs",
          params: 1,
          inputFormatter: [a.inputLogFormatter],
          outputFormatter: this._decodeEventABI.bind(t.event)
        });
      e.setRequestManager(this._requestManager);
      var r = e.buildCall();
      return e = null, r(t.params, t.callback)
    }, u.prototype._createTxObject = function() {
      var t = Array.prototype.slice.call(arguments),
        e = {};
      if ("function" === this.method.type && (e.call = this.parent._executeMethod.bind(e, "call"), e.call.request = this.parent._executeMethod.bind(e, "call", !0)), e.send = this.parent._executeMethod.bind(e, "send"), e.send.request = this.parent._executeMethod.bind(e, "send", !0), e.encodeABI = this.parent._encodeMethodABI.bind(e), e.estimateGas = this.parent._executeMethod.bind(e, "estimate"), t && this.method.inputs && t.length !== this.method.inputs.length) {
        if (this.nextMethod) return this.nextMethod.apply(null, t);
        throw s.InvalidNumberOfParams(t.length, this.method.inputs.length, this.method.name)
      }
      return e.arguments = t || [], e._method = this.method, e._parent = this.parent, e._ethAccounts = this.parent.constructor._ethAccounts || this._ethAccounts, this.deployData && (e._deployData = this.deployData), e
    }, u.prototype._processExecuteArguments = function(e, n) {
      var o = {};
      if (o.type = e.shift(), o.callback = this._parent._getCallback(e), "call" === o.type && !0 !== e[e.length - 1] && (t.isString(e[e.length - 1]) || isFinite(e[e.length - 1])) && (o.defaultBlock = e.pop()), o.options = t.isObject(e[e.length - 1]) ? e.pop() : {}, o.generateRequest = !0 === e[e.length - 1] && e.pop(), o.options = this._parent._getOrSetDefaultOptions(o.options), o.options.data = this.encodeABI(), !this._deployData && !r.isAddress(this._parent.options.address)) throw s.ContractNoAddressDefinedError();
      return this._deployData || (o.options.to = this._parent.options.address), o.options.data ? o : r._fireError(new Error("Couldn't find a matching contract method, or the number of parameters is wrong."), n.eventEmitter, n.reject, o.callback)
    }, u.prototype._executeMethod = function() {
      var e = this,
        o = this._parent._processExecuteArguments.call(this, Array.prototype.slice.call(arguments), u),
        u = i("send" !== o.type),
        l = e.constructor._ethAccounts || e._ethAccounts;
      if (o.generateRequest) {
        var p = {
          params: [a.inputCallFormatter.call(this._parent, o.options)],
          callback: o.callback
        };
        return "call" === o.type ? (p.params.push(a.inputDefaultBlockNumberFormatter.call(this._parent, o.defaultBlock)), p.method = "eth_call", p.format = this._parent._decodeMethodReturn.bind(null, this._method.outputs)) : p.method = "eth_sendTransaction", p
      }
      switch (o.type) {
        case "estimate":
          return new n({
            name: "estimateGas",
            call: "eth_estimateGas",
            params: 1,
            inputFormatter: [a.inputCallFormatter],
            outputFormatter: r.hexToNumber,
            requestManager: e._parent._requestManager,
            accounts: l,
            defaultAccount: e._parent.defaultAccount,
            defaultBlock: e._parent.defaultBlock
          }).createFunction()(o.options, o.callback);
        case "call":
          return new n({
            name: "call",
            call: "eth_call",
            params: 2,
            inputFormatter: [a.inputCallFormatter, a.inputDefaultBlockNumberFormatter],
            outputFormatter: function(t) {
              return e._parent._decodeMethodReturn(e._method.outputs, t)
            },
            requestManager: e._parent._requestManager,
            accounts: l,
            defaultAccount: e._parent.defaultAccount,
            defaultBlock: e._parent.defaultBlock,
            handleRevert: e._parent.handleRevert,
            abiCoder: c
          }).createFunction()(o.options, o.defaultBlock, o.callback);
        case "send":
          if (!r.isAddress(o.options.from)) return r._fireError(s.ContractNoFromAddressDefinedError(), u.eventEmitter, u.reject, o.callback);
          if (t.isBoolean(this._method.payable) && !this._method.payable && o.options.value && o.options.value > 0) return r._fireError(new Error("Can not send value to non-payable contract method or constructor"), u.eventEmitter, u.reject, o.callback);
          var d = {
            receiptFormatter: function(n) {
              if (t.isArray(n.logs)) {
                var r = t.map(n.logs, function(t) {
                  return e._parent._decodeEventABI.call({
                    name: "ALLEVENTS",
                    jsonInterface: e._parent.options.jsonInterface
                  }, t)
                });
                n.events = {};
                var o = 0;
                r.forEach(function(t) {
                  t.event ? n.events[t.event] ? Array.isArray(n.events[t.event]) ? n.events[t.event].push(t) : n.events[t.event] = [n.events[t.event], t] : n.events[t.event] = t : (n.events[o] = t, o++)
                }), delete n.logs
              }
              return n
            },
            contractDeployFormatter: function(t) {
              var n = e._parent.clone();
              return n.options.address = t.contractAddress, n
            }
          };
          return new n({
            name: "sendTransaction",
            call: "eth_sendTransaction",
            params: 1,
            inputFormatter: [a.inputTransactionFormatter],
            requestManager: e._parent._requestManager,
            accounts: e.constructor._ethAccounts || e._ethAccounts,
            defaultAccount: e._parent.defaultAccount,
            defaultBlock: e._parent.defaultBlock,
            transactionBlockTimeout: e._parent.transactionBlockTimeout,
            transactionConfirmationBlocks: e._parent.transactionConfirmationBlocks,
            transactionPollingTimeout: e._parent.transactionPollingTimeout,
            defaultCommon: e._parent.defaultCommon,
            defaultChain: e._parent.defaultChain,
            defaultHardfork: e._parent.defaultHardfork,
            handleRevert: e._parent.handleRevert,
            extraFormatters: d,
            abiCoder: c
          }).createFunction()(o.options, o.callback);
        default:
          throw new Error('Method "' + o.type + '" not implemented.')
      }
    }, module.exports = u;
  }, {
    "underscore": "h15N",
    "web3-core": "KUai",
    "web3-core-method": "pw7F",
    "web3-utils": "uckD",
    "web3-core-subscriptions": "Sn3u",
    "web3-core-helpers": "EoeS",
    "web3-core-promievent": "J2II",
    "web3-eth-abi": "TqCA"
  }],
  "zfoe": [function(require, module, exports) {
    var define;
    var n;

    function r(n) {
      return (r = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(n) {
        return typeof n
      } : function(n) {
        return n && "function" == typeof Symbol && n.constructor === Symbol && n !== Symbol.prototype ? "symbol" : typeof n
      })(n)
    }! function(t, e) {
      "function" == typeof n && n.amd ? n([], function() {
        return e()
      }) : "object" === ("undefined" == typeof exports ? "undefined" : r(exports)) ? module.exports = e() : t.uts46_map = e()
    }(this, function() {
      var n = [new Uint32Array([2157250, 2157314, 2157378, 2157442, 2157506, 2157570, 2157634, 0, 2157698, 2157762, 2157826, 2157890, 2157954, 0, 2158018, 0]), new Uint32Array([2179041, 6291456, 2179073, 6291456, 2179105, 6291456, 2179137, 6291456, 2179169, 6291456, 2179201, 6291456, 2179233, 6291456, 2179265, 6291456]), new Uint32Array([6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 14680064, 14680064, 14680064, 14680064, 14680064]), new Uint32Array([0, 2113729, 2197345, 2197377, 2113825, 2197409, 2197441, 2113921, 2197473, 2114017, 2197505, 2197537, 2197569, 2197601, 2197633, 2197665]), new Uint32Array([6291456, 6291456, 6291456, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 6291456, 23068672, 23068672, 0, 0]), new Uint32Array([6291456, 6291456, 6291456, 6291456, 0, 0, 0, 0, 23068672, 23068672, 23068672, 0, 0, 0, 0, 23068672]), new Uint32Array([14680064, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 14680064, 14680064]), new Uint32Array([2196001, 2196033, 2196065, 2196097, 2196129, 2196161, 2196193, 2196225, 2196257, 2196289, 2196321, 2196353, 2196385, 2196417, 2196449, 2196481]), new Uint32Array([6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 23068672, 6291456, 0, 0, 0, 0, 0]), new Uint32Array([2097281, 2105921, 2097729, 2106081, 0, 2097601, 2162337, 2106017, 2133281, 2097505, 2105889, 2097185, 2097697, 2135777, 2097633, 2097441]), new Uint32Array([2177025, 6291456, 2177057, 6291456, 2177089, 6291456, 2177121, 6291456, 2177153, 6291456, 2177185, 6291456, 2177217, 6291456, 2177249, 6291456]), new Uint32Array([6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 0, 6291456, 6291456, 6291456, 6291456, 6291456]), new Uint32Array([6291456, 6291456, 6291456, 0, 6291456, 6291456, 0, 0, 0, 0, 0, 6291456, 6291456, 6291456, 6291456, 6291456]), new Uint32Array([6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 0, 0, 0, 6291456]), new Uint32Array([0, 23068672, 23068672, 23068672, 0, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 0, 0, 0, 0, 6291456]), new Uint32Array([2134435, 2134531, 2134627, 2134723, 2134723, 2134819, 2134819, 2134915, 2134915, 2135011, 2105987, 2135107, 2135203, 2135299, 2131587, 2135395]), new Uint32Array([0, 0, 0, 0, 0, 0, 0, 6291456, 2168673, 2169249, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456]), new Uint32Array([2147906, 2147970, 2148034, 2148098, 2148162, 2148226, 2148290, 2148354, 2147906, 2147970, 2148034, 2148098, 2148162, 2148226, 2148290, 2148354]), new Uint32Array([2125219, 2125315, 2152834, 2152898, 2125411, 2152962, 2153026, 2125506, 2125507, 2125603, 2153090, 2153154, 2153218, 2153282, 2153346, 2105348]), new Uint32Array([2203393, 6291456, 2203425, 6291456, 2203457, 6291456, 2203489, 6291456, 6291456, 6291456, 6291456, 2203521, 6291456, 2181281, 6291456, 6291456]), new Uint32Array([6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 23068672, 23068672, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456]), new Uint32Array([6291456, 23068672, 6291456, 2145538, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 0, 0, 0, 0, 6291456]), new Uint32Array([2139426, 2160834, 2160898, 2160962, 2134242, 2161026, 2161090, 2161154, 2161218, 2161282, 2161346, 2161410, 2138658, 2161474, 2161538, 2134722]), new Uint32Array([2119939, 2124930, 2125026, 2106658, 2125218, 2128962, 2129058, 2129154, 2129250, 2129346, 2129442, 2108866, 2108770, 2150466, 2150530, 2150594]), new Uint32Array([2201601, 6291456, 2201633, 6291456, 2201665, 6291456, 2201697, 6291456, 2201729, 6291456, 2201761, 6291456, 2201793, 6291456, 2201825, 6291456]), new Uint32Array([2193537, 2193569, 2193601, 2193633, 2193665, 2193697, 2193729, 2193761, 2193793, 2193825, 2193857, 2193889, 2193921, 2193953, 2193985, 2194017]), new Uint32Array([6291456, 23068672, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456]), new Uint32Array([0, 6291456, 6291456, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]), new Uint32Array([2190561, 6291456, 2190593, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 2190625, 6291456, 2190657, 6291456, 23068672]), new Uint32Array([2215905, 2215937, 2215969, 2216001, 2216033, 2216065, 2216097, 2216129, 2216161, 2216193, 2216225, 2216257, 2105441, 2216289, 2216321, 2216353]), new Uint32Array([23068672, 18884130, 23068672, 23068672, 23068672, 6291456, 23068672, 23068672, 6291456, 6291456, 6291456, 6291456, 6291456, 23068672, 23068672, 23068672]), new Uint32Array([23068672, 23068672, 0, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672]), new Uint32Array([6291456, 6291456, 23068672, 23068672, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]), new Uint32Array([6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672]), new Uint32Array([2191233, 2191265, 2191297, 2191329, 2191361, 2191393, 2191425, 2117377, 2191457, 2191489, 2191521, 2191553, 2191585, 2191617, 2191649, 2117953]), new Uint32Array([2132227, 2132323, 2132419, 2132419, 2132515, 2132515, 2132611, 2132707, 2132707, 2132803, 2132899, 2132899, 2132995, 2132995, 2133091, 2133187]), new Uint32Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456]), new Uint32Array([23068672, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 23068672, 23068672, 23068672, 6291456, 0, 0]), new Uint32Array([2112481, 2112577, 2098177, 2098305, 2108321, 2108289, 2100865, 2113153, 2108481, 2113345, 2113441, 10609889, 10610785, 10609921, 10610817, 2222241]), new Uint32Array([6291456, 6291456, 6291456, 23068672, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 23068672, 23068672, 0, 0]), new Uint32Array([2219969, 2157121, 2157441, 2157505, 2157889, 2157953, 2220001, 2158465, 2158529, 10575617, 2156994, 2157058, 2129923, 2130019, 2157122, 2157186]), new Uint32Array([6291456, 6291456, 6291456, 6291456, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 0, 0, 0, 0, 0]), new Uint32Array([2185249, 6291456, 2185281, 6291456, 2185313, 6291456, 2185345, 6291456, 2185377, 6291456, 2185409, 6291456, 2185441, 6291456, 2185473, 6291456]), new Uint32Array([0, 0, 0, 0, 6291456, 6291456, 6291456, 6291456, 0, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456]), new Uint32Array([6291456, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672]), new Uint32Array([23068672, 23068672, 23068672, 23068672, 23068672, 0, 0, 23068672, 23068672, 0, 0, 23068672, 23068672, 23068672, 6291456, 0]), new Uint32Array([2183361, 6291456, 2183393, 6291456, 2183425, 6291456, 2183457, 6291456, 2183489, 6291456, 2183521, 6291456, 2183553, 6291456, 2183585, 6291456]), new Uint32Array([2192161, 2192193, 2192225, 2192257, 2192289, 2192321, 2192353, 2192385, 2192417, 2192449, 2192481, 2192513, 2192545, 2192577, 2192609, 2192641]), new Uint32Array([2212001, 2212033, 2212065, 2212097, 2212129, 2212161, 2212193, 2212225, 2212257, 2212289, 2212321, 2212353, 2212385, 2212417, 2212449, 2207265]), new Uint32Array([2249825, 2249857, 2249889, 2249921, 2249954, 2250018, 2250082, 2250145, 2250177, 2250209, 2250241, 2250274, 2250337, 2250370, 2250433, 2250465]), new Uint32Array([6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 2147905, 2147969, 2148033, 2148097, 2148161, 2148225, 2148289, 2148353]), new Uint32Array([10485857, 6291456, 2197217, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456]), new Uint32Array([6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 0, 0, 0, 0, 23068672, 23068672]), new Uint32Array([0, 23068672, 23068672, 23068672, 0, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 0, 6291456, 6291456]), new Uint32Array([2180353, 2180385, 2144033, 2180417, 2180449, 2180481, 2180513, 0, 0, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456]), new Uint32Array([2112481, 2112577, 2098177, 2098305, 2108321, 2108289, 2100865, 2113153, 2108481, 2113345, 2113441, 10610209, 10610465, 10610241, 10610753, 10609857]), new Uint32Array([6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 23068672, 0, 0]), new Uint32Array([2223842, 2223906, 2223970, 2224034, 2224098, 2224162, 2224226, 2224290, 2224354, 2224418, 2224482, 2224546, 2224610, 2224674, 2224738, 2224802]), new Uint32Array([6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 23068672, 23068672, 23068672, 23068672, 6291456, 23068672, 23068672, 23068672, 23068672, 23068672]), new Uint32Array([6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 0, 6291456]), new Uint32Array([23068672, 23068672, 23068672, 18923650, 23068672, 23068672, 23068672, 23068672, 0, 23068672, 23068672, 23068672, 23068672, 18923714, 23068672, 23068672]), new Uint32Array([2126179, 2125538, 2126275, 2126371, 2126467, 2125634, 2126563, 2105603, 2105604, 2125346, 2126659, 2126755, 2126851, 2098179, 2098181, 2098182]), new Uint32Array([2227426, 2227490, 2227554, 2227618, 0, 0, 0, 0, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456]), new Uint32Array([2192353, 2240642, 2240642, 2240705, 2240737, 2240737, 2240769, 2240802, 2240866, 2240929, 2240961, 2240993, 2241025, 2241057, 2241089, 2241121]), new Uint32Array([6291456, 2170881, 2170913, 2170945, 6291456, 2170977, 6291456, 2171009, 2171041, 6291456, 6291456, 6291456, 2171073, 6291456, 6291456, 6291456]), new Uint32Array([6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672]), new Uint32Array([2132226, 2132514, 2163586, 2132610, 2160386, 2133090, 2133186, 2160450, 2160514, 2160578, 2133570, 2106178, 2160642, 2133858, 2160706, 2160770]), new Uint32Array([6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 0, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456]), new Uint32Array([6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 10532162, 10532226, 10532290, 10532354, 10532418, 10532482, 6291456, 6291456]), new Uint32Array([6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 0, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456]), new Uint32Array([23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 6291456, 23068672]), new Uint32Array([2098209, 2108353, 2108193, 2108481, 2170241, 2111713, 2105473, 2105569, 2105601, 2112289, 2112481, 2098305, 2108321, 0, 0, 0]), new Uint32Array([2209121, 2209153, 2209185, 2209217, 2209249, 2209281, 2209313, 2209345, 2209377, 2209409, 2209441, 2209473, 2207265, 2209505, 2209537, 2209569]), new Uint32Array([2189025, 6291456, 2189057, 6291456, 2189089, 6291456, 2189121, 6291456, 2189153, 6291456, 2189185, 6291456, 2189217, 6291456, 2189249, 6291456]), new Uint32Array([2173825, 2153473, 2173857, 2173889, 2173921, 2173953, 2173985, 2173761, 2174017, 2174049, 2174081, 2174113, 2174145, 2174177, 2149057, 2233057]), new Uint32Array([6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 2165764, 2140004]), new Uint32Array([2215105, 6291456, 2215137, 6291456, 6291456, 2215169, 2215201, 6291456, 6291456, 6291456, 2215233, 2215265, 2215297, 2215329, 2215361, 2215393]), new Uint32Array([6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 0, 0, 6291456, 0, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456]), new Uint32Array([23068672, 23068672, 6291456, 6291456, 6291456, 23068672, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]), new Uint32Array([10505091, 10505187, 10505283, 10505379, 10505475, 10505571, 10505667, 10505763, 10505859, 10505955, 10506051, 10506147, 10506243, 10506339, 10506435, 10506531]), new Uint32Array([2229730, 2229794, 2229858, 2229922, 2229986, 2230050, 2230114, 2230178, 2230242, 2230306, 2230370, 2230434, 2230498, 2230562, 2230626, 2230690]), new Uint32Array([2105505, 2098241, 2108353, 2108417, 2105825, 0, 2100897, 2111905, 2105473, 2105569, 2105601, 2112289, 2108193, 2112481, 2112577, 2098177]), new Uint32Array([6291456, 6291456, 6291456, 6291456, 10502115, 10502178, 10502211, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456]), new Uint32Array([0, 23068672, 23068672, 23068672, 0, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 0, 0, 6291456]), new Uint32Array([2190305, 6291456, 2190337, 6291456, 2190369, 6291456, 2190401, 6291456, 2190433, 6291456, 2190465, 6291456, 2190497, 6291456, 2190529, 6291456]), new Uint32Array([2173793, 2173985, 2174017, 6291456, 2173761, 2173697, 6291456, 2174689, 6291456, 2174017, 2174721, 6291456, 6291456, 2174753, 2174785, 2174817]), new Uint32Array([6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456]), new Uint32Array([2099521, 2099105, 2120705, 2098369, 2120801, 2103361, 2097985, 2098433, 2121377, 2121473, 2099169, 2099873, 2098401, 2099393, 2152609, 2100033]), new Uint32Array([2132898, 2163842, 2163906, 2133282, 2132034, 2131938, 2137410, 2132802, 2132706, 2164866, 2133282, 2160578, 2165186, 2165186, 6291456, 6291456]), new Uint32Array([10500003, 10500099, 10500195, 10500291, 10500387, 10500483, 10500579, 10500675, 10500771, 10500867, 10500963, 10501059, 10501155, 10501251, 10501347, 10501443]), new Uint32Array([2163458, 2130978, 2131074, 2131266, 2131362, 2163522, 2160130, 2132066, 2131010, 2131106, 2106018, 2131618, 2131298, 2132034, 2131938, 2137410]), new Uint32Array([2212961, 2116993, 2212993, 2213025, 2213057, 2213089, 2213121, 2213153, 2213185, 2213217, 2213249, 2209633, 2213281, 2213313, 2213345, 2213377]), new Uint32Array([6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 23068672, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 0, 6291456, 6291456]), new Uint32Array([2113729, 2113825, 2113921, 2114017, 2114113, 2114209, 2114305, 2114401, 2114497, 2114593, 2114689, 2114785, 2114881, 2114977, 2115073, 2115169]), new Uint32Array([2238177, 2238209, 2238241, 2238273, 2238305, 2238337, 2238337, 2217537, 2238369, 2238401, 2238433, 2238465, 2215649, 2238497, 2238529, 2238561]), new Uint32Array([2108289, 2100865, 2113153, 2108481, 2113345, 2113441, 2098209, 2111137, 2105505, 2098241, 2108353, 2108417, 2105825, 2111713, 2100897, 2111905]), new Uint32Array([6291456, 6291456, 0, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 0, 6291456, 0, 0]), new Uint32Array([6291456, 0, 6291456, 2145026, 0, 6291456, 2145090, 0, 6291456, 6291456, 0, 0, 23068672, 0, 23068672, 23068672]), new Uint32Array([2099233, 2122017, 2200673, 2098113, 2121537, 2103201, 2200705, 2104033, 2121857, 2121953, 2122401, 2099649, 2099969, 2123009, 2100129, 2100289]), new Uint32Array([6291456, 23068672, 6291456, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]), new Uint32Array([6291456, 6291456, 23068672, 23068672, 0, 0, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 0, 0, 0]), new Uint32Array([2187681, 2187713, 2187745, 2187777, 2187809, 2187841, 2187873, 2187905, 2187937, 2187969, 2188001, 2188033, 2188065, 2188097, 2188129, 2188161]), new Uint32Array([0, 10554498, 10554562, 10554626, 10554690, 10554754, 10554818, 10554882, 10554946, 10555010, 10555074, 6291456, 6291456, 0, 0, 0]), new Uint32Array([2235170, 2235234, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456]), new Uint32Array([6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 0, 0, 0, 0, 0, 0, 0]), new Uint32Array([2181153, 6291456, 2188897, 6291456, 6291456, 2188929, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 2111905, 2100865, 2188961, 2188993]), new Uint32Array([2100833, 2100897, 0, 0, 2101569, 2101697, 2101825, 2101953, 2102081, 2102209, 10575617, 2187041, 10502177, 10489601, 10489697, 2112289]), new Uint32Array([6291456, 2172833, 6291456, 2172865, 2172897, 2172929, 2172961, 6291456, 2172993, 6291456, 2173025, 6291456, 2173057, 6291456, 2173089, 6291456]), new Uint32Array([6291456, 0, 6291456, 6291456, 0, 6291456, 6291456, 6291456, 6291456, 6291456, 0, 0, 23068672, 6291456, 23068672, 23068672]), new Uint32Array([6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 0, 0, 0, 0, 0, 0, 0, 2190721]), new Uint32Array([23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 6291456, 6291456, 6291456, 6291456, 23068672, 6291456, 6291456]), new Uint32Array([2184993, 6291456, 2185025, 6291456, 2185057, 6291456, 2185089, 6291456, 2185121, 6291456, 2185153, 6291456, 2185185, 6291456, 2185217, 6291456]), new Uint32Array([2115265, 2115361, 2115457, 2115553, 2115649, 2115745, 2115841, 2115937, 2116033, 2116129, 2116225, 2116321, 2150658, 2150722, 2200225, 6291456]), new Uint32Array([2168321, 6291456, 2168353, 6291456, 2168385, 6291456, 2168417, 6291456, 2168449, 6291456, 2168481, 6291456, 2168513, 6291456, 2168545, 6291456]), new Uint32Array([23068672, 23068672, 23068672, 6291456, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672]), new Uint32Array([6291456, 0, 6291456, 6291456, 6291456, 6291456, 0, 0, 0, 6291456, 6291456, 0, 6291456, 0, 6291456, 6291456]), new Uint32Array([6291456, 6291456, 6291456, 2186625, 0, 0, 6291456, 6291456, 2186657, 2186689, 2186721, 2173505, 0, 10496067, 10496163, 10496259]), new Uint32Array([2178785, 6291456, 2178817, 6291456, 2178849, 6291456, 2178881, 6291456, 2178913, 6291456, 2178945, 6291456, 2178977, 6291456, 2179009, 6291456]), new Uint32Array([6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 0, 0, 0, 0, 0]), new Uint32Array([2097152, 0, 0, 0, 2097152, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]), new Uint32Array([6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 6291456, 6291456]), new Uint32Array([6291456, 0, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456]), new Uint32Array([0, 0, 2197857, 2197889, 2197921, 2197953, 2197985, 2198017, 0, 0, 2198049, 2198081, 2198113, 2198145, 2198177, 2198209]), new Uint32Array([6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 2098209, 2167297, 2111137, 6291456]), new Uint32Array([2171393, 6291456, 2171425, 6291456, 2171457, 6291456, 2171489, 6291456, 2171521, 6291456, 2171553, 6291456, 2171585, 6291456, 2171617, 6291456]), new Uint32Array([2206753, 2206785, 2195457, 2206817, 2206849, 2206881, 2206913, 2197153, 2197153, 2206945, 2117857, 2206977, 2207009, 2207041, 2207073, 2207105]), new Uint32Array([0, 0, 0, 0, 0, 0, 0, 23068672, 0, 0, 0, 0, 2144834, 2144898, 0, 2144962]), new Uint32Array([23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 0, 0, 23068672]), new Uint32Array([2108193, 2112481, 2112577, 2098177, 2098305, 2108321, 2108289, 2100865, 2113153, 2108481, 2113345, 2113441, 2098209, 0, 2105505, 2098241]), new Uint32Array([6291456, 6291456, 6291456, 6291456, 0, 6291456, 6291456, 6291456, 0, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456]), new Uint32Array([6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 0, 0, 0, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456]), new Uint32Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]), new Uint32Array([6291456, 6291456, 2202049, 6291456, 2202081, 6291456, 2202113, 6291456, 2202145, 6291456, 2202177, 6291456, 2202209, 6291456, 2202241, 6291456]), new Uint32Array([10501155, 10501251, 10501347, 10501443, 10501539, 10501635, 10501731, 10501827, 10501923, 10502019, 2141731, 2105505, 2098177, 2155586, 2166530, 0]), new Uint32Array([2102081, 2102209, 2100833, 2100737, 2098337, 2101441, 2101569, 2101697, 2101825, 2101953, 2102081, 2102209, 2100833, 2100737, 2098337, 2101441]), new Uint32Array([2146882, 2146946, 2147010, 2147074, 2147138, 2147202, 2147266, 2147330, 2146882, 2146946, 2147010, 2147074, 2147138, 2147202, 2147266, 2147330]), new Uint32Array([23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 0, 0]), new Uint32Array([10502307, 10502403, 10502499, 10502595, 10502691, 10502787, 10502883, 10502979, 10503075, 10503171, 10503267, 10503363, 10503459, 10503555, 10503651, 10503747]), new Uint32Array([2179937, 2179969, 2180001, 2180033, 2156545, 2180065, 2156577, 2180097, 2180129, 2180161, 2180193, 2180225, 2180257, 2180289, 2156737, 2180321]), new Uint32Array([6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 0, 6291456, 6291456, 0, 0, 0, 6291456, 0, 0, 6291456]), new Uint32Array([6291456, 6291456, 6291456, 6291456, 6291456, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 0]), new Uint32Array([2227682, 2227746, 2227810, 2227874, 2227938, 2228002, 2228066, 2228130, 2228194, 2228258, 2228322, 2228386, 2228450, 2228514, 2228578, 2228642]), new Uint32Array([2105601, 2169121, 2108193, 2170049, 2181025, 2181057, 2112481, 2108321, 2108289, 2181089, 2170497, 2100865, 2181121, 2173601, 2173633, 2173665]), new Uint32Array([6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 2180641, 6291456, 6291456, 6291456]), new Uint32Array([0, 6291456, 6291456, 6291456, 0, 6291456, 0, 6291456, 0, 0, 6291456, 6291456, 0, 6291456, 6291456, 6291456]), new Uint32Array([2178273, 6291456, 2178305, 6291456, 2178337, 6291456, 2178369, 6291456, 2178401, 6291456, 2178433, 6291456, 2178465, 6291456, 2178497, 6291456]), new Uint32Array([6291456, 6291456, 23068672, 23068672, 23068672, 6291456, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]), new Uint32Array([6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 14680064, 14680064, 14680064, 14680064, 14680064, 14680064]), new Uint32Array([6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 6291456]), new Uint32Array([2237377, 2237409, 2236225, 2237441, 2237473, 2217441, 2215521, 2215553, 2217473, 2237505, 2237537, 2209697, 2237569, 2215585, 2237601, 2237633]), new Uint32Array([2221985, 2165601, 2165601, 2165665, 2165665, 2222017, 2222017, 2165729, 2165729, 2158913, 2158913, 2158913, 2158913, 2097281, 2097281, 2105921]), new Uint32Array([23068672, 23068672, 23068672, 23068672, 23068672, 0, 23068672, 23068672, 23068672, 0, 23068672, 23068672, 23068672, 23068672, 0, 0]), new Uint32Array([6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 2149634, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456]), new Uint32Array([2176897, 6291456, 6291456, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 2176929, 6291456, 2176961, 6291456, 2176993, 6291456]), new Uint32Array([2172641, 6291456, 2172673, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 2172705, 2172737, 6291456, 2172769, 2172801, 6291456]), new Uint32Array([2099173, 2104196, 2121667, 2099395, 2121763, 2152258, 2152322, 2098946, 2152386, 2121859, 2121955, 2099333, 2122051, 2104324, 2099493, 2122147]), new Uint32Array([6291456, 6291456, 6291456, 2145794, 6291456, 6291456, 6291456, 6291456, 0, 6291456, 6291456, 6291456, 6291456, 2145858, 6291456, 6291456]), new Uint32Array([6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 23068672, 23068672, 23068672, 0, 0, 6291456, 0]), new Uint32Array([0, 2105921, 2097729, 0, 2097377, 0, 0, 2106017, 0, 2097505, 2105889, 2097185, 2097697, 2135777, 2097633, 2097441]), new Uint32Array([6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672]), new Uint32Array([2239074, 2239138, 2239201, 2239233, 2239265, 2239297, 2239329, 2239361, 0, 2239393, 2239425, 2239425, 2239458, 2239521, 2239553, 2209569]), new Uint32Array([14680064, 2098209, 2111137, 2105505, 2098241, 2108353, 2108417, 2105825, 2111713, 2100897, 2111905, 2105473, 2105569, 2105601, 2112289, 2108193]), new Uint32Array([6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 0, 6291456, 23068672]), new Uint32Array([2108321, 2108289, 2113153, 2098209, 2180897, 2180929, 2180961, 2111137, 2098241, 2108353, 2170241, 2170273, 2180993, 2105825, 6291456, 2105473]), new Uint32Array([6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 2146114, 6291456, 6291456, 6291456, 0, 0, 0]), new Uint32Array([2105921, 2105921, 2105921, 2222049, 2222049, 2130977, 2130977, 2130977, 2130977, 2160065, 2160065, 2160065, 2160065, 2097729, 2097729, 2097729]), new Uint32Array([2218145, 2214785, 2207937, 2218177, 2218209, 2192993, 2210113, 2212769, 2218241, 2218273, 2216129, 2218305, 2216161, 2218337, 2218369, 2218401]), new Uint32Array([0, 0, 0, 2156546, 2156610, 2156674, 2156738, 2156802, 0, 0, 0, 0, 0, 2156866, 23068672, 2156930]), new Uint32Array([23068672, 23068672, 23068672, 0, 0, 0, 0, 23068672, 23068672, 0, 0, 23068672, 23068672, 23068672, 0, 0]), new Uint32Array([2213409, 2213441, 2213473, 2213505, 2213537, 2213569, 2213601, 2213633, 2213665, 2195681, 2213697, 2213729, 2213761, 2213793, 2213825, 2213857]), new Uint32Array([2100033, 2099233, 2122017, 2200673, 2098113, 2121537, 2103201, 2200705, 2104033, 2121857, 2121953, 2122401, 2099649, 2099969, 2123009, 2100129]), new Uint32Array([6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 0, 0, 0, 0, 0, 0, 0, 0, 0]), new Uint32Array([2201857, 6291456, 2201889, 6291456, 2201921, 6291456, 2201953, 6291456, 2201985, 6291456, 2202017, 6291456, 2176193, 2176257, 23068672, 23068672]), new Uint32Array([6291456, 6291456, 23068672, 23068672, 0, 0, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456]), new Uint32Array([2188193, 2188225, 2188257, 2188289, 2188321, 2188353, 2188385, 2188417, 2188449, 2188481, 2188513, 2188545, 2188577, 2188609, 2188641, 0]), new Uint32Array([10554529, 2221089, 0, 10502113, 10562017, 10537921, 10538049, 2221121, 2221153, 0, 0, 0, 0, 0, 0, 0]), new Uint32Array([2213889, 2213921, 2213953, 2213985, 2214017, 2214049, 2214081, 2194177, 2214113, 2214145, 2214177, 2214209, 2214241, 2214273, 2214305, 2214337]), new Uint32Array([2166978, 2167042, 2099169, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]), new Uint32Array([6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 2180545, 6291456, 6291456, 6291456]), new Uint32Array([10518915, 10519011, 10519107, 10519203, 2162242, 2162306, 2159554, 2162370, 2159362, 2159618, 2105922, 2162434, 2159746, 2162498, 2159810, 2159874]), new Uint32Array([2161730, 2161794, 2135586, 2161858, 2161922, 2137186, 2131810, 2160290, 2135170, 2161986, 2137954, 2162050, 2162114, 2162178, 10518723, 10518819]), new Uint32Array([10506627, 10506723, 10506819, 10506915, 10507011, 10507107, 10507203, 10507299, 10507395, 10507491, 10507587, 10507683, 10507779, 10507875, 10507971, 10508067]), new Uint32Array([6291456, 23068672, 23068672, 23068672, 0, 23068672, 23068672, 0, 0, 0, 0, 0, 23068672, 23068672, 23068672, 23068672]), new Uint32Array([23068672, 23068672, 23068672, 23068672, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 0, 0, 0, 0, 0]), new Uint32Array([2175873, 2175905, 2175937, 2175969, 2176001, 2176033, 2176065, 2176097, 2176129, 2176161, 2176193, 2176225, 2176257, 2176289, 2176321, 2176353]), new Uint32Array([2140006, 2140198, 2140390, 2140582, 2140774, 23068672, 23068672, 23068672, 23068672, 23068672, 6291456, 6291456, 6291456, 23068672, 23068672, 23068672]), new Uint32Array([2108193, 2112481, 2112577, 2098177, 2098305, 2108321, 2108289, 2100865, 2113153, 2108481, 2113345, 2113441, 2098209, 2111137, 2105505, 2098241]), new Uint32Array([0, 23068672, 0, 0, 0, 0, 0, 0, 0, 2145154, 2145218, 2145282, 6291456, 0, 2145346, 0]), new Uint32Array([0, 0, 0, 0, 10531458, 10495395, 2148545, 2143201, 2173473, 2148865, 2173505, 0, 2173537, 0, 2173569, 2149121]), new Uint32Array([10537282, 10495683, 2148738, 2148802, 2148866, 0, 6291456, 2148930, 2186593, 2173473, 2148737, 2148865, 2148802, 10495779, 10495875, 10495971]), new Uint32Array([23068672, 23068672, 23068672, 23068672, 23068672, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]), new Uint32Array([2215425, 2215457, 2215489, 2215521, 2215553, 2215585, 2215617, 2215649, 2215681, 2215713, 2215745, 2215777, 2192033, 2215809, 2215841, 2215873]), new Uint32Array([2242049, 2242081, 2242113, 2242145, 2242177, 2242209, 2242241, 2242273, 2215937, 2242305, 2242338, 2242401, 2242433, 2242465, 2242497, 2216001]), new Uint32Array([10554529, 2221089, 0, 0, 10562017, 10502113, 10538049, 10537921, 2221185, 10489601, 10489697, 10609889, 10609921, 2141729, 2141793, 10610273]), new Uint32Array([2141923, 2142019, 2142115, 2142211, 2142307, 2142403, 2142499, 2142595, 2142691, 0, 0, 0, 0, 0, 0, 0]), new Uint32Array([0, 2221185, 2221217, 10609857, 10609857, 10489601, 10489697, 10609889, 10609921, 2141729, 2141793, 2221345, 2221377, 2221409, 2221441, 2187105]), new Uint32Array([6291456, 23068672, 23068672, 23068672, 23068672, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456]), new Uint32Array([23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 0]), new Uint32Array([23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 18923970, 23068672, 23068672, 23068672, 0, 6291456, 6291456]), new Uint32Array([2183105, 6291456, 2183137, 6291456, 2183169, 6291456, 2183201, 6291456, 2183233, 6291456, 2183265, 6291456, 2183297, 6291456, 2183329, 6291456]), new Uint32Array([6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 0, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 0]), new Uint32Array([23068672, 23068672, 23068672, 23068672, 0, 0, 0, 0, 0, 0, 0, 0, 6291456, 6291456, 6291456, 6291456]), new Uint32Array([2134434, 2134818, 2097666, 2097186, 2097474, 2097698, 2105986, 2131586, 2132450, 2131874, 2131778, 2135970, 2135778, 2161602, 2136162, 2161666]), new Uint32Array([2236865, 2236897, 2236930, 2236993, 2237025, 2235681, 2237058, 2237121, 2237153, 2237185, 2237217, 2217281, 2237250, 2191233, 2237313, 2237345]), new Uint32Array([2190049, 6291456, 2190081, 6291456, 2190113, 6291456, 2190145, 6291456, 2190177, 6291456, 2190209, 6291456, 2190241, 6291456, 2190273, 6291456]), new Uint32Array([6291456, 6291456, 6291456, 6291456, 6291456, 23068672, 23068672, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456]), new Uint32Array([2101922, 2102050, 2102178, 2102306, 10498755, 10498851, 10498947, 10499043, 10499139, 10499235, 10499331, 10499427, 10499523, 10489604, 10489732, 10489860]), new Uint32Array([2166914, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456]), new Uint32Array([23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 0, 0, 0, 0, 0]), new Uint32Array([2181601, 2170561, 2181633, 2181665, 2170753, 2181697, 2172897, 2170881, 2181729, 2170913, 2172929, 2113441, 2181761, 2181793, 2171009, 2173761]), new Uint32Array([0, 2105921, 2097729, 2106081, 0, 2097601, 2162337, 2106017, 2133281, 2097505, 0, 2097185, 2097697, 2135777, 2097633, 2097441]), new Uint32Array([6291456, 6291456, 6291456, 23068672, 23068672, 23068672, 23068672, 23068672, 6291456, 6291456, 6291456, 6291456, 0, 0, 0, 0]), new Uint32Array([2248001, 2248033, 2248066, 2248130, 2248193, 2248226, 2248289, 2248322, 2248385, 2248417, 2216673, 2248450, 2248514, 2248577, 2248610, 2248673]), new Uint32Array([6291456, 6291456, 0, 0, 0, 0, 0, 0, 0, 6291456, 6291456, 6291456, 6291456, 0, 0, 0]), new Uint32Array([2169729, 6291456, 2169761, 6291456, 2169793, 6291456, 2169825, 6291456, 2169857, 2169889, 6291456, 2169921, 6291456, 2143329, 6291456, 2098305]), new Uint32Array([2162178, 2163202, 2163266, 2135170, 2136226, 2161986, 2137954, 2159426, 2159490, 2163330, 2159554, 2163394, 2159682, 2139522, 2136450, 2159746]), new Uint32Array([2173953, 2173985, 0, 2174017, 2174049, 2174081, 2174113, 2174145, 2174177, 2149057, 2174209, 2174241, 6291456, 6291456, 6291456, 6291456]), new Uint32Array([6291456, 6291456, 4271169, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 2174273]), new Uint32Array([23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672]), new Uint32Array([6291456, 6291456, 0, 0, 0, 0, 0, 0, 0, 6291456, 0, 0, 0, 0, 0, 0]), new Uint32Array([6291456, 6291456, 6291456, 2190785, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]), new Uint32Array([2189793, 6291456, 2189825, 6291456, 2189857, 6291456, 2189889, 6291456, 2189921, 6291456, 2189953, 6291456, 2189985, 6291456, 2190017, 6291456]), new Uint32Array([2105601, 2112289, 2108193, 2112481, 2112577, 0, 2098305, 2108321, 2108289, 2100865, 2113153, 2108481, 2113345, 0, 2098209, 2111137]), new Uint32Array([2172129, 6291456, 2172161, 6291456, 2172193, 6291456, 2172225, 6291456, 2172257, 6291456, 2172289, 6291456, 2172321, 6291456, 2172353, 6291456]), new Uint32Array([2214753, 6291456, 2214785, 6291456, 6291456, 2214817, 2214849, 2214881, 2214913, 2214945, 2214977, 2215009, 2215041, 2215073, 2194401, 6291456]), new Uint32Array([23068672, 23068672, 23068672, 23068672, 23068672, 6291456, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]), new Uint32Array([0, 0, 0, 0, 6291456, 6291456, 6291456, 23068672, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456]), new Uint32Array([10610305, 10610337, 10575617, 2221761, 10610401, 10610433, 10502177, 0, 10610465, 10610497, 10610529, 10610561, 0, 0, 0, 0]), new Uint32Array([6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 0, 0, 0, 23068672, 0, 0, 0, 0, 23068672]), new Uint32Array([6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 2187105, 2187137, 6291456, 6291456, 6291456, 6291456, 6291456]), new Uint32Array([2199393, 2199425, 2199457, 2199489, 2199521, 2199553, 2199585, 2199617, 2199649, 2199681, 2199713, 2199745, 2199777, 2199809, 2199841, 0]), new Uint32Array([2217249, 2217281, 2217313, 2217345, 2217377, 2217409, 2217441, 2217473, 2215617, 2217505, 2217537, 2217569, 2214753, 2217601, 2217633, 2217665]), new Uint32Array([2170273, 2170305, 6291456, 2170337, 2170369, 6291456, 2170401, 2170433, 2170465, 6291456, 6291456, 6291456, 2170497, 2170529, 6291456, 2170561]), new Uint32Array([2188673, 6291456, 2188705, 2188737, 2188769, 6291456, 6291456, 2188801, 6291456, 2188833, 6291456, 2188865, 6291456, 2180929, 2181505, 2180897]), new Uint32Array([10489988, 10490116, 10490244, 10490372, 10490500, 10490628, 10490756, 10490884, 0, 0, 0, 0, 0, 0, 0, 0]), new Uint32Array([6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 2147393, 2147457, 2147521, 2147585, 2147649, 2147713, 2147777, 2147841]), new Uint32Array([23068672, 23068672, 0, 23068672, 23068672, 0, 23068672, 23068672, 23068672, 23068672, 23068672, 0, 0, 0, 0, 0]), new Uint32Array([2241153, 2241185, 2241217, 2215809, 2241250, 2241313, 2241345, 2241377, 2217921, 2241377, 2241409, 2215873, 2241441, 2241473, 2241505, 2241537]), new Uint32Array([23068672, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456]), new Uint32Array([2220417, 2220417, 2220449, 2220449, 2220481, 2220481, 2220513, 2220513, 2220545, 2220545, 2220577, 2220577, 2220609, 2220609, 2220641, 2220641]), new Uint32Array([6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 2144002, 0, 6291456, 6291456, 0, 0, 6291456, 6291456, 6291456]), new Uint32Array([2167105, 2167137, 2167169, 2167201, 2167233, 2167265, 2167297, 2167329, 2167361, 2167393, 2167425, 2167457, 2167489, 2167521, 2167553, 2167585]), new Uint32Array([10575521, 2098209, 2111137, 2105505, 2098241, 2108353, 2108417, 2105825, 2111713, 2100897, 2111905, 2105473, 2105569, 2105601, 2112289, 2108193]), new Uint32Array([2234146, 2234210, 2234274, 2234338, 2234402, 2234466, 2234530, 2234594, 2234658, 2234722, 2234786, 2234850, 2234914, 2234978, 2235042, 2235106]), new Uint32Array([0, 0, 0, 0, 0, 0, 0, 2180577, 0, 0, 0, 0, 0, 2180609, 0, 0]), new Uint32Array([6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 23068672, 23068672, 23068672, 23068672, 23068672, 0, 0, 6291456, 6291456]), new Uint32Array([2098209, 2111137, 2105505, 2098241, 2108353, 2108417, 2105825, 2111713, 2100897, 2111905, 2105473, 2105569, 2105601, 2112289, 2108193, 2112481]), new Uint32Array([23068672, 23068672, 23068672, 23068672, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456]), new Uint32Array([2242529, 2242561, 2242593, 2242625, 2242657, 2242689, 2242721, 2242753, 2207937, 2218177, 2242785, 2242817, 2242849, 2242882, 2242945, 2242977]), new Uint32Array([2118049, 2105345, 2118241, 2105441, 2118433, 2118529, 2118625, 2118721, 2118817, 2200257, 2200289, 2191809, 2200321, 2200353, 2200385, 2200417]), new Uint32Array([6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 23068672, 23068672, 23068672, 6291456, 6291456]), new Uint32Array([23068672, 23068672, 23068672, 23068672, 23068672, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 0, 0, 0, 0]), new Uint32Array([2185505, 6291456, 2185537, 6291456, 2185569, 6291456, 2185601, 6291456, 2185633, 6291456, 2185665, 6291456, 2185697, 6291456, 2185729, 6291456]), new Uint32Array([2231970, 2232034, 2232098, 2232162, 2232226, 2232290, 2232354, 2232418, 2232482, 2232546, 2232610, 2232674, 2232738, 2232802, 2232866, 2232930]), new Uint32Array([2218625, 2246402, 2246466, 2246530, 2246594, 2246657, 2246689, 2246689, 2218657, 2219681, 2246721, 2246753, 2246785, 2246818, 2246881, 2208481]), new Uint32Array([2197025, 2197057, 2197089, 2197121, 2197153, 2197185, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]), new Uint32Array([2219137, 2216961, 2219169, 2219201, 2219233, 2219265, 2219297, 2217025, 2215041, 2219329, 2217057, 2219361, 2217089, 2219393, 2197153, 2219426]), new Uint32Array([23068672, 23068672, 23068672, 0, 0, 0, 23068672, 23068672, 23068672, 0, 23068672, 23068672, 23068672, 23068672, 0, 0]), new Uint32Array([2098305, 2108321, 2108289, 2100865, 2113153, 2108481, 2113345, 2113441, 2098209, 2111137, 2105505, 2098241, 2108353, 2108417, 2105825, 2111713]), new Uint32Array([2243522, 2243585, 2243617, 2243649, 2243681, 2210113, 2243713, 2243746, 2243810, 2243874, 2243937, 2243970, 2244033, 2244065, 2244097, 2244129]), new Uint32Array([2178017, 6291456, 2178049, 6291456, 2178081, 6291456, 2178113, 6291456, 2178145, 6291456, 2178177, 6291456, 2178209, 6291456, 2178241, 6291456]), new Uint32Array([10553858, 2165314, 10518722, 6291456, 10518818, 0, 10518914, 2130690, 10519010, 2130786, 10519106, 2130882, 10519202, 2165378, 10554050, 2165506]), new Uint32Array([0, 0, 2135491, 2135587, 2135683, 2135779, 2135875, 2135971, 2135971, 2136067, 2136163, 2136259, 2136355, 2136355, 2136451, 2136547]), new Uint32Array([23068672, 23068672, 23068672, 6291456, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 6291456, 6291456]), new Uint32Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6291456, 6291456, 6291456, 6291456]), new Uint32Array([23068672, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]), new Uint32Array([2220033, 2220033, 2220065, 2220065, 2220065, 2220065, 2220097, 2220097, 2220097, 2220097, 2220129, 2220129, 2220129, 2220129, 2220161, 2220161]), new Uint32Array([6291456, 6291456, 6291456, 0, 0, 0, 0, 0, 0, 0, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456]), new Uint32Array([23068672, 23068672, 23068672, 23068672, 23068672, 0, 23068672, 0, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672]), new Uint32Array([2100897, 2100898, 2100899, 2150018, 2100865, 2100866, 2100867, 2100868, 2150082, 2108481, 2109858, 2109859, 2105569, 2105505, 2098241, 2105601]), new Uint32Array([2097217, 2097505, 2097505, 2097505, 2097505, 2165570, 2165570, 2165634, 2165634, 2165698, 2165698, 2097858, 2097858, 0, 0, 2097152]), new Uint32Array([23068672, 6291456, 23068672, 23068672, 23068672, 6291456, 6291456, 23068672, 23068672, 6291456, 6291456, 6291456, 6291456, 6291456, 23068672, 23068672]), new Uint32Array([23068672, 23068672, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 0, 0]), new Uint32Array([10503843, 10503939, 10504035, 10504131, 10504227, 10504323, 10504419, 10504515, 10504611, 10504707, 10504803, 10504899, 10504995, 10491140, 10491268, 0]), new Uint32Array([2173697, 2173729, 2148801, 2173761, 2143969, 2173793, 2173825, 2153473, 2173857, 2173889, 2173921, 2173953, 2173985, 2173761, 2174017, 2174049]), new Uint32Array([23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 0, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672]), new Uint32Array([2134145, 2097153, 2134241, 2105953, 2132705, 2130977, 2160065, 2131297, 2162049, 2133089, 2160577, 2133857, 2235297, 2220769, 2235329, 2235361]), new Uint32Array([6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672]), new Uint32Array([2222401, 2222433, 2222465, 10531394, 2222497, 2222529, 2222561, 0, 2222593, 2222625, 2222657, 2222689, 2222721, 2222753, 2222785, 0]), new Uint32Array([2184481, 6291456, 2184513, 6291456, 2184545, 6291456, 2184577, 6291456, 2184609, 6291456, 2184641, 6291456, 2184673, 6291456, 2184705, 6291456]), new Uint32Array([6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 23068672, 23068672, 23068672, 23068672, 6291456, 6291456, 6291456, 6291456, 23068672, 23068672]), new Uint32Array([6291456, 6291456, 6291456, 6291456, 6291456, 23068672, 23068672, 0, 0, 0, 0, 0, 0, 0, 0, 0]), new Uint32Array([2105570, 2156034, 2126947, 2156098, 2153666, 2127043, 2127139, 2156162, 0, 2127235, 2156226, 2156290, 2156354, 2156418, 2127331, 2127427]), new Uint32Array([2215905, 2207041, 2153185, 2241569, 2241601, 2241633, 2241665, 2241697, 2241730, 2241793, 2241825, 2241857, 2241889, 2241921, 2241954, 2242017]), new Uint32Array([2203777, 6291456, 2203809, 6291456, 2203841, 6291456, 2203873, 6291456, 2203905, 6291456, 2173121, 2180993, 2181249, 2203937, 2181313, 0]), new Uint32Array([2168577, 6291456, 2168609, 6291456, 2168641, 6291456, 2168673, 6291456, 2168705, 6291456, 2168737, 6291456, 2168769, 6291456, 2168801, 6291456]), new Uint32Array([6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 0, 0, 6291456, 23068672, 23068672, 6291456]), new Uint32Array([23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 0, 23068672, 23068672, 23068672, 0, 23068672, 23068672, 23068672, 0, 0]), new Uint32Array([2210113, 2195521, 2210145, 2210177, 2210209, 2210241, 2210273, 2210305, 2210337, 2210369, 2210401, 2210433, 2210465, 2210497, 2210529, 2210561]), new Uint32Array([6291456, 0, 0, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 0]), new Uint32Array([2228706, 2228770, 2228834, 2228898, 2228962, 2229026, 2229090, 2229154, 2229218, 2229282, 2229346, 2229410, 2229474, 2229538, 2229602, 2229666]), new Uint32Array([23068672, 6291456, 6291456, 6291456, 6291456, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]), new Uint32Array([6291456, 6291456, 6291456, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6291456]), new Uint32Array([6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 0, 6291456, 6291456, 6291456, 6291456, 18874368, 18874368, 18874368, 0, 0]), new Uint32Array([2133089, 2133281, 2133281, 2133281, 2133281, 2160577, 2160577, 2160577, 2160577, 2097441, 2097441, 2097441, 2097441, 2133857, 2133857, 2133857]), new Uint32Array([6291456, 0, 0, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456]), new Uint32Array([6291456, 6291456, 6291456, 6291456, 6291456, 0, 0, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456]), new Uint32Array([2173825, 2153473, 2173857, 2173889, 2173921, 2173953, 2173985, 2174017, 2174017, 2174049, 2174081, 2174113, 2174145, 2174177, 2149057, 2233089]), new Uint32Array([2178529, 6291456, 2178561, 6291456, 2178593, 6291456, 2178625, 6291456, 2178657, 6291456, 2178689, 6291456, 2178721, 6291456, 2178753, 6291456]), new Uint32Array([2221025, 2221025, 2221057, 2221057, 2159329, 2159329, 2159329, 2159329, 2097217, 2097217, 2158914, 2158914, 2158978, 2158978, 2159042, 2159042]), new Uint32Array([2208161, 2208193, 2208225, 2208257, 2194433, 2208289, 2208321, 2208353, 2208385, 2208417, 2208449, 2208481, 2208513, 2208545, 2208577, 2208609]), new Uint32Array([2169217, 6291456, 2169249, 6291456, 2169281, 6291456, 2169313, 6291456, 2169345, 6291456, 2169377, 6291456, 2169409, 6291456, 2169441, 6291456]), new Uint32Array([6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 0, 0, 6291456, 6291456, 6291456, 6291456]), new Uint32Array([2133187, 2133283, 2133283, 2133379, 2133475, 2133571, 2133667, 2133667, 2133763, 2133859, 2133955, 2134051, 2134147, 2134147, 2134243, 2134339]), new Uint32Array([2197697, 2114113, 2114209, 2197729, 2197761, 2114305, 2197793, 2114401, 2114497, 2197825, 2114593, 2114689, 2114785, 2114881, 2114977, 0]), new Uint32Array([2193089, 2193121, 2193153, 2193185, 2117665, 2117569, 2193217, 2193249, 2193281, 2193313, 2193345, 2193377, 2193409, 2193441, 2193473, 2193505]), new Uint32Array([6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 23068672, 23068672, 23068672, 23068672, 23068672]), new Uint32Array([6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 0, 0, 0]), new Uint32Array([6291456, 6291456, 6291456, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]), new Uint32Array([6291456, 6291456, 6291456, 0, 0, 0, 0, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456]), new Uint32Array([2184225, 6291456, 2184257, 6291456, 2184289, 6291456, 2184321, 6291456, 2184353, 6291456, 2184385, 6291456, 2184417, 6291456, 2184449, 6291456]), new Uint32Array([2112577, 2098177, 2098305, 2108321, 2108289, 2100865, 2113153, 2108481, 2113345, 2113441, 2100833, 6291456, 6291456, 6291456, 6291456, 6291456]), new Uint32Array([6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672]), new Uint32Array([2098657, 2098049, 2200737, 2123489, 2123681, 2200769, 2098625, 2100321, 2098145, 2100449, 2098017, 2098753, 2200801, 2200833, 2200865, 0]), new Uint32Array([23068672, 23068672, 23068672, 0, 0, 0, 0, 0, 0, 0, 0, 23068672, 23068672, 23068672, 23068672, 23068672]), new Uint32Array([6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 23068672, 23068672, 23068672, 23068672, 23068672, 0, 0, 0, 0, 0]), new Uint32Array([2098305, 2108321, 2108289, 2100865, 2113153, 2108481, 2113345, 2113441, 2098209, 2111137, 0, 2098241, 2108353, 2108417, 2105825, 0]), new Uint32Array([6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 2181153, 2105505, 2181185, 2167617, 2180993]), new Uint32Array([2160002, 2160066, 2160130, 2160194, 2160258, 2132066, 2131010, 2131106, 2106018, 2131618, 2160322, 2131298, 2132034, 2131938, 2137410, 2132226]), new Uint32Array([6291456, 6291456, 6291456, 6291456, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6291456]), new Uint32Array([2183617, 6291456, 2183649, 6291456, 2183681, 6291456, 2183713, 6291456, 2183745, 6291456, 2183777, 6291456, 2183809, 6291456, 2183841, 6291456]), new Uint32Array([0, 6291456, 6291456, 0, 6291456, 0, 0, 6291456, 6291456, 0, 6291456, 0, 0, 6291456, 0, 0]), new Uint32Array([2250977, 2251009, 2251041, 2251073, 2195009, 2251106, 2251169, 2251201, 2251233, 2251265, 2251297, 2251330, 2251394, 2251457, 2251489, 2251521]), new Uint32Array([2205729, 2205761, 2205793, 2205825, 2205857, 2205889, 2205921, 2205953, 2205985, 2206017, 2206049, 2206081, 2206113, 2206145, 2206177, 2206209]), new Uint32Array([6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 0, 0, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456]), new Uint32Array([2143170, 2168993, 6291456, 2169025, 6291456, 2169057, 6291456, 2169089, 6291456, 2143234, 2169121, 6291456, 2169153, 6291456, 2169185, 6291456]), new Uint32Array([23068672, 23068672, 2190689, 6291456, 0, 0, 0, 0, 0, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456]), new Uint32Array([2248706, 2248769, 2248801, 2248833, 2248865, 2248897, 2248929, 2248962, 2249026, 2249090, 2249154, 2240705, 2249217, 2249249, 2249281, 2249313]), new Uint32Array([10485857, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 10495394, 6291456, 2098209, 6291456, 6291456, 2097152, 6291456, 10531394]), new Uint32Array([0, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 0, 0, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 0]), new Uint32Array([14680064, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456]), new Uint32Array([2173985, 2173953, 2148481, 2173601, 2173633, 2173665, 2173697, 2173729, 2148801, 2173761, 2143969, 2173793, 2173825, 2153473, 2173857, 2173889]), new Uint32Array([6291456, 2186977, 6291456, 6291456, 6291456, 6291456, 6291456, 10537858, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456]), new Uint32Array([2209601, 2209633, 2209665, 2209697, 2209729, 2209761, 2209793, 2209825, 2209857, 2209889, 2209921, 2209953, 2209985, 2210017, 2210049, 2210081]), new Uint32Array([10501539, 10501635, 10501731, 10501827, 10501923, 10502019, 2098209, 2111137, 2105505, 2098241, 2108353, 2108417, 2105825, 2111713, 2100897, 2111905]), new Uint32Array([2173697, 2173729, 2148801, 2173761, 2143969, 2173793, 2173825, 2153473, 2173857, 2173889, 2173921, 2173953, 2173985, 2174017, 2174017, 2174049]), new Uint32Array([6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 0, 6291456, 6291456, 6291456, 6291456, 0, 0]), new Uint32Array([6291456, 6291456, 23068672, 23068672, 23068672, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]), new Uint32Array([2194561, 2194593, 2194625, 2119777, 2119873, 2194657, 2194689, 2194721, 2194753, 2194785, 2194817, 2194849, 2194881, 2194913, 2194945, 2194977]), new Uint32Array([2113153, 2108481, 2113345, 2113441, 2098209, 2111137, 2105505, 2098241, 2108353, 2108417, 2105825, 2111713, 2100897, 2111905, 2105473, 2105569]), new Uint32Array([2222818, 2222882, 2222946, 2223010, 2223074, 2223138, 2223202, 2223266, 2223330, 2223394, 2223458, 2223522, 2223586, 2223650, 2223714, 2223778]), new Uint32Array([6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 23068672]), new Uint32Array([0, 2179553, 2179585, 2179617, 2179649, 2144001, 2179681, 2179713, 2179745, 2179777, 2179809, 2156705, 2179841, 2156833, 2179873, 2179905]), new Uint32Array([6291456, 23068672, 6291456, 2145602, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 0, 23068672, 23068672, 6291456, 0, 0]), new Uint32Array([2196513, 2196545, 2196577, 2196609, 2196641, 2196673, 2196705, 2196737, 2196769, 2196801, 2196833, 2196865, 2196897, 2196929, 2196961, 2196993]), new Uint32Array([6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 0, 0, 0, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456]), new Uint32Array([2177281, 6291456, 2177313, 6291456, 2177345, 6291456, 2177377, 6291456, 2177409, 6291456, 2177441, 6291456, 2177473, 6291456, 2177505, 6291456]), new Uint32Array([2187137, 2221473, 2221505, 2221537, 2221569, 6291456, 6291456, 10610209, 10610241, 10537986, 10537986, 10537986, 10537986, 10609857, 10609857, 10609857]), new Uint32Array([2243009, 2243041, 2216033, 2243074, 2243137, 2243169, 2243201, 2219617, 2243233, 2243265, 2243297, 2243329, 2243362, 2243425, 2243457, 2243489]), new Uint32Array([10485857, 10485857, 10485857, 10485857, 10485857, 10485857, 10485857, 10485857, 10485857, 10485857, 10485857, 2097152, 4194304, 4194304, 0, 0]), new Uint32Array([2143042, 6291456, 2143106, 2143106, 2168833, 6291456, 2168865, 6291456, 6291456, 2168897, 6291456, 2168929, 6291456, 2168961, 6291456, 2143170]), new Uint32Array([6291456, 6291456, 23068672, 23068672, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456]), new Uint32Array([2204193, 2204225, 2204257, 2204289, 2204321, 2204353, 2204385, 2204417, 2204449, 2204481, 2204513, 2204545, 2204577, 2204609, 2204641, 2204673]), new Uint32Array([2202753, 6291456, 2202785, 6291456, 2202817, 6291456, 2202849, 6291456, 2202881, 6291456, 2202913, 6291456, 2202945, 6291456, 2202977, 6291456]), new Uint32Array([23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 0, 0, 23068672, 23068672, 23068672, 23068672, 23068672]), new Uint32Array([2108353, 2108417, 2105825, 2111713, 2100897, 2111905, 2105473, 2105569, 2105601, 2112289, 2108193, 2112481, 2112577, 2098177, 2098305, 2108321]), new Uint32Array([2147394, 2147458, 2147522, 2147586, 2147650, 2147714, 2147778, 2147842, 2147394, 2147458, 2147522, 2147586, 2147650, 2147714, 2147778, 2147842]), new Uint32Array([2253313, 2253346, 2253409, 2253441, 2253473, 2253505, 2253537, 2253569, 2253601, 2253634, 2219393, 2253697, 2253729, 2253761, 2253793, 2253825]), new Uint32Array([6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 23068672, 23068672, 23068672, 23068672, 6291456, 6291456]), new Uint32Array([2162562, 2162626, 2131362, 2162690, 2159938, 2160002, 2162754, 2162818, 2160130, 2162882, 2160194, 2160258, 2160834, 2160898, 2161026, 2161090]), new Uint32Array([2175361, 2175393, 2175425, 2175457, 2175489, 2175521, 2175553, 2175585, 2175617, 2175649, 2175681, 2175713, 2175745, 2175777, 2175809, 2175841]), new Uint32Array([2253858, 2253921, 2253954, 2254018, 2254082, 2196737, 2254145, 2196865, 2254177, 2254209, 2254241, 2254273, 2197025, 2254306, 0, 0]), new Uint32Array([6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 2202113, 2204129, 2188705, 2204161]), new Uint32Array([6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 0, 6291456, 0, 6291456, 6291456, 6291456, 6291456, 0, 0]), new Uint32Array([2173985, 2174017, 2174017, 2174049, 2174081, 2174113, 2174145, 2174177, 2149057, 2233089, 2173697, 2173761, 2173793, 2174113, 2173985, 2173953]), new Uint32Array([2101569, 2101697, 2101825, 2101953, 2102081, 2102209, 2100833, 2100737, 2098337, 2101441, 2101569, 2101697, 2101825, 2101953, 2102081, 2102209]), new Uint32Array([2108289, 2100865, 2113153, 2108481, 2113345, 2113441, 2098209, 2111137, 2105505, 2098241, 0, 2108417, 0, 2111713, 2100897, 2111905]), new Uint32Array([23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 0, 0, 0, 0, 0, 0, 0, 0]), new Uint32Array([2175425, 2175489, 2175809, 2175905, 2175937, 2175937, 2176193, 2176417, 2180865, 0, 0, 0, 0, 0, 0, 0]), new Uint32Array([6291456, 6291456, 6291456, 6291456, 2143298, 2143298, 2143298, 2143362, 2143362, 2143362, 2143426, 2143426, 2143426, 2171105, 6291456, 2171137]), new Uint32Array([2120162, 2120258, 2151618, 2151682, 2151746, 2151810, 2151874, 2151938, 2152002, 2120035, 2120131, 2120227, 2152066, 2120323, 2152130, 2120419]), new Uint32Array([23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 0, 0, 0, 0, 0, 23068672, 23068672, 23068672, 23068672, 23068672]), new Uint32Array([23068672, 23068672, 23068672, 23068672, 23068672, 0, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456]), new Uint32Array([2195361, 2142433, 2236065, 2236097, 2236129, 2236161, 2118241, 2117473, 2236193, 2236225, 2236257, 2236289, 0, 0, 0, 0]), new Uint32Array([2189281, 6291456, 2189313, 6291456, 2189345, 6291456, 2189377, 6291456, 2189409, 6291456, 2189441, 6291456, 2189473, 6291456, 2189505, 6291456]), new Uint32Array([6291456, 6291456, 2145922, 6291456, 6291456, 6291456, 6291456, 2145986, 6291456, 6291456, 6291456, 6291456, 2146050, 6291456, 6291456, 6291456]), new Uint32Array([2100833, 2100737, 2098337, 2101441, 2101569, 2101697, 2101825, 2101953, 2102081, 2102209, 10502113, 10562017, 10610401, 10502177, 10610433, 10538049]), new Uint32Array([6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 0, 2186401, 0, 2186433, 0, 2186465, 0, 2186497]), new Uint32Array([6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 0, 0, 0, 23068672, 23068672, 23068672]), new Uint32Array([0, 0, 2198241, 2198273, 2198305, 2198337, 2198369, 2198401, 0, 0, 2198433, 2198465, 2198497, 0, 0, 0]), new Uint32Array([6291456, 0, 6291456, 6291456, 6291456, 6291456, 0, 0, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 0]), new Uint32Array([6291456, 6291456, 6291456, 6291456, 6291456, 0, 6291456, 0, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 0, 0]), new Uint32Array([6291456, 6291456, 6291456, 6291456, 0, 6291456, 6291456, 6291456, 6291456, 6291456, 0, 0, 23068672, 6291456, 23068672, 23068672]), new Uint32Array([0, 2105921, 2097729, 0, 2097377, 0, 0, 2106017, 2133281, 2097505, 2105889, 0, 2097697, 2135777, 2097633, 2097441]), new Uint32Array([2197889, 2197921, 2197953, 2197985, 2198017, 2198049, 2198081, 2198113, 2198145, 2198177, 2198209, 2198241, 2198273, 2198305, 2198337, 2198369]), new Uint32Array([2132514, 2132610, 2160386, 2133090, 2133186, 2160450, 2160514, 2133282, 2160578, 2133570, 2106178, 2160642, 2133858, 2160706, 2160770, 2134146]), new Uint32Array([6291456, 6291456, 6291456, 6291456, 6291456, 23068672, 23068672, 0, 0, 0, 0, 6291456, 6291456, 6291456, 6291456, 6291456]), new Uint32Array([6291456, 23068672, 23068672, 6291456, 23068672, 23068672, 6291456, 23068672, 0, 0, 0, 0, 0, 0, 0, 0]), new Uint32Array([2184737, 6291456, 2184769, 6291456, 2184801, 6291456, 2184833, 6291456, 2184865, 6291456, 2184897, 6291456, 2184929, 6291456, 2184961, 6291456]), new Uint32Array([6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 0, 6291456, 0, 6291456, 6291456, 6291456, 6291456, 0, 6291456]), new Uint32Array([6291456, 6291456, 0, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456]), new Uint32Array([23068672, 23068672, 23068672, 23068672, 6291456, 23068672, 23068672, 23068672, 6291456, 23068672, 23068672, 23068672, 23068672, 23068672, 0, 0]), new Uint32Array([6291456, 6291456, 6291456, 2186753, 6291456, 6291456, 6291456, 6291456, 2186785, 2186817, 2186849, 2173569, 2186881, 10496355, 10495395, 10575521]), new Uint32Array([0, 0, 2097729, 0, 0, 0, 0, 2106017, 0, 2097505, 0, 2097185, 0, 2135777, 2097633, 2097441]), new Uint32Array([2189537, 6291456, 2189569, 6291456, 2189601, 6291456, 2189633, 6291456, 2189665, 6291456, 2189697, 6291456, 2189729, 6291456, 2189761, 6291456]), new Uint32Array([2202497, 6291456, 2202529, 6291456, 2202561, 6291456, 2202593, 6291456, 2202625, 6291456, 2202657, 6291456, 2202689, 6291456, 2202721, 6291456]), new Uint32Array([2245217, 2218369, 2245249, 2245282, 2245345, 2245377, 2245410, 2245474, 2245537, 2245569, 2245601, 2245633, 2245665, 2245665, 2245697, 2245729]), new Uint32Array([6291456, 0, 23068672, 23068672, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]), new Uint32Array([6291456, 0, 0, 0, 0, 0, 0, 23068672, 0, 0, 0, 0, 0, 0, 0, 0]), new Uint32Array([6291456, 6291456, 6291456, 6291456, 6291456, 23068672, 6291456, 23068672, 6291456, 23068672, 6291456, 6291456, 6291456, 6291456, 23068672, 23068672]), new Uint32Array([0, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 0, 0, 0, 0, 0, 0, 0, 0, 0]), new Uint32Array([2097281, 2105921, 2097729, 2106081, 2097377, 2097601, 2162337, 2106017, 2133281, 2097505, 0, 2097185, 2097697, 2135777, 2097633, 2097441]), new Uint32Array([2176641, 6291456, 2176673, 6291456, 2176705, 6291456, 2176737, 6291456, 2176769, 6291456, 2176801, 6291456, 2176833, 6291456, 2176865, 6291456]), new Uint32Array([2174145, 2174177, 2149057, 2233089, 2173697, 2173761, 2173793, 2174113, 2173985, 2173953, 2174369, 2174369, 0, 0, 2100833, 2100737]), new Uint32Array([2116513, 2190817, 2190849, 2190881, 2190913, 2190945, 2116609, 2190977, 2191009, 2191041, 2191073, 2117185, 2191105, 2191137, 2191169, 2191201]), new Uint32Array([6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 0, 0, 0, 0, 0, 6291456, 6291456, 6291456]), new Uint32Array([0, 0, 0, 0, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672]), new Uint32Array([23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 6291456]), new Uint32Array([2167617, 2167649, 2167681, 2167713, 2167745, 2167777, 2167809, 6291456, 2167841, 2167873, 2167905, 2167937, 2167969, 2168001, 2168033, 4240130]), new Uint32Array([2165122, 2163970, 2164034, 2164098, 2164162, 2164226, 2164290, 2164354, 2164418, 2164482, 2164546, 2133122, 2134562, 2132162, 2132834, 2136866]), new Uint32Array([6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 0, 0, 2186209, 2186241, 2186273, 2186305, 2186337, 2186369, 0, 0]), new Uint32Array([2112481, 2112577, 2098177, 2098305, 2108321, 2108289, 2100865, 2113153, 2108481, 2113345, 2113441, 14680064, 14680064, 14680064, 14680064, 14680064]), new Uint32Array([0, 0, 23068672, 6291456, 0, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 0, 0, 0, 6291456, 6291456]), new Uint32Array([0, 10537921, 10610689, 10610273, 10610497, 10610529, 10610305, 10610721, 10489601, 10489697, 10610337, 10575617, 10554529, 2221761, 2197217, 10496577]), new Uint32Array([2105473, 2105569, 2105601, 2112289, 0, 2112481, 2112577, 2098177, 2098305, 2108321, 2108289, 2100865, 2113153, 2108481, 2113345, 2113441]), new Uint32Array([2100897, 2111905, 2105473, 2105569, 2105601, 2112289, 2108193, 2112481, 2112577, 2098177, 2098305, 2108321, 2108289, 2100865, 2113153, 2108481]), new Uint32Array([2125346, 2153410, 2153474, 2127394, 2153538, 2153602, 2153666, 2153730, 2105507, 2105476, 2153794, 2153858, 2153922, 2153986, 2154050, 2105794]), new Uint32Array([2200449, 2119681, 2200481, 2153313, 2199873, 2199905, 2199937, 2200513, 2200545, 2200577, 2200609, 2119105, 2119201, 2119297, 2119393, 2119489]), new Uint32Array([6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 2175777, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456]), new Uint32Array([2222273, 2197217, 2221473, 2221505, 2221089, 2222305, 2200865, 2099681, 2104481, 2222337, 2099905, 2120737, 2222369, 2103713, 2100225, 2098785]), new Uint32Array([2201377, 6291456, 2201409, 6291456, 2201441, 6291456, 2201473, 6291456, 2201505, 6291456, 2201537, 6291456, 2201569, 6291456, 6291456, 23068672]), new Uint32Array([2174081, 2174113, 2174145, 2174177, 2149057, 2233057, 2148481, 2173601, 2173633, 2173665, 2173697, 2173729, 2148801, 2173761, 2143969, 2173793]), new Uint32Array([2200897, 6291456, 2200929, 6291456, 2200961, 6291456, 2200993, 6291456, 2201025, 6291456, 2180865, 6291456, 2201057, 6291456, 2201089, 6291456]), new Uint32Array([0, 0, 0, 0, 0, 23068672, 23068672, 0, 6291456, 6291456, 6291456, 0, 0, 0, 0, 0]), new Uint32Array([2161154, 2161410, 2138658, 2161474, 2161538, 2097666, 2097186, 2097474, 2162946, 2132450, 2163010, 2163074, 2136162, 2163138, 2161666, 2161730]), new Uint32Array([2148481, 2173601, 2173633, 2173665, 2173697, 2173729, 2148801, 2173761, 2143969, 2173793, 2173825, 2153473, 2173857, 2173889, 2173921, 2173953]), new Uint32Array([0, 0, 0, 0, 0, 0, 23068672, 23068672, 0, 0, 0, 0, 2145410, 2145474, 0, 6291456]), new Uint32Array([2244161, 2216065, 2212769, 2244193, 2244225, 2244257, 2244290, 2244353, 2244385, 2244417, 2244449, 2218273, 2244481, 2244514, 2244577, 2244609]), new Uint32Array([2125730, 2125699, 2125795, 2125891, 2125987, 2154114, 2154178, 2154242, 2154306, 2154370, 2154434, 2154498, 2126082, 2126178, 2126274, 2126083]), new Uint32Array([2237665, 2237697, 2237697, 2237697, 2237730, 2237793, 2237825, 2237857, 2237890, 2237953, 2237985, 2238017, 2238049, 2238081, 2238113, 2238145]), new Uint32Array([6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 2150146, 6291456, 6291456, 6291456]), new Uint32Array([23068672, 23068672, 23068672, 23068672, 23068672, 0, 0, 23068672, 23068672, 0, 0, 23068672, 23068672, 23068672, 0, 0]), new Uint32Array([2214369, 2238593, 2238625, 2238657, 2238689, 2238721, 2238753, 2238785, 2238817, 2238850, 2238913, 2238945, 2238977, 2235457, 2239009, 2239041]), new Uint32Array([6291456, 6291456, 6291456, 6291456, 6291456, 0, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 0, 0]), new Uint32Array([2252066, 2252130, 2252193, 2252225, 2252257, 2252290, 2252353, 2252385, 2252417, 2252449, 2252481, 2252513, 2252545, 2252578, 2252641, 2252673]), new Uint32Array([2197697, 2114113, 2114209, 2197729, 2197761, 2114305, 2197793, 2114401, 2114497, 2197825, 2114593, 2114689, 2114785, 2114881, 2114977, 2197857]), new Uint32Array([2224866, 2224930, 2224994, 2225058, 2225122, 2225186, 2225250, 2225314, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456]), new Uint32Array([2219490, 2219554, 2219617, 2219649, 2219681, 2219714, 2219778, 2219842, 2219905, 2219937, 0, 0, 0, 0, 0, 0]), new Uint32Array([6291456, 23068672, 23068672, 23068672, 0, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 0, 0, 6291456]), new Uint32Array([2113345, 2113441, 2098209, 2111137, 2105505, 2098241, 2108353, 2108417, 2105825, 2111713, 2100897, 2111905, 2105473, 2105569, 2105601, 2112289]), new Uint32Array([2174081, 2174113, 2174145, 2174177, 2149057, 2233089, 2173697, 2173761, 2173793, 2174113, 2173985, 2173953, 2148481, 2173601, 2173633, 2173665]), new Uint32Array([2220161, 2220161, 2220193, 2220193, 2220193, 2220193, 2220225, 2220225, 2220225, 2220225, 2220257, 2220257, 2220257, 2220257, 2220289, 2220289]), new Uint32Array([2192673, 2192705, 2192737, 2192769, 2192801, 2192833, 2192865, 2118049, 2192897, 2117473, 2117761, 2192929, 2192961, 2192993, 2193025, 2193057]), new Uint32Array([2179297, 6291456, 2179329, 6291456, 2179361, 6291456, 2179393, 6291456, 2179425, 6291456, 2179457, 6291456, 2179489, 6291456, 2179521, 6291456]), new Uint32Array([6291456, 6291456, 6291456, 23068672, 6291456, 6291456, 6291456, 0, 0, 0, 0, 0, 0, 0, 0, 0]), new Uint32Array([2235745, 2235777, 2193633, 2235809, 2235841, 2235873, 2235905, 2235937, 2235969, 2116513, 2116705, 2236001, 2200513, 2199905, 2200545, 2236033]), new Uint32Array([2113153, 2108481, 2113345, 2113441, 2232993, 2233025, 0, 0, 2148481, 2173601, 2173633, 2173665, 2173697, 2173729, 2148801, 2173761]), new Uint32Array([2170593, 6291456, 2170625, 6291456, 2170657, 6291456, 2170689, 2170721, 6291456, 2170753, 6291456, 6291456, 2170785, 6291456, 2170817, 2170849]), new Uint32Array([6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 2166786, 2166850, 0, 0, 0, 0]), new Uint32Array([23068672, 6291456, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]), new Uint32Array([6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 0, 6291456, 6291456]), new Uint32Array([2100833, 2100737, 2098337, 2101441, 2101569, 2101697, 2101825, 2101953, 2102081, 2102209, 10575617, 2187041, 10502177, 10489601, 10489697, 0]), new Uint32Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6291456, 6291456, 6291456, 6291456, 6291456]), new Uint32Array([2134562, 2132162, 2132834, 2136866, 2136482, 2164610, 2164674, 2164738, 2164802, 2132802, 2132706, 2164866, 2132898, 2164930, 2164994, 2165058]), new Uint32Array([6291456, 6291456, 2098337, 2101441, 10531458, 2153473, 6291456, 6291456, 10531522, 2100737, 2108193, 6291456, 2106499, 2106595, 2106691, 6291456]), new Uint32Array([23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 0, 0, 0, 0, 0, 0, 0, 0, 0]), new Uint32Array([2233122, 2233186, 2233250, 2233314, 2233378, 2233442, 2233506, 2233570, 2233634, 2233698, 2233762, 2233826, 2233890, 2233954, 2234018, 2234082]), new Uint32Array([23068672, 6291456, 23068672, 23068672, 23068672, 6291456, 6291456, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 6291456, 6291456]), new Uint32Array([6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 0, 0]), new Uint32Array([6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 0, 0, 0, 0, 6291456, 6291456]), new Uint32Array([6291456, 6291456, 6291456, 6291456, 6291456, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]), new Uint32Array([2205217, 2205249, 2205281, 2205313, 2205345, 2205377, 2205409, 2205441, 2205473, 2205505, 2205537, 2205569, 2205601, 2205633, 2205665, 2205697]), new Uint32Array([6291456, 0, 6291456, 0, 0, 0, 6291456, 6291456, 6291456, 6291456, 0, 0, 23068672, 6291456, 23068672, 23068672]), new Uint32Array([2173601, 2173761, 2174081, 2173569, 2174241, 2174113, 2173953, 6291456, 2174305, 6291456, 2174337, 6291456, 2174369, 6291456, 2174401, 6291456]), new Uint32Array([6291456, 23068672, 23068672, 23068672, 0, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 0, 6291456, 6291456]), new Uint32Array([2152450, 2152514, 2099653, 2104452, 2099813, 2122243, 2099973, 2152578, 2122339, 2122435, 2122531, 2122627, 2122723, 2104580, 2122819, 2152642]), new Uint32Array([2236385, 2236417, 2236449, 2236482, 2236545, 2215425, 2236577, 2236609, 2236641, 2236673, 2215457, 2236705, 2236737, 2236770, 2215489, 2236833]), new Uint32Array([2163394, 2159746, 2163458, 2131362, 2163522, 2160130, 2163778, 2132226, 2163842, 2132898, 2163906, 2161410, 2138658, 2097666, 2136162, 2163650]), new Uint32Array([2218721, 2246913, 2246946, 2216385, 2247010, 2247074, 2215009, 2247137, 2247169, 2216481, 2247201, 2247233, 2247266, 2247330, 2247330, 0]), new Uint32Array([2129730, 2129762, 2129858, 2129731, 2129827, 2156482, 2156482, 0, 0, 0, 0, 0, 0, 0, 0, 0]), new Uint32Array([6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 0, 0, 0, 6291456, 6291456, 6291456]), new Uint32Array([6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 0, 6291456, 0, 0, 0, 0, 0, 6291456, 0, 0]), new Uint32Array([2203969, 2204001, 2181377, 2204033, 2204065, 6291456, 2204097, 6291456, 0, 0, 0, 0, 0, 0, 0, 0]), new Uint32Array([2169473, 6291456, 2169505, 6291456, 2169537, 6291456, 2169569, 6291456, 2169601, 6291456, 2169633, 6291456, 2169665, 6291456, 2169697, 6291456]), new Uint32Array([2141542, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456]), new Uint32Array([2220801, 2220801, 2220801, 2220801, 2220833, 2220833, 2220865, 2220865, 2220865, 2220865, 2220897, 2220897, 2220897, 2220897, 2139873, 2139873]), new Uint32Array([0, 0, 0, 0, 0, 23068672, 23068672, 0, 0, 0, 0, 0, 0, 0, 6291456, 0]), new Uint32Array([2214849, 2218433, 2218465, 2218497, 2218529, 2218561, 2214881, 2218593, 2218625, 2218657, 2218689, 2218721, 2218753, 2216545, 2218785, 2218817]), new Uint32Array([23068672, 23068672, 23068672, 23068672, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6291456]), new Uint32Array([2136482, 2164610, 2164674, 2164738, 2164802, 2132802, 2132706, 2164866, 2132898, 2164930, 2164994, 2165058, 2165122, 2132802, 2132706, 2164866]), new Uint32Array([2207649, 2207681, 2207713, 2207745, 2207777, 2207809, 2207841, 2207873, 2207905, 2207937, 2207969, 2208001, 2208033, 2208065, 2208097, 2208129]), new Uint32Array([2123683, 2105092, 2152706, 2123779, 2105220, 2152770, 2100453, 2098755, 2123906, 2124002, 2124098, 2124194, 2124290, 2124386, 2124482, 2124578]), new Uint32Array([6291456, 6291456, 6291456, 6291456, 0, 0, 0, 6291456, 0, 0, 0, 0, 0, 0, 0, 10485857]), new Uint32Array([6291456, 6291456, 6291456, 6291456, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672]), new Uint32Array([10508163, 10508259, 10508355, 10508451, 2200129, 2200161, 2192737, 2200193, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456]), new Uint32Array([2203553, 6291456, 2203585, 6291456, 6291456, 6291456, 2203617, 6291456, 2203649, 6291456, 2203681, 6291456, 2203713, 6291456, 2203745, 6291456]), new Uint32Array([18884449, 18884065, 23068672, 18884417, 18884034, 18921185, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 18874368]), new Uint32Array([2247393, 2247426, 2247489, 2247521, 2247553, 2247586, 2247649, 2247681, 2247713, 2247745, 2247777, 2247810, 2247873, 2247905, 2247937, 2247969]), new Uint32Array([6291456, 6291456, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 6291456, 23068672]), new Uint32Array([2134145, 2097153, 2134241, 0, 2132705, 2130977, 2160065, 2131297, 0, 2133089, 2160577, 2133857, 2235297, 0, 2235329, 0]), new Uint32Array([2182593, 6291456, 2182625, 6291456, 2182657, 6291456, 2182689, 6291456, 2182721, 6291456, 2182753, 6291456, 2182785, 6291456, 2182817, 6291456]), new Uint32Array([6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 2102402, 2102403, 6291456, 2110050]), new Uint32Array([2149890, 2108323, 2149954, 6291456, 2113441, 6291456, 2149057, 6291456, 2113441, 6291456, 2105473, 2167265, 2111137, 2105505, 6291456, 2108353]), new Uint32Array([2219105, 2219137, 2195233, 2251554, 2251617, 2251649, 2251681, 2251713, 2251746, 2251810, 2251873, 2251905, 2251937, 2251970, 2252033, 2219169]), new Uint32Array([2203009, 6291456, 2203041, 6291456, 2203073, 6291456, 2203105, 6291456, 2203137, 6291456, 2203169, 6291456, 2203201, 6291456, 2203233, 6291456]), new Uint32Array([2128195, 2128291, 2128387, 2128483, 2128579, 2128675, 2128771, 2128867, 2128963, 2129059, 2129155, 2129251, 2129347, 2129443, 2129539, 2129635]), new Uint32Array([6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 2140964, 2141156, 2140966, 2141158, 2141350]), new Uint32Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 23068672, 23068672, 23068672, 23068672, 23068672]), new Uint32Array([23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 6291456, 6291456, 6291456, 6291456, 23068672, 23068672, 23068672, 23068672, 23068672]), new Uint32Array([2225378, 2225442, 2225506, 2225570, 2225634, 2225698, 2225762, 2225826, 2225890, 2225954, 2226018, 2226082, 2226146, 2226210, 2226274, 2226338]), new Uint32Array([23068672, 23068672, 23068672, 23068672, 23068672, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456]), new Uint32Array([23068672, 23068672, 23068672, 23068672, 0, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 0, 6291456, 6291456]), new Uint32Array([6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 0, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456]), new Uint32Array([2112577, 2098177, 2098305, 2108321, 2108289, 2100865, 2113153, 2108481, 2113345, 2113441, 2098209, 2111137, 2105505, 2098241, 2108353, 2108417]), new Uint32Array([2108353, 2108417, 0, 2105601, 2108193, 2157121, 2157313, 2157377, 2157441, 2100897, 6291456, 2108419, 2173953, 2173633, 2173633, 2173953]), new Uint32Array([2111713, 2173121, 2111905, 2098177, 2173153, 2173185, 2173217, 2113153, 2113345, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456]), new Uint32Array([6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 0, 6291456, 6291456, 6291456, 6291456, 2190753]), new Uint32Array([6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 2197249, 6291456, 2117377, 2197281, 2197313, 6291456, 6291456, 6291456, 6291456, 6291456]), new Uint32Array([6291456, 0, 0, 0, 0, 0, 0, 23068672, 0, 0, 0, 0, 0, 6291456, 6291456, 6291456]), new Uint32Array([2098337, 2101441, 2101569, 2101697, 2101825, 2101953, 2102081, 2102209, 2100833, 2100737, 2098337, 2101441, 2101569, 2101697, 2101825, 2101953]), new Uint32Array([23068672, 23068672, 23068672, 23068672, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 0, 0, 0]), new Uint32Array([0, 0, 0, 0, 0, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456]), new Uint32Array([6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 0, 0, 23068672, 23068672, 23068672]), new Uint32Array([2173281, 6291456, 2173313, 6291456, 2173345, 6291456, 2173377, 6291456, 0, 0, 10532546, 6291456, 6291456, 6291456, 10562017, 2173441]), new Uint32Array([6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 23068672, 23068672, 0, 0]), new Uint32Array([23068672, 23068672, 23068672, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456]), new Uint32Array([23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456]), new Uint32Array([2159426, 2159490, 2159554, 2159362, 2159618, 2159682, 2139522, 2136450, 2159746, 2159810, 2159874, 2130978, 2131074, 2131266, 2131362, 2159938]), new Uint32Array([6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 0, 0, 0, 0, 6291456, 6291456, 6291456, 6291456, 6291456]), new Uint32Array([2203233, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 2203265, 6291456, 2203297, 6291456, 2203329, 2203361, 6291456]), new Uint32Array([6291456, 6291456, 2148418, 2148482, 2148546, 0, 6291456, 2148610, 2186529, 2186561, 2148417, 2148545, 2148482, 10495778, 2143969, 10495778]), new Uint32Array([2134146, 2139426, 2160962, 2134242, 2161218, 2161282, 2161346, 2161410, 2138658, 2134722, 2134434, 2134818, 2097666, 2097346, 2097698, 2105986]), new Uint32Array([2198881, 2198913, 2198945, 2198977, 2199009, 2199041, 2199073, 2199105, 2199137, 2199169, 2199201, 2199233, 2199265, 2199297, 2199329, 2199361]), new Uint32Array([0, 23068672, 23068672, 23068672, 0, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 0, 6291456]), new Uint32Array([10610561, 2098209, 2111137, 2105505, 2098241, 2108353, 2108417, 2105825, 2111713, 2100897, 2111905, 2105473, 2105569, 2105601, 2112289, 2108193]), new Uint32Array([2183873, 6291456, 2183905, 6291456, 2183937, 6291456, 2183969, 6291456, 2184001, 6291456, 2184033, 6291456, 2184065, 6291456, 2184097, 6291456]), new Uint32Array([2244642, 2244706, 2244769, 2244801, 2218305, 2244833, 2244865, 2244897, 2244929, 2244961, 2244993, 2245026, 2245089, 2245122, 2245185, 0]), new Uint32Array([6291456, 6291456, 2116513, 2116609, 2116705, 2116801, 2199873, 2199905, 2199937, 2199969, 2190913, 2200001, 2200033, 2200065, 2200097, 2191009]), new Uint32Array([6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 0, 0, 2180673, 2180705, 2180737, 2180769, 2180801, 2180833, 0, 0]), new Uint32Array([2098081, 2099521, 2099105, 2120705, 2098369, 2120801, 2103361, 2097985, 2098433, 2121377, 2121473, 2099169, 2099873, 2098401, 2099393, 2152609]), new Uint32Array([6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 2150402]), new Uint32Array([6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 0, 0, 2145666, 2145730, 6291456, 6291456]), new Uint32Array([2173921, 2173953, 2173985, 2173761, 2174017, 2174049, 2174081, 2174113, 2174145, 2174177, 2149057, 2233057, 2148481, 2173601, 2173633, 2173665]), new Uint32Array([2187073, 6291456, 6291456, 6291456, 6291456, 2098241, 2098241, 2108353, 2100897, 2111905, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456]), new Uint32Array([6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 2102404, 6291456, 6291456, 6291456]), new Uint32Array([6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 2100612, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 10485857]), new Uint32Array([2149057, 2233057, 2148481, 2173601, 2173633, 2173665, 2173697, 2173729, 2148801, 2173761, 2143969, 2173793, 2173825, 2153473, 2173857, 2173889]), new Uint32Array([2217697, 2217729, 2217761, 2217793, 2217825, 2217857, 2217889, 2217921, 2217953, 2215873, 2217985, 2215905, 2218017, 2218049, 2218081, 2218113]), new Uint32Array([2211233, 2218849, 2216673, 2218881, 2218913, 2218945, 2218977, 2219009, 2216833, 2219041, 2215137, 2219073, 2216865, 2209505, 2219105, 2216897]), new Uint32Array([2240097, 2240129, 2240161, 2240193, 2240225, 2240257, 2240289, 2240321, 2240353, 2240386, 2240449, 2240481, 2240513, 2240545, 2207905, 2240578]), new Uint32Array([6291456, 6291456, 2202273, 6291456, 2202305, 6291456, 2202337, 6291456, 2202369, 6291456, 2202401, 6291456, 2202433, 6291456, 2202465, 6291456]), new Uint32Array([0, 23068672, 23068672, 18923394, 23068672, 18923458, 18923522, 18884099, 18923586, 18884195, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672]), new Uint32Array([2201121, 6291456, 2201153, 6291456, 2201185, 6291456, 2201217, 6291456, 2201249, 6291456, 2201281, 6291456, 2201313, 6291456, 2201345, 6291456]), new Uint32Array([6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 0, 0, 0, 6291456, 6291456]), new Uint32Array([2211041, 2211073, 2211105, 2211137, 2211169, 2211201, 2211233, 2211265, 2211297, 2211329, 2211361, 2211393, 2211425, 2211457, 2211489, 2211521]), new Uint32Array([2181825, 6291456, 2181857, 6291456, 2181889, 6291456, 2181921, 6291456, 2181953, 6291456, 2181985, 6291456, 2182017, 6291456, 2182049, 6291456]), new Uint32Array([2162337, 2097633, 2097633, 2097633, 2097633, 2132705, 2132705, 2132705, 2132705, 2097153, 2097153, 2097153, 2097153, 2133089, 2133089, 2133089]), new Uint32Array([6291456, 6291456, 6291456, 6291456, 0, 0, 0, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456]), new Uint32Array([6291456, 2148545, 6291456, 2173473, 6291456, 2148865, 6291456, 2173505, 6291456, 2173537, 6291456, 2173569, 6291456, 2149121, 0, 0]), new Uint32Array([6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]), new Uint32Array([23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 6291456, 6291456, 0, 6291456, 6291456]), new Uint32Array([6291456, 6291456, 6291456, 6291456, 23068672, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 0, 0, 0, 0]), new Uint32Array([2148801, 2173761, 2143969, 2173793, 2173825, 2153473, 2173857, 2173889, 2173921, 2173953, 2173985, 2174017, 2174017, 2174049, 2174081, 2174113]), new Uint32Array([23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 0, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672]), new Uint32Array([2207137, 2207169, 2207201, 2207233, 2207265, 2207297, 2207329, 2207361, 2207393, 2207425, 2207457, 2207489, 2207521, 2207553, 2207585, 2207617]), new Uint32Array([6291456, 6291456, 23068672, 23068672, 23068672, 6291456, 6291456, 0, 23068672, 23068672, 0, 0, 0, 0, 0, 0]), new Uint32Array([2198401, 2198433, 2198465, 2198497, 0, 2198529, 2198561, 2198593, 2198625, 2198657, 2198689, 2198721, 2198753, 2198785, 2198817, 2198849]), new Uint32Array([2105505, 2098241, 2108353, 2108417, 2105825, 2111713, 2100897, 2111905, 2105473, 2105569, 2105601, 2112289, 2108193, 2112481, 2112577, 2098177]), new Uint32Array([23068672, 23068672, 23068672, 23068672, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 23068672, 0, 0]), new Uint32Array([2216385, 2118721, 2216417, 2216449, 2216481, 2216513, 2216545, 2211233, 2216577, 2216609, 2216641, 2216673, 2216705, 2216737, 2216737, 2216769]), new Uint32Array([2216801, 2216833, 2216865, 2216897, 2216929, 2216961, 2216993, 2215169, 2217025, 2217057, 2217089, 2217121, 2217154, 2217217, 0, 0]), new Uint32Array([2210593, 2191809, 2210625, 2210657, 2210689, 2210721, 2210753, 2210785, 2210817, 2210849, 2191297, 2210881, 2210913, 2210945, 2210977, 2211009]), new Uint32Array([0, 0, 2105825, 0, 0, 2111905, 2105473, 0, 0, 2112289, 2108193, 2112481, 2112577, 0, 2098305, 2108321]), new Uint32Array([0, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456]), new Uint32Array([0, 2097153, 2134241, 0, 2132705, 0, 0, 2131297, 0, 2133089, 0, 2133857, 0, 2220769, 0, 2235361]), new Uint32Array([14680064, 14680064, 14680064, 14680064, 14680064, 14680064, 14680064, 14680064, 14680064, 14680064, 14680064, 14680064, 14680064, 6291456, 6291456, 14680064]), new Uint32Array([23068672, 23068672, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 0, 0, 0, 0, 0, 0, 0, 0]), new Uint32Array([2171873, 6291456, 2171905, 6291456, 2171937, 6291456, 2171969, 6291456, 2172001, 6291456, 2172033, 6291456, 2172065, 6291456, 2172097, 6291456]), new Uint32Array([2220929, 2220929, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456]), new Uint32Array([2133857, 2134145, 2134145, 2134145, 2134145, 2134241, 2134241, 2134241, 2134241, 2105889, 2105889, 2105889, 2105889, 2097185, 2097185, 2097185]), new Uint32Array([2173697, 2173761, 2173793, 2174113, 2173985, 2173953, 2148481, 2173601, 2173633, 2173665, 2173697, 2173729, 2148801, 2173761, 2143969, 2173793]), new Uint32Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 10499619, 10499715, 10499811, 10499907]), new Uint32Array([0, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672]), new Uint32Array([6291456, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 23068672]), new Uint32Array([6291456, 6291456, 6291456, 6291456, 0, 0, 0, 0, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456]), new Uint32Array([23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 0, 0, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672]), new Uint32Array([6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 0, 6291456, 6291456, 0, 6291456]), new Uint32Array([23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 6291456, 6291456, 6291456]), new Uint32Array([23068672, 23068672, 23068672, 23068672, 23068672, 0, 23068672, 23068672, 23068672, 0, 23068672, 23068672, 23068672, 23068672, 6291456, 6291456]), new Uint32Array([6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 0, 0, 0, 6291456, 23068672, 23068672]), new Uint32Array([23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 0, 0, 0, 6291456, 6291456, 6291456, 6291456, 6291456]), new Uint32Array([6291456, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 2144322, 2144386, 2144450, 2144514, 2144578, 2144642, 2144706, 2144770]), new Uint32Array([23068672, 23068672, 23068672, 6291456, 6291456, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 6291456, 6291456, 6291456, 6291456]), new Uint32Array([2113153, 2108481, 2113345, 2113441, 2098209, 2111137, 0, 2098241, 2108353, 2108417, 2105825, 0, 0, 2111905, 2105473, 2105569]), new Uint32Array([2236321, 2236353, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]), new Uint32Array([2152194, 2121283, 2103684, 2103812, 2097986, 2098533, 2097990, 2098693, 2098595, 2098853, 2099013, 2103940, 2121379, 2121475, 2121571, 2104068]), new Uint32Array([2206241, 2206273, 2206305, 2206337, 2206369, 2206401, 2206433, 2206465, 2206497, 2206529, 2206561, 2206593, 2206625, 2206657, 2206689, 2206721]), new Uint32Array([6291456, 6291456, 6291456, 6291456, 16777216, 16777216, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672]), new Uint32Array([6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 0, 0, 23068672, 23068672, 10538818, 10538882, 6291456, 6291456, 2150338]), new Uint32Array([6291456, 6291456, 6291456, 0, 0, 0, 0, 0, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456]), new Uint32Array([2214369, 2214401, 2214433, 2214465, 2214497, 2214529, 2214561, 2214593, 2194977, 2214625, 2195073, 2214657, 2214689, 2214721, 6291456, 6291456]), new Uint32Array([2097152, 2097152, 2097152, 2097152, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]), new Uint32Array([2182081, 6291456, 2182113, 6291456, 2182145, 6291456, 2182177, 6291456, 2182209, 6291456, 2182241, 6291456, 2182273, 6291456, 2182305, 6291456]), new Uint32Array([6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 2146881, 2146945, 2147009, 2147073, 2147137, 2147201, 2147265, 2147329]), new Uint32Array([6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 0, 0, 6291456, 23068672, 23068672]), new Uint32Array([0, 0, 0, 0, 0, 0, 0, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456]), new Uint32Array([2122915, 2123011, 2123107, 2104708, 2123203, 2123299, 2123395, 2100133, 2104836, 2100290, 2100293, 2104962, 2104964, 2098052, 2123491, 2123587]), new Uint32Array([23068672, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 0, 6291456]), new Uint32Array([6291456, 2171169, 6291456, 2171201, 6291456, 2171233, 6291456, 2171265, 6291456, 2171297, 6291456, 2171329, 6291456, 6291456, 2171361, 6291456]), new Uint32Array([6291456, 6291456, 6291456, 6291456, 0, 0, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456]), new Uint32Array([0, 0, 2148994, 2149058, 2149122, 0, 6291456, 2149186, 2186945, 2173537, 2148993, 2149121, 2149058, 10531458, 10496066, 0]), new Uint32Array([2195009, 2195041, 2195073, 2195105, 2195137, 2195169, 2195201, 2195233, 2195265, 2195297, 2195329, 2195361, 2195393, 2195425, 2195457, 2195489]), new Uint32Array([23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 6291456, 0, 0, 6291456, 6291456]), new Uint32Array([2182849, 6291456, 2182881, 6291456, 2182913, 6291456, 2182945, 6291456, 2182977, 6291456, 2183009, 6291456, 2183041, 6291456, 2183073, 6291456]), new Uint32Array([2211553, 2210081, 2211585, 2211617, 2211649, 2211681, 2211713, 2211745, 2211777, 2211809, 2209569, 2211841, 2211873, 2211905, 2211937, 2211969]), new Uint32Array([2112577, 2098177, 2098305, 2108321, 2108289, 2100865, 2113153, 2108481, 2113345, 2113441, 2166594, 2127298, 2166658, 2142978, 2141827, 2166722]), new Uint32Array([2173985, 2173761, 2174017, 2174049, 2174081, 2174113, 2174145, 2174177, 2149057, 2233057, 2148481, 2173601, 2173633, 2173665, 2173697, 2173729]), new Uint32Array([6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 0, 0, 2185761, 2185793, 2185825, 2185857, 2185889, 2185921, 0, 0]), new Uint32Array([6291456, 2148481, 2173601, 2173633, 2173665, 2173697, 2173729, 2148801, 2173761, 2143969, 2173793, 2173825, 2153473, 2173857, 2173889, 2173921]), new Uint32Array([6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 0, 0, 0, 0, 0, 6291456]), new Uint32Array([0, 0, 0, 2220961, 2220961, 2220961, 2220961, 2144193, 2144193, 2159201, 2159201, 2159265, 2159265, 2144194, 2220993, 2220993]), new Uint32Array([2192641, 2235393, 2235425, 2152257, 2116609, 2235457, 2235489, 2200065, 2235521, 2235553, 2235585, 2212449, 2235617, 2235649, 2235681, 2235713]), new Uint32Array([2194049, 2194081, 2194113, 2194145, 2194177, 2194209, 2194241, 2194273, 2194305, 2194337, 2194369, 2194401, 2194433, 2194465, 2194497, 2194529]), new Uint32Array([2196673, 2208641, 2208673, 2208705, 2208737, 2208769, 2208801, 2208833, 2208865, 2208897, 2208929, 2208961, 2208993, 2209025, 2209057, 2209089]), new Uint32Array([2191681, 2191713, 2191745, 2191777, 2153281, 2191809, 2191841, 2191873, 2191905, 2191937, 2191969, 2192001, 2192033, 2192065, 2192097, 2192129]), new Uint32Array([2230946, 2231010, 2231074, 2231138, 2231202, 2231266, 2231330, 2231394, 2231458, 2231522, 2231586, 2231650, 2231714, 2231778, 2231842, 2231906]), new Uint32Array([14680064, 14680064, 14680064, 14680064, 14680064, 14680064, 14680064, 14680064, 14680064, 14680064, 14680064, 14680064, 14680064, 14680064, 14680064, 14680064]), new Uint32Array([6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 2185953, 2185985, 2186017, 2186049, 2186081, 2186113, 2186145, 2186177]), new Uint32Array([2139811, 2139907, 2097284, 2105860, 2105988, 2106116, 2106244, 2097444, 2097604, 2097155, 10485778, 10486344, 2106372, 6291456, 0, 0]), new Uint32Array([2110051, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456]), new Uint32Array([0, 0, 0, 0, 0, 0, 0, 0, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456]), new Uint32Array([2172385, 6291456, 2172417, 6291456, 2172449, 6291456, 2172481, 6291456, 2172513, 6291456, 2172545, 6291456, 2172577, 6291456, 2172609, 6291456]), new Uint32Array([0, 0, 23068672, 23068672, 6291456, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]), new Uint32Array([2249345, 2249377, 2249409, 2249441, 2249473, 2249505, 2249537, 2249570, 2210209, 2249633, 2249665, 2249697, 2249729, 2249761, 2249793, 2216769]), new Uint32Array([6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 23068672, 23068672, 23068672, 23068672]), new Uint32Array([6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 0, 0, 0, 0, 6291456, 6291456, 6291456, 6291456]), new Uint32Array([2187169, 2187201, 2187233, 2187265, 2187297, 2187329, 2187361, 2187393, 2187425, 2187457, 2187489, 2187521, 2187553, 2187585, 2187617, 2187649]), new Uint32Array([6291456, 6291456, 6291456, 6291456, 6291456, 23068672, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456]), new Uint32Array([0, 0, 0, 6291456, 6291456, 0, 0, 0, 6291456, 6291456, 6291456, 0, 0, 0, 6291456, 6291456]), new Uint32Array([2182337, 6291456, 2182369, 6291456, 2182401, 6291456, 2182433, 6291456, 2182465, 6291456, 2182497, 6291456, 2182529, 6291456, 2182561, 6291456]), new Uint32Array([2138179, 2138275, 2138371, 2138467, 2134243, 2134435, 2138563, 2138659, 2138755, 2138851, 2138947, 2139043, 2138947, 2138755, 2139139, 2139235]), new Uint32Array([23068672, 23068672, 23068672, 23068672, 6291456, 6291456, 6291456, 6291456, 0, 0, 0, 0, 0, 0, 0, 0]), new Uint32Array([0, 0, 23068672, 23068672, 0, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456]), new Uint32Array([2250498, 2250562, 2250625, 2250657, 2208321, 2250689, 2250721, 2250753, 2250785, 2250817, 2250849, 2218945, 2250881, 2250913, 2250945, 0]), new Uint32Array([2170369, 2105569, 2098305, 2108481, 2173249, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456]), new Uint32Array([23068672, 23068672, 23068672, 23068672, 0, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 0, 0, 6291456]), new Uint32Array([2100897, 2111905, 2105473, 2105569, 2105601, 0, 2108193, 0, 0, 0, 2098305, 2108321, 2108289, 2100865, 2113153, 2108481]), new Uint32Array([2100897, 2100897, 2105569, 2105569, 6291456, 2112289, 2149826, 6291456, 6291456, 2112481, 2112577, 2098177, 2098177, 2098177, 6291456, 6291456]), new Uint32Array([23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 0, 0, 6291456, 6291456, 6291456]), new Uint32Array([6291456, 2169953, 2169985, 6291456, 2170017, 6291456, 2170049, 2170081, 6291456, 2170113, 2170145, 2170177, 6291456, 6291456, 2170209, 2170241]), new Uint32Array([6291456, 6291456, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]), new Uint32Array([0, 0, 0, 0, 0, 0, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456]), new Uint32Array([2220641, 2220641, 2220673, 2220673, 2220673, 2220673, 2220705, 2220705, 2220705, 2220705, 2220737, 2220737, 2220737, 2220737, 2220769, 2220769]), new Uint32Array([2127650, 2127746, 2127842, 2127938, 2128034, 2128130, 2128226, 2128322, 2128418, 2127523, 2127619, 2127715, 2127811, 2127907, 2128003, 2128099]), new Uint32Array([2143969, 2173793, 2173825, 2153473, 2173857, 2173889, 2173921, 2173953, 2173985, 2173761, 2174017, 2174049, 2174081, 2174113, 2174145, 2174177]), new Uint32Array([0, 0, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672]), new Uint32Array([2204705, 2204737, 2204769, 2204801, 2204833, 2204865, 2204897, 2204929, 2204961, 2204993, 2205025, 2205057, 2205089, 2205121, 2205153, 2205185]), new Uint32Array([2176385, 6291456, 2176417, 6291456, 2176449, 6291456, 2176481, 6291456, 2176513, 6291456, 2176545, 6291456, 2176577, 6291456, 2176609, 6291456]), new Uint32Array([2195521, 2195553, 2195585, 2195617, 2195649, 2195681, 2117857, 2195713, 2195745, 2195777, 2195809, 2195841, 2195873, 2195905, 2195937, 2195969]), new Uint32Array([6291456, 6291456, 6291456, 6291456, 6291456, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672]), new Uint32Array([6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 0, 0, 0, 0]), new Uint32Array([6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 0, 6291456, 6291456, 6291456]), new Uint32Array([2173921, 2173953, 2173985, 2174017, 2174017, 2174049, 2174081, 2174113, 2174145, 2174177, 2149057, 2233089, 2173697, 2173761, 2173793, 2174113]), new Uint32Array([2131586, 2132450, 2135970, 2135778, 2161602, 2136162, 2163650, 2161794, 2135586, 2163714, 2137186, 2131810, 2160290, 2135170, 2097506, 2159554]), new Uint32Array([2134145, 2097153, 2134241, 2105953, 2132705, 2130977, 2160065, 2131297, 2162049, 2133089, 2160577, 2133857, 0, 0, 0, 0]), new Uint32Array([2116513, 2116609, 2116705, 2116801, 2116897, 2116993, 2117089, 2117185, 2117281, 2117377, 2117473, 2117569, 2117665, 2117761, 2117857, 2117953]), new Uint32Array([2100737, 2098337, 2101441, 2101569, 2101697, 2101825, 2101953, 2102081, 2102209, 2100802, 2101154, 2101282, 2101410, 2101538, 2101666, 2101794]), new Uint32Array([2100289, 2098657, 2098049, 2200737, 2123489, 2123681, 2200769, 2098625, 2100321, 2098145, 2100449, 2098017, 2098753, 2098977, 2150241, 2150305]), new Uint32Array([6291456, 6291456, 6291456, 0, 6291456, 6291456, 6291456, 6291456, 6291456, 2109955, 6291456, 6291456, 0, 0, 0, 0]), new Uint32Array([18874368, 18874368, 18874368, 18874368, 18874368, 18874368, 18874368, 18874368, 18874368, 18874368, 18874368, 18874368, 18874368, 18874368, 18874368, 18874368]), new Uint32Array([6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 0, 6291456, 0, 6291456, 0, 0]), new Uint32Array([2130979, 2131075, 2131075, 2131171, 2131267, 2131363, 2131459, 2131555, 2131651, 2131651, 2131747, 2131843, 2131939, 2132035, 2132131, 2132227]), new Uint32Array([0, 2177793, 6291456, 2177825, 6291456, 2177857, 6291456, 2177889, 6291456, 2177921, 6291456, 2177953, 6291456, 2177985, 6291456, 6291456]), new Uint32Array([6291456, 6291456, 6291456, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672]), new Uint32Array([6291456, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]), new Uint32Array([2113345, 0, 2098209, 2111137, 2105505, 2098241, 2108353, 2108417, 2105825, 2111713, 2100897, 2111905, 2105473, 2105569, 2105601, 2112289]), new Uint32Array([2136643, 2136739, 2136835, 2136931, 2137027, 2137123, 2137219, 2137315, 2137411, 2137507, 2137603, 2137699, 2137795, 2137891, 2137987, 2138083]), new Uint32Array([6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 0]), new Uint32Array([2174433, 6291456, 2174465, 6291456, 2174497, 6291456, 2174529, 6291456, 2174561, 6291456, 2174593, 6291456, 2174625, 6291456, 2174657, 6291456]), new Uint32Array([0, 0, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456]), new Uint32Array([2105473, 2105569, 2105601, 2112289, 2108193, 2112481, 2112577, 2098177, 2098305, 2108321, 2108289, 2100865, 2113153, 2108481, 2113345, 2113441]), new Uint32Array([10496547, 10496643, 2105505, 2149698, 6291456, 10496739, 10496835, 2170273, 6291456, 2149762, 2105825, 2111713, 2111713, 2111713, 2111713, 2168673]), new Uint32Array([6291456, 2143490, 2143490, 2143490, 2171649, 6291456, 2171681, 2171713, 2171745, 6291456, 2171777, 6291456, 2171809, 6291456, 2171841, 6291456]), new Uint32Array([2159106, 2159106, 2159170, 2159170, 2159234, 2159234, 2159298, 2159298, 2159298, 2159362, 2159362, 2159362, 2106401, 2106401, 2106401, 2106401]), new Uint32Array([2105601, 2112289, 2108193, 2112481, 2112577, 2098177, 2098305, 2108321, 2108289, 2100865, 2113153, 2108481, 2113345, 2113441, 2098209, 2111137]), new Uint32Array([2108417, 2181217, 2181249, 2181281, 2170433, 2170401, 2181313, 2181345, 2181377, 2181409, 2181441, 2181473, 2181505, 2181537, 2170529, 2181569]), new Uint32Array([2218433, 2245761, 2245793, 2245825, 2245857, 2245890, 2245953, 2245986, 2209665, 2246050, 2246113, 2246146, 2246210, 2246274, 2246337, 2246369]), new Uint32Array([2230754, 2230818, 2230882, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]), new Uint32Array([6291456, 0, 6291456, 6291456, 6291456, 6291456, 0, 0, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456]), new Uint32Array([6291456, 0, 0, 0, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456]), new Uint32Array([2184129, 6291456, 2184161, 6291456, 2184193, 6291456, 6291456, 6291456, 6291456, 6291456, 2146818, 2183361, 6291456, 6291456, 2142978, 6291456]), new Uint32Array([6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 0, 0, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456]), new Uint32Array([2135170, 2097506, 2130691, 2130787, 2130883, 2163970, 2164034, 2164098, 2164162, 2164226, 2164290, 2164354, 2164418, 2164482, 2164546, 2133122]), new Uint32Array([2108515, 2108611, 2100740, 2108707, 2108803, 2108899, 2108995, 2109091, 2109187, 2109283, 2109379, 2109475, 2109571, 2109667, 2109763, 2100738]), new Uint32Array([2102788, 2102916, 2103044, 2120515, 2103172, 2120611, 2120707, 2098373, 2103300, 2120803, 2120899, 2120995, 2103428, 2103556, 2121091, 2121187]), new Uint32Array([2158082, 2158146, 0, 2158210, 2158274, 0, 2158338, 2158402, 2158466, 2129922, 2158530, 2158594, 2158658, 2158722, 2158786, 2158850]), new Uint32Array([10499619, 10499715, 10499811, 10499907, 10500003, 10500099, 10500195, 10500291, 10500387, 10500483, 10500579, 10500675, 10500771, 10500867, 10500963, 10501059]), new Uint32Array([2239585, 2239618, 2239681, 2239713, 0, 2191969, 2239745, 2239777, 2192033, 2239809, 2239841, 2239874, 2239937, 2239970, 2240033, 2240065]), new Uint32Array([2252705, 2252738, 2252801, 2252833, 2252865, 2252897, 2252930, 2252994, 2253057, 2253089, 2253121, 2253154, 2253217, 2253250, 2219361, 2219361]), new Uint32Array([2105825, 2111713, 2100897, 2111905, 2105473, 2105569, 2105601, 2112289, 2108193, 2112481, 2112577, 2098177, 2098305, 2108321, 2108289, 2100865]), new Uint32Array([6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 10538050, 10538114, 10538178, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456]), new Uint32Array([2226402, 2226466, 2226530, 2226594, 2226658, 2226722, 2226786, 2226850, 2226914, 2226978, 2227042, 2227106, 2227170, 2227234, 2227298, 2227362]), new Uint32Array([23068672, 6291456, 6291456, 6291456, 6291456, 2144066, 2144130, 2144194, 2144258, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456]), new Uint32Array([6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 23068672, 23068672, 23068672, 6291456, 23068672, 23068672]), new Uint32Array([6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 0, 0, 0, 0, 0, 0, 0, 0]), new Uint32Array([2124674, 2124770, 2123875, 2123971, 2124067, 2124163, 2124259, 2124355, 2124451, 2124547, 2124643, 2124739, 2124835, 2124931, 2125027, 2125123]), new Uint32Array([2168065, 6291456, 2168097, 6291456, 2168129, 6291456, 2168161, 6291456, 2168193, 6291456, 2168225, 6291456, 2168257, 6291456, 2168289, 6291456]), new Uint32Array([23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 0, 0, 0, 0]), new Uint32Array([23068672, 23068672, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456]), new Uint32Array([6291456, 6291456, 6291456, 2100610, 2100611, 6291456, 2107842, 2107843, 6291456, 6291456, 6291456, 6291456, 10537922, 6291456, 10537986, 6291456]), new Uint32Array([2174849, 2174881, 2174913, 2174945, 2174977, 2175009, 2175041, 2175073, 2175105, 2175137, 2175169, 2175201, 2175233, 2175265, 2175297, 2175329]), new Uint32Array([2154562, 2154626, 2154690, 2154754, 2141858, 2154818, 2154882, 2127298, 2154946, 2127298, 2155010, 2155074, 2155138, 2155202, 2155266, 2155202]), new Uint32Array([23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 23068672, 0]), new Uint32Array([2200641, 2150786, 2150850, 2150914, 2150978, 2151042, 2106562, 2151106, 2150562, 2151170, 2151234, 2151298, 2151362, 2151426, 2151490, 2151554]), new Uint32Array([23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 0, 0, 0, 0, 0, 0, 0, 0, 6291456, 6291456]), new Uint32Array([2220289, 2220289, 2220321, 2220321, 2220321, 2220321, 2220353, 2220353, 2220353, 2220353, 2220385, 2220385, 2220385, 2220385, 2220417, 2220417]), new Uint32Array([2155330, 2155394, 0, 2155458, 2155522, 2155586, 2105732, 0, 2155650, 2155714, 2155778, 2125314, 2155842, 2155906, 2126274, 2155970]), new Uint32Array([23068672, 23068672, 23068672, 23068672, 23068672, 6291456, 6291456, 23068672, 23068672, 6291456, 23068672, 23068672, 23068672, 23068672, 6291456, 6291456]), new Uint32Array([6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 6291456, 0, 0, 0, 0, 0, 0]), new Uint32Array([2097729, 2106017, 2106017, 2106017, 2106017, 2131297, 2131297, 2131297, 2131297, 2106081, 2106081, 2162049, 2162049, 2105953, 2105953, 2162337]), new Uint32Array([2097185, 2097697, 2097697, 2097697, 2097697, 2135777, 2135777, 2135777, 2135777, 2097377, 2097377, 2097377, 2097377, 2097601, 2097601, 2097217]), new Uint32Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 23068672]), new Uint32Array([2139331, 2139427, 2139523, 2139043, 2133571, 2132611, 2139619, 2139715, 0, 0, 0, 0, 0, 0, 0, 0]), new Uint32Array([2174113, 2174145, 2100897, 2098177, 2108289, 2100865, 2173601, 2173633, 2173985, 2174113, 2174145, 6291456, 6291456, 6291456, 6291456, 6291456]), new Uint32Array([6291456, 6291456, 23068672, 6291456, 6291456, 6291456, 23068672, 6291456, 6291456, 6291456, 6291456, 23068672, 6291456, 6291456, 6291456, 6291456]), new Uint32Array([23068672, 23068672, 18923778, 23068672, 23068672, 23068672, 23068672, 18923842, 23068672, 23068672, 23068672, 23068672, 18923906, 23068672, 23068672, 23068672]), new Uint32Array([2134145, 2097153, 2134241, 0, 2132705, 2130977, 2160065, 2131297, 0, 2133089, 0, 2133857, 0, 0, 0, 0]), new Uint32Array([6291456, 6291456, 6291456, 6291456, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]), new Uint32Array([2177537, 6291456, 2177569, 6291456, 2177601, 6291456, 2177633, 6291456, 2177665, 6291456, 2177697, 6291456, 2177729, 6291456, 2177761, 6291456]), new Uint32Array([2212481, 2212513, 2212545, 2212577, 2197121, 2212609, 2212641, 2212673, 2212705, 2212737, 2212769, 2212801, 2212833, 2212865, 2212897, 2212929]), new Uint32Array([6291456, 6291456, 23068672, 23068672, 23068672, 6291456, 6291456, 0, 0, 0, 0, 0, 0, 0, 0, 0]), new Uint32Array([2098241, 2108353, 2170209, 2105825, 2111713, 2100897, 2111905, 2105473, 2105569, 2105601, 2112289, 6291456, 2108193, 2172417, 2112481, 2098177]), new Uint32Array([6291456, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 23068672, 6291456, 6291456])],
        r = new Uint16Array([616, 616, 565, 147, 161, 411, 330, 2, 131, 131, 328, 454, 241, 408, 86, 86, 696, 113, 285, 350, 325, 301, 473, 214, 639, 232, 447, 64, 369, 598, 124, 672, 567, 223, 621, 154, 107, 86, 86, 86, 86, 86, 86, 505, 86, 68, 634, 86, 218, 218, 218, 218, 486, 218, 218, 513, 188, 608, 216, 86, 217, 463, 668, 85, 700, 360, 184, 86, 86, 86, 647, 402, 153, 10, 346, 718, 662, 260, 145, 298, 117, 1, 443, 342, 138, 54, 563, 86, 240, 572, 218, 70, 387, 86, 118, 460, 641, 602, 86, 86, 306, 218, 86, 692, 86, 86, 86, 86, 86, 162, 707, 86, 458, 26, 86, 218, 638, 86, 86, 86, 86, 86, 65, 449, 86, 86, 306, 183, 86, 58, 391, 667, 86, 157, 131, 131, 131, 131, 86, 433, 131, 406, 31, 218, 247, 86, 86, 693, 218, 581, 351, 86, 438, 295, 69, 462, 45, 126, 173, 650, 14, 295, 69, 97, 168, 187, 641, 78, 523, 390, 69, 108, 287, 664, 173, 219, 83, 295, 69, 108, 431, 426, 173, 694, 412, 115, 628, 52, 257, 398, 641, 118, 501, 121, 69, 579, 151, 423, 173, 620, 464, 121, 69, 382, 151, 476, 173, 27, 53, 121, 86, 594, 578, 226, 173, 86, 632, 130, 86, 96, 228, 268, 641, 622, 563, 86, 86, 21, 148, 650, 131, 131, 321, 43, 144, 343, 381, 531, 131, 131, 178, 20, 86, 399, 156, 375, 164, 541, 30, 60, 715, 198, 92, 118, 131, 131, 86, 86, 306, 407, 86, 280, 457, 196, 488, 358, 131, 131, 244, 86, 86, 143, 86, 86, 86, 86, 86, 667, 563, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 336, 363, 86, 86, 336, 86, 86, 380, 678, 67, 86, 86, 86, 678, 86, 86, 86, 512, 86, 307, 86, 708, 86, 86, 86, 86, 86, 528, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 563, 307, 86, 86, 86, 86, 86, 104, 450, 337, 86, 720, 86, 32, 450, 397, 86, 86, 86, 587, 218, 558, 708, 708, 293, 708, 86, 86, 86, 86, 86, 694, 205, 86, 8, 86, 86, 86, 86, 549, 86, 667, 697, 697, 679, 86, 458, 460, 86, 86, 650, 86, 708, 543, 86, 86, 86, 245, 86, 86, 86, 140, 218, 127, 708, 708, 458, 197, 131, 131, 131, 131, 500, 86, 86, 483, 251, 86, 306, 510, 515, 86, 722, 86, 86, 86, 65, 201, 86, 86, 483, 580, 470, 86, 86, 86, 368, 131, 131, 131, 694, 114, 110, 555, 86, 86, 123, 721, 163, 142, 713, 418, 86, 317, 675, 209, 218, 218, 218, 371, 545, 592, 629, 490, 603, 199, 46, 320, 525, 680, 310, 279, 388, 111, 42, 252, 593, 607, 235, 617, 410, 377, 50, 548, 135, 356, 17, 520, 189, 116, 392, 600, 349, 332, 482, 699, 690, 535, 119, 106, 451, 71, 152, 667, 131, 218, 218, 265, 671, 637, 492, 504, 533, 683, 269, 269, 658, 86, 86, 86, 86, 86, 86, 86, 86, 86, 491, 619, 86, 86, 6, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 229, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 667, 86, 86, 171, 131, 118, 131, 656, 206, 234, 571, 89, 334, 670, 246, 311, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 534, 86, 86, 86, 86, 86, 86, 82, 86, 86, 86, 86, 86, 430, 86, 86, 86, 86, 86, 86, 86, 86, 86, 599, 86, 324, 86, 470, 69, 640, 264, 131, 626, 101, 174, 86, 86, 667, 233, 105, 73, 374, 394, 221, 204, 84, 28, 326, 86, 86, 471, 86, 86, 86, 109, 573, 86, 171, 200, 200, 200, 200, 218, 218, 86, 86, 86, 86, 460, 131, 131, 131, 86, 506, 86, 86, 86, 86, 86, 220, 404, 34, 614, 47, 442, 305, 25, 612, 338, 601, 648, 7, 344, 255, 131, 131, 51, 86, 312, 507, 563, 86, 86, 86, 86, 588, 86, 86, 86, 86, 86, 530, 511, 86, 458, 3, 435, 384, 556, 522, 230, 527, 86, 118, 86, 86, 717, 86, 137, 273, 79, 181, 484, 23, 93, 112, 655, 249, 417, 703, 370, 87, 98, 313, 684, 585, 155, 465, 596, 481, 695, 18, 416, 428, 61, 701, 706, 282, 643, 495, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 549, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 549, 131, 131, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 307, 86, 86, 86, 171, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 650, 131, 422, 542, 420, 263, 24, 172, 86, 86, 86, 86, 86, 566, 86, 86, 132, 540, 395, 353, 494, 519, 19, 485, 284, 472, 131, 131, 131, 16, 714, 86, 211, 708, 86, 86, 86, 694, 698, 86, 86, 483, 704, 708, 218, 272, 86, 86, 120, 86, 159, 478, 86, 307, 247, 86, 86, 663, 597, 459, 627, 667, 86, 86, 277, 455, 39, 302, 86, 250, 86, 86, 86, 271, 99, 452, 306, 281, 329, 400, 200, 86, 86, 362, 549, 352, 646, 461, 323, 586, 86, 86, 4, 708, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 717, 86, 518, 86, 86, 650, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 125, 554, 480, 300, 613, 72, 333, 288, 561, 544, 604, 48, 719, 91, 169, 176, 590, 224, 76, 191, 29, 559, 560, 231, 537, 166, 477, 538, 256, 437, 131, 131, 469, 167, 40, 0, 685, 266, 441, 705, 239, 642, 475, 568, 640, 610, 299, 673, 517, 318, 385, 22, 202, 180, 179, 359, 424, 215, 90, 66, 521, 653, 467, 682, 453, 409, 479, 88, 131, 661, 35, 303, 15, 262, 666, 630, 712, 131, 131, 618, 659, 175, 218, 195, 347, 193, 227, 261, 150, 165, 709, 546, 294, 569, 710, 270, 413, 376, 524, 55, 242, 38, 419, 529, 170, 657, 3, 304, 122, 379, 278, 131, 651, 86, 67, 576, 458, 458, 131, 131, 86, 86, 86, 86, 86, 86, 86, 118, 309, 86, 86, 547, 86, 86, 86, 86, 667, 650, 664, 131, 131, 86, 86, 56, 131, 131, 131, 131, 131, 131, 131, 131, 86, 307, 86, 86, 86, 664, 238, 650, 86, 86, 717, 86, 118, 86, 86, 315, 86, 59, 86, 86, 574, 549, 131, 131, 340, 57, 436, 86, 86, 86, 86, 86, 86, 458, 708, 499, 691, 62, 86, 650, 86, 86, 694, 86, 86, 86, 319, 131, 131, 131, 131, 131, 131, 131, 131, 131, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 171, 86, 549, 694, 131, 131, 131, 131, 131, 131, 131, 131, 131, 77, 86, 86, 139, 86, 502, 86, 86, 86, 667, 595, 131, 131, 131, 86, 12, 86, 13, 86, 609, 131, 131, 131, 131, 86, 86, 86, 625, 86, 669, 86, 86, 182, 129, 86, 5, 694, 104, 86, 86, 86, 86, 131, 131, 86, 86, 386, 171, 86, 86, 86, 345, 86, 324, 86, 589, 86, 213, 36, 131, 131, 131, 131, 131, 86, 86, 86, 86, 104, 131, 131, 131, 141, 290, 80, 677, 86, 86, 86, 267, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 86, 667, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 515, 86, 86, 33, 136, 669, 86, 711, 515, 86, 86, 550, 640, 86, 104, 708, 515, 86, 159, 372, 717, 86, 86, 444, 515, 86, 86, 663, 37, 86, 563, 460, 86, 390, 624, 702, 131, 131, 131, 131, 389, 59, 708, 86, 86, 341, 208, 708, 635, 295, 69, 108, 431, 508, 100, 190, 131, 131, 131, 131, 131, 131, 131, 131, 86, 86, 86, 649, 516, 660, 131, 131, 86, 86, 86, 218, 631, 708, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 86, 86, 341, 575, 238, 514, 131, 131, 86, 86, 86, 218, 291, 708, 307, 131, 86, 86, 306, 367, 708, 131, 131, 131, 86, 378, 697, 86, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 615, 253, 86, 86, 86, 292, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 86, 86, 86, 104, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 69, 86, 341, 553, 549, 86, 307, 86, 86, 645, 275, 455, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 708, 131, 131, 131, 131, 131, 131, 86, 86, 86, 86, 86, 86, 667, 460, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 717, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 667, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 171, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 104, 86, 667, 459, 131, 131, 131, 131, 131, 131, 86, 458, 225, 86, 86, 86, 516, 549, 11, 390, 405, 86, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 86, 86, 86, 86, 460, 44, 218, 197, 711, 515, 131, 131, 131, 131, 664, 131, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 307, 131, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 308, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 640, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 86, 86, 86, 86, 86, 86, 118, 307, 104, 286, 591, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 549, 86, 86, 681, 86, 86, 75, 185, 314, 582, 86, 358, 496, 474, 86, 104, 131, 86, 86, 86, 86, 146, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 86, 86, 86, 86, 86, 171, 86, 640, 131, 131, 131, 131, 131, 131, 131, 131, 246, 503, 689, 339, 674, 81, 258, 415, 439, 128, 562, 366, 414, 246, 503, 689, 583, 222, 557, 316, 636, 665, 186, 355, 95, 670, 246, 503, 689, 339, 674, 557, 258, 415, 439, 186, 355, 95, 670, 246, 503, 689, 446, 644, 536, 652, 331, 532, 335, 440, 274, 421, 297, 570, 74, 425, 364, 425, 606, 552, 403, 509, 134, 365, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 218, 218, 218, 498, 218, 218, 577, 627, 551, 497, 572, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 553, 354, 236, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 296, 455, 131, 131, 456, 243, 103, 86, 41, 459, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 9, 276, 158, 716, 393, 564, 383, 489, 401, 654, 210, 654, 131, 131, 131, 640, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 86, 86, 650, 86, 86, 86, 86, 86, 86, 717, 667, 563, 563, 563, 86, 549, 102, 686, 133, 246, 605, 86, 448, 86, 86, 207, 307, 131, 131, 131, 641, 86, 177, 611, 445, 373, 194, 584, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 308, 307, 171, 86, 86, 86, 86, 86, 86, 86, 717, 86, 86, 86, 86, 86, 460, 131, 131, 650, 86, 86, 86, 694, 708, 86, 86, 694, 86, 458, 131, 131, 131, 131, 131, 131, 667, 694, 289, 650, 667, 131, 131, 86, 640, 131, 131, 664, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 171, 131, 131, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 460, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 458, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 640, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 466, 203, 149, 429, 94, 432, 160, 687, 539, 63, 237, 283, 192, 248, 348, 259, 427, 526, 396, 676, 254, 468, 487, 212, 327, 623, 49, 633, 322, 493, 434, 688, 357, 361, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131, 131]);
      return {
        mapStr: "    rads2110viii(10)(11)(12)(13)(14)(15)(16)(17)(18)(19)(20)()()kcalms2ckg141234         a/ca/sc/oc/utelfax1719132315253545165618385878xii03(1)(2)(3)(4)(5)(6)(7)(8)(9)(a)(b)(c)(d)(e)(f)(g)(h)(i)(j)(k)(l)(m)(n)(o)(p)(q)(r)(s)(t)(u)(v)(w)(x)(y)(z)::====()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()pte101112ergltd101112131415161718192021222324hpabardm2dm3khzmhzghzthzmm2cm2km2mm3cm3km3kpampagpalogmilmolppmvmam10111213141516171819202122232425262728293031galffiffl      sppv   ssiijlndljnjdz       a  !! ???!!?rscfnosmtmivix  333435363738394042444546474849503456789hgevdaauovpciunaakakbmbgbpfnffgmglmldlklfmnmmpsnssmsnvvkvpwnwwmwkwkmbqcccddbgyhainkkktlnlxphprsrsvwbst  0,1,2,3,4,5,6,7,8,9,wzhvsdwcmcmddj;`+._{}[]#&*-<>\\$%@\"'^|~",
        mapChar: function(t) {
          return t >= 196608 ? t >= 917760 && t <= 917999 ? 18874368 : 0 : n[r[t >> 4]][15 & t]
        }
      }
    });
  }, {}],
  "qBXN": [function(require, module, exports) {
    var define;
    var process = require("process");
    var t, n = require("process");

    function r(t) {
      return (r = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t) {
        return typeof t
      } : function(t) {
        return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
      })(t)
    }! function(n, e) {
      "function" == typeof t && t.amd ? t(["punycode", "./idna-map"], function(t, n) {
        return e(t, n)
      }) : "object" === ("undefined" == typeof exports ? "undefined" : r(exports)) ? module.exports = e(require("punycode"), require("./idna-map")) : n.uts46 = e(n.punycode, n.idna_map)
    }(this, function(t, n) {
      function r(r, e, o) {
        for (var i = [], a = t.ucs2.decode(r), u = 0; u < a.length; u++) {
          var l = a[u],
            s = t.ucs2.encode([a[u]]),
            f = n.mapChar(l),
            d = f >> 23,
            c = f >> 21 & 3,
            h = f >> 5 & 65535,
            p = 31 & f,
            y = n.mapStr.substr(h, p);
          if (0 === c || e && 1 & d) throw new Error("Illegal char " + s);
          1 === c ? i.push(y) : 2 === c ? i.push(o ? y : s) : 3 === c && i.push(s)
        }
        return i.join("").normalize("NFC")
      }

      function e(n, e, i) {
        void 0 === i && (i = !1);
        var a = r(n, i, e).split(".");
        return (a = a.map(function(n) {
          return n.startsWith("xn--") ? o(n = t.decode(n.substring(4)), i, !1) : o(n, i, e), n
        })).join(".")
      }

      function o(t, e, o) {
        if ("-" === t[2] && "-" === t[3]) throw new Error("Failed to validate " + t);
        if (t.startsWith("-") || t.endsWith("-")) throw new Error("Failed to validate " + t);
        if (t.includes(".")) throw new Error("Failed to validate " + t);
        if (r(t, e, o) !== t) throw new Error("Failed to validate " + t);
        var i = t.codePointAt(0);
        if (n.mapChar(i) & 2 << 23) throw new Error("Label contains illegal character: " + i)
      }
      return {
        toUnicode: function(t, n) {
          return void 0 === n && (n = {}), e(t, !1, "useStd3ASCII" in n && n.useStd3ASCII)
        },
        toAscii: function(n, r) {
          void 0 === r && (r = {});
          var o, i = !("transitional" in r) || r.transitional,
            a = "useStd3ASCII" in r && r.useStd3ASCII,
            u = "verifyDnsLength" in r && r.verifyDnsLength,
            l = e(n, i, a).split(".").map(t.toASCII),
            s = l.join(".");
          if (u) {
            if (s.length < 1 || s.length > 253) throw new Error("DNS name has wrong length: " + s);
            for (o = 0; o < l.length; o++) {
              var f = l[o];
              if (f.length < 1 || f.length > 63) throw new Error("DNS label has wrong length: " + f)
            }
          }
          return s
        }
      }
    });
  }, {
    "punycode": "FIMm",
    "./idna-map": "zfoe",
    "process": "pBGv"
  }],
  "Ruki": [function(require, module, exports) {
    var Buffer = require("buffer").Buffer;
    var e = require("buffer").Buffer,
      r = require("js-sha3").keccak_256,
      n = require("idna-uts46-hx");

    function a(n) {
      for (var a = "", i = 0; i < 32; i++) a += "00";
      if (name = t(n), name) {
        var u = name.split(".");
        for (i = u.length - 1; i >= 0; i--) {
          var o = r(u[i]);
          a = r(new e(a + o, "hex"))
        }
      }
      return "0x" + a
    }

    function t(e) {
      return e ? n.toUnicode(e, {
        useStd3ASCII: !0,
        transitional: !1
      }) : e
    }
    exports.hash = a, exports.normalize = t;
  }, {
    "js-sha3": "hT6R",
    "idna-uts46-hx": "qBXN",
    "buffer": "dskh"
  }],
  "SCkK": [function(require, module, exports) {
    "use strict";
    var e = [{
      constant: !0,
      inputs: [{
        name: "node",
        type: "bytes32"
      }],
      name: "resolver",
      outputs: [{
        name: "",
        type: "address"
      }],
      payable: !1,
      type: "function"
    }, {
      constant: !0,
      inputs: [{
        name: "node",
        type: "bytes32"
      }],
      name: "owner",
      outputs: [{
        name: "",
        type: "address"
      }],
      payable: !1,
      type: "function"
    }, {
      constant: !1,
      inputs: [{
        name: "node",
        type: "bytes32"
      }, {
        name: "label",
        type: "bytes32"
      }, {
        name: "owner",
        type: "address"
      }],
      name: "setSubnodeOwner",
      outputs: [],
      payable: !1,
      type: "function"
    }, {
      constant: !1,
      inputs: [{
        name: "node",
        type: "bytes32"
      }, {
        name: "ttl",
        type: "uint64"
      }],
      name: "setTTL",
      outputs: [],
      payable: !1,
      type: "function"
    }, {
      constant: !0,
      inputs: [{
        name: "node",
        type: "bytes32"
      }],
      name: "ttl",
      outputs: [{
        name: "",
        type: "uint64"
      }],
      payable: !1,
      type: "function"
    }, {
      constant: !1,
      inputs: [{
        name: "node",
        type: "bytes32"
      }, {
        name: "resolver",
        type: "address"
      }],
      name: "setResolver",
      outputs: [],
      payable: !1,
      type: "function"
    }, {
      constant: !1,
      inputs: [{
        name: "node",
        type: "bytes32"
      }, {
        name: "owner",
        type: "address"
      }],
      name: "setOwner",
      outputs: [],
      payable: !1,
      type: "function"
    }, {
      anonymous: !1,
      inputs: [{
        indexed: !0,
        name: "node",
        type: "bytes32"
      }, {
        indexed: !1,
        name: "owner",
        type: "address"
      }],
      name: "Transfer",
      type: "event"
    }, {
      anonymous: !1,
      inputs: [{
        indexed: !0,
        name: "node",
        type: "bytes32"
      }, {
        indexed: !0,
        name: "label",
        type: "bytes32"
      }, {
        indexed: !1,
        name: "owner",
        type: "address"
      }],
      name: "NewOwner",
      type: "event"
    }, {
      anonymous: !1,
      inputs: [{
        indexed: !0,
        name: "node",
        type: "bytes32"
      }, {
        indexed: !1,
        name: "resolver",
        type: "address"
      }],
      name: "NewResolver",
      type: "event"
    }, {
      anonymous: !1,
      inputs: [{
        indexed: !0,
        name: "node",
        type: "bytes32"
      }, {
        indexed: !1,
        name: "ttl",
        type: "uint64"
      }],
      name: "NewTTL",
      type: "event"
    }, {
      constant: !1,
      inputs: [{
        internalType: "bytes32",
        name: "node",
        type: "bytes32"
      }, {
        internalType: "address",
        name: "owner",
        type: "address"
      }, {
        internalType: "address",
        name: "resolver",
        type: "address"
      }, {
        internalType: "uint64",
        name: "ttl",
        type: "uint64"
      }],
      name: "setRecord",
      outputs: [],
      payable: !1,
      stateMutability: "nonpayable",
      type: "function"
    }, {
      constant: !1,
      inputs: [{
        internalType: "address",
        name: "operator",
        type: "address"
      }, {
        internalType: "bool",
        name: "approved",
        type: "bool"
      }],
      name: "setApprovalForAll",
      outputs: [],
      payable: !1,
      stateMutability: "nonpayable",
      type: "function"
    }, {
      anonymous: !1,
      inputs: [{
        indexed: !0,
        internalType: "address",
        name: "owner",
        type: "address"
      }, {
        indexed: !0,
        internalType: "address",
        name: "operator",
        type: "address"
      }, {
        indexed: !1,
        internalType: "bool",
        name: "approved",
        type: "bool"
      }],
      name: "ApprovalForAll",
      type: "event"
    }, {
      constant: !0,
      inputs: [{
        internalType: "address",
        name: "owner",
        type: "address"
      }, {
        internalType: "address",
        name: "operator",
        type: "address"
      }],
      name: "isApprovedForAll",
      outputs: [{
        internalType: "bool",
        name: "",
        type: "bool"
      }],
      payable: !1,
      stateMutability: "view",
      type: "function"
    }, {
      constant: !0,
      inputs: [{
        internalType: "bytes32",
        name: "node",
        type: "bytes32"
      }],
      name: "recordExists",
      outputs: [{
        internalType: "bool",
        name: "",
        type: "bool"
      }],
      payable: !1,
      stateMutability: "view",
      type: "function"
    }, {
      constant: !1,
      inputs: [{
        internalType: "bytes32",
        name: "node",
        type: "bytes32"
      }, {
        internalType: "bytes32",
        name: "label",
        type: "bytes32"
      }, {
        internalType: "address",
        name: "owner",
        type: "address"
      }, {
        internalType: "address",
        name: "resolver",
        type: "address"
      }, {
        internalType: "uint64",
        name: "ttl",
        type: "uint64"
      }],
      name: "setSubnodeRecord",
      outputs: [],
      payable: !1,
      stateMutability: "nonpayable",
      type: "function"
    }];
    module.exports = e;
  }, {}],
  "Mdqi": [function(require, module, exports) {
    "use strict";
    var e = [{
      constant: !0,
      inputs: [{
        name: "interfaceID",
        type: "bytes4"
      }],
      name: "supportsInterface",
      outputs: [{
        name: "",
        type: "bool"
      }],
      payable: !1,
      type: "function"
    }, {
      constant: !0,
      inputs: [{
        name: "node",
        type: "bytes32"
      }, {
        name: "contentTypes",
        type: "uint256"
      }],
      name: "ABI",
      outputs: [{
        name: "contentType",
        type: "uint256"
      }, {
        name: "data",
        type: "bytes"
      }],
      payable: !1,
      type: "function"
    }, {
      constant: !1,
      inputs: [{
        name: "node",
        type: "bytes32"
      }, {
        name: "hash",
        type: "bytes"
      }],
      name: "setMultihash",
      outputs: [],
      payable: !1,
      stateMutability: "nonpayable",
      type: "function"
    }, {
      constant: !0,
      inputs: [{
        name: "node",
        type: "bytes32"
      }],
      name: "multihash",
      outputs: [{
        name: "",
        type: "bytes"
      }],
      payable: !1,
      stateMutability: "view",
      type: "function"
    }, {
      constant: !1,
      inputs: [{
        name: "node",
        type: "bytes32"
      }, {
        name: "x",
        type: "bytes32"
      }, {
        name: "y",
        type: "bytes32"
      }],
      name: "setPubkey",
      outputs: [],
      payable: !1,
      type: "function"
    }, {
      constant: !0,
      inputs: [{
        name: "node",
        type: "bytes32"
      }],
      name: "content",
      outputs: [{
        name: "ret",
        type: "bytes32"
      }],
      payable: !1,
      type: "function"
    }, {
      constant: !0,
      inputs: [{
        name: "node",
        type: "bytes32"
      }],
      name: "addr",
      outputs: [{
        name: "ret",
        type: "address"
      }],
      payable: !1,
      type: "function"
    }, {
      constant: !1,
      inputs: [{
        name: "node",
        type: "bytes32"
      }, {
        name: "contentType",
        type: "uint256"
      }, {
        name: "data",
        type: "bytes"
      }],
      name: "setABI",
      outputs: [],
      payable: !1,
      type: "function"
    }, {
      constant: !0,
      inputs: [{
        name: "node",
        type: "bytes32"
      }],
      name: "name",
      outputs: [{
        name: "ret",
        type: "string"
      }],
      payable: !1,
      type: "function"
    }, {
      constant: !1,
      inputs: [{
        name: "node",
        type: "bytes32"
      }, {
        name: "name",
        type: "string"
      }],
      name: "setName",
      outputs: [],
      payable: !1,
      type: "function"
    }, {
      constant: !1,
      inputs: [{
        name: "node",
        type: "bytes32"
      }, {
        name: "hash",
        type: "bytes32"
      }],
      name: "setContent",
      outputs: [],
      payable: !1,
      type: "function"
    }, {
      constant: !0,
      inputs: [{
        name: "node",
        type: "bytes32"
      }],
      name: "pubkey",
      outputs: [{
        name: "x",
        type: "bytes32"
      }, {
        name: "y",
        type: "bytes32"
      }],
      payable: !1,
      type: "function"
    }, {
      constant: !1,
      inputs: [{
        name: "node",
        type: "bytes32"
      }, {
        name: "addr",
        type: "address"
      }],
      name: "setAddr",
      outputs: [],
      payable: !1,
      type: "function"
    }, {
      inputs: [{
        name: "ensAddr",
        type: "address"
      }],
      payable: !1,
      type: "constructor"
    }, {
      anonymous: !1,
      inputs: [{
        indexed: !0,
        name: "node",
        type: "bytes32"
      }, {
        indexed: !1,
        name: "a",
        type: "address"
      }],
      name: "AddrChanged",
      type: "event"
    }, {
      anonymous: !1,
      inputs: [{
        indexed: !0,
        name: "node",
        type: "bytes32"
      }, {
        indexed: !1,
        name: "hash",
        type: "bytes32"
      }],
      name: "ContentChanged",
      type: "event"
    }, {
      anonymous: !1,
      inputs: [{
        indexed: !0,
        name: "node",
        type: "bytes32"
      }, {
        indexed: !1,
        name: "name",
        type: "string"
      }],
      name: "NameChanged",
      type: "event"
    }, {
      anonymous: !1,
      inputs: [{
        indexed: !0,
        name: "node",
        type: "bytes32"
      }, {
        indexed: !0,
        name: "contentType",
        type: "uint256"
      }],
      name: "ABIChanged",
      type: "event"
    }, {
      anonymous: !1,
      inputs: [{
        indexed: !0,
        name: "node",
        type: "bytes32"
      }, {
        indexed: !1,
        name: "x",
        type: "bytes32"
      }, {
        indexed: !1,
        name: "y",
        type: "bytes32"
      }],
      name: "PubkeyChanged",
      type: "event"
    }, {
      anonymous: !1,
      inputs: [{
        indexed: !0,
        name: "node",
        type: "bytes32"
      }, {
        indexed: !1,
        name: "hash",
        type: "bytes"
      }],
      name: "ContenthashChanged",
      type: "event"
    }, {
      constant: !0,
      inputs: [{
        name: "node",
        type: "bytes32"
      }],
      name: "contenthash",
      outputs: [{
        name: "",
        type: "bytes"
      }],
      payable: !1,
      stateMutability: "view",
      type: "function"
    }, {
      constant: !1,
      inputs: [{
        name: "node",
        type: "bytes32"
      }, {
        name: "hash",
        type: "bytes"
      }],
      name: "setContenthash",
      outputs: [],
      payable: !1,
      stateMutability: "nonpayable",
      type: "function"
    }];
    module.exports = e;
  }, {}],
  "n4kR": [function(require, module, exports) {
    "use strict";
    var t = require("underscore"),
      e = require("web3-eth-contract"),
      n = require("eth-ens-namehash"),
      r = require("web3-core-promievent"),
      o = require("web3-core-helpers").formatters,
      i = require("web3-utils"),
      c = require("../resources/ABI/Registry"),
      s = require("../resources/ABI/Resolver");

    function u(t) {
      var n = this;
      this.ens = t, this.contract = t.checkNetwork().then(function(t) {
        var r = new e(c, t);
        return r.setProvider(n.ens.eth.currentProvider), r
      })
    }
    u.prototype.owner = function(t, e) {
      return console.warn('Deprecated: Please use the "getOwner" method instead of "owner".'), this.getOwner(t, e)
    }, u.prototype.getOwner = function(e, o) {
      var i = new r(!0);
      return this.contract.then(function(t) {
        return t.methods.owner(n.hash(e)).call()
      }).then(function(e) {
        t.isFunction(o) ? o(e, e) : i.resolve(e)
      }).catch(function(e) {
        t.isFunction(o) ? o(e, null) : i.reject(e)
      }), i.eventEmitter
    }, u.prototype.setOwner = function(e, i, c, s) {
      var u = new r(!0);
      return this.contract.then(function(t) {
        return t.methods.setOwner(n.hash(e), o.inputAddressFormatter(i)).send(c)
      }).then(function(e) {
        t.isFunction(s) ? s(e, e) : u.resolve(e)
      }).catch(function(e) {
        t.isFunction(s) ? s(e, null) : u.reject(e)
      }), u.eventEmitter
    }, u.prototype.getTTL = function(e, o) {
      var i = new r(!0);
      return this.contract.then(function(t) {
        return t.methods.ttl(n.hash(e)).call()
      }).then(function(e) {
        t.isFunction(o) ? o(e, e) : i.resolve(e)
      }).catch(function(e) {
        t.isFunction(o) ? o(e, null) : i.reject(e)
      }), i.eventEmitter
    }, u.prototype.setTTL = function(e, o, i, c) {
      var s = new r(!0);
      return this.contract.then(function(t) {
        return t.methods.setTTL(n.hash(e), o).send(i)
      }).then(function(e) {
        t.isFunction(c) ? c(e, e) : s.resolve(e)
      }).catch(function(e) {
        t.isFunction(c) ? c(e, null) : s.reject(e)
      }), s.eventEmitter
    }, u.prototype.setSubnodeOwner = function(e, c, s, u, h) {
      var a = new r(!0);
      return i.isHexStrict(c) || (c = i.sha3(c)), this.contract.then(function(t) {
        return t.methods.setSubnodeOwner(n.hash(e), c, o.inputAddressFormatter(s)).send(u)
      }).then(function(e) {
        t.isFunction(h) ? h(e, e) : a.resolve(e)
      }).catch(function(e) {
        t.isFunction(h) ? h(e, null) : a.reject(e)
      }), a.eventEmitter
    }, u.prototype.setRecord = function(e, i, c, s, u, h) {
      var a = new r(!0);
      return this.contract.then(function(t) {
        return t.methods.setRecord(n.hash(e), o.inputAddressFormatter(i), o.inputAddressFormatter(c), s).send(u)
      }).then(function(e) {
        t.isFunction(h) ? h(e, e) : a.resolve(e)
      }).catch(function(e) {
        t.isFunction(h) ? h(e, null) : a.reject(e)
      }), a.eventEmitter
    }, u.prototype.setSubnodeRecord = function(e, c, s, u, h, a, l) {
      var d = new r(!0);
      return i.isHexStrict(c) || (c = i.sha3(c)), this.contract.then(function(t) {
        return t.methods.setSubnodeRecord(n.hash(e), c, o.inputAddressFormatter(s), o.inputAddressFormatter(u), h).send(a)
      }).then(function(e) {
        t.isFunction(l) ? l(e, e) : d.resolve(e)
      }).catch(function(e) {
        t.isFunction(l) ? l(e, null) : d.reject(e)
      }), d.eventEmitter
    }, u.prototype.setApprovalForAll = function(e, n, i, c) {
      var s = new r(!0);
      return this.contract.then(function(t) {
        return t.methods.setApprovalForAll(o.inputAddressFormatter(e), n).send(i)
      }).then(function(e) {
        t.isFunction(c) ? c(e, e) : s.resolve(e)
      }).catch(function(e) {
        t.isFunction(c) ? c(e, null) : s.reject(e)
      }), s.eventEmitter
    }, u.prototype.isApprovedForAll = function(e, n, i) {
      var c = new r(!0);
      return this.contract.then(function(t) {
        return t.methods.isApprovedForAll(o.inputAddressFormatter(e), o.inputAddressFormatter(n)).call()
      }).then(function(e) {
        t.isFunction(i) ? i(e, e) : c.resolve(e)
      }).catch(function(e) {
        t.isFunction(i) ? i(e, null) : c.reject(e)
      }), c.eventEmitter
    }, u.prototype.recordExists = function(e, o) {
      var i = new r(!0);
      return this.contract.then(function(t) {
        return t.methods.recordExists(n.hash(e)).call()
      }).then(function(e) {
        t.isFunction(o) ? o(e, e) : i.resolve(e)
      }).catch(function(e) {
        t.isFunction(o) ? o(e, null) : i.reject(e)
      }), i.eventEmitter
    }, u.prototype.resolver = function(t, e) {
      return console.warn('Deprecated: Please use the "getResolver" method instead of "resolver".'), this.getResolver(t, e)
    }, u.prototype.getResolver = function(r, o) {
      var i = this;
      return this.contract.then(function(t) {
        return t.methods.resolver(n.hash(r)).call()
      }).then(function(n) {
        var r = new e(s, n);
        if (r.setProvider(i.ens.eth.currentProvider), !t.isFunction(o)) return r;
        o(r, r)
      }).catch(function(e) {
        if (!t.isFunction(o)) throw e;
        o(e, null)
      })
    }, u.prototype.setResolver = function(e, i, c, s) {
      var u = new r(!0);
      return this.contract.then(function(t) {
        return t.methods.setResolver(n.hash(e), o.inputAddressFormatter(i)).send(c)
      }).then(function(e) {
        t.isFunction(s) ? s(e, e) : u.resolve(e)
      }).catch(function(e) {
        t.isFunction(s) ? s(e, null) : u.reject(e)
      }), u.eventEmitter
    }, module.exports = u;
  }, {
    "underscore": "h15N",
    "web3-eth-contract": "vrPZ",
    "eth-ens-namehash": "Ruki",
    "web3-core-promievent": "J2II",
    "web3-core-helpers": "EoeS",
    "web3-utils": "uckD",
    "../resources/ABI/Registry": "SCkK",
    "../resources/ABI/Resolver": "Mdqi"
  }],
  "njCu": [function(require, module, exports) {
    "use strict";

    function e(e, t, n, r, o, i, a) {
      try {
        var s = e[i](a),
          c = s.value
      } catch (u) {
        return void n(u)
      }
      s.done ? t(c) : Promise.resolve(c).then(r, o)
    }

    function t(t) {
      return function() {
        var n = this,
          r = arguments;
        return new Promise(function(o, i) {
          var a = t.apply(n, r);

          function s(t) {
            e(a, o, i, s, c, "next", t)
          }

          function c(t) {
            e(a, o, i, s, c, "throw", t)
          }
          s(void 0)
        })
      }
    }
    var n = require("web3-core-promievent"),
      r = require("eth-ens-namehash"),
      o = require("web3-core-helpers").errors,
      i = require("underscore"),
      a = require("../config").interfaceIds;

    function s(e) {
      this.registry = e
    }
    s.prototype.method = function(e, t, n, r, o) {
      return {
        call: this.call.bind({
          ensName: e,
          methodName: t,
          methodArguments: n,
          callback: o,
          parent: this,
          outputFormatter: r
        }),
        send: this.send.bind({
          ensName: e,
          methodName: t,
          methodArguments: n,
          callback: o,
          parent: this
        })
      }
    }, s.prototype.call = function(e) {
      var r = this,
        o = new n,
        a = this.parent.prepareArguments(this.ensName, this.methodArguments),
        s = this.outputFormatter || null;
      return this.parent.registry.getResolver(this.ensName).then(function() {
        var n = t(regeneratorRuntime.mark(function t(n) {
          return regeneratorRuntime.wrap(function(t) {
            for (;;) switch (t.prev = t.next) {
              case 0:
                return t.next = 2, r.parent.checkInterfaceSupport(n, r.methodName);
              case 2:
                r.parent.handleCall(o, n.methods[r.methodName], a, s, e);
              case 3:
              case "end":
                return t.stop()
            }
          }, t)
        }));
        return function(e) {
          return n.apply(this, arguments)
        }
      }()).catch(function(t) {
        i.isFunction(e) ? e(t, null) : o.reject(t)
      }), o.eventEmitter
    }, s.prototype.send = function(e, r) {
      var o = this,
        a = new n,
        s = this.parent.prepareArguments(this.ensName, this.methodArguments);
      return this.parent.registry.getResolver(this.ensName).then(function() {
        var n = t(regeneratorRuntime.mark(function t(n) {
          return regeneratorRuntime.wrap(function(t) {
            for (;;) switch (t.prev = t.next) {
              case 0:
                return t.next = 2, o.parent.checkInterfaceSupport(n, o.methodName);
              case 2:
                o.parent.handleSend(a, n.methods[o.methodName], s, e, r);
              case 3:
              case "end":
                return t.stop()
            }
          }, t)
        }));
        return function(e) {
          return n.apply(this, arguments)
        }
      }()).catch(function(e) {
        i.isFunction(r) ? r(e, null) : a.reject(e)
      }), a.eventEmitter
    }, s.prototype.handleCall = function(e, t, n, r, o) {
      return t.apply(this, n).call().then(function(t) {
        r && (t = r(t)), i.isFunction(o) ? o(t, t) : e.resolve(t)
      }).catch(function(t) {
        i.isFunction(o) ? o(t, null) : e.reject(t)
      }), e
    }, s.prototype.handleSend = function(e, t, n, r, o) {
      return t.apply(this, n).send(r).on("sending", function() {
        e.eventEmitter.emit("sending")
      }).on("sent", function() {
        e.eventEmitter.emit("sent")
      }).on("transactionHash", function(t) {
        e.eventEmitter.emit("transactionHash", t)
      }).on("confirmation", function(t, n) {
        e.eventEmitter.emit("confirmation", t, n)
      }).on("receipt", function(t) {
        e.eventEmitter.emit("receipt", t), e.resolve(t), i.isFunction(o) && o(t, t)
      }).on("error", function(t) {
        e.eventEmitter.emit("error", t), i.isFunction(o) ? o(t, null) : e.reject(t)
      }), e
    }, s.prototype.prepareArguments = function(e, t) {
      var n = r.hash(e);
      return t.length > 0 ? (t.unshift(n), t) : [n]
    }, s.prototype.checkInterfaceSupport = function() {
      var e = t(regeneratorRuntime.mark(function e(t, n) {
        var r;
        return regeneratorRuntime.wrap(function(e) {
          for (;;) switch (e.prev = e.next) {
            case 0:
              if (a[n]) {
                e.next = 2;
                break
              }
              return e.abrupt("return");
            case 2:
              return r = !1, e.prev = 3, e.next = 6, t.methods.supportsInterface(a[n]).call();
            case 6:
              r = e.sent, e.next = 12;
              break;
            case 9:
              e.prev = 9, e.t0 = e.catch(3), console.warn('Could not verify interface of resolver contract at "' + t.options.address + '". ');
            case 12:
              if (r) {
                e.next = 14;
                break
              }
              throw o.ResolverMethodMissingError(t.options.address, n);
            case 14:
            case "end":
              return e.stop()
          }
        }, e, null, [
          [3, 9]
        ])
      }));
      return function(t, n) {
        return e.apply(this, arguments)
      }
    }(), module.exports = s;
  }, {
    "web3-core-promievent": "J2II",
    "eth-ens-namehash": "Ruki",
    "web3-core-helpers": "EoeS",
    "underscore": "h15N",
    "../config": "jgOf"
  }],
  "zWK1": [function(require, module, exports) {
    module.exports = a;
    var r = 128,
      o = 127,
      t = ~o,
      e = Math.pow(2, 31);

    function a(o, f, n) {
      f = f || [];
      for (var u = n = n || 0; o >= e;) f[n++] = 255 & o | r, o /= 128;
      for (; o & t;) f[n++] = 255 & o | r, o >>>= 7;
      return f[n] = 0 | o, a.bytes = n - u + 1, f
    }
  }, {}],
  "yP5U": [function(require, module, exports) {
    module.exports = r;
    var e = 128,
      o = 127;

    function r(t, n) {
      var a, d = 0,
        h = 0,
        i = n = n || 0,
        l = t.length;
      do {
        if (i >= l) throw r.bytes = 0, new RangeError("Could not decode varint");
        a = t[i++], d += h < 28 ? (a & o) << h : (a & o) * Math.pow(2, h), h += 7
      } while (a >= e);
      return r.bytes = i - n, d
    }
  }, {}],
  "piXV": [function(require, module, exports) {
    var o = Math.pow(2, 7),
      t = Math.pow(2, 14),
      a = Math.pow(2, 21),
      p = Math.pow(2, 28),
      h = Math.pow(2, 35),
      w = Math.pow(2, 42),
      M = Math.pow(2, 49),
      r = Math.pow(2, 56),
      e = Math.pow(2, 63);
    module.exports = function(n) {
      return n < o ? 1 : n < t ? 2 : n < a ? 3 : n < p ? 4 : n < h ? 5 : n < w ? 6 : n < M ? 7 : n < r ? 8 : n < e ? 9 : 10
    };
  }, {}],
  "tvfU": [function(require, module, exports) {
    module.exports = {
      encode: require("./encode.js"),
      decode: require("./decode.js"),
      encodingLength: require("./length.js")
    };
  }, {
    "./encode.js": "zWK1",
    "./decode.js": "yP5U",
    "./length.js": "piXV"
  }],
  "cvU0": [function(require, module, exports) {
    module.exports = {
      identity: 0,
      ip4: 4,
      tcp: 6,
      sha1: 17,
      "sha2-256": 18,
      "sha2-512": 19,
      "sha3-512": 20,
      "sha3-384": 21,
      "sha3-256": 22,
      "sha3-224": 23,
      "shake-128": 24,
      "shake-256": 25,
      "keccak-224": 26,
      "keccak-256": 27,
      "keccak-384": 28,
      "keccak-512": 29,
      dccp: 33,
      "murmur3-128": 34,
      "murmur3-32": 35,
      ip6: 41,
      ip6zone: 42,
      path: 47,
      multicodec: 48,
      multihash: 49,
      multiaddr: 50,
      multibase: 51,
      dns: 53,
      dns4: 54,
      dns6: 55,
      dnsaddr: 56,
      protobuf: 80,
      cbor: 81,
      raw: 85,
      "dbl-sha2-256": 86,
      rlp: 96,
      bencode: 99,
      "dag-pb": 112,
      "dag-cbor": 113,
      "libp2p-key": 114,
      "git-raw": 120,
      "torrent-info": 123,
      "torrent-file": 124,
      "leofcoin-block": 129,
      "leofcoin-tx": 130,
      "leofcoin-pr": 131,
      sctp: 132,
      "eth-block": 144,
      "eth-block-list": 145,
      "eth-tx-trie": 146,
      "eth-tx": 147,
      "eth-tx-receipt-trie": 148,
      "eth-tx-receipt": 149,
      "eth-state-trie": 150,
      "eth-account-snapshot": 151,
      "eth-storage-trie": 152,
      "bitcoin-block": 176,
      "bitcoin-tx": 177,
      "zcash-block": 192,
      "zcash-tx": 193,
      "stellar-block": 208,
      "stellar-tx": 209,
      md4: 212,
      md5: 213,
      bmt: 214,
      "decred-block": 224,
      "decred-tx": 225,
      "ipld-ns": 226,
      "ipfs-ns": 227,
      "swarm-ns": 228,
      "ipns-ns": 229,
      zeronet: 230,
      "ed25519-pub": 237,
      "dash-block": 240,
      "dash-tx": 241,
      "swarm-manifest": 250,
      "swarm-feed": 251,
      udp: 273,
      "p2p-webrtc-star": 275,
      "p2p-webrtc-direct": 276,
      "p2p-stardust": 277,
      "p2p-circuit": 290,
      "dag-json": 297,
      udt: 301,
      utp: 302,
      unix: 400,
      p2p: 421,
      ipfs: 421,
      https: 443,
      onion: 444,
      onion3: 445,
      garlic64: 446,
      garlic32: 447,
      tls: 448,
      quic: 460,
      ws: 477,
      wss: 478,
      "p2p-websocket-star": 479,
      http: 480,
      json: 512,
      messagepack: 513,
      x11: 4352,
      "blake2b-8": 45569,
      "blake2b-16": 45570,
      "blake2b-24": 45571,
      "blake2b-32": 45572,
      "blake2b-40": 45573,
      "blake2b-48": 45574,
      "blake2b-56": 45575,
      "blake2b-64": 45576,
      "blake2b-72": 45577,
      "blake2b-80": 45578,
      "blake2b-88": 45579,
      "blake2b-96": 45580,
      "blake2b-104": 45581,
      "blake2b-112": 45582,
      "blake2b-120": 45583,
      "blake2b-128": 45584,
      "blake2b-136": 45585,
      "blake2b-144": 45586,
      "blake2b-152": 45587,
      "blake2b-160": 45588,
      "blake2b-168": 45589,
      "blake2b-176": 45590,
      "blake2b-184": 45591,
      "blake2b-192": 45592,
      "blake2b-200": 45593,
      "blake2b-208": 45594,
      "blake2b-216": 45595,
      "blake2b-224": 45596,
      "blake2b-232": 45597,
      "blake2b-240": 45598,
      "blake2b-248": 45599,
      "blake2b-256": 45600,
      "blake2b-264": 45601,
      "blake2b-272": 45602,
      "blake2b-280": 45603,
      "blake2b-288": 45604,
      "blake2b-296": 45605,
      "blake2b-304": 45606,
      "blake2b-312": 45607,
      "blake2b-320": 45608,
      "blake2b-328": 45609,
      "blake2b-336": 45610,
      "blake2b-344": 45611,
      "blake2b-352": 45612,
      "blake2b-360": 45613,
      "blake2b-368": 45614,
      "blake2b-376": 45615,
      "blake2b-384": 45616,
      "blake2b-392": 45617,
      "blake2b-400": 45618,
      "blake2b-408": 45619,
      "blake2b-416": 45620,
      "blake2b-424": 45621,
      "blake2b-432": 45622,
      "blake2b-440": 45623,
      "blake2b-448": 45624,
      "blake2b-456": 45625,
      "blake2b-464": 45626,
      "blake2b-472": 45627,
      "blake2b-480": 45628,
      "blake2b-488": 45629,
      "blake2b-496": 45630,
      "blake2b-504": 45631,
      "blake2b-512": 45632,
      "blake2s-8": 45633,
      "blake2s-16": 45634,
      "blake2s-24": 45635,
      "blake2s-32": 45636,
      "blake2s-40": 45637,
      "blake2s-48": 45638,
      "blake2s-56": 45639,
      "blake2s-64": 45640,
      "blake2s-72": 45641,
      "blake2s-80": 45642,
      "blake2s-88": 45643,
      "blake2s-96": 45644,
      "blake2s-104": 45645,
      "blake2s-112": 45646,
      "blake2s-120": 45647,
      "blake2s-128": 45648,
      "blake2s-136": 45649,
      "blake2s-144": 45650,
      "blake2s-152": 45651,
      "blake2s-160": 45652,
      "blake2s-168": 45653,
      "blake2s-176": 45654,
      "blake2s-184": 45655,
      "blake2s-192": 45656,
      "blake2s-200": 45657,
      "blake2s-208": 45658,
      "blake2s-216": 45659,
      "blake2s-224": 45660,
      "blake2s-232": 45661,
      "blake2s-240": 45662,
      "blake2s-248": 45663,
      "blake2s-256": 45664,
      "skein256-8": 45825,
      "skein256-16": 45826,
      "skein256-24": 45827,
      "skein256-32": 45828,
      "skein256-40": 45829,
      "skein256-48": 45830,
      "skein256-56": 45831,
      "skein256-64": 45832,
      "skein256-72": 45833,
      "skein256-80": 45834,
      "skein256-88": 45835,
      "skein256-96": 45836,
      "skein256-104": 45837,
      "skein256-112": 45838,
      "skein256-120": 45839,
      "skein256-128": 45840,
      "skein256-136": 45841,
      "skein256-144": 45842,
      "skein256-152": 45843,
      "skein256-160": 45844,
      "skein256-168": 45845,
      "skein256-176": 45846,
      "skein256-184": 45847,
      "skein256-192": 45848,
      "skein256-200": 45849,
      "skein256-208": 45850,
      "skein256-216": 45851,
      "skein256-224": 45852,
      "skein256-232": 45853,
      "skein256-240": 45854,
      "skein256-248": 45855,
      "skein256-256": 45856,
      "skein512-8": 45857,
      "skein512-16": 45858,
      "skein512-24": 45859,
      "skein512-32": 45860,
      "skein512-40": 45861,
      "skein512-48": 45862,
      "skein512-56": 45863,
      "skein512-64": 45864,
      "skein512-72": 45865,
      "skein512-80": 45866,
      "skein512-88": 45867,
      "skein512-96": 45868,
      "skein512-104": 45869,
      "skein512-112": 45870,
      "skein512-120": 45871,
      "skein512-128": 45872,
      "skein512-136": 45873,
      "skein512-144": 45874,
      "skein512-152": 45875,
      "skein512-160": 45876,
      "skein512-168": 45877,
      "skein512-176": 45878,
      "skein512-184": 45879,
      "skein512-192": 45880,
      "skein512-200": 45881,
      "skein512-208": 45882,
      "skein512-216": 45883,
      "skein512-224": 45884,
      "skein512-232": 45885,
      "skein512-240": 45886,
      "skein512-248": 45887,
      "skein512-256": 45888,
      "skein512-264": 45889,
      "skein512-272": 45890,
      "skein512-280": 45891,
      "skein512-288": 45892,
      "skein512-296": 45893,
      "skein512-304": 45894,
      "skein512-312": 45895,
      "skein512-320": 45896,
      "skein512-328": 45897,
      "skein512-336": 45898,
      "skein512-344": 45899,
      "skein512-352": 45900,
      "skein512-360": 45901,
      "skein512-368": 45902,
      "skein512-376": 45903,
      "skein512-384": 45904,
      "skein512-392": 45905,
      "skein512-400": 45906,
      "skein512-408": 45907,
      "skein512-416": 45908,
      "skein512-424": 45909,
      "skein512-432": 45910,
      "skein512-440": 45911,
      "skein512-448": 45912,
      "skein512-456": 45913,
      "skein512-464": 45914,
      "skein512-472": 45915,
      "skein512-480": 45916,
      "skein512-488": 45917,
      "skein512-496": 45918,
      "skein512-504": 45919,
      "skein512-512": 45920,
      "skein1024-8": 45921,
      "skein1024-16": 45922,
      "skein1024-24": 45923,
      "skein1024-32": 45924,
      "skein1024-40": 45925,
      "skein1024-48": 45926,
      "skein1024-56": 45927,
      "skein1024-64": 45928,
      "skein1024-72": 45929,
      "skein1024-80": 45930,
      "skein1024-88": 45931,
      "skein1024-96": 45932,
      "skein1024-104": 45933,
      "skein1024-112": 45934,
      "skein1024-120": 45935,
      "skein1024-128": 45936,
      "skein1024-136": 45937,
      "skein1024-144": 45938,
      "skein1024-152": 45939,
      "skein1024-160": 45940,
      "skein1024-168": 45941,
      "skein1024-176": 45942,
      "skein1024-184": 45943,
      "skein1024-192": 45944,
      "skein1024-200": 45945,
      "skein1024-208": 45946,
      "skein1024-216": 45947,
      "skein1024-224": 45948,
      "skein1024-232": 45949,
      "skein1024-240": 45950,
      "skein1024-248": 45951,
      "skein1024-256": 45952,
      "skein1024-264": 45953,
      "skein1024-272": 45954,
      "skein1024-280": 45955,
      "skein1024-288": 45956,
      "skein1024-296": 45957,
      "skein1024-304": 45958,
      "skein1024-312": 45959,
      "skein1024-320": 45960,
      "skein1024-328": 45961,
      "skein1024-336": 45962,
      "skein1024-344": 45963,
      "skein1024-352": 45964,
      "skein1024-360": 45965,
      "skein1024-368": 45966,
      "skein1024-376": 45967,
      "skein1024-384": 45968,
      "skein1024-392": 45969,
      "skein1024-400": 45970,
      "skein1024-408": 45971,
      "skein1024-416": 45972,
      "skein1024-424": 45973,
      "skein1024-432": 45974,
      "skein1024-440": 45975,
      "skein1024-448": 45976,
      "skein1024-456": 45977,
      "skein1024-464": 45978,
      "skein1024-472": 45979,
      "skein1024-480": 45980,
      "skein1024-488": 45981,
      "skein1024-496": 45982,
      "skein1024-504": 45983,
      "skein1024-512": 45984,
      "skein1024-520": 45985,
      "skein1024-528": 45986,
      "skein1024-536": 45987,
      "skein1024-544": 45988,
      "skein1024-552": 45989,
      "skein1024-560": 45990,
      "skein1024-568": 45991,
      "skein1024-576": 45992,
      "skein1024-584": 45993,
      "skein1024-592": 45994,
      "skein1024-600": 45995,
      "skein1024-608": 45996,
      "skein1024-616": 45997,
      "skein1024-624": 45998,
      "skein1024-632": 45999,
      "skein1024-640": 46e3,
      "skein1024-648": 46001,
      "skein1024-656": 46002,
      "skein1024-664": 46003,
      "skein1024-672": 46004,
      "skein1024-680": 46005,
      "skein1024-688": 46006,
      "skein1024-696": 46007,
      "skein1024-704": 46008,
      "skein1024-712": 46009,
      "skein1024-720": 46010,
      "skein1024-728": 46011,
      "skein1024-736": 46012,
      "skein1024-744": 46013,
      "skein1024-752": 46014,
      "skein1024-760": 46015,
      "skein1024-768": 46016,
      "skein1024-776": 46017,
      "skein1024-784": 46018,
      "skein1024-792": 46019,
      "skein1024-800": 46020,
      "skein1024-808": 46021,
      "skein1024-816": 46022,
      "skein1024-824": 46023,
      "skein1024-832": 46024,
      "skein1024-840": 46025,
      "skein1024-848": 46026,
      "skein1024-856": 46027,
      "skein1024-864": 46028,
      "skein1024-872": 46029,
      "skein1024-880": 46030,
      "skein1024-888": 46031,
      "skein1024-896": 46032,
      "skein1024-904": 46033,
      "skein1024-912": 46034,
      "skein1024-920": 46035,
      "skein1024-928": 46036,
      "skein1024-936": 46037,
      "skein1024-944": 46038,
      "skein1024-952": 46039,
      "skein1024-960": 46040,
      "skein1024-968": 46041,
      "skein1024-976": 46042,
      "skein1024-984": 46043,
      "skein1024-992": 46044,
      "skein1024-1000": 46045,
      "skein1024-1008": 46046,
      "skein1024-1016": 46047,
      "skein1024-1024": 46048,
      "holochain-adr-v0": 8417572,
      "holochain-adr-v1": 8483108,
      "holochain-key-v0": 9728292,
      "holochain-key-v1": 9793828,
      "holochain-sig-v0": 10645796,
      "holochain-sig-v1": 10711332
    };
  }, {}],
  "AcPh": [function(require, module, exports) {
    "use strict";
    const e = require("./base-table.json"),
      s = new Map;
    for (const t in e) {
      const o = e[t];
      s.set(o, t)
    }
    module.exports = Object.freeze(s);
  }, {
    "./base-table.json": "cvU0"
  }],
  "jElh": [function(require, module, exports) {
    var Buffer = require("buffer").Buffer;
    var e = require("buffer").Buffer;
    const r = require("varint");

    function n(e) {
      return parseInt(e.toString("hex"), 16)
    }

    function t(r) {
      let n = r.toString(16);
      return n.length % 2 == 1 && (n = "0" + n), e.from(n, "hex")
    }

    function o(t) {
      return e.from(r.encode(n(t)))
    }

    function u(e) {
      return t(r.decode(e))
    }

    function f(n) {
      return e.from(r.encode(n))
    }
    module.exports = {
      numberToBuffer: t,
      bufferToNumber: n,
      varintBufferEncode: o,
      varintBufferDecode: u,
      varintEncode: f
    };
  }, {
    "varint": "tvfU",
    "buffer": "dskh"
  }],
  "FOZD": [function(require, module, exports) {
    "use strict";
    const e = require("./base-table.json"),
      t = require("./util").varintEncode,
      r = {};
    for (const o in e) {
      const s = e[o];
      r[o] = t(s)
    }
    module.exports = Object.freeze(r);
  }, {
    "./base-table.json": "cvU0",
    "./util": "jElh"
  }],
  "DMiL": [function(require, module, exports) {
    "use strict";
    const e = require("./base-table.json"),
      t = {};
    for (const [r, s] of Object.entries(e)) t[r.toUpperCase().replace(/-/g, "_")] = s;
    module.exports = Object.freeze(t);
  }, {
    "./base-table.json": "cvU0"
  }],
  "vBL7": [function(require, module, exports) {
    "use strict";
    const e = require("./base-table.json"),
      t = {};
    for (const [o, s] of Object.entries(e)) void 0 === t[s] && (t[s] = o);
    module.exports = Object.freeze(t);
  }, {
    "./base-table.json": "cvU0"
  }],
  "Mgln": [function(require, module, exports) {
    var Buffer = require("buffer").Buffer;
    var e = require("buffer").Buffer;
    const r = require("varint"),
      t = require("./int-table"),
      o = require("./varint-table"),
      n = require("./util");
    exports = module.exports, exports.addPrefix = ((r, t) => {
      let i;
      if (e.isBuffer(r)) i = n.varintBufferEncode(r);
      else {
        if (!o[r]) throw new Error("multicodec not recognized");
        i = o[r]
      }
      return e.concat([i, t])
    }), exports.rmPrefix = (e => (r.decode(e), e.slice(r.decode.bytes))), exports.getCodec = (e => {
      const o = r.decode(e),
        n = t.get(o);
      if (void 0 === n) throw new Error(`Code ${o} not found`);
      return n
    }), exports.getName = (e => t.get(e)), exports.getNumber = (e => {
      const r = o[e];
      if (void 0 === r) throw new Error("Codec `" + e + "` not found");
      return n.varintBufferDecode(r)[0]
    }), exports.getCode = (e => r.decode(e)), exports.getCodeVarint = (e => {
      const r = o[e];
      if (void 0 === r) throw new Error("Codec `" + e + "` not found");
      return r
    }), exports.getVarint = (e => r.encode(e));
    const i = require("./constants");
    Object.assign(exports, i), exports.print = require("./print");
  }, {
    "varint": "tvfU",
    "./int-table": "AcPh",
    "./varint-table": "FOZD",
    "./util": "jElh",
    "./constants": "DMiL",
    "./print": "vBL7",
    "buffer": "dskh"
  }],
  "dTsG": [function(require, module, exports) {
    "use strict";
    class e {
      constructor(e, t, n, s) {
        this.name = e, this.code = t, this.alphabet = s, n && s && (this.engine = n(s))
      }
      encode(e) {
        return this.engine.encode(e)
      }
      decode(e) {
        return this.engine.decode(e)
      }
      isImplemented() {
        return this.engine
      }
    }
    module.exports = e;
  }, {}],
  "g2zT": [function(require, module, exports) {
    "use strict";
    var r = require("safe-buffer").Buffer;

    function e(e) {
      if (e.length >= 255) throw new TypeError("Alphabet too long");
      for (var o = new Uint8Array(256), t = 0; t < o.length; t++) o[t] = 255;
      for (var a = 0; a < e.length; a++) {
        var n = e.charAt(a),
          f = n.charCodeAt(0);
        if (255 !== o[f]) throw new TypeError(n + " is ambiguous");
        o[f] = a
      }
      var i = e.length,
        h = e.charAt(0),
        c = Math.log(i) / Math.log(256),
        l = Math.log(256) / Math.log(i);

      function u(e) {
        if ("string" != typeof e) throw new TypeError("Expected String");
        if (0 === e.length) return r.alloc(0);
        var t = 0;
        if (" " !== e[t]) {
          for (var a = 0, n = 0; e[t] === h;) a++, t++;
          for (var f = (e.length - t) * c + 1 >>> 0, l = new Uint8Array(f); e[t];) {
            var u = o[e.charCodeAt(t)];
            if (255 === u) return;
            for (var v = 0, w = f - 1;
              (0 !== u || v < n) && -1 !== w; w--, v++) u += i * l[w] >>> 0, l[w] = u % 256 >>> 0, u = u / 256 >>> 0;
            if (0 !== u) throw new Error("Non-zero carry");
            n = v, t++
          }
          if (" " !== e[t]) {
            for (var g = f - n; g !== f && 0 === l[g];) g++;
            var s = r.allocUnsafe(a + (f - g));
            s.fill(0, 0, a);
            for (var y = a; g !== f;) s[y++] = l[g++];
            return s
          }
        }
      }
      return {
        encode: function(o) {
          if ((Array.isArray(o) || o instanceof Uint8Array) && (o = r.from(o)), !r.isBuffer(o)) throw new TypeError("Expected Buffer");
          if (0 === o.length) return "";
          for (var t = 0, a = 0, n = 0, f = o.length; n !== f && 0 === o[n];) n++, t++;
          for (var c = (f - n) * l + 1 >>> 0, u = new Uint8Array(c); n !== f;) {
            for (var v = o[n], w = 0, g = c - 1;
              (0 !== v || w < a) && -1 !== g; g--, w++) v += 256 * u[g] >>> 0, u[g] = v % i >>> 0, v = v / i >>> 0;
            if (0 !== v) throw new Error("Non-zero carry");
            a = w, n++
          }
          for (var s = c - a; s !== c && 0 === u[s];) s++;
          for (var y = h.repeat(t); s < c; ++s) y += e.charAt(u[s]);
          return y
        },
        decodeUnsafe: u,
        decode: function(r) {
          var e = u(r);
          if (e) return e;
          throw new Error("Non-base" + i + " character")
        }
      }
    }
    module.exports = e;
  }, {
    "safe-buffer": "Wugr"
  }],
  "TZrm": [function(require, module, exports) {

    "use strict";
    const {
      Buffer: r
    } = require("buffer");
    module.exports = function(e) {
      return {
        encode: e => "string" == typeof e ? r.from(e).toString("hex") : e.toString("hex"),
        decode(o) {
          for (const r of o)
            if (e.indexOf(r) < 0) throw new Error("invalid base16 character");
          return r.from(o, "hex")
        }
      }
    };
  }, {
    "buffer": "dskh"
  }],
  "CLvn": [function(require, module, exports) {
    "use strict";

    function e(e, n) {
      const r = (e = e.replace(new RegExp("=", "g"), "")).length;
      let t = 0,
        o = 0,
        f = 0;
      const i = new Uint8Array(5 * r / 8 | 0);
      for (let c = 0; c < r; c++) o = o << 5 | n.indexOf(e[c]), (t += 5) >= 8 && (i[f++] = o >>> t - 8 & 255, t -= 8);
      return i.buffer
    }

    function n(e, n) {
      const r = e.byteLength,
        t = new Uint8Array(e),
        o = n.indexOf("=") === n.length - 1;
      o && (n = n.substring(0, n.length - 1));
      let f = 0,
        i = 0,
        c = "";
      for (let l = 0; l < r; l++)
        for (i = i << 8 | t[l], f += 8; f >= 5;) c += n[i >>> f - 5 & 31], f -= 5;
      if (f > 0 && (c += n[i << 5 - f & 31]), o)
        for (; c.length % 8 != 0;) c += "=";
      return c
    }
    module.exports = function(r) {
      return {
        encode: e => n("string" == typeof e ? Uint8Array.from(e) : e, r),
        decode(n) {
          for (const e of n)
            if (r.indexOf(e) < 0) throw new Error("invalid base32 character");
          return e(n, r)
        }
      }
    };
  }, {}],
  "QMoJ": [function(require, module, exports) {

    "use strict";
    const {
      Buffer: e
    } = require("buffer");
    module.exports = function(r) {
      const n = r.indexOf("=") > -1,
        t = r.indexOf("-") > -1 && r.indexOf("_") > -1;
      return {
        encode(r) {
          let o = "";
          o = "string" == typeof r ? e.from(r).toString("base64") : r.toString("base64"), t && (o = o.replace(/\+/g, "-").replace(/\//g, "_"));
          const f = o.indexOf("=");
          return f > 0 && !n && (o = o.substring(0, f)), o
        },
        decode(n) {
          for (const e of n)
            if (r.indexOf(e) < 0) throw new Error("invalid base64 character");
          return e.from(n, "base64")
        }
      }
    };
  }, {
    "buffer": "dskh"
  }],
  "kOWY": [function(require, module, exports) {
    "use strict";
    const e = require("./base.js"),
      s = require("base-x"),
      a = require("./base16"),
      b = require("./base32"),
      r = require("./base64"),
      u = [
        ["base1", "1", "", "1"],
        ["base2", "0", s, "01"],
        ["base8", "7", s, "01234567"],
        ["base10", "9", s, "0123456789"],
        ["base16", "f", a, "0123456789abcdef"],
        ["base32", "b", b, "abcdefghijklmnopqrstuvwxyz234567"],
        ["base32pad", "c", b, "abcdefghijklmnopqrstuvwxyz234567="],
        ["base32hex", "v", b, "0123456789abcdefghijklmnopqrstuv"],
        ["base32hexpad", "t", b, "0123456789abcdefghijklmnopqrstuv="],
        ["base32z", "h", b, "ybndrfg8ejkmcpqxot1uwisza345h769"],
        ["base58flickr", "Z", s, "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"],
        ["base58btc", "z", s, "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"],
        ["base64", "m", r, "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"],
        ["base64pad", "M", r, "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/="],
        ["base64url", "u", r, "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"],
        ["base64urlpad", "U", r, "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_="]
      ],
      c = u.reduce((s, a) => (s[a[0]] = new e(a[0], a[1], a[2], a[3]), s), {}),
      d = u.reduce((e, s) => (e[s[1]] = c[s[0]], e), {});
    module.exports = {
      names: c,
      codes: d
    };
  }, {
    "./base.js": "dTsG",
    "base-x": "g2zT",
    "./base16": "TZrm",
    "./base32": "CLvn",
    "./base64": "QMoJ"
  }],
  "Ij5g": [function(require, module, exports) {

    "use strict";
    const {
      Buffer: e
    } = require("buffer"), t = require("./constants");

    function r(t, r) {
      if (!r) throw new Error("requires an encoded buffer");
      const n = i(t),
        o = e.from(n.code);
      return c(n.name, r), e.concat([o, r])
    }

    function n(t, n) {
      const o = i(t);
      return r(o.name, e.from(o.encode(n)))
    }

    function o(t) {
      e.isBuffer(t) && (t = t.toString());
      const r = t.substring(0, 1);
      "string" == typeof(t = t.substring(1, t.length)) && (t = e.from(t));
      const n = i(r);
      return e.from(n.decode(t.toString()))
    }

    function s(t) {
      if (e.isBuffer(t) && (t = t.toString()), "[object String]" !== Object.prototype.toString.call(t)) return !1;
      const r = t.substring(0, 1);
      try {
        return i(r).name
      } catch (n) {
        return !1
      }
    }

    function c(e, t) {
      i(e).decode(t.toString())
    }

    function i(e) {
      let r;
      if (t.names[e]) r = t.names[e];
      else {
        if (!t.codes[e]) throw new Error("Unsupported encoding");
        r = t.codes[e]
      }
      if (!r.isImplemented()) throw new Error("Base " + e + " is not implemented yet");
      return r
    }
    exports = module.exports = r, exports.encode = n, exports.decode = o, exports.isEncoded = s, exports.names = Object.freeze(Object.keys(t.names)), exports.codes = Object.freeze(Object.keys(t.codes));
  }, {
    "buffer": "dskh",
    "./constants": "kOWY"
  }],
  "GDRJ": [function(require, module, exports) {
    "use strict";
    exports.names = Object.freeze({
      identity: 0,
      sha1: 17,
      "sha2-256": 18,
      "sha2-512": 19,
      "dbl-sha2-256": 86,
      "sha3-224": 23,
      "sha3-256": 22,
      "sha3-384": 21,
      "sha3-512": 20,
      "shake-128": 24,
      "shake-256": 25,
      "keccak-224": 26,
      "keccak-256": 27,
      "keccak-384": 28,
      "keccak-512": 29,
      "murmur3-128": 34,
      "murmur3-32": 35,
      md4: 212,
      md5: 213,
      "blake2b-8": 45569,
      "blake2b-16": 45570,
      "blake2b-24": 45571,
      "blake2b-32": 45572,
      "blake2b-40": 45573,
      "blake2b-48": 45574,
      "blake2b-56": 45575,
      "blake2b-64": 45576,
      "blake2b-72": 45577,
      "blake2b-80": 45578,
      "blake2b-88": 45579,
      "blake2b-96": 45580,
      "blake2b-104": 45581,
      "blake2b-112": 45582,
      "blake2b-120": 45583,
      "blake2b-128": 45584,
      "blake2b-136": 45585,
      "blake2b-144": 45586,
      "blake2b-152": 45587,
      "blake2b-160": 45588,
      "blake2b-168": 45589,
      "blake2b-176": 45590,
      "blake2b-184": 45591,
      "blake2b-192": 45592,
      "blake2b-200": 45593,
      "blake2b-208": 45594,
      "blake2b-216": 45595,
      "blake2b-224": 45596,
      "blake2b-232": 45597,
      "blake2b-240": 45598,
      "blake2b-248": 45599,
      "blake2b-256": 45600,
      "blake2b-264": 45601,
      "blake2b-272": 45602,
      "blake2b-280": 45603,
      "blake2b-288": 45604,
      "blake2b-296": 45605,
      "blake2b-304": 45606,
      "blake2b-312": 45607,
      "blake2b-320": 45608,
      "blake2b-328": 45609,
      "blake2b-336": 45610,
      "blake2b-344": 45611,
      "blake2b-352": 45612,
      "blake2b-360": 45613,
      "blake2b-368": 45614,
      "blake2b-376": 45615,
      "blake2b-384": 45616,
      "blake2b-392": 45617,
      "blake2b-400": 45618,
      "blake2b-408": 45619,
      "blake2b-416": 45620,
      "blake2b-424": 45621,
      "blake2b-432": 45622,
      "blake2b-440": 45623,
      "blake2b-448": 45624,
      "blake2b-456": 45625,
      "blake2b-464": 45626,
      "blake2b-472": 45627,
      "blake2b-480": 45628,
      "blake2b-488": 45629,
      "blake2b-496": 45630,
      "blake2b-504": 45631,
      "blake2b-512": 45632,
      "blake2s-8": 45633,
      "blake2s-16": 45634,
      "blake2s-24": 45635,
      "blake2s-32": 45636,
      "blake2s-40": 45637,
      "blake2s-48": 45638,
      "blake2s-56": 45639,
      "blake2s-64": 45640,
      "blake2s-72": 45641,
      "blake2s-80": 45642,
      "blake2s-88": 45643,
      "blake2s-96": 45644,
      "blake2s-104": 45645,
      "blake2s-112": 45646,
      "blake2s-120": 45647,
      "blake2s-128": 45648,
      "blake2s-136": 45649,
      "blake2s-144": 45650,
      "blake2s-152": 45651,
      "blake2s-160": 45652,
      "blake2s-168": 45653,
      "blake2s-176": 45654,
      "blake2s-184": 45655,
      "blake2s-192": 45656,
      "blake2s-200": 45657,
      "blake2s-208": 45658,
      "blake2s-216": 45659,
      "blake2s-224": 45660,
      "blake2s-232": 45661,
      "blake2s-240": 45662,
      "blake2s-248": 45663,
      "blake2s-256": 45664,
      "Skein256-8": 45825,
      "Skein256-16": 45826,
      "Skein256-24": 45827,
      "Skein256-32": 45828,
      "Skein256-40": 45829,
      "Skein256-48": 45830,
      "Skein256-56": 45831,
      "Skein256-64": 45832,
      "Skein256-72": 45833,
      "Skein256-80": 45834,
      "Skein256-88": 45835,
      "Skein256-96": 45836,
      "Skein256-104": 45837,
      "Skein256-112": 45838,
      "Skein256-120": 45839,
      "Skein256-128": 45840,
      "Skein256-136": 45841,
      "Skein256-144": 45842,
      "Skein256-152": 45843,
      "Skein256-160": 45844,
      "Skein256-168": 45845,
      "Skein256-176": 45846,
      "Skein256-184": 45847,
      "Skein256-192": 45848,
      "Skein256-200": 45849,
      "Skein256-208": 45850,
      "Skein256-216": 45851,
      "Skein256-224": 45852,
      "Skein256-232": 45853,
      "Skein256-240": 45854,
      "Skein256-248": 45855,
      "Skein256-256": 45856,
      "Skein512-8": 45857,
      "Skein512-16": 45858,
      "Skein512-24": 45859,
      "Skein512-32": 45860,
      "Skein512-40": 45861,
      "Skein512-48": 45862,
      "Skein512-56": 45863,
      "Skein512-64": 45864,
      "Skein512-72": 45865,
      "Skein512-80": 45866,
      "Skein512-88": 45867,
      "Skein512-96": 45868,
      "Skein512-104": 45869,
      "Skein512-112": 45870,
      "Skein512-120": 45871,
      "Skein512-128": 45872,
      "Skein512-136": 45873,
      "Skein512-144": 45874,
      "Skein512-152": 45875,
      "Skein512-160": 45876,
      "Skein512-168": 45877,
      "Skein512-176": 45878,
      "Skein512-184": 45879,
      "Skein512-192": 45880,
      "Skein512-200": 45881,
      "Skein512-208": 45882,
      "Skein512-216": 45883,
      "Skein512-224": 45884,
      "Skein512-232": 45885,
      "Skein512-240": 45886,
      "Skein512-248": 45887,
      "Skein512-256": 45888,
      "Skein512-264": 45889,
      "Skein512-272": 45890,
      "Skein512-280": 45891,
      "Skein512-288": 45892,
      "Skein512-296": 45893,
      "Skein512-304": 45894,
      "Skein512-312": 45895,
      "Skein512-320": 45896,
      "Skein512-328": 45897,
      "Skein512-336": 45898,
      "Skein512-344": 45899,
      "Skein512-352": 45900,
      "Skein512-360": 45901,
      "Skein512-368": 45902,
      "Skein512-376": 45903,
      "Skein512-384": 45904,
      "Skein512-392": 45905,
      "Skein512-400": 45906,
      "Skein512-408": 45907,
      "Skein512-416": 45908,
      "Skein512-424": 45909,
      "Skein512-432": 45910,
      "Skein512-440": 45911,
      "Skein512-448": 45912,
      "Skein512-456": 45913,
      "Skein512-464": 45914,
      "Skein512-472": 45915,
      "Skein512-480": 45916,
      "Skein512-488": 45917,
      "Skein512-496": 45918,
      "Skein512-504": 45919,
      "Skein512-512": 45920,
      "Skein1024-8": 45921,
      "Skein1024-16": 45922,
      "Skein1024-24": 45923,
      "Skein1024-32": 45924,
      "Skein1024-40": 45925,
      "Skein1024-48": 45926,
      "Skein1024-56": 45927,
      "Skein1024-64": 45928,
      "Skein1024-72": 45929,
      "Skein1024-80": 45930,
      "Skein1024-88": 45931,
      "Skein1024-96": 45932,
      "Skein1024-104": 45933,
      "Skein1024-112": 45934,
      "Skein1024-120": 45935,
      "Skein1024-128": 45936,
      "Skein1024-136": 45937,
      "Skein1024-144": 45938,
      "Skein1024-152": 45939,
      "Skein1024-160": 45940,
      "Skein1024-168": 45941,
      "Skein1024-176": 45942,
      "Skein1024-184": 45943,
      "Skein1024-192": 45944,
      "Skein1024-200": 45945,
      "Skein1024-208": 45946,
      "Skein1024-216": 45947,
      "Skein1024-224": 45948,
      "Skein1024-232": 45949,
      "Skein1024-240": 45950,
      "Skein1024-248": 45951,
      "Skein1024-256": 45952,
      "Skein1024-264": 45953,
      "Skein1024-272": 45954,
      "Skein1024-280": 45955,
      "Skein1024-288": 45956,
      "Skein1024-296": 45957,
      "Skein1024-304": 45958,
      "Skein1024-312": 45959,
      "Skein1024-320": 45960,
      "Skein1024-328": 45961,
      "Skein1024-336": 45962,
      "Skein1024-344": 45963,
      "Skein1024-352": 45964,
      "Skein1024-360": 45965,
      "Skein1024-368": 45966,
      "Skein1024-376": 45967,
      "Skein1024-384": 45968,
      "Skein1024-392": 45969,
      "Skein1024-400": 45970,
      "Skein1024-408": 45971,
      "Skein1024-416": 45972,
      "Skein1024-424": 45973,
      "Skein1024-432": 45974,
      "Skein1024-440": 45975,
      "Skein1024-448": 45976,
      "Skein1024-456": 45977,
      "Skein1024-464": 45978,
      "Skein1024-472": 45979,
      "Skein1024-480": 45980,
      "Skein1024-488": 45981,
      "Skein1024-496": 45982,
      "Skein1024-504": 45983,
      "Skein1024-512": 45984,
      "Skein1024-520": 45985,
      "Skein1024-528": 45986,
      "Skein1024-536": 45987,
      "Skein1024-544": 45988,
      "Skein1024-552": 45989,
      "Skein1024-560": 45990,
      "Skein1024-568": 45991,
      "Skein1024-576": 45992,
      "Skein1024-584": 45993,
      "Skein1024-592": 45994,
      "Skein1024-600": 45995,
      "Skein1024-608": 45996,
      "Skein1024-616": 45997,
      "Skein1024-624": 45998,
      "Skein1024-632": 45999,
      "Skein1024-640": 46e3,
      "Skein1024-648": 46001,
      "Skein1024-656": 46002,
      "Skein1024-664": 46003,
      "Skein1024-672": 46004,
      "Skein1024-680": 46005,
      "Skein1024-688": 46006,
      "Skein1024-696": 46007,
      "Skein1024-704": 46008,
      "Skein1024-712": 46009,
      "Skein1024-720": 46010,
      "Skein1024-728": 46011,
      "Skein1024-736": 46012,
      "Skein1024-744": 46013,
      "Skein1024-752": 46014,
      "Skein1024-760": 46015,
      "Skein1024-768": 46016,
      "Skein1024-776": 46017,
      "Skein1024-784": 46018,
      "Skein1024-792": 46019,
      "Skein1024-800": 46020,
      "Skein1024-808": 46021,
      "Skein1024-816": 46022,
      "Skein1024-824": 46023,
      "Skein1024-832": 46024,
      "Skein1024-840": 46025,
      "Skein1024-848": 46026,
      "Skein1024-856": 46027,
      "Skein1024-864": 46028,
      "Skein1024-872": 46029,
      "Skein1024-880": 46030,
      "Skein1024-888": 46031,
      "Skein1024-896": 46032,
      "Skein1024-904": 46033,
      "Skein1024-912": 46034,
      "Skein1024-920": 46035,
      "Skein1024-928": 46036,
      "Skein1024-936": 46037,
      "Skein1024-944": 46038,
      "Skein1024-952": 46039,
      "Skein1024-960": 46040,
      "Skein1024-968": 46041,
      "Skein1024-976": 46042,
      "Skein1024-984": 46043,
      "Skein1024-992": 46044,
      "Skein1024-1000": 46045,
      "Skein1024-1008": 46046,
      "Skein1024-1016": 46047,
      "Skein1024-1024": 46048
    }), exports.codes = Object.freeze({
      0: "identity",
      17: "sha1",
      18: "sha2-256",
      19: "sha2-512",
      86: "dbl-sha2-256",
      23: "sha3-224",
      22: "sha3-256",
      21: "sha3-384",
      20: "sha3-512",
      24: "shake-128",
      25: "shake-256",
      26: "keccak-224",
      27: "keccak-256",
      28: "keccak-384",
      29: "keccak-512",
      34: "murmur3-128",
      35: "murmur3-32",
      212: "md4",
      213: "md5",
      45569: "blake2b-8",
      45570: "blake2b-16",
      45571: "blake2b-24",
      45572: "blake2b-32",
      45573: "blake2b-40",
      45574: "blake2b-48",
      45575: "blake2b-56",
      45576: "blake2b-64",
      45577: "blake2b-72",
      45578: "blake2b-80",
      45579: "blake2b-88",
      45580: "blake2b-96",
      45581: "blake2b-104",
      45582: "blake2b-112",
      45583: "blake2b-120",
      45584: "blake2b-128",
      45585: "blake2b-136",
      45586: "blake2b-144",
      45587: "blake2b-152",
      45588: "blake2b-160",
      45589: "blake2b-168",
      45590: "blake2b-176",
      45591: "blake2b-184",
      45592: "blake2b-192",
      45593: "blake2b-200",
      45594: "blake2b-208",
      45595: "blake2b-216",
      45596: "blake2b-224",
      45597: "blake2b-232",
      45598: "blake2b-240",
      45599: "blake2b-248",
      45600: "blake2b-256",
      45601: "blake2b-264",
      45602: "blake2b-272",
      45603: "blake2b-280",
      45604: "blake2b-288",
      45605: "blake2b-296",
      45606: "blake2b-304",
      45607: "blake2b-312",
      45608: "blake2b-320",
      45609: "blake2b-328",
      45610: "blake2b-336",
      45611: "blake2b-344",
      45612: "blake2b-352",
      45613: "blake2b-360",
      45614: "blake2b-368",
      45615: "blake2b-376",
      45616: "blake2b-384",
      45617: "blake2b-392",
      45618: "blake2b-400",
      45619: "blake2b-408",
      45620: "blake2b-416",
      45621: "blake2b-424",
      45622: "blake2b-432",
      45623: "blake2b-440",
      45624: "blake2b-448",
      45625: "blake2b-456",
      45626: "blake2b-464",
      45627: "blake2b-472",
      45628: "blake2b-480",
      45629: "blake2b-488",
      45630: "blake2b-496",
      45631: "blake2b-504",
      45632: "blake2b-512",
      45633: "blake2s-8",
      45634: "blake2s-16",
      45635: "blake2s-24",
      45636: "blake2s-32",
      45637: "blake2s-40",
      45638: "blake2s-48",
      45639: "blake2s-56",
      45640: "blake2s-64",
      45641: "blake2s-72",
      45642: "blake2s-80",
      45643: "blake2s-88",
      45644: "blake2s-96",
      45645: "blake2s-104",
      45646: "blake2s-112",
      45647: "blake2s-120",
      45648: "blake2s-128",
      45649: "blake2s-136",
      45650: "blake2s-144",
      45651: "blake2s-152",
      45652: "blake2s-160",
      45653: "blake2s-168",
      45654: "blake2s-176",
      45655: "blake2s-184",
      45656: "blake2s-192",
      45657: "blake2s-200",
      45658: "blake2s-208",
      45659: "blake2s-216",
      45660: "blake2s-224",
      45661: "blake2s-232",
      45662: "blake2s-240",
      45663: "blake2s-248",
      45664: "blake2s-256",
      45825: "Skein256-8",
      45826: "Skein256-16",
      45827: "Skein256-24",
      45828: "Skein256-32",
      45829: "Skein256-40",
      45830: "Skein256-48",
      45831: "Skein256-56",
      45832: "Skein256-64",
      45833: "Skein256-72",
      45834: "Skein256-80",
      45835: "Skein256-88",
      45836: "Skein256-96",
      45837: "Skein256-104",
      45838: "Skein256-112",
      45839: "Skein256-120",
      45840: "Skein256-128",
      45841: "Skein256-136",
      45842: "Skein256-144",
      45843: "Skein256-152",
      45844: "Skein256-160",
      45845: "Skein256-168",
      45846: "Skein256-176",
      45847: "Skein256-184",
      45848: "Skein256-192",
      45849: "Skein256-200",
      45850: "Skein256-208",
      45851: "Skein256-216",
      45852: "Skein256-224",
      45853: "Skein256-232",
      45854: "Skein256-240",
      45855: "Skein256-248",
      45856: "Skein256-256",
      45857: "Skein512-8",
      45858: "Skein512-16",
      45859: "Skein512-24",
      45860: "Skein512-32",
      45861: "Skein512-40",
      45862: "Skein512-48",
      45863: "Skein512-56",
      45864: "Skein512-64",
      45865: "Skein512-72",
      45866: "Skein512-80",
      45867: "Skein512-88",
      45868: "Skein512-96",
      45869: "Skein512-104",
      45870: "Skein512-112",
      45871: "Skein512-120",
      45872: "Skein512-128",
      45873: "Skein512-136",
      45874: "Skein512-144",
      45875: "Skein512-152",
      45876: "Skein512-160",
      45877: "Skein512-168",
      45878: "Skein512-176",
      45879: "Skein512-184",
      45880: "Skein512-192",
      45881: "Skein512-200",
      45882: "Skein512-208",
      45883: "Skein512-216",
      45884: "Skein512-224",
      45885: "Skein512-232",
      45886: "Skein512-240",
      45887: "Skein512-248",
      45888: "Skein512-256",
      45889: "Skein512-264",
      45890: "Skein512-272",
      45891: "Skein512-280",
      45892: "Skein512-288",
      45893: "Skein512-296",
      45894: "Skein512-304",
      45895: "Skein512-312",
      45896: "Skein512-320",
      45897: "Skein512-328",
      45898: "Skein512-336",
      45899: "Skein512-344",
      45900: "Skein512-352",
      45901: "Skein512-360",
      45902: "Skein512-368",
      45903: "Skein512-376",
      45904: "Skein512-384",
      45905: "Skein512-392",
      45906: "Skein512-400",
      45907: "Skein512-408",
      45908: "Skein512-416",
      45909: "Skein512-424",
      45910: "Skein512-432",
      45911: "Skein512-440",
      45912: "Skein512-448",
      45913: "Skein512-456",
      45914: "Skein512-464",
      45915: "Skein512-472",
      45916: "Skein512-480",
      45917: "Skein512-488",
      45918: "Skein512-496",
      45919: "Skein512-504",
      45920: "Skein512-512",
      45921: "Skein1024-8",
      45922: "Skein1024-16",
      45923: "Skein1024-24",
      45924: "Skein1024-32",
      45925: "Skein1024-40",
      45926: "Skein1024-48",
      45927: "Skein1024-56",
      45928: "Skein1024-64",
      45929: "Skein1024-72",
      45930: "Skein1024-80",
      45931: "Skein1024-88",
      45932: "Skein1024-96",
      45933: "Skein1024-104",
      45934: "Skein1024-112",
      45935: "Skein1024-120",
      45936: "Skein1024-128",
      45937: "Skein1024-136",
      45938: "Skein1024-144",
      45939: "Skein1024-152",
      45940: "Skein1024-160",
      45941: "Skein1024-168",
      45942: "Skein1024-176",
      45943: "Skein1024-184",
      45944: "Skein1024-192",
      45945: "Skein1024-200",
      45946: "Skein1024-208",
      45947: "Skein1024-216",
      45948: "Skein1024-224",
      45949: "Skein1024-232",
      45950: "Skein1024-240",
      45951: "Skein1024-248",
      45952: "Skein1024-256",
      45953: "Skein1024-264",
      45954: "Skein1024-272",
      45955: "Skein1024-280",
      45956: "Skein1024-288",
      45957: "Skein1024-296",
      45958: "Skein1024-304",
      45959: "Skein1024-312",
      45960: "Skein1024-320",
      45961: "Skein1024-328",
      45962: "Skein1024-336",
      45963: "Skein1024-344",
      45964: "Skein1024-352",
      45965: "Skein1024-360",
      45966: "Skein1024-368",
      45967: "Skein1024-376",
      45968: "Skein1024-384",
      45969: "Skein1024-392",
      45970: "Skein1024-400",
      45971: "Skein1024-408",
      45972: "Skein1024-416",
      45973: "Skein1024-424",
      45974: "Skein1024-432",
      45975: "Skein1024-440",
      45976: "Skein1024-448",
      45977: "Skein1024-456",
      45978: "Skein1024-464",
      45979: "Skein1024-472",
      45980: "Skein1024-480",
      45981: "Skein1024-488",
      45982: "Skein1024-496",
      45983: "Skein1024-504",
      45984: "Skein1024-512",
      45985: "Skein1024-520",
      45986: "Skein1024-528",
      45987: "Skein1024-536",
      45988: "Skein1024-544",
      45989: "Skein1024-552",
      45990: "Skein1024-560",
      45991: "Skein1024-568",
      45992: "Skein1024-576",
      45993: "Skein1024-584",
      45994: "Skein1024-592",
      45995: "Skein1024-600",
      45996: "Skein1024-608",
      45997: "Skein1024-616",
      45998: "Skein1024-624",
      45999: "Skein1024-632",
      46000: "Skein1024-640",
      46001: "Skein1024-648",
      46002: "Skein1024-656",
      46003: "Skein1024-664",
      46004: "Skein1024-672",
      46005: "Skein1024-680",
      46006: "Skein1024-688",
      46007: "Skein1024-696",
      46008: "Skein1024-704",
      46009: "Skein1024-712",
      46010: "Skein1024-720",
      46011: "Skein1024-728",
      46012: "Skein1024-736",
      46013: "Skein1024-744",
      46014: "Skein1024-752",
      46015: "Skein1024-760",
      46016: "Skein1024-768",
      46017: "Skein1024-776",
      46018: "Skein1024-784",
      46019: "Skein1024-792",
      46020: "Skein1024-800",
      46021: "Skein1024-808",
      46022: "Skein1024-816",
      46023: "Skein1024-824",
      46024: "Skein1024-832",
      46025: "Skein1024-840",
      46026: "Skein1024-848",
      46027: "Skein1024-856",
      46028: "Skein1024-864",
      46029: "Skein1024-872",
      46030: "Skein1024-880",
      46031: "Skein1024-888",
      46032: "Skein1024-896",
      46033: "Skein1024-904",
      46034: "Skein1024-912",
      46035: "Skein1024-920",
      46036: "Skein1024-928",
      46037: "Skein1024-936",
      46038: "Skein1024-944",
      46039: "Skein1024-952",
      46040: "Skein1024-960",
      46041: "Skein1024-968",
      46042: "Skein1024-976",
      46043: "Skein1024-984",
      46044: "Skein1024-992",
      46045: "Skein1024-1000",
      46046: "Skein1024-1008",
      46047: "Skein1024-1016",
      46048: "Skein1024-1024"
    }), exports.defaultLengths = Object.freeze({
      17: 20,
      18: 32,
      19: 64,
      86: 32,
      23: 28,
      22: 32,
      21: 48,
      20: 64,
      24: 32,
      25: 64,
      26: 28,
      27: 32,
      28: 48,
      29: 64,
      34: 32,
      45569: 1,
      45570: 2,
      45571: 3,
      45572: 4,
      45573: 5,
      45574: 6,
      45575: 7,
      45576: 8,
      45577: 9,
      45578: 10,
      45579: 11,
      45580: 12,
      45581: 13,
      45582: 14,
      45583: 15,
      45584: 16,
      45585: 17,
      45586: 18,
      45587: 19,
      45588: 20,
      45589: 21,
      45590: 22,
      45591: 23,
      45592: 24,
      45593: 25,
      45594: 26,
      45595: 27,
      45596: 28,
      45597: 29,
      45598: 30,
      45599: 31,
      45600: 32,
      45601: 33,
      45602: 34,
      45603: 35,
      45604: 36,
      45605: 37,
      45606: 38,
      45607: 39,
      45608: 40,
      45609: 41,
      45610: 42,
      45611: 43,
      45612: 44,
      45613: 45,
      45614: 46,
      45615: 47,
      45616: 48,
      45617: 49,
      45618: 50,
      45619: 51,
      45620: 52,
      45621: 53,
      45622: 54,
      45623: 55,
      45624: 56,
      45625: 57,
      45626: 58,
      45627: 59,
      45628: 60,
      45629: 61,
      45630: 62,
      45631: 63,
      45632: 64,
      45633: 1,
      45634: 2,
      45635: 3,
      45636: 4,
      45637: 5,
      45638: 6,
      45639: 7,
      45640: 8,
      45641: 9,
      45642: 10,
      45643: 11,
      45644: 12,
      45645: 13,
      45646: 14,
      45647: 15,
      45648: 16,
      45649: 17,
      45650: 18,
      45651: 19,
      45652: 20,
      45653: 21,
      45654: 22,
      45655: 23,
      45656: 24,
      45657: 25,
      45658: 26,
      45659: 27,
      45660: 28,
      45661: 29,
      45662: 30,
      45663: 31,
      45664: 32,
      45825: 1,
      45826: 2,
      45827: 3,
      45828: 4,
      45829: 5,
      45830: 6,
      45831: 7,
      45832: 8,
      45833: 9,
      45834: 10,
      45835: 11,
      45836: 12,
      45837: 13,
      45838: 14,
      45839: 15,
      45840: 16,
      45841: 17,
      45842: 18,
      45843: 19,
      45844: 20,
      45845: 21,
      45846: 22,
      45847: 23,
      45848: 24,
      45849: 25,
      45850: 26,
      45851: 27,
      45852: 28,
      45853: 29,
      45854: 30,
      45855: 31,
      45856: 32,
      45857: 1,
      45858: 2,
      45859: 3,
      45860: 4,
      45861: 5,
      45862: 6,
      45863: 7,
      45864: 8,
      45865: 9,
      45866: 10,
      45867: 11,
      45868: 12,
      45869: 13,
      45870: 14,
      45871: 15,
      45872: 16,
      45873: 17,
      45874: 18,
      45875: 19,
      45876: 20,
      45877: 21,
      45878: 22,
      45879: 23,
      45880: 24,
      45881: 25,
      45882: 26,
      45883: 27,
      45884: 28,
      45885: 29,
      45886: 30,
      45887: 31,
      45888: 32,
      45889: 33,
      45890: 34,
      45891: 35,
      45892: 36,
      45893: 37,
      45894: 38,
      45895: 39,
      45896: 40,
      45897: 41,
      45898: 42,
      45899: 43,
      45900: 44,
      45901: 45,
      45902: 46,
      45903: 47,
      45904: 48,
      45905: 49,
      45906: 50,
      45907: 51,
      45908: 52,
      45909: 53,
      45910: 54,
      45911: 55,
      45912: 56,
      45913: 57,
      45914: 58,
      45915: 59,
      45916: 60,
      45917: 61,
      45918: 62,
      45919: 63,
      45920: 64,
      45921: 1,
      45922: 2,
      45923: 3,
      45924: 4,
      45925: 5,
      45926: 6,
      45927: 7,
      45928: 8,
      45929: 9,
      45930: 10,
      45931: 11,
      45932: 12,
      45933: 13,
      45934: 14,
      45935: 15,
      45936: 16,
      45937: 17,
      45938: 18,
      45939: 19,
      45940: 20,
      45941: 21,
      45942: 22,
      45943: 23,
      45944: 24,
      45945: 25,
      45946: 26,
      45947: 27,
      45948: 28,
      45949: 29,
      45950: 30,
      45951: 31,
      45952: 32,
      45953: 33,
      45954: 34,
      45955: 35,
      45956: 36,
      45957: 37,
      45958: 38,
      45959: 39,
      45960: 40,
      45961: 41,
      45962: 42,
      45963: 43,
      45964: 44,
      45965: 45,
      45966: 46,
      45967: 47,
      45968: 48,
      45969: 49,
      45970: 50,
      45971: 51,
      45972: 52,
      45973: 53,
      45974: 54,
      45975: 55,
      45976: 56,
      45977: 57,
      45978: 58,
      45979: 59,
      45980: 60,
      45981: 61,
      45982: 62,
      45983: 63,
      45984: 64,
      45985: 65,
      45986: 66,
      45987: 67,
      45988: 68,
      45989: 69,
      45990: 70,
      45991: 71,
      45992: 72,
      45993: 73,
      45994: 74,
      45995: 75,
      45996: 76,
      45997: 77,
      45998: 78,
      45999: 79,
      46000: 80,
      46001: 81,
      46002: 82,
      46003: 83,
      46004: 84,
      46005: 85,
      46006: 86,
      46007: 87,
      46008: 88,
      46009: 89,
      46010: 90,
      46011: 91,
      46012: 92,
      46013: 93,
      46014: 94,
      46015: 95,
      46016: 96,
      46017: 97,
      46018: 98,
      46019: 99,
      46020: 100,
      46021: 101,
      46022: 102,
      46023: 103,
      46024: 104,
      46025: 105,
      46026: 106,
      46027: 107,
      46028: 108,
      46029: 109,
      46030: 110,
      46031: 111,
      46032: 112,
      46033: 113,
      46034: 114,
      46035: 115,
      46036: 116,
      46037: 117,
      46038: 118,
      46039: 119,
      46040: 120,
      46041: 121,
      46042: 122,
      46043: 123,
      46044: 124,
      46045: 125,
      46046: 126,
      46047: 127,
      46048: 128
    });
  }, {}],
  "CaqF": [function(require, module, exports) {

    "use strict";
    const {
      Buffer: e
    } = require("buffer"), r = require("multibase"), t = require("varint"), o = require("./constants");

    function n(e) {
      exports.decode(e)
    }
    exports.names = o.names, exports.codes = o.codes, exports.defaultLengths = o.defaultLengths, exports.toHexString = function(r) {
      if (!e.isBuffer(r)) throw new Error("must be passed a buffer");
      return r.toString("hex")
    }, exports.fromHexString = function(r) {
      return e.from(r, "hex")
    }, exports.toB58String = function(t) {
      if (!e.isBuffer(t)) throw new Error("must be passed a buffer");
      return r.encode("base58btc", t).toString().slice(1)
    }, exports.fromB58String = function(t) {
      let o = t;
      return e.isBuffer(t) && (o = t.toString()), r.decode("z" + o)
    }, exports.decode = function(r) {
      if (!e.isBuffer(r)) throw new Error("multihash must be a Buffer");
      if (r.length < 2) throw new Error("multihash too short. must be > 2 bytes.");
      const n = t.decode(r);
      if (!exports.isValidCode(n)) throw new Error(`multihash unknown function code: 0x${n.toString(16)}`);
      r = r.slice(t.decode.bytes);
      const s = t.decode(r);
      if (s < 0) throw new Error(`multihash invalid length: ${s}`);
      if ((r = r.slice(t.decode.bytes)).length !== s) throw new Error(`multihash length inconsistent: 0x${r.toString("hex")}`);
      return {
        code: n,
        name: o.codes[n],
        length: s,
        digest: r
      }
    }, exports.encode = function(r, o, n) {
      if (!r || void 0 === o) throw new Error("multihash encode requires at least two args: digest, code");
      const s = exports.coerceCode(o);
      if (!e.isBuffer(r)) throw new Error("digest should be a Buffer");
      if (null == n && (n = r.length), n && r.length !== n) throw new Error("digest length should be equal to specified length.");
      return e.concat([e.from(t.encode(s)), e.from(t.encode(n)), r])
    }, exports.coerceCode = function(e) {
      let r = e;
      if ("string" == typeof e) {
        if (void 0 === o.names[e]) throw new Error(`Unrecognized hash function named: ${e}`);
        r = o.names[e]
      }
      if ("number" != typeof r) throw new Error(`Hash function code should be a number. Got: ${r}`);
      if (void 0 === o.codes[r] && !exports.isAppCode(r)) throw new Error(`Unrecognized function code: ${r}`);
      return r
    }, exports.isAppCode = function(e) {
      return e > 0 && e < 16
    }, exports.isValidCode = function(e) {
      return !!exports.isAppCode(e) || !!o.codes[e]
    }, exports.validate = n, exports.prefix = function(e) {
      return n(e), e.slice(0, 2)
    };
  }, {
    "buffer": "dskh",
    "multibase": "Ij5g",
    "varint": "tvfU",
    "./constants": "GDRJ"
  }],
  "Y4Wf": [function(require, module, exports) {
    "use strict";
    const e = require("./base.js"),
      s = require("base-x"),
      a = require("./base16"),
      b = require("./base32"),
      r = require("./base64"),
      u = [
        ["base1", "1", "", "1"],
        ["base2", "0", s, "01"],
        ["base8", "7", s, "01234567"],
        ["base10", "9", s, "0123456789"],
        ["base16", "f", a, "0123456789abcdef"],
        ["base32", "b", b, "abcdefghijklmnopqrstuvwxyz234567"],
        ["base32pad", "c", b, "abcdefghijklmnopqrstuvwxyz234567="],
        ["base32hex", "v", b, "0123456789abcdefghijklmnopqrstuv"],
        ["base32hexpad", "t", b, "0123456789abcdefghijklmnopqrstuv="],
        ["base32z", "h", b, "ybndrfg8ejkmcpqxot1uwisza345h769"],
        ["base58flickr", "Z", s, "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"],
        ["base58btc", "z", s, "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"],
        ["base64", "m", r, "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"],
        ["base64pad", "M", r, "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/="],
        ["base64url", "u", r, "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"],
        ["base64urlpad", "U", r, "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_="]
      ],
      c = u.reduce((s, a) => (s[a[0]] = new e(a[0], a[1], a[2], a[3]), s), {}),
      d = u.reduce((e, s) => (e[s[1]] = c[s[0]], e), {});
    module.exports = {
      names: c,
      codes: d
    };
  }, {
    "./base.js": "dTsG",
    "base-x": "g2zT",
    "./base16": "TZrm",
    "./base32": "CLvn",
    "./base64": "QMoJ"
  }],
  "tWhI": [function(require, module, exports) {

    "use strict";
    const {
      Buffer: e
    } = require("buffer"), t = require("./constants");
    exports = module.exports = n, exports.encode = o, exports.decode = s, exports.isEncoded = c, exports.names = Object.freeze(Object.keys(t.names)), exports.codes = Object.freeze(Object.keys(t.codes));
    const r = new Error("Unsupported encoding");

    function n(t, r) {
      if (!r) throw new Error("requires an encoded buffer");
      const n = f(t),
        o = e.from(n.code);
      return i(n.name, r), e.concat([o, r])
    }

    function o(t, r) {
      const o = f(t);
      return n(o.name, e.from(o.encode(r)))
    }

    function s(t) {
      e.isBuffer(t) && (t = t.toString());
      const r = t.substring(0, 1);
      "string" == typeof(t = t.substring(1, t.length)) && (t = e.from(t));
      const n = f(r);
      return e.from(n.decode(t.toString()))
    }

    function c(t) {
      if (e.isBuffer(t) && (t = t.toString()), "[object String]" !== Object.prototype.toString.call(t)) return !1;
      const r = t.substring(0, 1);
      try {
        return f(r).name
      } catch (n) {
        return !1
      }
    }

    function i(e, t) {
      f(e).decode(t.toString())
    }

    function f(e) {
      let n;
      if (t.names[e]) n = t.names[e];
      else {
        if (!t.codes[e]) throw r;
        n = t.codes[e]
      }
      if (!n.isImplemented()) throw new Error("Base " + e + " is not implemented yet");
      return n
    }
  }, {
    "buffer": "dskh",
    "./constants": "Y4Wf"
  }],
  "k09N": [function(require, module, exports) {
    module.exports = {
      identity: 0,
      ip4: 4,
      tcp: 6,
      sha1: 17,
      "sha2-256": 18,
      "sha2-512": 19,
      "sha3-512": 20,
      "sha3-384": 21,
      "sha3-256": 22,
      "sha3-224": 23,
      "shake-128": 24,
      "shake-256": 25,
      "keccak-224": 26,
      "keccak-256": 27,
      "keccak-384": 28,
      "keccak-512": 29,
      blake3: 30,
      dccp: 33,
      "murmur3-128": 34,
      "murmur3-32": 35,
      ip6: 41,
      ip6zone: 42,
      path: 47,
      multicodec: 48,
      multihash: 49,
      multiaddr: 50,
      multibase: 51,
      dns: 53,
      dns4: 54,
      dns6: 55,
      dnsaddr: 56,
      protobuf: 80,
      cbor: 81,
      raw: 85,
      "dbl-sha2-256": 86,
      rlp: 96,
      bencode: 99,
      "dag-pb": 112,
      "dag-cbor": 113,
      "libp2p-key": 114,
      "git-raw": 120,
      "torrent-info": 123,
      "torrent-file": 124,
      "leofcoin-block": 129,
      "leofcoin-tx": 130,
      "leofcoin-pr": 131,
      sctp: 132,
      "dag-jose": 133,
      "dag-cose": 134,
      "eth-block": 144,
      "eth-block-list": 145,
      "eth-tx-trie": 146,
      "eth-tx": 147,
      "eth-tx-receipt-trie": 148,
      "eth-tx-receipt": 149,
      "eth-state-trie": 150,
      "eth-account-snapshot": 151,
      "eth-storage-trie": 152,
      "bitcoin-block": 176,
      "bitcoin-tx": 177,
      "bitcoin-witness-commitment": 178,
      "zcash-block": 192,
      "zcash-tx": 193,
      "stellar-block": 208,
      "stellar-tx": 209,
      md4: 212,
      md5: 213,
      bmt: 214,
      "decred-block": 224,
      "decred-tx": 225,
      "ipld-ns": 226,
      "ipfs-ns": 227,
      "swarm-ns": 228,
      "ipns-ns": 229,
      zeronet: 230,
      "secp256k1-pub": 231,
      "bls12_381-g1-pub": 234,
      "bls12_381-g2-pub": 235,
      "x25519-pub": 236,
      "ed25519-pub": 237,
      "dash-block": 240,
      "dash-tx": 241,
      "swarm-manifest": 250,
      "swarm-feed": 251,
      udp: 273,
      "p2p-webrtc-star": 275,
      "p2p-webrtc-direct": 276,
      "p2p-stardust": 277,
      "p2p-circuit": 290,
      "dag-json": 297,
      udt: 301,
      utp: 302,
      unix: 400,
      p2p: 421,
      ipfs: 421,
      https: 443,
      onion: 444,
      onion3: 445,
      garlic64: 446,
      garlic32: 447,
      tls: 448,
      quic: 460,
      ws: 477,
      wss: 478,
      "p2p-websocket-star": 479,
      http: 480,
      json: 512,
      messagepack: 513,
      "libp2p-peer-record": 769,
      "sha2-256-trunc254-padded": 4114,
      "ripemd-128": 4178,
      "ripemd-160": 4179,
      "ripemd-256": 4180,
      "ripemd-320": 4181,
      x11: 4352,
      "sm3-256": 21325,
      "blake2b-8": 45569,
      "blake2b-16": 45570,
      "blake2b-24": 45571,
      "blake2b-32": 45572,
      "blake2b-40": 45573,
      "blake2b-48": 45574,
      "blake2b-56": 45575,
      "blake2b-64": 45576,
      "blake2b-72": 45577,
      "blake2b-80": 45578,
      "blake2b-88": 45579,
      "blake2b-96": 45580,
      "blake2b-104": 45581,
      "blake2b-112": 45582,
      "blake2b-120": 45583,
      "blake2b-128": 45584,
      "blake2b-136": 45585,
      "blake2b-144": 45586,
      "blake2b-152": 45587,
      "blake2b-160": 45588,
      "blake2b-168": 45589,
      "blake2b-176": 45590,
      "blake2b-184": 45591,
      "blake2b-192": 45592,
      "blake2b-200": 45593,
      "blake2b-208": 45594,
      "blake2b-216": 45595,
      "blake2b-224": 45596,
      "blake2b-232": 45597,
      "blake2b-240": 45598,
      "blake2b-248": 45599,
      "blake2b-256": 45600,
      "blake2b-264": 45601,
      "blake2b-272": 45602,
      "blake2b-280": 45603,
      "blake2b-288": 45604,
      "blake2b-296": 45605,
      "blake2b-304": 45606,
      "blake2b-312": 45607,
      "blake2b-320": 45608,
      "blake2b-328": 45609,
      "blake2b-336": 45610,
      "blake2b-344": 45611,
      "blake2b-352": 45612,
      "blake2b-360": 45613,
      "blake2b-368": 45614,
      "blake2b-376": 45615,
      "blake2b-384": 45616,
      "blake2b-392": 45617,
      "blake2b-400": 45618,
      "blake2b-408": 45619,
      "blake2b-416": 45620,
      "blake2b-424": 45621,
      "blake2b-432": 45622,
      "blake2b-440": 45623,
      "blake2b-448": 45624,
      "blake2b-456": 45625,
      "blake2b-464": 45626,
      "blake2b-472": 45627,
      "blake2b-480": 45628,
      "blake2b-488": 45629,
      "blake2b-496": 45630,
      "blake2b-504": 45631,
      "blake2b-512": 45632,
      "blake2s-8": 45633,
      "blake2s-16": 45634,
      "blake2s-24": 45635,
      "blake2s-32": 45636,
      "blake2s-40": 45637,
      "blake2s-48": 45638,
      "blake2s-56": 45639,
      "blake2s-64": 45640,
      "blake2s-72": 45641,
      "blake2s-80": 45642,
      "blake2s-88": 45643,
      "blake2s-96": 45644,
      "blake2s-104": 45645,
      "blake2s-112": 45646,
      "blake2s-120": 45647,
      "blake2s-128": 45648,
      "blake2s-136": 45649,
      "blake2s-144": 45650,
      "blake2s-152": 45651,
      "blake2s-160": 45652,
      "blake2s-168": 45653,
      "blake2s-176": 45654,
      "blake2s-184": 45655,
      "blake2s-192": 45656,
      "blake2s-200": 45657,
      "blake2s-208": 45658,
      "blake2s-216": 45659,
      "blake2s-224": 45660,
      "blake2s-232": 45661,
      "blake2s-240": 45662,
      "blake2s-248": 45663,
      "blake2s-256": 45664,
      "skein256-8": 45825,
      "skein256-16": 45826,
      "skein256-24": 45827,
      "skein256-32": 45828,
      "skein256-40": 45829,
      "skein256-48": 45830,
      "skein256-56": 45831,
      "skein256-64": 45832,
      "skein256-72": 45833,
      "skein256-80": 45834,
      "skein256-88": 45835,
      "skein256-96": 45836,
      "skein256-104": 45837,
      "skein256-112": 45838,
      "skein256-120": 45839,
      "skein256-128": 45840,
      "skein256-136": 45841,
      "skein256-144": 45842,
      "skein256-152": 45843,
      "skein256-160": 45844,
      "skein256-168": 45845,
      "skein256-176": 45846,
      "skein256-184": 45847,
      "skein256-192": 45848,
      "skein256-200": 45849,
      "skein256-208": 45850,
      "skein256-216": 45851,
      "skein256-224": 45852,
      "skein256-232": 45853,
      "skein256-240": 45854,
      "skein256-248": 45855,
      "skein256-256": 45856,
      "skein512-8": 45857,
      "skein512-16": 45858,
      "skein512-24": 45859,
      "skein512-32": 45860,
      "skein512-40": 45861,
      "skein512-48": 45862,
      "skein512-56": 45863,
      "skein512-64": 45864,
      "skein512-72": 45865,
      "skein512-80": 45866,
      "skein512-88": 45867,
      "skein512-96": 45868,
      "skein512-104": 45869,
      "skein512-112": 45870,
      "skein512-120": 45871,
      "skein512-128": 45872,
      "skein512-136": 45873,
      "skein512-144": 45874,
      "skein512-152": 45875,
      "skein512-160": 45876,
      "skein512-168": 45877,
      "skein512-176": 45878,
      "skein512-184": 45879,
      "skein512-192": 45880,
      "skein512-200": 45881,
      "skein512-208": 45882,
      "skein512-216": 45883,
      "skein512-224": 45884,
      "skein512-232": 45885,
      "skein512-240": 45886,
      "skein512-248": 45887,
      "skein512-256": 45888,
      "skein512-264": 45889,
      "skein512-272": 45890,
      "skein512-280": 45891,
      "skein512-288": 45892,
      "skein512-296": 45893,
      "skein512-304": 45894,
      "skein512-312": 45895,
      "skein512-320": 45896,
      "skein512-328": 45897,
      "skein512-336": 45898,
      "skein512-344": 45899,
      "skein512-352": 45900,
      "skein512-360": 45901,
      "skein512-368": 45902,
      "skein512-376": 45903,
      "skein512-384": 45904,
      "skein512-392": 45905,
      "skein512-400": 45906,
      "skein512-408": 45907,
      "skein512-416": 45908,
      "skein512-424": 45909,
      "skein512-432": 45910,
      "skein512-440": 45911,
      "skein512-448": 45912,
      "skein512-456": 45913,
      "skein512-464": 45914,
      "skein512-472": 45915,
      "skein512-480": 45916,
      "skein512-488": 45917,
      "skein512-496": 45918,
      "skein512-504": 45919,
      "skein512-512": 45920,
      "skein1024-8": 45921,
      "skein1024-16": 45922,
      "skein1024-24": 45923,
      "skein1024-32": 45924,
      "skein1024-40": 45925,
      "skein1024-48": 45926,
      "skein1024-56": 45927,
      "skein1024-64": 45928,
      "skein1024-72": 45929,
      "skein1024-80": 45930,
      "skein1024-88": 45931,
      "skein1024-96": 45932,
      "skein1024-104": 45933,
      "skein1024-112": 45934,
      "skein1024-120": 45935,
      "skein1024-128": 45936,
      "skein1024-136": 45937,
      "skein1024-144": 45938,
      "skein1024-152": 45939,
      "skein1024-160": 45940,
      "skein1024-168": 45941,
      "skein1024-176": 45942,
      "skein1024-184": 45943,
      "skein1024-192": 45944,
      "skein1024-200": 45945,
      "skein1024-208": 45946,
      "skein1024-216": 45947,
      "skein1024-224": 45948,
      "skein1024-232": 45949,
      "skein1024-240": 45950,
      "skein1024-248": 45951,
      "skein1024-256": 45952,
      "skein1024-264": 45953,
      "skein1024-272": 45954,
      "skein1024-280": 45955,
      "skein1024-288": 45956,
      "skein1024-296": 45957,
      "skein1024-304": 45958,
      "skein1024-312": 45959,
      "skein1024-320": 45960,
      "skein1024-328": 45961,
      "skein1024-336": 45962,
      "skein1024-344": 45963,
      "skein1024-352": 45964,
      "skein1024-360": 45965,
      "skein1024-368": 45966,
      "skein1024-376": 45967,
      "skein1024-384": 45968,
      "skein1024-392": 45969,
      "skein1024-400": 45970,
      "skein1024-408": 45971,
      "skein1024-416": 45972,
      "skein1024-424": 45973,
      "skein1024-432": 45974,
      "skein1024-440": 45975,
      "skein1024-448": 45976,
      "skein1024-456": 45977,
      "skein1024-464": 45978,
      "skein1024-472": 45979,
      "skein1024-480": 45980,
      "skein1024-488": 45981,
      "skein1024-496": 45982,
      "skein1024-504": 45983,
      "skein1024-512": 45984,
      "skein1024-520": 45985,
      "skein1024-528": 45986,
      "skein1024-536": 45987,
      "skein1024-544": 45988,
      "skein1024-552": 45989,
      "skein1024-560": 45990,
      "skein1024-568": 45991,
      "skein1024-576": 45992,
      "skein1024-584": 45993,
      "skein1024-592": 45994,
      "skein1024-600": 45995,
      "skein1024-608": 45996,
      "skein1024-616": 45997,
      "skein1024-624": 45998,
      "skein1024-632": 45999,
      "skein1024-640": 46e3,
      "skein1024-648": 46001,
      "skein1024-656": 46002,
      "skein1024-664": 46003,
      "skein1024-672": 46004,
      "skein1024-680": 46005,
      "skein1024-688": 46006,
      "skein1024-696": 46007,
      "skein1024-704": 46008,
      "skein1024-712": 46009,
      "skein1024-720": 46010,
      "skein1024-728": 46011,
      "skein1024-736": 46012,
      "skein1024-744": 46013,
      "skein1024-752": 46014,
      "skein1024-760": 46015,
      "skein1024-768": 46016,
      "skein1024-776": 46017,
      "skein1024-784": 46018,
      "skein1024-792": 46019,
      "skein1024-800": 46020,
      "skein1024-808": 46021,
      "skein1024-816": 46022,
      "skein1024-824": 46023,
      "skein1024-832": 46024,
      "skein1024-840": 46025,
      "skein1024-848": 46026,
      "skein1024-856": 46027,
      "skein1024-864": 46028,
      "skein1024-872": 46029,
      "skein1024-880": 46030,
      "skein1024-888": 46031,
      "skein1024-896": 46032,
      "skein1024-904": 46033,
      "skein1024-912": 46034,
      "skein1024-920": 46035,
      "skein1024-928": 46036,
      "skein1024-936": 46037,
      "skein1024-944": 46038,
      "skein1024-952": 46039,
      "skein1024-960": 46040,
      "skein1024-968": 46041,
      "skein1024-976": 46042,
      "skein1024-984": 46043,
      "skein1024-992": 46044,
      "skein1024-1000": 46045,
      "skein1024-1008": 46046,
      "skein1024-1016": 46047,
      "skein1024-1024": 46048,
      "poseidon-bls12_381-a2-fc1": 46081,
      "poseidon-bls12_381-a2-fc1-sc": 46082,
      "zeroxcert-imprint-256": 52753,
      "fil-commitment-unsealed": 61697,
      "fil-commitment-sealed": 61698,
      "holochain-adr-v0": 8417572,
      "holochain-adr-v1": 8483108,
      "holochain-key-v0": 9728292,
      "holochain-key-v1": 9793828,
      "holochain-sig-v0": 10645796,
      "holochain-sig-v1": 10711332
    };
  }, {}],
  "gR0b": [function(require, module, exports) {
    "use strict";
    const e = require("./base-table.json"),
      s = new Map;
    for (const t in e) {
      const o = e[t];
      s.set(o, t)
    }
    module.exports = Object.freeze(s);
  }, {
    "./base-table.json": "k09N"
  }],
  "gqxP": [function(require, module, exports) {

    "use strict";
    const e = require("varint"),
      {
        Buffer: r
      } = require("buffer");

    function n(e) {
      return parseInt(e.toString("hex"), 16)
    }

    function t(e) {
      let n = e.toString(16);
      return n.length % 2 == 1 && (n = "0" + n), r.from(n, "hex")
    }

    function u(t) {
      return r.from(e.encode(n(t)))
    }

    function o(r) {
      return t(e.decode(r))
    }

    function f(n) {
      return r.from(e.encode(n))
    }
    module.exports = {
      numberToBuffer: t,
      bufferToNumber: n,
      varintBufferEncode: u,
      varintBufferDecode: o,
      varintEncode: f
    };
  }, {
    "varint": "tvfU",
    "buffer": "dskh"
  }],
  "cnQH": [function(require, module, exports) {
    "use strict";
    const e = require("./base-table.json"),
      t = require("./util").varintEncode,
      r = {};
    for (const o in e) {
      const s = e[o];
      r[o] = t(s)
    }
    module.exports = Object.freeze(r);
  }, {
    "./base-table.json": "k09N",
    "./util": "gqxP"
  }],
  "Xsaf": [function(require, module, exports) {
    "use strict";
    const e = require("./base-table.json"),
      t = {};
    for (const [r, s] of Object.entries(e)) t[r.toUpperCase().replace(/-/g, "_")] = s;
    module.exports = Object.freeze(t);
  }, {
    "./base-table.json": "k09N"
  }],
  "pOcJ": [function(require, module, exports) {
    "use strict";
    const e = require("./base-table.json"),
      t = {};
    for (const [o, s] of Object.entries(e)) void 0 === t[s] && (t[s] = o);
    module.exports = Object.freeze(t);
  }, {
    "./base-table.json": "k09N"
  }],
  "Ua9r": [function(require, module, exports) {

    "use strict";
    const {
      Buffer: e
    } = require("buffer"), r = require("varint"), t = require("./int-table"), o = require("./varint-table"), n = require("./util");
    exports = module.exports, exports.addPrefix = ((r, t) => {
      let i;
      if (e.isBuffer(r)) i = n.varintBufferEncode(r);
      else {
        if (!o[r]) throw new Error("multicodec not recognized");
        i = o[r]
      }
      return e.concat([i, t])
    }), exports.rmPrefix = (e => (r.decode(e), e.slice(r.decode.bytes))), exports.getCodec = (e => {
      const o = r.decode(e),
        n = t.get(o);
      if (void 0 === n) throw new Error(`Code ${o} not found`);
      return n
    }), exports.getName = (e => t.get(e)), exports.getNumber = (e => {
      const r = o[e];
      if (void 0 === r) throw new Error("Codec `" + e + "` not found");
      return n.varintBufferDecode(r)[0]
    }), exports.getCode = (e => r.decode(e)), exports.getCodeVarint = (e => {
      const r = o[e];
      if (void 0 === r) throw new Error("Codec `" + e + "` not found");
      return r
    }), exports.getVarint = (e => r.encode(e));
    const i = require("./constants");
    Object.assign(exports, i), exports.print = require("./print");
  }, {
    "buffer": "dskh",
    "varint": "tvfU",
    "./int-table": "gR0b",
    "./varint-table": "cnQH",
    "./util": "gqxP",
    "./constants": "Xsaf",
    "./print": "pOcJ"
  }],
  "p99Q": [function(require, module, exports) {

    "use strict";
    const e = require("multihashes"),
      {
        Buffer: r
      } = require("buffer");
    var t = {
      checkCIDComponents: function(t) {
        if (null == t) return "null values are not valid CIDs";
        if (0 !== t.version && 1 !== t.version) return "Invalid version, must be a number equal to 1 or 0";
        if ("string" != typeof t.codec) return "codec must be string";
        if (0 === t.version) {
          if ("dag-pb" !== t.codec) return "codec must be 'dag-pb' for CIDv0";
          if ("base58btc" !== t.multibaseName) return "multibaseName must be 'base58btc' for CIDv0"
        }
        if (!r.isBuffer(t.multihash)) return "multihash must be a Buffer";
        try {
          e.validate(t.multihash)
        } catch (u) {
          let e = u.message;
          return e || (e = "Multihash validation failed"), e
        }
      }
    };
    module.exports = t;
  }, {
    "multihashes": "CaqF",
    "buffer": "dskh"
  }],
  "VOo0": [function(require, module, exports) {
    "use strict";

    function t(t, {
      className: e,
      symbolName: o
    }) {
      const r = Symbol.for(o),
        s = {
          [e]: class extends t {
            constructor(...t) {
              super(...t), Object.defineProperty(this, r, {
                value: !0
              })
            }
            get[Symbol.toStringTag]() {
              return e
            }
          }
        } [e];
      return s[`is${e}`] = (t => !(!t || !t[r])), s
    }

    function e(t, {
      className: e,
      symbolName: o,
      withoutNew: r
    }) {
      const s = Symbol.for(o),
        n = {
          [e]: function(...e) {
            if (r && !(this instanceof n)) return new n(...e);
            const o = t.call(this, ...e) || this;
            return o && !o[s] && Object.defineProperty(o, s, {
              value: !0
            }), o
          }
        } [e];
      return n.prototype = Object.create(t.prototype), n.prototype.constructor = n, Object.defineProperty(n.prototype, Symbol.toStringTag, {
        get: () => e
      }), n[`is${e}`] = (t => !(!t || !t[s])), n
    }
    module.exports = t, module.exports.proto = e;
  }, {}],
  "WF2I": [function(require, module, exports) {

    "use strict";
    const {
      Buffer: t
    } = require("buffer"), e = require("multihashes"), i = require("multibase"), s = require("multicodec"), r = require("multicodec/src/base-table.json"), o = require("./cid-util"), h = require("class-is");
    class n {
      constructor(r, o, h, c) {
        if (a.isCID(r)) {
          const e = r;
          return this.version = e.version, this.codec = e.codec, this.multihash = t.from(e.multihash), void(this.multibaseName = e.multibaseName || (0 === e.version ? "base58btc" : "base32"))
        }
        if ("string" == typeof r) {
          const t = i.isEncoded(r);
          if (t) {
            const e = i.decode(r);
            this.version = parseInt(e.slice(0, 1).toString("hex"), 16), this.codec = s.getCodec(e.slice(1)), this.multihash = s.rmPrefix(e.slice(1)), this.multibaseName = t
          } else this.version = 0, this.codec = "dag-pb", this.multihash = e.fromB58String(r), this.multibaseName = "base58btc";
          return n.validateCID(this), void Object.defineProperty(this, "string", {
            value: r
          })
        }
        if (t.isBuffer(r)) {
          const t = r.slice(0, 1),
            e = parseInt(t.toString("hex"), 16);
          if (1 === e) {
            const t = r;
            this.version = e, this.codec = s.getCodec(t.slice(1)), this.multihash = s.rmPrefix(t.slice(1)), this.multibaseName = "base32"
          } else this.version = 0, this.codec = "dag-pb", this.multihash = r, this.multibaseName = "base58btc";
          n.validateCID(this)
        } else this.version = r, this.codec = o, this.multihash = h, this.multibaseName = c || (0 === r ? "base58btc" : "base32"), n.validateCID(this)
      }
      get buffer() {
        let e = this._buffer;
        if (!e) {
          if (0 === this.version) e = this.multihash;
          else {
            if (1 !== this.version) throw new Error("unsupported version");
            e = t.concat([t.from("01", "hex"), s.getCodeVarint(this.codec), this.multihash])
          }
          Object.defineProperty(this, "_buffer", {
            value: e
          })
        }
        return e
      }
      get prefix() {
        return t.concat([t.from("0".concat(this.version), "hex"), s.getCodeVarint(this.codec), e.prefix(this.multihash)])
      }
      toV0() {
        if ("dag-pb" !== this.codec) throw new Error("Cannot convert a non dag-pb CID to CIDv0");
        const {
          name: t,
          length: i
        } = e.decode(this.multihash);
        if ("sha2-256" !== t) throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");
        if (32 !== i) throw new Error("Cannot convert non 32 byte multihash CID to CIDv0");
        return new a(0, this.codec, this.multihash)
      }
      toV1() {
        return new a(1, this.codec, this.multihash)
      }
      toBaseEncodedString(t = this.multibaseName) {
        if (this.string && t === this.multibaseName) return this.string;
        let s = null;
        if (0 === this.version) {
          if ("base58btc" !== t) throw new Error("not supported with CIDv0, to support different bases, please migrate the instance do CIDv1, you can do that through cid.toV1()");
          s = e.toB58String(this.multihash)
        } else {
          if (1 !== this.version) throw new Error("unsupported version");
          s = i.encode(t, this.buffer).toString()
        }
        return t === this.multibaseName && Object.defineProperty(this, "string", {
          value: s
        }), s
      } [Symbol.for("nodejs.util.inspect.custom")]() {
        return "CID(" + this.toString() + ")"
      }
      toString(t) {
        return this.toBaseEncodedString(t)
      }
      toJSON() {
        return {
          codec: this.codec,
          version: this.version,
          hash: this.multihash
        }
      }
      equals(t) {
        return this.codec === t.codec && this.version === t.version && this.multihash.equals(t.multihash)
      }
      static validateCID(t) {
        const e = o.checkCIDComponents(t);
        if (e) throw new Error(e)
      }
    }
    const a = h(n, {
      className: "CID",
      symbolName: "@ipld/js-cid/CID"
    });
    a.codecs = r, module.exports = a;
  }, {
    "buffer": "dskh",
    "multihashes": "CaqF",
    "multibase": "tWhI",
    "multicodec": "Ua9r",
    "multicodec/src/base-table.json": "k09N",
    "./cid-util": "p99Q",
    "class-is": "VOo0"
  }],
  "jK7G": [function(require, module, exports) {
    var Buffer = require("buffer").Buffer;
    var e = require("buffer").Buffer;
    const t = require("cids"),
      r = require("multihashes"),
      s = e => {
        let t = e.slice(0, 2),
          s = e.slice(2),
          n = "";
        return n = "0x" === t ? s : e, r.fromHexString(n)
      },
      n = {
        swarm: e => {
          const n = r.encode(s(e), "keccak-256");
          return new t(1, "swarm-manifest", n).buffer
        },
        ipfs: e => {
          const s = r.fromB58String(e);
          return new t(1, "dag-pb", s).buffer
        },
        utf8: t => e.from(t, "utf8")
      },
      i = {
        hexMultiHash: e => {
          const s = new t(e);
          return r.decode(s.multihash).digest.toString("hex")
        },
        b58MultiHash: e => {
          const s = new t(e);
          return r.toB58String(s.multihash)
        },
        utf8: e => e.toString("utf8")
      },
      u = {
        "swarm-ns": {
          encode: n.swarm,
          decode: i.hexMultiHash
        },
        "ipfs-ns": {
          encode: n.ipfs,
          decode: i.b58MultiHash
        },
        "ipns-ns": {
          encode: n.ipfs,
          decode: i.b58MultiHash
        },
        default: {
          encode: n.utf8,
          decode: i.utf8
        }
      };
    exports.hexStringToBuffer = s, exports.profiles = u;
  }, {
    "cids": "WF2I",
    "multihashes": "CaqF",
    "buffer": "dskh"
  }],
  "EhjW": [function(require, module, exports) {
    const e = require("cids"),
      r = r => {
        let t = new e(r);
        return 0 === t.version && (t = t.toV1()), t.toString("base32")
      };
    exports.cidV0ToV1Base32 = r;
  }, {
    "cids": "WF2I"
  }],
  "nlkb": [function(require, module, exports) {
    const e = require("multicodec"),
      {
        hexStringToBuffer: r,
        profiles: o
      } = require("./profiles"),
      {
        cidV0ToV1Base32: t
      } = require("./helpers");
    module.exports = {
      helpers: {
        cidV0ToV1Base32: t
      },
      decode: function(t) {
        const n = r(t),
          c = e.getCodec(n),
          i = e.rmPrefix(n);
        let d = o[c];
        return d || (d = o.default), d.decode(i)
      },
      fromIpfs: function(e) {
        return this.encode("ipfs-ns", e)
      },
      fromSwarm: function(e) {
        return this.encode("swarm-ns", e)
      },
      encode: function(r, t) {
        let n = o[r];
        n || (n = o.default);
        const c = n.encode(t);
        return e.addPrefix(r, c).toString("hex")
      },
      getCodec: function(o) {
        let t = r(o);
        return e.getCodec(t)
      }
    };
  }, {
    "multicodec": "Mgln",
    "./profiles": "jK7G",
    "./helpers": "EhjW"
  }],
  "aCcs": [function(require, module, exports) {
    var o = require("content-hash");

    function n(n) {
      var e = null,
        r = null,
        t = null;
      if (n && n.error) return {
        protocolType: null,
        decoded: n.error
      };
      if (n) try {
        e = o.decode(n);
        var i = o.getCodec(n);
        "ipfs-ns" === i ? r = "ipfs" : "swarm-ns" === i ? r = "bzz" : "onion" === i ? r = "onion" : "onion3" === i ? r = "onion3" : e = n
      } catch (c) {
        t = c.message
      }
      return {
        protocolType: r,
        decoded: e,
        error: t
      }
    }

    function e(n) {
      var e, r, t = !1;
      if (n) {
        var i = n.match(/^(ipfs|bzz|onion|onion3):\/\/(.*)/) || n.match(/\/(ipfs)\/(.*)/);
        i && (r = i[1], e = i[2]);
        try {
          if ("ipfs" === r) e.length >= 4 && (t = "0x" + o.fromIpfs(e));
          else if ("bzz" === r) e.length >= 4 && (t = "0x" + o.fromSwarm(e));
          else if ("onion" === r) 16 === e.length && (t = "0x" + o.encode("onion", e));
          else {
            if ("onion3" !== r) throw new Error("Could not encode content hash: unsupported content type");
            56 === e.length && (t = "0x" + o.encode("onion3", e))
          }
        } catch (c) {
          throw c
        }
      }
      return t
    }
    module.exports = {
      decode: n,
      encode: e
    };
  }, {
    "content-hash": "nlkb"
  }],
  "N1MF": [function(require, module, exports) {
    "use strict";

    function e(e, t, r, n, o, s, i) {
      try {
        var u = e[s](i),
          d = u.value
      } catch (c) {
        return void r(c)
      }
      u.done ? t(d) : Promise.resolve(d).then(n, o)
    }

    function t(t) {
      return function() {
        var r = this,
          n = arguments;
        return new Promise(function(o, s) {
          var i = t.apply(r, n);

          function u(t) {
            e(i, o, s, u, d, "next", t)
          }

          function d(t) {
            e(i, o, s, u, d, "throw", t)
          }
          u(void 0)
        })
      }
    }
    var r = require("underscore"),
      n = require("./config"),
      o = require("web3-core-helpers").formatters,
      s = require("web3-utils"),
      i = require("./contracts/Registry"),
      u = require("./lib/ResolverMethodHandler"),
      d = require("./lib/contentHash");

    function c(e) {
      this.eth = e;
      var t = null;
      this._detectedAddress = null, this._lastSyncCheck = null, Object.defineProperty(this, "registry", {
        get: function() {
          return new i(this)
        },
        enumerable: !0
      }), Object.defineProperty(this, "resolverMethodHandler", {
        get: function() {
          return new u(this.registry)
        },
        enumerable: !0
      }), Object.defineProperty(this, "registryAddress", {
        get: function() {
          return t
        },
        set: function(e) {
          t = null !== e ? o.inputAddressFormatter(e) : e
        },
        enumerable: !0
      })
    }
    c.prototype.supportsInterface = function(e, t, n) {
      return this.getResolver(e).then(function(e) {
        return s.isHexStrict(t) || (t = s.sha3(t).slice(0, 10)), e.methods.supportsInterface(t).call(n)
      }).catch(function(e) {
        if (!r.isFunction(n)) throw e;
        n(e, null)
      })
    }, c.prototype.resolver = function(e, t) {
      return this.registry.resolver(e, t)
    }, c.prototype.getResolver = function(e, t) {
      return this.registry.getResolver(e, t)
    }, c.prototype.setResolver = function(e, t, r, n) {
      return this.registry.setResolver(e, t, r, n)
    }, c.prototype.setRecord = function(e, t, r, n, o, s) {
      return this.registry.setRecord(e, t, r, n, o, s)
    }, c.prototype.setSubnodeRecord = function(e, t, r, n, o, s, i) {
      return this.registry.setSubnodeRecord(e, t, r, n, o, s, i)
    }, c.prototype.setApprovalForAll = function(e, t, r, n) {
      return this.registry.setApprovalForAll(e, t, r, n)
    }, c.prototype.isApprovedForAll = function(e, t, r) {
      return this.registry.isApprovedForAll(e, t, r)
    }, c.prototype.recordExists = function(e, t) {
      return this.registry.recordExists(e, t)
    }, c.prototype.setSubnodeOwner = function(e, t, r, n, o) {
      return this.registry.setSubnodeOwner(e, t, r, n, o)
    }, c.prototype.getTTL = function(e, t) {
      return this.registry.getTTL(e, t)
    }, c.prototype.setTTL = function(e, t, r, n) {
      return this.registry.setTTL(e, t, r, n)
    }, c.prototype.getOwner = function(e, t) {
      return this.registry.getOwner(e, t)
    }, c.prototype.setOwner = function(e, t, r, n) {
      return this.registry.setOwner(e, t, r, n)
    }, c.prototype.getAddress = function(e, t) {
      return this.resolverMethodHandler.method(e, "addr", []).call(t)
    }, c.prototype.setAddress = function(e, t, r, n) {
      return this.resolverMethodHandler.method(e, "setAddr", [t]).send(r, n)
    }, c.prototype.getPubkey = function(e, t) {
      return this.resolverMethodHandler.method(e, "pubkey", [], null, t).call(t)
    }, c.prototype.setPubkey = function(e, t, r, n, o) {
      return this.resolverMethodHandler.method(e, "setPubkey", [t, r]).send(n, o)
    }, c.prototype.getContent = function(e, t) {
      return this.resolverMethodHandler.method(e, "content", []).call(t)
    }, c.prototype.setContent = function(e, t, r, n) {
      return this.resolverMethodHandler.method(e, "setContent", [t]).send(r, n)
    }, c.prototype.getContenthash = function(e, t) {
      return this.resolverMethodHandler.method(e, "contenthash", [], d.decode).call(t)
    }, c.prototype.setContenthash = function(e, t, n, o) {
      var s;
      try {
        s = d.encode(t)
      } catch (u) {
        var i = new Error("Could not encode " + t + ". See docs for supported hash protocols.");
        if (r.isFunction(o)) return void o(i, null);
        throw i
      }
      return this.resolverMethodHandler.method(e, "setContenthash", [s]).send(n, o)
    }, c.prototype.getMultihash = function(e, t) {
      return this.resolverMethodHandler.method(e, "multihash", []).call(t)
    }, c.prototype.setMultihash = function(e, t, r, n) {
      return this.resolverMethodHandler.method(e, "multihash", [t]).send(r, n)
    }, c.prototype.checkNetwork = t(regeneratorRuntime.mark(function e() {
      var t, r, o, s, i;
      return regeneratorRuntime.wrap(function(e) {
        for (;;) switch (e.prev = e.next) {
          case 0:
            if (t = new Date / 1e3, this._lastSyncCheck && !(t - this._lastSyncCheck > 3600)) {
              e.next = 9;
              break
            }
            return e.next = 4, this.eth.getBlock("latest");
          case 4:
            if (r = e.sent, !((o = t - r.timestamp) > 3600)) {
              e.next = 8;
              break
            }
            throw new Error("Network not synced; last block was " + o + " seconds ago");
          case 8:
            this._lastSyncCheck = t;
          case 9:
            if (!this.registryAddress) {
              e.next = 11;
              break
            }
            return e.abrupt("return", this.registryAddress);
          case 11:
            if (this._detectedAddress) {
              e.next = 20;
              break
            }
            return e.next = 14, this.eth.net.getNetworkType();
          case 14:
            if (s = e.sent, void 0 !== (i = n.addresses[s])) {
              e.next = 18;
              break
            }
            throw new Error("ENS is not supported on network " + s);
          case 18:
            return this._detectedAddress = i, e.abrupt("return", this._detectedAddress);
          case 20:
            return e.abrupt("return", this._detectedAddress);
          case 21:
          case "end":
            return e.stop()
        }
      }, e, this)
    })), module.exports = c;
  }, {
    "underscore": "h15N",
    "./config": "jgOf",
    "web3-core-helpers": "EoeS",
    "web3-utils": "uckD",
    "./contracts/Registry": "n4kR",
    "./lib/ResolverMethodHandler": "njCu",
    "./lib/contentHash": "aCcs"
  }],
  "dtHq": [function(require, module, exports) {
    "use strict";
    var e = require("./ENS");
    module.exports = e;
  }, {
    "./ENS": "N1MF"
  }],
  "TVxr": [function(require, module, exports) {
    "use strict";
    var e = require("web3-core"),
      t = require("web3-core-method"),
      n = require("web3-utils"),
      r = require("web3-net"),
      a = require("web3-core-helpers").formatters,
      o = function() {
        var o = this;
        e.packageInit(this, arguments), this.net = new r(this);
        var u = null,
          c = "latest";
        Object.defineProperty(this, "defaultAccount", {
          get: function() {
            return u
          },
          set: function(e) {
            return e && (u = n.toChecksumAddress(a.inputAddressFormatter(e))), s.forEach(function(e) {
              e.defaultAccount = u
            }), e
          },
          enumerable: !0
        }), Object.defineProperty(this, "defaultBlock", {
          get: function() {
            return c
          },
          set: function(e) {
            return c = e, s.forEach(function(e) {
              e.defaultBlock = c
            }), e
          },
          enumerable: !0
        });
        var s = [new t({
          name: "getAccounts",
          call: "personal_listAccounts",
          params: 0,
          outputFormatter: n.toChecksumAddress
        }), new t({
          name: "newAccount",
          call: "personal_newAccount",
          params: 1,
          inputFormatter: [null],
          outputFormatter: n.toChecksumAddress
        }), new t({
          name: "unlockAccount",
          call: "personal_unlockAccount",
          params: 3,
          inputFormatter: [a.inputAddressFormatter, null, null]
        }), new t({
          name: "lockAccount",
          call: "personal_lockAccount",
          params: 1,
          inputFormatter: [a.inputAddressFormatter]
        }), new t({
          name: "importRawKey",
          call: "personal_importRawKey",
          params: 2
        }), new t({
          name: "sendTransaction",
          call: "personal_sendTransaction",
          params: 2,
          inputFormatter: [a.inputTransactionFormatter, null]
        }), new t({
          name: "signTransaction",
          call: "personal_signTransaction",
          params: 2,
          inputFormatter: [a.inputTransactionFormatter, null]
        }), new t({
          name: "sign",
          call: "personal_sign",
          params: 3,
          inputFormatter: [a.inputSignFormatter, a.inputAddressFormatter, null]
        }), new t({
          name: "ecRecover",
          call: "personal_ecRecover",
          params: 2,
          inputFormatter: [a.inputSignFormatter, null]
        })];
        s.forEach(function(e) {
          e.attachToObject(o), e.setRequestManager(o._requestManager), e.defaultBlock = o.defaultBlock, e.defaultAccount = o.defaultAccount
        })
      };
    e.addProviders(o), module.exports = o;
  }, {
    "web3-core": "KUai",
    "web3-core-method": "pw7F",
    "web3-utils": "uckD",
    "web3-net": "SwGM",
    "web3-core-helpers": "EoeS"
  }],
  "a3Xt": [function(require, module, exports) {
    const e = (e, t) => {
        let r = [];
        for (var l = 0; l < e; ++l) r.push(t(l));
        return r
      },
      t = (t, r) => e(t, () => r),
      r = (e, t) => e.concat(t),
      l = e => {
        let t = [];
        for (let r = 0, l = e.length; r < l; ++r)
          for (let n = 0, o = e[r].length; n < o; ++n) t.push(e[r][n]);
        return t
      },
      n = (e, t) => {
        let r = [];
        for (let l = 0, n = t.length; l < n; l += e) r.push(t.slice(l, l + e));
        return r
      };
    module.exports = {
      generate: e,
      replicate: t,
      concat: r,
      flatten: l,
      chunksOf: n
    };
  }, {}],
  "k4zK": [function(require, module, exports) {
    const e = require("./array.js"),
      r = (e, r) => parseInt(e.slice(2 * r + 2, 2 * r + 4), 16),
      t = e => {
        let r;
        if ("undefined" != typeof window && window.crypto && window.crypto.getRandomValues) r = window.crypto.getRandomValues(new Uint8Array(e));
        else {
          if ("undefined" == typeof require) throw "Safe random numbers not available.";
          r = require("crypto").randomBytes(e)
        }
        let t = "0x";
        for (let n = 0; n < e; ++n) t += ("00" + r[n].toString(16)).slice(-2);
        return t
      },
      n = e => (e.length - 2) / 2,
      l = e => "0x" + e.reduce((e, r) => e + r.slice(2), ""),
      i = (e, r, t) => "0x" + t.slice(2 * e + 2, 2 * r + 2),
      o = e => {
        let r = "0x";
        for (let t = 0, l = n(e); t < l; ++t) r += e.slice(2 * (l - t), 2 * (l - t + 1));
        return r
      },
      f = (e, r) => r.length === 2 * e + 2 ? r : f(e, "0x0" + r.slice(2)),
      s = (e, r) => r.length === 2 * e + 2 ? r : s(e, r + "0"),
      a = e => {
        let r = [];
        for (let t = 2, n = e.length; t < n; t += 2) r.push(parseInt(e.slice(t, t + 2), 16));
        return r
      },
      u = e => {
        let r = "0x";
        for (let t = 0, n = e.length; t < n; ++t) {
          let n = e[t];
          r += (n < 16 ? "0" : "") + n.toString(16)
        }
        return r
      },
      c = e => new Uint8Array(a(e)),
      g = e => u([].slice.call(e, 0)),
      d = e => {
        let r = e.toString(16);
        return r.length % 2 == 0 ? "0x" + r : "0x0" + r
      },
      h = e => parseInt(e.slice(2), 16),
      m = (e, r) => e.concat(r.slice(2)),
      x = e => "0x0" === e ? "0x" : e.length % 2 == 0 ? e : "0x0" + e.slice(2),
      p = e => "0" === e[2] ? "0x" + e.slice(3) : e,
      y = e => {
        let r = "0x";
        for (let t = 0; t < e.length; ++t) r += ("00" + e.charCodeAt(t).toString(16)).slice(-2);
        return r
      },
      S = e => {
        let r = "";
        for (let t = 2; t < e.length; t += 2) r += String.fromCharCode(parseInt(e.slice(t, t + 2), 16));
        return r
      },
      w = e => {
        const r = e => {
          const r = e.toString(16);
          return r.length < 2 ? "0" + r : r
        };
        let t = "0x";
        for (let n = 0; n != e.length; n++) {
          let l = e.charCodeAt(n);
          if (l < 128) t += r(l);
          else {
            if (l < 2048) t += r(l >> 6 | 192);
            else {
              if (l > 55295 && l < 56320) {
                if (++n == e.length) return null;
                let i = e.charCodeAt(n);
                if (i < 56320 || i > 57343) return null;
                t += r((l = 65536 + ((1023 & l) << 10) + (1023 & i)) >> 18 | 240), t += r(l >> 12 & 63 | 128)
              } else t += r(l >> 12 | 224);
              t += r(l >> 6 & 63 | 128)
            }
            t += r(63 & l | 128)
          }
        }
        return t
      },
      A = e => {
        let t = "",
          l = 0,
          i = n(e);
        for (; l < i;) {
          let n = r(e, l++);
          if (n > 127) {
            if (n > 191 && n < 224) {
              if (l >= i) return null;
              n = (31 & n) << 6 | 63 & r(e, l)
            } else if (n > 223 && n < 240) {
              if (l + 1 >= i) return null;
              n = (15 & n) << 12 | (63 & r(e, l)) << 6 | 63 & r(e, ++l)
            } else {
              if (!(n > 239 && n < 248)) return null;
              if (l + 2 >= i) return null;
              n = (7 & n) << 18 | (63 & r(e, l)) << 12 | (63 & r(e, ++l)) << 6 | 63 & r(e, ++l)
            }++l
          }
          if (n <= 65535) t += String.fromCharCode(n);
          else {
            if (!(n <= 1114111)) return null;
            n -= 65536, t += String.fromCharCode(n >> 10 | 55296), t += String.fromCharCode(1023 & n | 56320)
          }
        }
        return t
      };
    module.exports = {
      random: t,
      length: n,
      concat: m,
      flatten: l,
      slice: i,
      reverse: o,
      pad: f,
      padRight: s,
      fromAscii: y,
      toAscii: S,
      fromString: w,
      toString: A,
      fromNumber: d,
      toNumber: h,
      fromNat: x,
      toNat: p,
      fromArray: u,
      toArray: a,
      fromUint8Array: g,
      toUint8Array: c
    };
  }, {
    "./array.js": "a3Xt"
  }],
  "wlQN": [function(require, module, exports) {
    const t = require("bn.js"),
      e = require("./bytes"),
      r = t => "0x" + t.toString("hex"),
      o = e => new t(e.slice(2), 16),
      n = e => {
        const r = "0x" + ("0x" === e.slice(0, 2) ? new t(e.slice(2), 16) : new t(e, 10)).toString("hex");
        return "0x0" === r ? "0x" : r
      },
      i = t => m(h(t, n("10000000000"))) / 1e8,
      s = t => l(u(Math.floor(1e8 * t)), n("10000000000")),
      x = t => o(t).toString(10),
      u = e => "string" == typeof e ? /^0x/.test(e) ? e : "0x" + e : "0x" + new t(e).toString("hex"),
      m = t => o(t).toNumber(),
      d = t => e.pad(32, t),
      b = t => (e, n) => r(o(e)[t](o(n))),
      g = b("add"),
      l = b("mul"),
      h = b("div"),
      S = b("sub");
    module.exports = {
      toString: x,
      fromString: n,
      toNumber: m,
      fromNumber: u,
      toEther: i,
      fromEther: s,
      toUint256: d,
      add: g,
      mul: l,
      div: h,
      sub: S
    };
  }, {
    "bn.js": "AGD1",
    "./bytes": "k4zK"
  }],
  "bNi7": [function(require, module, exports) {
    module.exports = {
      _args: [
        ["elliptic@6.5.4", "C:\\Users\\jesh\\Desktop\\o1t site\\new site"]
      ],
      _from: "elliptic@6.5.4",
      _id: "elliptic@6.5.4",
      _inBundle: !1,
      _integrity: "sha512-iLhC6ULemrljPZb+QutR5TQGB+pdW6KGD5RSegS+8sorOZT+rdQFbsQFJgvN3eRqNALqJer4oQ16YvJHlU8hzQ==",
      _location: "/elliptic",
      _phantomChildren: {},
      _requested: {
        type: "version",
        registry: !0,
        raw: "elliptic@6.5.4",
        name: "elliptic",
        escapedName: "elliptic",
        rawSpec: "6.5.4",
        saveSpec: null,
        fetchSpec: "6.5.4"
      },
      _requiredBy: ["/@ethersproject/signing-key", "/browserify-sign", "/create-ecdh", "/eth-lib", "/ethereumjs-util", "/secp256k1", "/web3-eth-accounts/eth-lib", "/web3-utils/eth-lib"],
      _resolved: "https://registry.npmjs.org/elliptic/-/elliptic-6.5.4.tgz",
      _spec: "6.5.4",
      _where: "C:\\Users\\jesh\\Desktop\\o1t site\\new site",
      author: {
        name: "Fedor Indutny",
        email: "fedor@indutny.com"
      },
      bugs: {
        url: "https://github.com/indutny/elliptic/issues"
      },
      dependencies: {
        "bn.js": "^4.11.9",
        brorand: "^1.1.0",
        "hash.js": "^1.0.0",
        "hmac-drbg": "^1.0.1",
        inherits: "^2.0.4",
        "minimalistic-assert": "^1.0.1",
        "minimalistic-crypto-utils": "^1.0.1"
      },
      description: "EC cryptography",
      devDependencies: {
        brfs: "^2.0.2",
        coveralls: "^3.1.0",
        eslint: "^7.6.0",
        grunt: "^1.2.1",
        "grunt-browserify": "^5.3.0",
        "grunt-cli": "^1.3.2",
        "grunt-contrib-connect": "^3.0.0",
        "grunt-contrib-copy": "^1.0.0",
        "grunt-contrib-uglify": "^5.0.0",
        "grunt-mocha-istanbul": "^5.0.2",
        "grunt-saucelabs": "^9.0.1",
        istanbul: "^0.4.5",
        mocha: "^8.0.1"
      },
      files: ["lib"],
      homepage: "https://github.com/indutny/elliptic",
      keywords: ["EC", "Elliptic", "curve", "Cryptography"],
      license: "MIT",
      main: "lib/elliptic.js",
      name: "elliptic",
      repository: {
        type: "git",
        url: "git+ssh://git@github.com/indutny/elliptic.git"
      },
      scripts: {
        lint: "eslint lib test",
        "lint:fix": "npm run lint -- --fix",
        test: "npm run lint && npm run unit",
        unit: "istanbul test _mocha --reporter=spec test/index.js",
        version: "grunt dist && git add dist/"
      },
      version: "6.5.4"
    };
  }, {}],
  "vl2S": [function(require, module, exports) {
    "use strict";
    var r = exports;

    function e(r, e) {
      if (Array.isArray(r)) return r.slice();
      if (!r) return [];
      var t = [];
      if ("string" != typeof r) {
        for (var n = 0; n < r.length; n++) t[n] = 0 | r[n];
        return t
      }
      if ("hex" === e) {
        (r = r.replace(/[^a-z0-9]+/gi, "")).length % 2 != 0 && (r = "0" + r);
        for (n = 0; n < r.length; n += 2) t.push(parseInt(r[n] + r[n + 1], 16))
      } else
        for (n = 0; n < r.length; n++) {
          var o = r.charCodeAt(n),
            u = o >> 8,
            i = 255 & o;
          u ? t.push(u, i) : t.push(i)
        }
      return t
    }

    function t(r) {
      return 1 === r.length ? "0" + r : r
    }

    function n(r) {
      for (var e = "", n = 0; n < r.length; n++) e += t(r[n].toString(16));
      return e
    }
    r.toArray = e, r.zero2 = t, r.toHex = n, r.encode = function(r, e) {
      return "hex" === e ? n(r) : r
    };
  }, {}],
  "F8Ez": [function(require, module, exports) {
    "use strict";
    var r = exports,
      n = require("bn.js"),
      t = require("minimalistic-assert"),
      e = require("minimalistic-crypto-utils");

    function i(r, n, t) {
      var e = new Array(Math.max(r.bitLength(), t) + 1);
      e.fill(0);
      for (var i = 1 << n + 1, o = r.clone(), a = 0; a < e.length; a++) {
        var s, u = o.andln(i - 1);
        o.isOdd() ? (s = u > (i >> 1) - 1 ? (i >> 1) - u : u, o.isubn(s)) : s = 0, e[a] = s, o.iushrn(1)
      }
      return e
    }

    function o(r, n) {
      var t = [
        [],
        []
      ];
      r = r.clone(), n = n.clone();
      for (var e, i = 0, o = 0; r.cmpn(-i) > 0 || n.cmpn(-o) > 0;) {
        var a, s, u = r.andln(3) + i & 3,
          c = n.andln(3) + o & 3;
        3 === u && (u = -1), 3 === c && (c = -1), a = 0 == (1 & u) ? 0 : 3 !== (e = r.andln(7) + i & 7) && 5 !== e || 2 !== c ? u : -u, t[0].push(a), s = 0 == (1 & c) ? 0 : 3 !== (e = n.andln(7) + o & 7) && 5 !== e || 2 !== u ? c : -c, t[1].push(s), 2 * i === a + 1 && (i = 1 - i), 2 * o === s + 1 && (o = 1 - o), r.iushrn(1), n.iushrn(1)
      }
      return t
    }

    function a(r, n, t) {
      var e = "_" + n;
      r.prototype[n] = function() {
        return void 0 !== this[e] ? this[e] : this[e] = t.call(this)
      }
    }

    function s(n) {
      return "string" == typeof n ? r.toArray(n, "hex") : n
    }

    function u(r) {
      return new n(r, "hex", "le")
    }
    r.assert = t, r.toArray = e.toArray, r.zero2 = e.zero2, r.toHex = e.toHex, r.encode = e.encode, r.getNAF = i, r.getJSF = o, r.cachedProperty = a, r.parseBytes = s, r.intFromLE = u;
  }, {
    "bn.js": "AGD1",
    "minimalistic-assert": "MpuC",
    "minimalistic-crypto-utils": "vl2S"
  }],
  "e03B": [function(require, module, exports) {
    var t;

    function e(t) {
      this.rand = t
    }
    if (module.exports = function(r) {
        return t || (t = new e(null)), t.generate(r)
      }, module.exports.Rand = e, e.prototype.generate = function(t) {
        return this._rand(t)
      }, e.prototype._rand = function(t) {
        if (this.rand.getBytes) return this.rand.getBytes(t);
        for (var e = new Uint8Array(t), r = 0; r < e.length; r++) e[r] = this.rand.getByte();
        return e
      }, "object" == typeof self) self.crypto && self.crypto.getRandomValues ? e.prototype._rand = function(t) {
      var e = new Uint8Array(t);
      return self.crypto.getRandomValues(e), e
    } : self.msCrypto && self.msCrypto.getRandomValues ? e.prototype._rand = function(t) {
      var e = new Uint8Array(t);
      return self.msCrypto.getRandomValues(e), e
    } : "object" == typeof window && (e.prototype._rand = function() {
      throw new Error("Not implemented yet")
    });
    else try {
      var r = require("crypto");
      if ("function" != typeof r.randomBytes) throw new Error("Not supported");
      e.prototype._rand = function(t) {
        return r.randomBytes(t)
      }
    } catch (n) {}
  }, {
    "crypto": "rDCW"
  }],
  "NX8i": [function(require, module, exports) {
    "use strict";
    var t = require("bn.js"),
      e = require("../utils"),
      n = e.getNAF,
      r = e.getJSF,
      i = e.assert;

    function o(e, n) {
      this.type = e, this.p = new t(n.p, 16), this.red = n.prime ? t.red(n.prime) : t.mont(this.p), this.zero = new t(0).toRed(this.red), this.one = new t(1).toRed(this.red), this.two = new t(2).toRed(this.red), this.n = n.n && new t(n.n, 16), this.g = n.g && this.pointFromJSON(n.g, n.gRed), this._wnafT1 = new Array(4), this._wnafT2 = new Array(4), this._wnafT3 = new Array(4), this._wnafT4 = new Array(4), this._bitLength = this.n ? this.n.bitLength() : 0;
      var r = this.n && this.p.div(this.n);
      !r || r.cmpn(100) > 0 ? this.redN = null : (this._maxwellTrick = !0, this.redN = this.n.toRed(this.red))
    }

    function s(t, e) {
      this.curve = t, this.type = e, this.precomputed = null
    }
    module.exports = o, o.prototype.point = function() {
      throw new Error("Not implemented")
    }, o.prototype.validate = function() {
      throw new Error("Not implemented")
    }, o.prototype._fixedNafMul = function(t, e) {
      i(t.precomputed);
      var r = t._getDoubles(),
        o = n(e, 1, this._bitLength),
        s = (1 << r.step + 1) - (r.step % 2 == 0 ? 2 : 1);
      s /= 3;
      var p, h, d = [];
      for (p = 0; p < o.length; p += r.step) {
        h = 0;
        for (var u = p + r.step - 1; u >= p; u--) h = (h << 1) + o[u];
        d.push(h)
      }
      for (var a = this.jpoint(null, null, null), l = this.jpoint(null, null, null), f = s; f > 0; f--) {
        for (p = 0; p < d.length; p++)(h = d[p]) === f ? l = l.mixedAdd(r.points[p]) : h === -f && (l = l.mixedAdd(r.points[p].neg()));
        a = a.add(l)
      }
      return a.toP()
    }, o.prototype._wnafMul = function(t, e) {
      var r = 4,
        o = t._getNAFPoints(r);
      r = o.wnd;
      for (var s = o.points, p = n(e, r, this._bitLength), h = this.jpoint(null, null, null), d = p.length - 1; d >= 0; d--) {
        for (var u = 0; d >= 0 && 0 === p[d]; d--) u++;
        if (d >= 0 && u++, h = h.dblp(u), d < 0) break;
        var a = p[d];
        i(0 !== a), h = "affine" === t.type ? a > 0 ? h.mixedAdd(s[a - 1 >> 1]) : h.mixedAdd(s[-a - 1 >> 1].neg()) : a > 0 ? h.add(s[a - 1 >> 1]) : h.add(s[-a - 1 >> 1].neg())
      }
      return "affine" === t.type ? h.toP() : h
    }, o.prototype._wnafMulAdd = function(t, e, i, o, s) {
      var p, h, d, u = this._wnafT1,
        a = this._wnafT2,
        l = this._wnafT3,
        f = 0;
      for (p = 0; p < o; p++) {
        var c = (d = e[p])._getNAFPoints(t);
        u[p] = c.wnd, a[p] = c.points
      }
      for (p = o - 1; p >= 1; p -= 2) {
        var g = p - 1,
          m = p;
        if (1 === u[g] && 1 === u[m]) {
          var y = [e[g], null, null, e[m]];
          0 === e[g].y.cmp(e[m].y) ? (y[1] = e[g].add(e[m]), y[2] = e[g].toJ().mixedAdd(e[m].neg())) : 0 === e[g].y.cmp(e[m].y.redNeg()) ? (y[1] = e[g].toJ().mixedAdd(e[m]), y[2] = e[g].add(e[m].neg())) : (y[1] = e[g].toJ().mixedAdd(e[m]), y[2] = e[g].toJ().mixedAdd(e[m].neg()));
          var v = [-3, -1, -5, -7, 0, 7, 5, 1, 3],
            w = r(i[g], i[m]);
          for (f = Math.max(w[0].length, f), l[g] = new Array(f), l[m] = new Array(f), h = 0; h < f; h++) {
            var b = 0 | w[0][h],
              _ = 0 | w[1][h];
            l[g][h] = v[3 * (b + 1) + (_ + 1)], l[m][h] = 0, a[g] = y
          }
        } else l[g] = n(i[g], u[g], this._bitLength), l[m] = n(i[m], u[m], this._bitLength), f = Math.max(l[g].length, f), f = Math.max(l[m].length, f)
      }
      var A = this.jpoint(null, null, null),
        x = this._wnafT4;
      for (p = f; p >= 0; p--) {
        for (var N = 0; p >= 0;) {
          var L = !0;
          for (h = 0; h < o; h++) x[h] = 0 | l[h][p], 0 !== x[h] && (L = !1);
          if (!L) break;
          N++, p--
        }
        if (p >= 0 && N++, A = A.dblp(N), p < 0) break;
        for (h = 0; h < o; h++) {
          var P = x[h];
          0 !== P && (P > 0 ? d = a[h][P - 1 >> 1] : P < 0 && (d = a[h][-P - 1 >> 1].neg()), A = "affine" === d.type ? A.mixedAdd(d) : A.add(d))
        }
      }
      for (p = 0; p < o; p++) a[p] = null;
      return s ? A : A.toP()
    }, o.BasePoint = s, s.prototype.eq = function() {
      throw new Error("Not implemented")
    }, s.prototype.validate = function() {
      return this.curve.validate(this)
    }, o.prototype.decodePoint = function(t, n) {
      t = e.toArray(t, n);
      var r = this.p.byteLength();
      if ((4 === t[0] || 6 === t[0] || 7 === t[0]) && t.length - 1 == 2 * r) return 6 === t[0] ? i(t[t.length - 1] % 2 == 0) : 7 === t[0] && i(t[t.length - 1] % 2 == 1), this.point(t.slice(1, 1 + r), t.slice(1 + r, 1 + 2 * r));
      if ((2 === t[0] || 3 === t[0]) && t.length - 1 === r) return this.pointFromX(t.slice(1, 1 + r), 3 === t[0]);
      throw new Error("Unknown point format")
    }, s.prototype.encodeCompressed = function(t) {
      return this.encode(t, !0)
    }, s.prototype._encode = function(t) {
      var e = this.curve.p.byteLength(),
        n = this.getX().toArray("be", e);
      return t ? [this.getY().isEven() ? 2 : 3].concat(n) : [4].concat(n, this.getY().toArray("be", e))
    }, s.prototype.encode = function(t, n) {
      return e.encode(this._encode(n), t)
    }, s.prototype.precompute = function(t) {
      if (this.precomputed) return this;
      var e = {
        doubles: null,
        naf: null,
        beta: null
      };
      return e.naf = this._getNAFPoints(8), e.doubles = this._getDoubles(4, t), e.beta = this._getBeta(), this.precomputed = e, this
    }, s.prototype._hasDoubles = function(t) {
      if (!this.precomputed) return !1;
      var e = this.precomputed.doubles;
      return !!e && e.points.length >= Math.ceil((t.bitLength() + 1) / e.step)
    }, s.prototype._getDoubles = function(t, e) {
      if (this.precomputed && this.precomputed.doubles) return this.precomputed.doubles;
      for (var n = [this], r = this, i = 0; i < e; i += t) {
        for (var o = 0; o < t; o++) r = r.dbl();
        n.push(r)
      }
      return {
        step: t,
        points: n
      }
    }, s.prototype._getNAFPoints = function(t) {
      if (this.precomputed && this.precomputed.naf) return this.precomputed.naf;
      for (var e = [this], n = (1 << t) - 1, r = 1 === n ? null : this.dbl(), i = 1; i < n; i++) e[i] = e[i - 1].add(r);
      return {
        wnd: t,
        points: e
      }
    }, s.prototype._getBeta = function() {
      return null
    }, s.prototype.dblp = function(t) {
      for (var e = this, n = 0; n < t; n++) e = e.dbl();
      return e
    };
  }, {
    "bn.js": "AGD1",
    "../utils": "F8Ez"
  }],
  "CO0D": [function(require, module, exports) {
    "use strict";
    var r = require("../utils"),
      e = require("bn.js"),
      t = require("inherits"),
      d = require("./base"),
      i = r.assert;

    function n(r) {
      d.call(this, "short", r), this.a = new e(r.a, 16).toRed(this.red), this.b = new e(r.b, 16).toRed(this.red), this.tinv = this.two.redInvm(), this.zeroA = 0 === this.a.fromRed().cmpn(0), this.threeA = 0 === this.a.fromRed().sub(this.p).cmpn(-3), this.endo = this._getEndomorphism(r), this._endoWnafT1 = new Array(4), this._endoWnafT2 = new Array(4)
    }

    function u(r, t, i, n) {
      d.BasePoint.call(this, r, "affine"), null === t && null === i ? (this.x = null, this.y = null, this.inf = !0) : (this.x = new e(t, 16), this.y = new e(i, 16), n && (this.x.forceRed(this.curve.red), this.y.forceRed(this.curve.red)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.inf = !1)
    }

    function s(r, t, i, n) {
      d.BasePoint.call(this, r, "jacobian"), null === t && null === i && null === n ? (this.x = this.curve.one, this.y = this.curve.one, this.z = new e(0)) : (this.x = new e(t, 16), this.y = new e(i, 16), this.z = new e(n, 16)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)), this.zOne = this.z === this.curve.one
    }
    t(n, d), module.exports = n, n.prototype._getEndomorphism = function(r) {
      if (this.zeroA && this.g && this.n && 1 === this.p.modn(3)) {
        var t, d;
        if (r.beta) t = new e(r.beta, 16).toRed(this.red);
        else {
          var n = this._getEndoRoots(this.p);
          t = (t = n[0].cmp(n[1]) < 0 ? n[0] : n[1]).toRed(this.red)
        }
        if (r.lambda) d = new e(r.lambda, 16);
        else {
          var u = this._getEndoRoots(this.n);
          0 === this.g.mul(u[0]).x.cmp(this.g.x.redMul(t)) ? d = u[0] : (d = u[1], i(0 === this.g.mul(d).x.cmp(this.g.x.redMul(t))))
        }
        return {
          beta: t,
          lambda: d,
          basis: r.basis ? r.basis.map(function(r) {
            return {
              a: new e(r.a, 16),
              b: new e(r.b, 16)
            }
          }) : this._getEndoBasis(d)
        }
      }
    }, n.prototype._getEndoRoots = function(r) {
      var t = r === this.p ? this.red : e.mont(r),
        d = new e(2).toRed(t).redInvm(),
        i = d.redNeg(),
        n = new e(3).toRed(t).redNeg().redSqrt().redMul(d);
      return [i.redAdd(n).fromRed(), i.redSub(n).fromRed()]
    }, n.prototype._getEndoBasis = function(r) {
      for (var t, d, i, n, u, s, o, h, p, l = this.n.ushrn(Math.floor(this.n.bitLength() / 2)), a = r, f = this.n.clone(), c = new e(1), S = new e(0), b = new e(0), v = new e(1), I = 0; 0 !== a.cmpn(0);) {
        var y = f.div(a);
        h = f.sub(y.mul(a)), p = b.sub(y.mul(c));
        var A = v.sub(y.mul(S));
        if (!i && h.cmp(l) < 0) t = o.neg(), d = c, i = h.neg(), n = p;
        else if (i && 2 == ++I) break;
        o = h, f = a, a = h, b = c, c = p, v = S, S = A
      }
      u = h.neg(), s = p;
      var m = i.sqr().add(n.sqr());
      return u.sqr().add(s.sqr()).cmp(m) >= 0 && (u = t, s = d), i.negative && (i = i.neg(), n = n.neg()), u.negative && (u = u.neg(), s = s.neg()), [{
        a: i,
        b: n
      }, {
        a: u,
        b: s
      }]
    }, n.prototype._endoSplit = function(r) {
      var e = this.endo.basis,
        t = e[0],
        d = e[1],
        i = d.b.mul(r).divRound(this.n),
        n = t.b.neg().mul(r).divRound(this.n),
        u = i.mul(t.a),
        s = n.mul(d.a),
        o = i.mul(t.b),
        h = n.mul(d.b);
      return {
        k1: r.sub(u).sub(s),
        k2: o.add(h).neg()
      }
    }, n.prototype.pointFromX = function(r, t) {
      (r = new e(r, 16)).red || (r = r.toRed(this.red));
      var d = r.redSqr().redMul(r).redIAdd(r.redMul(this.a)).redIAdd(this.b),
        i = d.redSqrt();
      if (0 !== i.redSqr().redSub(d).cmp(this.zero)) throw new Error("invalid point");
      var n = i.fromRed().isOdd();
      return (t && !n || !t && n) && (i = i.redNeg()), this.point(r, i)
    }, n.prototype.validate = function(r) {
      if (r.inf) return !0;
      var e = r.x,
        t = r.y,
        d = this.a.redMul(e),
        i = e.redSqr().redMul(e).redIAdd(d).redIAdd(this.b);
      return 0 === t.redSqr().redISub(i).cmpn(0)
    }, n.prototype._endoWnafMulAdd = function(r, e, t) {
      for (var d = this._endoWnafT1, i = this._endoWnafT2, n = 0; n < r.length; n++) {
        var u = this._endoSplit(e[n]),
          s = r[n],
          o = s._getBeta();
        u.k1.negative && (u.k1.ineg(), s = s.neg(!0)), u.k2.negative && (u.k2.ineg(), o = o.neg(!0)), d[2 * n] = s, d[2 * n + 1] = o, i[2 * n] = u.k1, i[2 * n + 1] = u.k2
      }
      for (var h = this._wnafMulAdd(1, d, i, 2 * n, t), p = 0; p < 2 * n; p++) d[p] = null, i[p] = null;
      return h
    }, t(u, d.BasePoint), n.prototype.point = function(r, e, t) {
      return new u(this, r, e, t)
    }, n.prototype.pointFromJSON = function(r, e) {
      return u.fromJSON(this, r, e)
    }, u.prototype._getBeta = function() {
      if (this.curve.endo) {
        var r = this.precomputed;
        if (r && r.beta) return r.beta;
        var e = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
        if (r) {
          var t = this.curve,
            d = function(r) {
              return t.point(r.x.redMul(t.endo.beta), r.y)
            };
          r.beta = e, e.precomputed = {
            beta: null,
            naf: r.naf && {
              wnd: r.naf.wnd,
              points: r.naf.points.map(d)
            },
            doubles: r.doubles && {
              step: r.doubles.step,
              points: r.doubles.points.map(d)
            }
          }
        }
        return e
      }
    }, u.prototype.toJSON = function() {
      return this.precomputed ? [this.x, this.y, this.precomputed && {
        doubles: this.precomputed.doubles && {
          step: this.precomputed.doubles.step,
          points: this.precomputed.doubles.points.slice(1)
        },
        naf: this.precomputed.naf && {
          wnd: this.precomputed.naf.wnd,
          points: this.precomputed.naf.points.slice(1)
        }
      }] : [this.x, this.y]
    }, u.fromJSON = function(r, e, t) {
      "string" == typeof e && (e = JSON.parse(e));
      var d = r.point(e[0], e[1], t);
      if (!e[2]) return d;

      function i(e) {
        return r.point(e[0], e[1], t)
      }
      var n = e[2];
      return d.precomputed = {
        beta: null,
        doubles: n.doubles && {
          step: n.doubles.step,
          points: [d].concat(n.doubles.points.map(i))
        },
        naf: n.naf && {
          wnd: n.naf.wnd,
          points: [d].concat(n.naf.points.map(i))
        }
      }, d
    }, u.prototype.inspect = function() {
      return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + ">"
    }, u.prototype.isInfinity = function() {
      return this.inf
    }, u.prototype.add = function(r) {
      if (this.inf) return r;
      if (r.inf) return this;
      if (this.eq(r)) return this.dbl();
      if (this.neg().eq(r)) return this.curve.point(null, null);
      if (0 === this.x.cmp(r.x)) return this.curve.point(null, null);
      var e = this.y.redSub(r.y);
      0 !== e.cmpn(0) && (e = e.redMul(this.x.redSub(r.x).redInvm()));
      var t = e.redSqr().redISub(this.x).redISub(r.x),
        d = e.redMul(this.x.redSub(t)).redISub(this.y);
      return this.curve.point(t, d)
    }, u.prototype.dbl = function() {
      if (this.inf) return this;
      var r = this.y.redAdd(this.y);
      if (0 === r.cmpn(0)) return this.curve.point(null, null);
      var e = this.curve.a,
        t = this.x.redSqr(),
        d = r.redInvm(),
        i = t.redAdd(t).redIAdd(t).redIAdd(e).redMul(d),
        n = i.redSqr().redISub(this.x.redAdd(this.x)),
        u = i.redMul(this.x.redSub(n)).redISub(this.y);
      return this.curve.point(n, u)
    }, u.prototype.getX = function() {
      return this.x.fromRed()
    }, u.prototype.getY = function() {
      return this.y.fromRed()
    }, u.prototype.mul = function(r) {
      return r = new e(r, 16), this.isInfinity() ? this : this._hasDoubles(r) ? this.curve._fixedNafMul(this, r) : this.curve.endo ? this.curve._endoWnafMulAdd([this], [r]) : this.curve._wnafMul(this, r)
    }, u.prototype.mulAdd = function(r, e, t) {
      var d = [this, e],
        i = [r, t];
      return this.curve.endo ? this.curve._endoWnafMulAdd(d, i) : this.curve._wnafMulAdd(1, d, i, 2)
    }, u.prototype.jmulAdd = function(r, e, t) {
      var d = [this, e],
        i = [r, t];
      return this.curve.endo ? this.curve._endoWnafMulAdd(d, i, !0) : this.curve._wnafMulAdd(1, d, i, 2, !0)
    }, u.prototype.eq = function(r) {
      return this === r || this.inf === r.inf && (this.inf || 0 === this.x.cmp(r.x) && 0 === this.y.cmp(r.y))
    }, u.prototype.neg = function(r) {
      if (this.inf) return this;
      var e = this.curve.point(this.x, this.y.redNeg());
      if (r && this.precomputed) {
        var t = this.precomputed,
          d = function(r) {
            return r.neg()
          };
        e.precomputed = {
          naf: t.naf && {
            wnd: t.naf.wnd,
            points: t.naf.points.map(d)
          },
          doubles: t.doubles && {
            step: t.doubles.step,
            points: t.doubles.points.map(d)
          }
        }
      }
      return e
    }, u.prototype.toJ = function() {
      return this.inf ? this.curve.jpoint(null, null, null) : this.curve.jpoint(this.x, this.y, this.curve.one)
    }, t(s, d.BasePoint), n.prototype.jpoint = function(r, e, t) {
      return new s(this, r, e, t)
    }, s.prototype.toP = function() {
      if (this.isInfinity()) return this.curve.point(null, null);
      var r = this.z.redInvm(),
        e = r.redSqr(),
        t = this.x.redMul(e),
        d = this.y.redMul(e).redMul(r);
      return this.curve.point(t, d)
    }, s.prototype.neg = function() {
      return this.curve.jpoint(this.x, this.y.redNeg(), this.z)
    }, s.prototype.add = function(r) {
      if (this.isInfinity()) return r;
      if (r.isInfinity()) return this;
      var e = r.z.redSqr(),
        t = this.z.redSqr(),
        d = this.x.redMul(e),
        i = r.x.redMul(t),
        n = this.y.redMul(e.redMul(r.z)),
        u = r.y.redMul(t.redMul(this.z)),
        s = d.redSub(i),
        o = n.redSub(u);
      if (0 === s.cmpn(0)) return 0 !== o.cmpn(0) ? this.curve.jpoint(null, null, null) : this.dbl();
      var h = s.redSqr(),
        p = h.redMul(s),
        l = d.redMul(h),
        a = o.redSqr().redIAdd(p).redISub(l).redISub(l),
        f = o.redMul(l.redISub(a)).redISub(n.redMul(p)),
        c = this.z.redMul(r.z).redMul(s);
      return this.curve.jpoint(a, f, c)
    }, s.prototype.mixedAdd = function(r) {
      if (this.isInfinity()) return r.toJ();
      if (r.isInfinity()) return this;
      var e = this.z.redSqr(),
        t = this.x,
        d = r.x.redMul(e),
        i = this.y,
        n = r.y.redMul(e).redMul(this.z),
        u = t.redSub(d),
        s = i.redSub(n);
      if (0 === u.cmpn(0)) return 0 !== s.cmpn(0) ? this.curve.jpoint(null, null, null) : this.dbl();
      var o = u.redSqr(),
        h = o.redMul(u),
        p = t.redMul(o),
        l = s.redSqr().redIAdd(h).redISub(p).redISub(p),
        a = s.redMul(p.redISub(l)).redISub(i.redMul(h)),
        f = this.z.redMul(u);
      return this.curve.jpoint(l, a, f)
    }, s.prototype.dblp = function(r) {
      if (0 === r) return this;
      if (this.isInfinity()) return this;
      if (!r) return this.dbl();
      var e;
      if (this.curve.zeroA || this.curve.threeA) {
        var t = this;
        for (e = 0; e < r; e++) t = t.dbl();
        return t
      }
      var d = this.curve.a,
        i = this.curve.tinv,
        n = this.x,
        u = this.y,
        s = this.z,
        o = s.redSqr().redSqr(),
        h = u.redAdd(u);
      for (e = 0; e < r; e++) {
        var p = n.redSqr(),
          l = h.redSqr(),
          a = l.redSqr(),
          f = p.redAdd(p).redIAdd(p).redIAdd(d.redMul(o)),
          c = n.redMul(l),
          S = f.redSqr().redISub(c.redAdd(c)),
          b = c.redISub(S),
          v = f.redMul(b);
        v = v.redIAdd(v).redISub(a);
        var I = h.redMul(s);
        e + 1 < r && (o = o.redMul(a)), n = S, s = I, h = v
      }
      return this.curve.jpoint(n, h.redMul(i), s)
    }, s.prototype.dbl = function() {
      return this.isInfinity() ? this : this.curve.zeroA ? this._zeroDbl() : this.curve.threeA ? this._threeDbl() : this._dbl()
    }, s.prototype._zeroDbl = function() {
      var r, e, t;
      if (this.zOne) {
        var d = this.x.redSqr(),
          i = this.y.redSqr(),
          n = i.redSqr(),
          u = this.x.redAdd(i).redSqr().redISub(d).redISub(n);
        u = u.redIAdd(u);
        var s = d.redAdd(d).redIAdd(d),
          o = s.redSqr().redISub(u).redISub(u),
          h = n.redIAdd(n);
        h = (h = h.redIAdd(h)).redIAdd(h), r = o, e = s.redMul(u.redISub(o)).redISub(h), t = this.y.redAdd(this.y)
      } else {
        var p = this.x.redSqr(),
          l = this.y.redSqr(),
          a = l.redSqr(),
          f = this.x.redAdd(l).redSqr().redISub(p).redISub(a);
        f = f.redIAdd(f);
        var c = p.redAdd(p).redIAdd(p),
          S = c.redSqr(),
          b = a.redIAdd(a);
        b = (b = b.redIAdd(b)).redIAdd(b), r = S.redISub(f).redISub(f), e = c.redMul(f.redISub(r)).redISub(b), t = (t = this.y.redMul(this.z)).redIAdd(t)
      }
      return this.curve.jpoint(r, e, t)
    }, s.prototype._threeDbl = function() {
      var r, e, t;
      if (this.zOne) {
        var d = this.x.redSqr(),
          i = this.y.redSqr(),
          n = i.redSqr(),
          u = this.x.redAdd(i).redSqr().redISub(d).redISub(n);
        u = u.redIAdd(u);
        var s = d.redAdd(d).redIAdd(d).redIAdd(this.curve.a),
          o = s.redSqr().redISub(u).redISub(u);
        r = o;
        var h = n.redIAdd(n);
        h = (h = h.redIAdd(h)).redIAdd(h), e = s.redMul(u.redISub(o)).redISub(h), t = this.y.redAdd(this.y)
      } else {
        var p = this.z.redSqr(),
          l = this.y.redSqr(),
          a = this.x.redMul(l),
          f = this.x.redSub(p).redMul(this.x.redAdd(p));
        f = f.redAdd(f).redIAdd(f);
        var c = a.redIAdd(a),
          S = (c = c.redIAdd(c)).redAdd(c);
        r = f.redSqr().redISub(S), t = this.y.redAdd(this.z).redSqr().redISub(l).redISub(p);
        var b = l.redSqr();
        b = (b = (b = b.redIAdd(b)).redIAdd(b)).redIAdd(b), e = f.redMul(c.redISub(r)).redISub(b)
      }
      return this.curve.jpoint(r, e, t)
    }, s.prototype._dbl = function() {
      var r = this.curve.a,
        e = this.x,
        t = this.y,
        d = this.z,
        i = d.redSqr().redSqr(),
        n = e.redSqr(),
        u = t.redSqr(),
        s = n.redAdd(n).redIAdd(n).redIAdd(r.redMul(i)),
        o = e.redAdd(e),
        h = (o = o.redIAdd(o)).redMul(u),
        p = s.redSqr().redISub(h.redAdd(h)),
        l = h.redISub(p),
        a = u.redSqr();
      a = (a = (a = a.redIAdd(a)).redIAdd(a)).redIAdd(a);
      var f = s.redMul(l).redISub(a),
        c = t.redAdd(t).redMul(d);
      return this.curve.jpoint(p, f, c)
    }, s.prototype.trpl = function() {
      if (!this.curve.zeroA) return this.dbl().add(this);
      var r = this.x.redSqr(),
        e = this.y.redSqr(),
        t = this.z.redSqr(),
        d = e.redSqr(),
        i = r.redAdd(r).redIAdd(r),
        n = i.redSqr(),
        u = this.x.redAdd(e).redSqr().redISub(r).redISub(d),
        s = (u = (u = (u = u.redIAdd(u)).redAdd(u).redIAdd(u)).redISub(n)).redSqr(),
        o = d.redIAdd(d);
      o = (o = (o = o.redIAdd(o)).redIAdd(o)).redIAdd(o);
      var h = i.redIAdd(u).redSqr().redISub(n).redISub(s).redISub(o),
        p = e.redMul(h);
      p = (p = p.redIAdd(p)).redIAdd(p);
      var l = this.x.redMul(s).redISub(p);
      l = (l = l.redIAdd(l)).redIAdd(l);
      var a = this.y.redMul(h.redMul(o.redISub(h)).redISub(u.redMul(s)));
      a = (a = (a = a.redIAdd(a)).redIAdd(a)).redIAdd(a);
      var f = this.z.redAdd(u).redSqr().redISub(t).redISub(s);
      return this.curve.jpoint(l, a, f)
    }, s.prototype.mul = function(r, t) {
      return r = new e(r, t), this.curve._wnafMul(this, r)
    }, s.prototype.eq = function(r) {
      if ("affine" === r.type) return this.eq(r.toJ());
      if (this === r) return !0;
      var e = this.z.redSqr(),
        t = r.z.redSqr();
      if (0 !== this.x.redMul(t).redISub(r.x.redMul(e)).cmpn(0)) return !1;
      var d = e.redMul(this.z),
        i = t.redMul(r.z);
      return 0 === this.y.redMul(i).redISub(r.y.redMul(d)).cmpn(0)
    }, s.prototype.eqXToP = function(r) {
      var e = this.z.redSqr(),
        t = r.toRed(this.curve.red).redMul(e);
      if (0 === this.x.cmp(t)) return !0;
      for (var d = r.clone(), i = this.curve.redN.redMul(e);;) {
        if (d.iadd(this.curve.n), d.cmp(this.curve.p) >= 0) return !1;
        if (t.redIAdd(i), 0 === this.x.cmp(t)) return !0
      }
    }, s.prototype.inspect = function() {
      return this.isInfinity() ? "<EC JPoint Infinity>" : "<EC JPoint x: " + this.x.toString(16, 2) + " y: " + this.y.toString(16, 2) + " z: " + this.z.toString(16, 2) + ">"
    }, s.prototype.isInfinity = function() {
      return 0 === this.z.cmpn(0)
    };
  }, {
    "../utils": "F8Ez",
    "bn.js": "AGD1",
    "inherits": "Bm0n",
    "./base": "NX8i"
  }],
  "PwwO": [function(require, module, exports) {
    "use strict";
    var t = require("bn.js"),
      r = require("inherits"),
      e = require("./base"),
      i = require("../utils");

    function o(r) {
      e.call(this, "mont", r), this.a = new t(r.a, 16).toRed(this.red), this.b = new t(r.b, 16).toRed(this.red), this.i4 = new t(4).toRed(this.red).redInvm(), this.two = new t(2).toRed(this.red), this.a24 = this.i4.redMul(this.a.redAdd(this.two))
    }

    function n(r, i, o) {
      e.BasePoint.call(this, r, "projective"), null === i && null === o ? (this.x = this.curve.one, this.z = this.curve.zero) : (this.x = new t(i, 16), this.z = new t(o, 16), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)))
    }
    r(o, e), module.exports = o, o.prototype.validate = function(t) {
      var r = t.normalize().x,
        e = r.redSqr(),
        i = e.redMul(r).redAdd(e.redMul(this.a)).redAdd(r);
      return 0 === i.redSqrt().redSqr().cmp(i)
    }, r(n, e.BasePoint), o.prototype.decodePoint = function(t, r) {
      return this.point(i.toArray(t, r), 1)
    }, o.prototype.point = function(t, r) {
      return new n(this, t, r)
    }, o.prototype.pointFromJSON = function(t) {
      return n.fromJSON(this, t)
    }, n.prototype.precompute = function() {}, n.prototype._encode = function() {
      return this.getX().toArray("be", this.curve.p.byteLength())
    }, n.fromJSON = function(t, r) {
      return new n(t, r[0], r[1] || t.one)
    }, n.prototype.inspect = function() {
      return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">"
    }, n.prototype.isInfinity = function() {
      return 0 === this.z.cmpn(0)
    }, n.prototype.dbl = function() {
      var t = this.x.redAdd(this.z).redSqr(),
        r = this.x.redSub(this.z).redSqr(),
        e = t.redSub(r),
        i = t.redMul(r),
        o = e.redMul(r.redAdd(this.curve.a24.redMul(e)));
      return this.curve.point(i, o)
    }, n.prototype.add = function() {
      throw new Error("Not supported on Montgomery curve")
    }, n.prototype.diffAdd = function(t, r) {
      var e = this.x.redAdd(this.z),
        i = this.x.redSub(this.z),
        o = t.x.redAdd(t.z),
        n = t.x.redSub(t.z).redMul(e),
        d = o.redMul(i),
        u = r.z.redMul(n.redAdd(d).redSqr()),
        s = r.x.redMul(n.redISub(d).redSqr());
      return this.curve.point(u, s)
    }, n.prototype.mul = function(t) {
      for (var r = t.clone(), e = this, i = this.curve.point(null, null), o = []; 0 !== r.cmpn(0); r.iushrn(1)) o.push(r.andln(1));
      for (var n = o.length - 1; n >= 0; n--) 0 === o[n] ? (e = e.diffAdd(i, this), i = i.dbl()) : (i = e.diffAdd(i, this), e = e.dbl());
      return i
    }, n.prototype.mulAdd = function() {
      throw new Error("Not supported on Montgomery curve")
    }, n.prototype.jumlAdd = function() {
      throw new Error("Not supported on Montgomery curve")
    }, n.prototype.eq = function(t) {
      return 0 === this.getX().cmp(t.getX())
    }, n.prototype.normalize = function() {
      return this.x = this.x.redMul(this.z.redInvm()), this.z = this.curve.one, this
    }, n.prototype.getX = function() {
      return this.normalize(), this.x.fromRed()
    };
  }, {
    "bn.js": "AGD1",
    "inherits": "Bm0n",
    "./base": "NX8i",
    "../utils": "F8Ez"
  }],
  "tiqw": [function(require, module, exports) {
    "use strict";
    var t = require("../utils"),
      e = require("bn.js"),
      r = require("inherits"),
      i = require("./base"),
      d = t.assert;

    function s(t) {
      this.twisted = 1 != (0 | t.a), this.mOneA = this.twisted && -1 == (0 | t.a), this.extended = this.mOneA, i.call(this, "edwards", t), this.a = new e(t.a, 16).umod(this.red.m), this.a = this.a.toRed(this.red), this.c = new e(t.c, 16).toRed(this.red), this.c2 = this.c.redSqr(), this.d = new e(t.d, 16).toRed(this.red), this.dd = this.d.redAdd(this.d), d(!this.twisted || 0 === this.c.fromRed().cmpn(1)), this.oneC = 1 == (0 | t.c)
    }

    function u(t, r, d, s, u) {
      i.BasePoint.call(this, t, "projective"), null === r && null === d && null === s ? (this.x = this.curve.zero, this.y = this.curve.one, this.z = this.curve.one, this.t = this.curve.zero, this.zOne = !0) : (this.x = new e(r, 16), this.y = new e(d, 16), this.z = s ? new e(s, 16) : this.curve.one, this.t = u && new e(u, 16), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)), this.t && !this.t.red && (this.t = this.t.toRed(this.curve.red)), this.zOne = this.z === this.curve.one, this.curve.extended && !this.t && (this.t = this.x.redMul(this.y), this.zOne || (this.t = this.t.redMul(this.z.redInvm()))))
    }
    r(s, i), module.exports = s, s.prototype._mulA = function(t) {
      return this.mOneA ? t.redNeg() : this.a.redMul(t)
    }, s.prototype._mulC = function(t) {
      return this.oneC ? t : this.c.redMul(t)
    }, s.prototype.jpoint = function(t, e, r, i) {
      return this.point(t, e, r, i)
    }, s.prototype.pointFromX = function(t, r) {
      (t = new e(t, 16)).red || (t = t.toRed(this.red));
      var i = t.redSqr(),
        d = this.c2.redSub(this.a.redMul(i)),
        s = this.one.redSub(this.c2.redMul(this.d).redMul(i)),
        u = d.redMul(s.redInvm()),
        h = u.redSqrt();
      if (0 !== h.redSqr().redSub(u).cmp(this.zero)) throw new Error("invalid point");
      var n = h.fromRed().isOdd();
      return (r && !n || !r && n) && (h = h.redNeg()), this.point(t, h)
    }, s.prototype.pointFromY = function(t, r) {
      (t = new e(t, 16)).red || (t = t.toRed(this.red));
      var i = t.redSqr(),
        d = i.redSub(this.c2),
        s = i.redMul(this.d).redMul(this.c2).redSub(this.a),
        u = d.redMul(s.redInvm());
      if (0 === u.cmp(this.zero)) {
        if (r) throw new Error("invalid point");
        return this.point(this.zero, t)
      }
      var h = u.redSqrt();
      if (0 !== h.redSqr().redSub(u).cmp(this.zero)) throw new Error("invalid point");
      return h.fromRed().isOdd() !== r && (h = h.redNeg()), this.point(h, t)
    }, s.prototype.validate = function(t) {
      if (t.isInfinity()) return !0;
      t.normalize();
      var e = t.x.redSqr(),
        r = t.y.redSqr(),
        i = e.redMul(this.a).redAdd(r),
        d = this.c2.redMul(this.one.redAdd(this.d.redMul(e).redMul(r)));
      return 0 === i.cmp(d)
    }, r(u, i.BasePoint), s.prototype.pointFromJSON = function(t) {
      return u.fromJSON(this, t)
    }, s.prototype.point = function(t, e, r, i) {
      return new u(this, t, e, r, i)
    }, u.fromJSON = function(t, e) {
      return new u(t, e[0], e[1], e[2])
    }, u.prototype.inspect = function() {
      return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">"
    }, u.prototype.isInfinity = function() {
      return 0 === this.x.cmpn(0) && (0 === this.y.cmp(this.z) || this.zOne && 0 === this.y.cmp(this.curve.c))
    }, u.prototype._extDbl = function() {
      var t = this.x.redSqr(),
        e = this.y.redSqr(),
        r = this.z.redSqr();
      r = r.redIAdd(r);
      var i = this.curve._mulA(t),
        d = this.x.redAdd(this.y).redSqr().redISub(t).redISub(e),
        s = i.redAdd(e),
        u = s.redSub(r),
        h = i.redSub(e),
        n = d.redMul(u),
        o = s.redMul(h),
        c = d.redMul(h),
        l = u.redMul(s);
      return this.curve.point(n, o, l, c)
    }, u.prototype._projDbl = function() {
      var t, e, r, i, d, s, u = this.x.redAdd(this.y).redSqr(),
        h = this.x.redSqr(),
        n = this.y.redSqr();
      if (this.curve.twisted) {
        var o = (i = this.curve._mulA(h)).redAdd(n);
        this.zOne ? (t = u.redSub(h).redSub(n).redMul(o.redSub(this.curve.two)), e = o.redMul(i.redSub(n)), r = o.redSqr().redSub(o).redSub(o)) : (d = this.z.redSqr(), s = o.redSub(d).redISub(d), t = u.redSub(h).redISub(n).redMul(s), e = o.redMul(i.redSub(n)), r = o.redMul(s))
      } else i = h.redAdd(n), d = this.curve._mulC(this.z).redSqr(), s = i.redSub(d).redSub(d), t = this.curve._mulC(u.redISub(i)).redMul(s), e = this.curve._mulC(i).redMul(h.redISub(n)), r = i.redMul(s);
      return this.curve.point(t, e, r)
    }, u.prototype.dbl = function() {
      return this.isInfinity() ? this : this.curve.extended ? this._extDbl() : this._projDbl()
    }, u.prototype._extAdd = function(t) {
      var e = this.y.redSub(this.x).redMul(t.y.redSub(t.x)),
        r = this.y.redAdd(this.x).redMul(t.y.redAdd(t.x)),
        i = this.t.redMul(this.curve.dd).redMul(t.t),
        d = this.z.redMul(t.z.redAdd(t.z)),
        s = r.redSub(e),
        u = d.redSub(i),
        h = d.redAdd(i),
        n = r.redAdd(e),
        o = s.redMul(u),
        c = h.redMul(n),
        l = s.redMul(n),
        p = u.redMul(h);
      return this.curve.point(o, c, p, l)
    }, u.prototype._projAdd = function(t) {
      var e, r, i = this.z.redMul(t.z),
        d = i.redSqr(),
        s = this.x.redMul(t.x),
        u = this.y.redMul(t.y),
        h = this.curve.d.redMul(s).redMul(u),
        n = d.redSub(h),
        o = d.redAdd(h),
        c = this.x.redAdd(this.y).redMul(t.x.redAdd(t.y)).redISub(s).redISub(u),
        l = i.redMul(n).redMul(c);
      return this.curve.twisted ? (e = i.redMul(o).redMul(u.redSub(this.curve._mulA(s))), r = n.redMul(o)) : (e = i.redMul(o).redMul(u.redSub(s)), r = this.curve._mulC(n).redMul(o)), this.curve.point(l, e, r)
    }, u.prototype.add = function(t) {
      return this.isInfinity() ? t : t.isInfinity() ? this : this.curve.extended ? this._extAdd(t) : this._projAdd(t)
    }, u.prototype.mul = function(t) {
      return this._hasDoubles(t) ? this.curve._fixedNafMul(this, t) : this.curve._wnafMul(this, t)
    }, u.prototype.mulAdd = function(t, e, r) {
      return this.curve._wnafMulAdd(1, [this, e], [t, r], 2, !1)
    }, u.prototype.jmulAdd = function(t, e, r) {
      return this.curve._wnafMulAdd(1, [this, e], [t, r], 2, !0)
    }, u.prototype.normalize = function() {
      if (this.zOne) return this;
      var t = this.z.redInvm();
      return this.x = this.x.redMul(t), this.y = this.y.redMul(t), this.t && (this.t = this.t.redMul(t)), this.z = this.curve.one, this.zOne = !0, this
    }, u.prototype.neg = function() {
      return this.curve.point(this.x.redNeg(), this.y, this.z, this.t && this.t.redNeg())
    }, u.prototype.getX = function() {
      return this.normalize(), this.x.fromRed()
    }, u.prototype.getY = function() {
      return this.normalize(), this.y.fromRed()
    }, u.prototype.eq = function(t) {
      return this === t || 0 === this.getX().cmp(t.getX()) && 0 === this.getY().cmp(t.getY())
    }, u.prototype.eqXToP = function(t) {
      var e = t.toRed(this.curve.red).redMul(this.z);
      if (0 === this.x.cmp(e)) return !0;
      for (var r = t.clone(), i = this.curve.redN.redMul(this.z);;) {
        if (r.iadd(this.curve.n), r.cmp(this.curve.p) >= 0) return !1;
        if (e.redIAdd(i), 0 === this.x.cmp(e)) return !0
      }
    }, u.prototype.toP = u.prototype.normalize, u.prototype.mixedAdd = u.prototype.add;
  }, {
    "../utils": "F8Ez",
    "bn.js": "AGD1",
    "inherits": "Bm0n",
    "./base": "NX8i"
  }],
  "P4Ml": [function(require, module, exports) {
    "use strict";
    var r = exports;
    r.base = require("./base"), r.short = require("./short"), r.mont = require("./mont"), r.edwards = require("./edwards");
  }, {
    "./base": "NX8i",
    "./short": "CO0D",
    "./mont": "PwwO",
    "./edwards": "tiqw"
  }],
  "khx4": [function(require, module, exports) {
    module.exports = {
      doubles: {
        step: 4,
        points: [
          ["e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a", "f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821"],
          ["8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508", "11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf"],
          ["175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739", "d3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695"],
          ["363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640", "4e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9"],
          ["8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c", "4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36"],
          ["723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda", "96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f"],
          ["eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa", "5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999"],
          ["100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0", "cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09"],
          ["e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d", "9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d"],
          ["feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d", "e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088"],
          ["da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1", "9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d"],
          ["53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0", "5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8"],
          ["8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047", "10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a"],
          ["385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862", "283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453"],
          ["6f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7", "7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160"],
          ["3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd", "56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0"],
          ["85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83", "7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6"],
          ["948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a", "53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589"],
          ["6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8", "bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17"],
          ["e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d", "4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda"],
          ["e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725", "7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd"],
          ["213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754", "4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2"],
          ["4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c", "17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6"],
          ["fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6", "6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f"],
          ["76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39", "c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01"],
          ["c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891", "893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3"],
          ["d895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b", "febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f"],
          ["b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03", "2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7"],
          ["e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d", "eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78"],
          ["a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070", "7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1"],
          ["90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4", "e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150"],
          ["8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da", "662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82"],
          ["e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11", "1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc"],
          ["8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e", "efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b"],
          ["e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41", "2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51"],
          ["b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef", "67c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45"],
          ["d68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8", "db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120"],
          ["324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d", "648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84"],
          ["4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96", "35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d"],
          ["9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd", "ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d"],
          ["6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5", "9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8"],
          ["a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266", "40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8"],
          ["7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71", "34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac"],
          ["928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac", "c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f"],
          ["85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751", "1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962"],
          ["ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e", "493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907"],
          ["827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241", "c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec"],
          ["eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3", "be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d"],
          ["e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f", "4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414"],
          ["1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19", "aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd"],
          ["146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be", "b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0"],
          ["fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9", "6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811"],
          ["da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2", "8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1"],
          ["a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13", "7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c"],
          ["174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c", "ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73"],
          ["959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba", "2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd"],
          ["d2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151", "e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405"],
          ["64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073", "d99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589"],
          ["8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458", "38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e"],
          ["13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b", "69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27"],
          ["bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366", "d3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1"],
          ["8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa", "40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482"],
          ["8ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0", "620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945"],
          ["dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787", "7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573"],
          ["f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e", "ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82"]
        ]
      },
      naf: {
        wnd: 7,
        points: [
          ["f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9", "388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672"],
          ["2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4", "d8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6"],
          ["5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc", "6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da"],
          ["acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe", "cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37"],
          ["774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb", "d984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b"],
          ["f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8", "ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81"],
          ["d7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e", "581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58"],
          ["defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34", "4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77"],
          ["2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c", "85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a"],
          ["352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5", "321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c"],
          ["2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f", "2de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67"],
          ["9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714", "73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402"],
          ["daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729", "a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55"],
          ["c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db", "2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482"],
          ["6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4", "e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82"],
          ["1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5", "b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396"],
          ["605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479", "2972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49"],
          ["62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d", "80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf"],
          ["80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f", "1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a"],
          ["7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb", "d0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7"],
          ["d528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9", "eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933"],
          ["49370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963", "758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a"],
          ["77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74", "958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6"],
          ["f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530", "e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37"],
          ["463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b", "5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e"],
          ["f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247", "cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6"],
          ["caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1", "cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476"],
          ["2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120", "4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40"],
          ["7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435", "91b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61"],
          ["754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18", "673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683"],
          ["e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8", "59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5"],
          ["186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb", "3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b"],
          ["df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f", "55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417"],
          ["5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143", "efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868"],
          ["290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba", "e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a"],
          ["af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45", "f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6"],
          ["766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a", "744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996"],
          ["59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e", "c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e"],
          ["f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8", "e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d"],
          ["7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c", "30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2"],
          ["948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519", "e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e"],
          ["7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab", "100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437"],
          ["3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca", "ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311"],
          ["d3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf", "8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4"],
          ["1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610", "68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575"],
          ["733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4", "f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d"],
          ["15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c", "d56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d"],
          ["a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940", "edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629"],
          ["e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980", "a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06"],
          ["311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3", "66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374"],
          ["34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf", "9414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee"],
          ["f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63", "4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1"],
          ["d7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448", "fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b"],
          ["32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf", "5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661"],
          ["7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5", "8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6"],
          ["ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6", "8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e"],
          ["16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5", "5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d"],
          ["eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99", "f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc"],
          ["78c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51", "f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4"],
          ["494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5", "42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c"],
          ["a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5", "204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b"],
          ["c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997", "4f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913"],
          ["841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881", "73867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154"],
          ["5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5", "39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865"],
          ["36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66", "d2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc"],
          ["336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726", "ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224"],
          ["8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede", "6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e"],
          ["1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94", "60660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6"],
          ["85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31", "3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511"],
          ["29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51", "b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b"],
          ["a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252", "ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2"],
          ["4e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5", "cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c"],
          ["d24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b", "6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3"],
          ["ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4", "322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d"],
          ["af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f", "6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700"],
          ["e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889", "2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4"],
          ["591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246", "b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196"],
          ["11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984", "998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4"],
          ["3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a", "b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257"],
          ["cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030", "bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13"],
          ["c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197", "6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096"],
          ["c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593", "c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38"],
          ["a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef", "21ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f"],
          ["347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38", "60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448"],
          ["da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a", "49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a"],
          ["c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111", "5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4"],
          ["4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502", "7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437"],
          ["3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea", "be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7"],
          ["cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26", "8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d"],
          ["b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986", "39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a"],
          ["d4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e", "62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54"],
          ["48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4", "25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77"],
          ["dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda", "ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517"],
          ["6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859", "cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10"],
          ["e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f", "f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125"],
          ["eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c", "6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e"],
          ["13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942", "fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1"],
          ["ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a", "1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2"],
          ["b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80", "5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423"],
          ["ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d", "438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8"],
          ["8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1", "cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758"],
          ["52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63", "c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375"],
          ["e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352", "6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d"],
          ["7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193", "ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec"],
          ["5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00", "9731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0"],
          ["32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58", "ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c"],
          ["e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7", "d3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4"],
          ["8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8", "c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f"],
          ["4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e", "67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649"],
          ["3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d", "cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826"],
          ["674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b", "299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5"],
          ["d32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f", "f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87"],
          ["30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6", "462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b"],
          ["be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297", "62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc"],
          ["93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a", "7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c"],
          ["b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c", "ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f"],
          ["d5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52", "4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a"],
          ["d3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb", "bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46"],
          ["463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065", "bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f"],
          ["7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917", "603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03"],
          ["74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9", "cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08"],
          ["30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3", "553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8"],
          ["9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57", "712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373"],
          ["176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66", "ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3"],
          ["75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8", "9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8"],
          ["809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721", "9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1"],
          ["1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180", "4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9"]
        ]
      }
    };
  }, {}],
  "ExaX": [function(require, module, exports) {
    "use strict";
    var f, e = exports,
      a = require("hash.js"),
      b = require("./curve"),
      c = require("./utils"),
      d = c.assert;

    function r(f) {
      "short" === f.type ? this.curve = new b.short(f) : "edwards" === f.type ? this.curve = new b.edwards(f) : this.curve = new b.mont(f), this.g = this.curve.g, this.n = this.curve.n, this.hash = f.hash, d(this.g.validate(), "Invalid curve"), d(this.g.mul(this.n).isInfinity(), "Invalid curve, G*N != O")
    }

    function s(f, a) {
      Object.defineProperty(e, f, {
        configurable: !0,
        enumerable: !0,
        get: function() {
          var b = new r(a);
          return Object.defineProperty(e, f, {
            configurable: !0,
            enumerable: !0,
            value: b
          }), b
        }
      })
    }
    e.PresetCurve = r, s("p192", {
      type: "short",
      prime: "p192",
      p: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff",
      a: "ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc",
      b: "64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1",
      n: "ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831",
      hash: a.sha256,
      gRed: !1,
      g: ["188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012", "07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811"]
    }), s("p224", {
      type: "short",
      prime: "p224",
      p: "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001",
      a: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe",
      b: "b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4",
      n: "ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d",
      hash: a.sha256,
      gRed: !1,
      g: ["b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21", "bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34"]
    }), s("p256", {
      type: "short",
      prime: null,
      p: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff",
      a: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc",
      b: "5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b",
      n: "ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551",
      hash: a.sha256,
      gRed: !1,
      g: ["6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296", "4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5"]
    }), s("p384", {
      type: "short",
      prime: null,
      p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff",
      a: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc",
      b: "b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef",
      n: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973",
      hash: a.sha384,
      gRed: !1,
      g: ["aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7", "3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f"]
    }), s("p521", {
      type: "short",
      prime: null,
      p: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff",
      a: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc",
      b: "00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00",
      n: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409",
      hash: a.sha512,
      gRed: !1,
      g: ["000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66", "00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650"]
    }), s("curve25519", {
      type: "mont",
      prime: "p25519",
      p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
      a: "76d06",
      b: "1",
      n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
      hash: a.sha256,
      gRed: !1,
      g: ["9"]
    }), s("ed25519", {
      type: "edwards",
      prime: "p25519",
      p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
      a: "-1",
      c: "1",
      d: "52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3",
      n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
      hash: a.sha256,
      gRed: !1,
      g: ["216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a", "6666666666666666666666666666666666666666666666666666666666666658"]
    });
    try {
      f = require("./precomputed/secp256k1")
    } catch (t) {
      f = void 0
    }
    s("secp256k1", {
      type: "short",
      prime: "k256",
      p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f",
      a: "0",
      b: "7",
      n: "ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141",
      h: "1",
      hash: a.sha256,
      beta: "7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee",
      lambda: "5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72",
      basis: [{
        a: "3086d221a7d46bcde86c90e49284eb15",
        b: "-e4437ed6010e88286f547fa90abfe4c3"
      }, {
        a: "114ca50f7a8e2f3f657c1108d9d44cfd8",
        b: "3086d221a7d46bcde86c90e49284eb15"
      }],
      gRed: !1,
      g: ["79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798", "483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8", f]
    });
  }, {
    "hash.js": "fVGI",
    "./curve": "P4Ml",
    "./utils": "F8Ez",
    "./precomputed/secp256k1": "khx4"
  }],
  "vdhc": [function(require, module, exports) {
    "use strict";
    var t = require("hash.js"),
      e = require("minimalistic-crypto-utils"),
      i = require("minimalistic-assert");

    function s(t) {
      if (!(this instanceof s)) return new s(t);
      this.hash = t.hash, this.predResist = !!t.predResist, this.outLen = this.hash.outSize, this.minEntropy = t.minEntropy || this.hash.hmacStrength, this._reseed = null, this.reseedInterval = null, this.K = null, this.V = null;
      var h = e.toArray(t.entropy, t.entropyEnc || "hex"),
        r = e.toArray(t.nonce, t.nonceEnc || "hex"),
        n = e.toArray(t.pers, t.persEnc || "hex");
      i(h.length >= this.minEntropy / 8, "Not enough entropy. Minimum is: " + this.minEntropy + " bits"), this._init(h, r, n)
    }
    module.exports = s, s.prototype._init = function(t, e, i) {
      var s = t.concat(e).concat(i);
      this.K = new Array(this.outLen / 8), this.V = new Array(this.outLen / 8);
      for (var h = 0; h < this.V.length; h++) this.K[h] = 0, this.V[h] = 1;
      this._update(s), this._reseed = 1, this.reseedInterval = 281474976710656
    }, s.prototype._hmac = function() {
      return new t.hmac(this.hash, this.K)
    }, s.prototype._update = function(t) {
      var e = this._hmac().update(this.V).update([0]);
      t && (e = e.update(t)), this.K = e.digest(), this.V = this._hmac().update(this.V).digest(), t && (this.K = this._hmac().update(this.V).update([1]).update(t).digest(), this.V = this._hmac().update(this.V).digest())
    }, s.prototype.reseed = function(t, s, h, r) {
      "string" != typeof s && (r = h, h = s, s = null), t = e.toArray(t, s), h = e.toArray(h, r), i(t.length >= this.minEntropy / 8, "Not enough entropy. Minimum is: " + this.minEntropy + " bits"), this._update(t.concat(h || [])), this._reseed = 1
    }, s.prototype.generate = function(t, i, s, h) {
      if (this._reseed > this.reseedInterval) throw new Error("Reseed is required");
      "string" != typeof i && (h = s, s = i, i = null), s && (s = e.toArray(s, h || "hex"), this._update(s));
      for (var r = []; r.length < t;) this.V = this._hmac().update(this.V).digest(), r = r.concat(this.V);
      var n = r.slice(0, t);
      return this._update(s), this._reseed++, e.encode(n, i)
    };
  }, {
    "hash.js": "fVGI",
    "minimalistic-crypto-utils": "vl2S",
    "minimalistic-assert": "MpuC"
  }],
  "YPk7": [function(require, module, exports) {
    "use strict";
    var t = require("bn.js"),
      i = require("../utils"),
      e = i.assert;

    function r(t, i) {
      this.ec = t, this.priv = null, this.pub = null, i.priv && this._importPrivate(i.priv, i.privEnc), i.pub && this._importPublic(i.pub, i.pubEnc)
    }
    module.exports = r, r.fromPublic = function(t, i, e) {
      return i instanceof r ? i : new r(t, {
        pub: i,
        pubEnc: e
      })
    }, r.fromPrivate = function(t, i, e) {
      return i instanceof r ? i : new r(t, {
        priv: i,
        privEnc: e
      })
    }, r.prototype.validate = function() {
      var t = this.getPublic();
      return t.isInfinity() ? {
        result: !1,
        reason: "Invalid public key"
      } : t.validate() ? t.mul(this.ec.curve.n).isInfinity() ? {
        result: !0,
        reason: null
      } : {
        result: !1,
        reason: "Public key * N != O"
      } : {
        result: !1,
        reason: "Public key is not a point"
      }
    }, r.prototype.getPublic = function(t, i) {
      return "string" == typeof t && (i = t, t = null), this.pub || (this.pub = this.ec.g.mul(this.priv)), i ? this.pub.encode(i, t) : this.pub
    }, r.prototype.getPrivate = function(t) {
      return "hex" === t ? this.priv.toString(16, 2) : this.priv
    }, r.prototype._importPrivate = function(i, e) {
      this.priv = new t(i, e || 16), this.priv = this.priv.umod(this.ec.curve.n)
    }, r.prototype._importPublic = function(t, i) {
      if (t.x || t.y) return "mont" === this.ec.curve.type ? e(t.x, "Need x coordinate") : "short" !== this.ec.curve.type && "edwards" !== this.ec.curve.type || e(t.x && t.y, "Need both x and y coordinate"), void(this.pub = this.ec.curve.point(t.x, t.y));
      this.pub = this.ec.curve.decodePoint(t, i)
    }, r.prototype.derive = function(t) {
      return t.validate() || e(t.validate(), "public point not validated"), t.mul(this.priv).getX()
    }, r.prototype.sign = function(t, i, e) {
      return this.ec.sign(t, this, i, e)
    }, r.prototype.verify = function(t, i) {
      return this.ec.verify(t, i, this)
    }, r.prototype.inspect = function() {
      return "<Key priv: " + (this.priv && this.priv.toString(16, 2)) + " pub: " + (this.pub && this.pub.inspect()) + " >"
    };
  }, {
    "bn.js": "AGD1",
    "../utils": "F8Ez"
  }],
  "g9QR": [function(require, module, exports) {
    "use strict";
    var r = require("bn.js"),
      e = require("../utils"),
      t = e.assert;

    function n(e, a) {
      if (e instanceof n) return e;
      this._importDER(e, a) || (t(e.r && e.s, "Signature without r or s"), this.r = new r(e.r, 16), this.s = new r(e.s, 16), void 0 === e.recoveryParam ? this.recoveryParam = null : this.recoveryParam = e.recoveryParam)
    }

    function a() {
      this.place = 0
    }

    function i(r, e) {
      var t = r[e.place++];
      if (!(128 & t)) return t;
      var n = 15 & t;
      if (0 === n || n > 4) return !1;
      for (var a = 0, i = 0, c = e.place; i < n; i++, c++) a <<= 8, a |= r[c], a >>>= 0;
      return !(a <= 127) && (e.place = c, a)
    }

    function c(r) {
      for (var e = 0, t = r.length - 1; !r[e] && !(128 & r[e + 1]) && e < t;) e++;
      return 0 === e ? r : r.slice(e)
    }

    function o(r, e) {
      if (e < 128) r.push(e);
      else {
        var t = 1 + (Math.log(e) / Math.LN2 >>> 3);
        for (r.push(128 | t); --t;) r.push(e >>> (t << 3) & 255);
        r.push(e)
      }
    }
    module.exports = n, n.prototype._importDER = function(t, n) {
      t = e.toArray(t, n);
      var c = new a;
      if (48 !== t[c.place++]) return !1;
      var o = i(t, c);
      if (!1 === o) return !1;
      if (o + c.place !== t.length) return !1;
      if (2 !== t[c.place++]) return !1;
      var u = i(t, c);
      if (!1 === u) return !1;
      var s = t.slice(c.place, u + c.place);
      if (c.place += u, 2 !== t[c.place++]) return !1;
      var l = i(t, c);
      if (!1 === l) return !1;
      if (t.length !== l + c.place) return !1;
      var f = t.slice(c.place, l + c.place);
      if (0 === s[0]) {
        if (!(128 & s[1])) return !1;
        s = s.slice(1)
      }
      if (0 === f[0]) {
        if (!(128 & f[1])) return !1;
        f = f.slice(1)
      }
      return this.r = new r(s), this.s = new r(f), this.recoveryParam = null, !0
    }, n.prototype.toDER = function(r) {
      var t = this.r.toArray(),
        n = this.s.toArray();
      for (128 & t[0] && (t = [0].concat(t)), 128 & n[0] && (n = [0].concat(n)), t = c(t), n = c(n); !(n[0] || 128 & n[1]);) n = n.slice(1);
      var a = [2];
      o(a, t.length), (a = a.concat(t)).push(2), o(a, n.length);
      var i = a.concat(n),
        u = [48];
      return o(u, i.length), u = u.concat(i), e.encode(u, r)
    };
  }, {
    "bn.js": "AGD1",
    "../utils": "F8Ez"
  }],
  "Ly8t": [function(require, module, exports) {
    "use strict";
    var e = require("bn.js"),
      r = require("hmac-drbg"),
      t = require("../utils"),
      n = require("../curves"),
      i = require("brorand"),
      s = t.assert,
      o = require("./key"),
      u = require("./signature");

    function h(e) {
      if (!(this instanceof h)) return new h(e);
      "string" == typeof e && (s(Object.prototype.hasOwnProperty.call(n, e), "Unknown curve " + e), e = n[e]), e instanceof n.PresetCurve && (e = {
        curve: e
      }), this.curve = e.curve.curve, this.n = this.curve.n, this.nh = this.n.ushrn(1), this.g = this.curve.g, this.g = e.curve.g, this.g.precompute(e.curve.n.bitLength() + 1), this.hash = e.hash || e.curve.hash
    }
    module.exports = h, h.prototype.keyPair = function(e) {
      return new o(this, e)
    }, h.prototype.keyFromPrivate = function(e, r) {
      return o.fromPrivate(this, e, r)
    }, h.prototype.keyFromPublic = function(e, r) {
      return o.fromPublic(this, e, r)
    }, h.prototype.genKeyPair = function(t) {
      t || (t = {});
      for (var n = new r({
          hash: this.hash,
          pers: t.pers,
          persEnc: t.persEnc || "utf8",
          entropy: t.entropy || i(this.hash.hmacStrength),
          entropyEnc: t.entropy && t.entropyEnc || "utf8",
          nonce: this.n.toArray()
        }), s = this.n.byteLength(), o = this.n.sub(new e(2));;) {
        var u = new e(n.generate(s));
        if (!(u.cmp(o) > 0)) return u.iaddn(1), this.keyFromPrivate(u)
      }
    }, h.prototype._truncateToN = function(e, r) {
      var t = 8 * e.byteLength() - this.n.bitLength();
      return t > 0 && (e = e.ushrn(t)), !r && e.cmp(this.n) >= 0 ? e.sub(this.n) : e
    }, h.prototype.sign = function(t, n, i, s) {
      "object" == typeof i && (s = i, i = null), s || (s = {}), n = this.keyFromPrivate(n, i), t = this._truncateToN(new e(t, 16));
      for (var o = this.n.byteLength(), h = n.getPrivate().toArray("be", o), c = t.toArray("be", o), a = new r({
          hash: this.hash,
          entropy: h,
          nonce: c,
          pers: s.pers,
          persEnc: s.persEnc || "utf8"
        }), p = this.n.sub(new e(1)), m = 0;; m++) {
        var v = s.k ? s.k(m) : new e(a.generate(this.n.byteLength()));
        if (!((v = this._truncateToN(v, !0)).cmpn(1) <= 0 || v.cmp(p) >= 0)) {
          var y = this.g.mul(v);
          if (!y.isInfinity()) {
            var f = y.getX(),
              g = f.umod(this.n);
            if (0 !== g.cmpn(0)) {
              var d = v.invm(this.n).mul(g.mul(n.getPrivate()).iadd(t));
              if (0 !== (d = d.umod(this.n)).cmpn(0)) {
                var l = (y.getY().isOdd() ? 1 : 0) | (0 !== f.cmp(g) ? 2 : 0);
                return s.canonical && d.cmp(this.nh) > 0 && (d = this.n.sub(d), l ^= 1), new u({
                  r: g,
                  s: d,
                  recoveryParam: l
                })
              }
            }
          }
        }
      }
    }, h.prototype.verify = function(r, t, n, i) {
      r = this._truncateToN(new e(r, 16)), n = this.keyFromPublic(n, i);
      var s = (t = new u(t, "hex")).r,
        o = t.s;
      if (s.cmpn(1) < 0 || s.cmp(this.n) >= 0) return !1;
      if (o.cmpn(1) < 0 || o.cmp(this.n) >= 0) return !1;
      var h, c = o.invm(this.n),
        a = c.mul(r).umod(this.n),
        p = c.mul(s).umod(this.n);
      return this.curve._maxwellTrick ? !(h = this.g.jmulAdd(a, n.getPublic(), p)).isInfinity() && h.eqXToP(s) : !(h = this.g.mulAdd(a, n.getPublic(), p)).isInfinity() && 0 === h.getX().umod(this.n).cmp(s)
    }, h.prototype.recoverPubKey = function(r, t, n, i) {
      s((3 & n) === n, "The recovery param is more than two bits"), t = new u(t, i);
      var o = this.n,
        h = new e(r),
        c = t.r,
        a = t.s,
        p = 1 & n,
        m = n >> 1;
      if (c.cmp(this.curve.p.umod(this.curve.n)) >= 0 && m) throw new Error("Unable to find sencond key candinate");
      c = m ? this.curve.pointFromX(c.add(this.curve.n), p) : this.curve.pointFromX(c, p);
      var v = t.r.invm(o),
        y = o.sub(h).mul(v).umod(o),
        f = a.mul(v).umod(o);
      return this.g.mulAdd(y, c, f)
    }, h.prototype.getKeyRecoveryParam = function(e, r, t, n) {
      if (null !== (r = new u(r, n)).recoveryParam) return r.recoveryParam;
      for (var i = 0; i < 4; i++) {
        var s;
        try {
          s = this.recoverPubKey(e, r, i)
        } catch (e) {
          continue
        }
        if (s.eq(t)) return i
      }
      throw new Error("Unable to find valid recovery factor")
    };
  }, {
    "bn.js": "AGD1",
    "hmac-drbg": "vdhc",
    "../utils": "F8Ez",
    "../curves": "ExaX",
    "brorand": "e03B",
    "./key": "YPk7",
    "./signature": "g9QR"
  }],
  "mg26": [function(require, module, exports) {
    "use strict";
    var t = require("../utils"),
      e = t.assert,
      s = t.parseBytes,
      i = t.cachedProperty;

    function n(t, e) {
      this.eddsa = t, this._secret = s(e.secret), t.isPoint(e.pub) ? this._pub = e.pub : this._pubBytes = s(e.pub)
    }
    n.fromPublic = function(t, e) {
      return e instanceof n ? e : new n(t, {
        pub: e
      })
    }, n.fromSecret = function(t, e) {
      return e instanceof n ? e : new n(t, {
        secret: e
      })
    }, n.prototype.secret = function() {
      return this._secret
    }, i(n, "pubBytes", function() {
      return this.eddsa.encodePoint(this.pub())
    }), i(n, "pub", function() {
      return this._pubBytes ? this.eddsa.decodePoint(this._pubBytes) : this.eddsa.g.mul(this.priv())
    }), i(n, "privBytes", function() {
      var t = this.eddsa,
        e = this.hash(),
        s = t.encodingLength - 1,
        i = e.slice(0, t.encodingLength);
      return i[0] &= 248, i[s] &= 127, i[s] |= 64, i
    }), i(n, "priv", function() {
      return this.eddsa.decodeInt(this.privBytes())
    }), i(n, "hash", function() {
      return this.eddsa.hash().update(this.secret()).digest()
    }), i(n, "messagePrefix", function() {
      return this.hash().slice(this.eddsa.encodingLength)
    }), n.prototype.sign = function(t) {
      return e(this._secret, "KeyPair can only verify"), this.eddsa.sign(t, this)
    }, n.prototype.verify = function(t, e) {
      return this.eddsa.verify(t, e, this)
    }, n.prototype.getSecret = function(s) {
      return e(this._secret, "KeyPair is public only"), t.encode(this.secret(), s)
    }, n.prototype.getPublic = function(e) {
      return t.encode(this.pubBytes(), e)
    }, module.exports = n;
  }, {
    "../utils": "F8Ez"
  }],
  "p5it": [function(require, module, exports) {
    "use strict";
    var e = require("bn.js"),
      t = require("../utils"),
      n = t.assert,
      o = t.cachedProperty,
      d = t.parseBytes;

    function i(t, o) {
      this.eddsa = t, "object" != typeof o && (o = d(o)), Array.isArray(o) && (o = {
        R: o.slice(0, t.encodingLength),
        S: o.slice(t.encodingLength)
      }), n(o.R && o.S, "Signature without R or S"), t.isPoint(o.R) && (this._R = o.R), o.S instanceof e && (this._S = o.S), this._Rencoded = Array.isArray(o.R) ? o.R : o.Rencoded, this._Sencoded = Array.isArray(o.S) ? o.S : o.Sencoded
    }
    o(i, "S", function() {
      return this.eddsa.decodeInt(this.Sencoded())
    }), o(i, "R", function() {
      return this.eddsa.decodePoint(this.Rencoded())
    }), o(i, "Rencoded", function() {
      return this.eddsa.encodePoint(this.R())
    }), o(i, "Sencoded", function() {
      return this.eddsa.encodeInt(this.S())
    }), i.prototype.toBytes = function() {
      return this.Rencoded().concat(this.Sencoded())
    }, i.prototype.toHex = function() {
      return t.encode(this.toBytes(), "hex").toUpperCase()
    }, module.exports = i;
  }, {
    "bn.js": "AGD1",
    "../utils": "F8Ez"
  }],
  "a3LM": [function(require, module, exports) {
    "use strict";
    var t = require("hash.js"),
      e = require("../curves"),
      n = require("../utils"),
      r = n.assert,
      i = n.parseBytes,
      o = require("./key"),
      s = require("./signature");

    function u(n) {
      if (r("ed25519" === n, "only tested with ed25519 so far"), !(this instanceof u)) return new u(n);
      n = e[n].curve, this.curve = n, this.g = n.g, this.g.precompute(n.n.bitLength() + 1), this.pointClass = n.point().constructor, this.encodingLength = Math.ceil(n.n.bitLength() / 8), this.hash = t.sha512
    }
    module.exports = u, u.prototype.sign = function(t, e) {
      t = i(t);
      var n = this.keyFromSecret(e),
        r = this.hashInt(n.messagePrefix(), t),
        o = this.g.mul(r),
        s = this.encodePoint(o),
        u = this.hashInt(s, n.pubBytes(), t).mul(n.priv()),
        h = r.add(u).umod(this.curve.n);
      return this.makeSignature({
        R: o,
        S: h,
        Rencoded: s
      })
    }, u.prototype.verify = function(t, e, n) {
      t = i(t), e = this.makeSignature(e);
      var r = this.keyFromPublic(n),
        o = this.hashInt(e.Rencoded(), r.pubBytes(), t),
        s = this.g.mul(e.S());
      return e.R().add(r.pub().mul(o)).eq(s)
    }, u.prototype.hashInt = function() {
      for (var t = this.hash(), e = 0; e < arguments.length; e++) t.update(arguments[e]);
      return n.intFromLE(t.digest()).umod(this.curve.n)
    }, u.prototype.keyFromPublic = function(t) {
      return o.fromPublic(this, t)
    }, u.prototype.keyFromSecret = function(t) {
      return o.fromSecret(this, t)
    }, u.prototype.makeSignature = function(t) {
      return t instanceof s ? t : new s(this, t)
    }, u.prototype.encodePoint = function(t) {
      var e = t.getY().toArray("le", this.encodingLength);
      return e[this.encodingLength - 1] |= t.getX().isOdd() ? 128 : 0, e
    }, u.prototype.decodePoint = function(t) {
      var e = (t = n.parseBytes(t)).length - 1,
        r = t.slice(0, e).concat(-129 & t[e]),
        i = 0 != (128 & t[e]),
        o = n.intFromLE(r);
      return this.curve.pointFromY(o, i)
    }, u.prototype.encodeInt = function(t) {
      return t.toArray("le", this.encodingLength)
    }, u.prototype.decodeInt = function(t) {
      return n.intFromLE(t)
    }, u.prototype.isPoint = function(t) {
      return t instanceof this.pointClass
    };
  }, {
    "hash.js": "fVGI",
    "../curves": "ExaX",
    "../utils": "F8Ez",
    "./key": "mg26",
    "./signature": "p5it"
  }],
  "xha3": [function(require, module, exports) {
    "use strict";
    var e = exports;
    e.version = require("../package.json").version, e.utils = require("./elliptic/utils"), e.rand = require("brorand"), e.curve = require("./elliptic/curve"), e.curves = require("./elliptic/curves"), e.ec = require("./elliptic/ec"), e.eddsa = require("./elliptic/eddsa");
  }, {
    "../package.json": "bNi7",
    "./elliptic/utils": "F8Ez",
    "brorand": "e03B",
    "./elliptic/curve": "P4Ml",
    "./elliptic/curves": "ExaX",
    "./elliptic/ec": "Ly8t",
    "./elliptic/eddsa": "a3LM"
  }],
  "P2po": [function(require, module, exports) {
    const t = t => {
        const e = t => (t => t.length % 2 == 0 ? t : "0" + t)(t.toString(16)),
          n = (t, n) => t < 56 ? e(n + t) : e(n + e(t).length / 2 + 55) + e(t),
          r = t => {
            if ("string" == typeof t) {
              const e = t.slice(2);
              return (2 != e.length || e >= "80" ? n(e.length / 2, 128) : "") + e
            } {
              const e = t.map(r).join("");
              return n(e.length / 2, 192) + e
            }
          };
        return "0x" + r(t)
      },
      e = t => {
        let e = 2;
        const n = () => {
            if (e >= t.length) throw "";
            const n = t.slice(e, e + 2);
            return n < "80" ? (e += 2, "0x" + n) : n < "c0" ? c() : s()
          },
          r = () => {
            const n = parseInt(t.slice(e, e += 2), 16) % 64;
            return n < 56 ? n : parseInt(t.slice(e, e += 2 * (n - 55)), 16)
          },
          c = () => {
            const n = r();
            return "0x" + t.slice(e, e += 2 * n)
          },
          s = () => {
            const t = 2 * r() + e;
            let c = [];
            for (; e < t;) c.push(n());
            return c
          };
        try {
          return n()
        } catch (o) {
          return []
        }
      };
    module.exports = {
      encode: t,
      decode: e
    };
  }, {}],
  "Yt2k": [function(require, module, exports) {
    var Buffer = require("buffer").Buffer;
    var e = require("buffer").Buffer;
    const r = require("./bytes"),
      c = require("./nat"),
      t = require("elliptic"),
      n = require("./rlp"),
      i = new t.ec("secp256k1"),
      {
        keccak256: o,
        keccak256s: s
      } = require("./hash"),
      a = e => {
        const c = o(r.concat(r.random(32), e || r.random(32))),
          t = r.concat(r.concat(r.random(32), c), r.random(32)),
          n = o(t);
        return u(n)
      },
      l = e => {
        const r = s(e.slice(2));
        let c = "0x";
        for (let t = 0; t < 40; t++) c += parseInt(r[t + 2], 16) > 7 ? e[t + 2].toUpperCase() : e[t + 2];
        return c
      },
      u = r => {
        const c = new e(r.slice(2), "hex"),
          t = "0x" + i.keyFromPrivate(c).getPublic(!1, "hex").slice(2),
          n = o(t);
        return {
          address: l("0x" + n.slice(-40)),
          privateKey: r
        }
      },
      m = ([e, c, t]) => r.flatten([c, t, e]),
      x = e => [r.slice(64, r.length(e), e), r.slice(0, 32, e), r.slice(32, 64, e)],
      d = t => (n, o) => {
        const s = i.keyFromPrivate(new e(o.slice(2), "hex")).sign(new e(n.slice(2), "hex"), {
          canonical: !0
        });
        return m([c.fromString(r.fromNumber(t + s.recoveryParam)), r.pad(32, r.fromNat("0x" + s.r.toString(16))), r.pad(32, r.fromNat("0x" + s.s.toString(16)))])
      },
      v = d(27),
      f = (c, t) => {
        const n = x(t),
          s = {
            v: r.toNumber(n[0]),
            r: n[1].slice(2),
            s: n[2].slice(2)
          },
          a = "0x" + i.recoverPubKey(new e(c.slice(2), "hex"), s, s.v < 2 ? s.v : 1 - s.v % 2).encode("hex", !1).slice(2),
          u = o(a);
        return l("0x" + u.slice(-40))
      };
    module.exports = {
      create: a,
      toChecksum: l,
      fromPrivate: u,
      sign: v,
      makeSigner: d,
      recover: f,
      encodeSignature: m,
      decodeSignature: x
    };
  }, {
    "./bytes": "k4zK",
    "./nat": "wlQN",
    "elliptic": "xha3",
    "./rlp": "P2po",
    "./hash": "Swo0",
    "buffer": "dskh"
  }],
  "wyv4": [function(require, module, exports) {

    var r = require("buffer"),
      e = r.Buffer;

    function o(r, e) {
      for (var o in r) e[o] = r[o]
    }

    function n(r, o, n) {
      return e(r, o, n)
    }
    e.from && e.alloc && e.allocUnsafe && e.allocUnsafeSlow ? module.exports = r : (o(r, exports), exports.Buffer = n), n.prototype = Object.create(e.prototype), o(e, n), n.from = function(r, o, n) {
      if ("number" == typeof r) throw new TypeError("Argument must not be a number");
      return e(r, o, n)
    }, n.alloc = function(r, o, n) {
      if ("number" != typeof r) throw new TypeError("Argument must be a number");
      var t = e(r);
      return void 0 !== o ? "string" == typeof n ? t.fill(o, n) : t.fill(o) : t.fill(0), t
    }, n.allocUnsafe = function(r) {
      if ("number" != typeof r) throw new TypeError("Argument must be a number");
      return e(r)
    }, n.allocUnsafeSlow = function(e) {
      if ("number" != typeof e) throw new TypeError("Argument must be a number");
      return r.SlowBuffer(e)
    };
  }, {
    "buffer": "dskh"
  }],
  "bUoY": [function(require, module, exports) {

    "use strict";

    function t(t, e) {
      var n = Object.keys(t);
      if (Object.getOwnPropertySymbols) {
        var a = Object.getOwnPropertySymbols(t);
        e && (a = a.filter(function(e) {
          return Object.getOwnPropertyDescriptor(t, e).enumerable
        })), n.push.apply(n, a)
      }
      return n
    }

    function e(e) {
      for (var a = 1; a < arguments.length; a++) {
        var i = null != arguments[a] ? arguments[a] : {};
        a % 2 ? t(Object(i), !0).forEach(function(t) {
          n(e, t, i[t])
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(i)) : t(Object(i)).forEach(function(t) {
          Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(i, t))
        })
      }
      return e
    }

    function n(t, e, n) {
      return e in t ? Object.defineProperty(t, e, {
        value: n,
        enumerable: !0,
        configurable: !0,
        writable: !0
      }) : t[e] = n, t
    }

    function a(t, e) {
      if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
    }

    function i(t, e) {
      for (var n = 0; n < e.length; n++) {
        var a = e[n];
        a.enumerable = a.enumerable || !1, a.configurable = !0, "value" in a && (a.writable = !0), Object.defineProperty(t, a.key, a)
      }
    }

    function r(t, e, n) {
      return e && i(t.prototype, e), n && i(t, n), t
    }
    var h = require("buffer"),
      l = h.Buffer,
      s = require("util"),
      u = s.inspect,
      o = u && u.custom || "inspect";

    function c(t, e, n) {
      l.prototype.copy.call(t, e, n)
    }
    module.exports = function() {
      function t() {
        a(this, t), this.head = null, this.tail = null, this.length = 0
      }
      return r(t, [{
        key: "push",
        value: function(t) {
          var e = {
            data: t,
            next: null
          };
          this.length > 0 ? this.tail.next = e : this.head = e, this.tail = e, ++this.length
        }
      }, {
        key: "unshift",
        value: function(t) {
          var e = {
            data: t,
            next: this.head
          };
          0 === this.length && (this.tail = e), this.head = e, ++this.length
        }
      }, {
        key: "shift",
        value: function() {
          if (0 !== this.length) {
            var t = this.head.data;
            return 1 === this.length ? this.head = this.tail = null : this.head = this.head.next, --this.length, t
          }
        }
      }, {
        key: "clear",
        value: function() {
          this.head = this.tail = null, this.length = 0
        }
      }, {
        key: "join",
        value: function(t) {
          if (0 === this.length) return "";
          for (var e = this.head, n = "" + e.data; e = e.next;) n += t + e.data;
          return n
        }
      }, {
        key: "concat",
        value: function(t) {
          if (0 === this.length) return l.alloc(0);
          for (var e = l.allocUnsafe(t >>> 0), n = this.head, a = 0; n;) c(n.data, e, a), a += n.data.length, n = n.next;
          return e
        }
      }, {
        key: "consume",
        value: function(t, e) {
          var n;
          return t < this.head.data.length ? (n = this.head.data.slice(0, t), this.head.data = this.head.data.slice(t)) : n = t === this.head.data.length ? this.shift() : e ? this._getString(t) : this._getBuffer(t), n
        }
      }, {
        key: "first",
        value: function() {
          return this.head.data
        }
      }, {
        key: "_getString",
        value: function(t) {
          var e = this.head,
            n = 1,
            a = e.data;
          for (t -= a.length; e = e.next;) {
            var i = e.data,
              r = t > i.length ? i.length : t;
            if (r === i.length ? a += i : a += i.slice(0, t), 0 === (t -= r)) {
              r === i.length ? (++n, e.next ? this.head = e.next : this.head = this.tail = null) : (this.head = e, e.data = i.slice(r));
              break
            }++n
          }
          return this.length -= n, a
        }
      }, {
        key: "_getBuffer",
        value: function(t) {
          var e = l.allocUnsafe(t),
            n = this.head,
            a = 1;
          for (n.data.copy(e), t -= n.data.length; n = n.next;) {
            var i = n.data,
              r = t > i.length ? i.length : t;
            if (i.copy(e, e.length - t, 0, r), 0 === (t -= r)) {
              r === i.length ? (++a, n.next ? this.head = n.next : this.head = this.tail = null) : (this.head = n, n.data = i.slice(r));
              break
            }++a
          }
          return this.length -= a, e
        }
      }, {
        key: o,
        value: function(t, n) {
          return u(this, e({}, n, {
            depth: 0,
            customInspect: !1
          }))
        }
      }]), t
    }();
  }, {
    "buffer": "dskh",
    "util": "rDCW"
  }],
  "DoEV": [function(require, module, exports) {
    var process = require("process");
    var t = require("process");

    function e(e, r) {
      var d = this,
        l = this._readableState && this._readableState.destroyed,
        o = this._writableState && this._writableState.destroyed;
      return l || o ? (r ? r(e) : e && (this._writableState ? this._writableState.errorEmitted || (this._writableState.errorEmitted = !0, t.nextTick(s, this, e)) : t.nextTick(s, this, e)), this) : (this._readableState && (this._readableState.destroyed = !0), this._writableState && (this._writableState.destroyed = !0), this._destroy(e || null, function(e) {
        !r && e ? d._writableState ? d._writableState.errorEmitted ? t.nextTick(i, d) : (d._writableState.errorEmitted = !0, t.nextTick(a, d, e)) : t.nextTick(a, d, e) : r ? (t.nextTick(i, d), r(e)) : t.nextTick(i, d)
      }), this)
    }

    function a(t, e) {
      s(t, e), i(t)
    }

    function i(t) {
      t._writableState && !t._writableState.emitClose || t._readableState && !t._readableState.emitClose || t.emit("close")
    }

    function r() {
      this._readableState && (this._readableState.destroyed = !1, this._readableState.reading = !1, this._readableState.ended = !1, this._readableState.endEmitted = !1), this._writableState && (this._writableState.destroyed = !1, this._writableState.ended = !1, this._writableState.ending = !1, this._writableState.finalCalled = !1, this._writableState.prefinished = !1, this._writableState.finished = !1, this._writableState.errorEmitted = !1)
    }

    function s(t, e) {
      t.emit("error", e)
    }

    function d(t, e) {
      var a = t._readableState,
        i = t._writableState;
      a && a.autoDestroy || i && i.autoDestroy ? t.destroy(e) : t.emit("error", e)
    }
    module.exports = {
      destroy: e,
      undestroy: r,
      errorOrDestroy: d
    };
  }, {
    "process": "pBGv"
  }],
  "eV81": [function(require, module, exports) {
    "use strict";

    function t(n) {
      return (t = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t) {
        return typeof t
      } : function(t) {
        return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
      })(n)
    }

    function n(t, n) {
      t.prototype = Object.create(n.prototype), t.prototype.constructor = t, t.__proto__ = n
    }
    var e = {};

    function o(t, o, r) {
      r || (r = Error);
      var c = function(t) {
        function e(n, e, r) {
          return t.call(this, function(t, n, e) {
            return "string" == typeof o ? o : o(t, n, e)
          }(n, e, r)) || this
        }
        return n(e, t), e
      }(r);
      c.prototype.name = r.name, c.prototype.code = t, e[t] = c
    }

    function r(t, n) {
      if (Array.isArray(t)) {
        var e = t.length;
        return t = t.map(function(t) {
          return String(t)
        }), e > 2 ? "one of ".concat(n, " ").concat(t.slice(0, e - 1).join(", "), ", or ") + t[e - 1] : 2 === e ? "one of ".concat(n, " ").concat(t[0], " or ").concat(t[1]) : "of ".concat(n, " ").concat(t[0])
      }
      return "of ".concat(n, " ").concat(String(t))
    }

    function c(t, n, e) {
      return t.substr(!e || e < 0 ? 0 : +e, n.length) === n
    }

    function a(t, n, e) {
      return (void 0 === e || e > t.length) && (e = t.length), t.substring(e - n.length, e) === n
    }

    function u(t, n, e) {
      return "number" != typeof e && (e = 0), !(e + n.length > t.length) && -1 !== t.indexOf(n, e)
    }
    o("ERR_INVALID_OPT_VALUE", function(t, n) {
      return 'The value "' + n + '" is invalid for option "' + t + '"'
    }, TypeError), o("ERR_INVALID_ARG_TYPE", function(n, e, o) {
      var i, E;
      if ("string" == typeof e && c(e, "not ") ? (i = "must not be", e = e.replace(/^not /, "")) : i = "must be", a(n, " argument")) E = "The ".concat(n, " ").concat(i, " ").concat(r(e, "type"));
      else {
        var f = u(n, ".") ? "property" : "argument";
        E = 'The "'.concat(n, '" ').concat(f, " ").concat(i, " ").concat(r(e, "type"))
      }
      return E += ". Received type ".concat(t(o))
    }, TypeError), o("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF"), o("ERR_METHOD_NOT_IMPLEMENTED", function(t) {
      return "The " + t + " method is not implemented"
    }), o("ERR_STREAM_PREMATURE_CLOSE", "Premature close"), o("ERR_STREAM_DESTROYED", function(t) {
      return "Cannot call " + t + " after a stream was destroyed"
    }), o("ERR_MULTIPLE_CALLBACK", "Callback called multiple times"), o("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable"), o("ERR_STREAM_WRITE_AFTER_END", "write after end"), o("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError), o("ERR_UNKNOWN_ENCODING", function(t) {
      return "Unknown encoding: " + t
    }, TypeError), o("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event"), module.exports.codes = e;
  }, {}],
  "nks4": [function(require, module, exports) {
    "use strict";
    var r = require("../../../errors").codes.ERR_INVALID_OPT_VALUE;

    function e(r, e, t) {
      return null != r.highWaterMark ? r.highWaterMark : e ? r[t] : null
    }

    function t(t, i, o, a) {
      var n = e(i, a, o);
      if (null != n) {
        if (!isFinite(n) || Math.floor(n) !== n || n < 0) throw new r(a ? o : "highWaterMark", n);
        return Math.floor(n)
      }
      return t.objectMode ? 16 : 16384
    }
    module.exports = {
      getHighWaterMark: t
    };
  }, {
    "../../../errors": "eV81"
  }],
  "zgAi": [function(require, module, exports) {

    var global = arguments[3];
    var process = require("process");
    var e, t = arguments[3],
      n = require("process");

    function r(e, t, n) {
      this.chunk = e, this.encoding = t, this.callback = n, this.next = null
    }

    function i(e) {
      var t = this;
      this.next = null, this.entry = null, this.finish = function() {
        G(t, e)
      }
    }
    module.exports = x, x.WritableState = m;
    var o = {
        deprecate: require("util-deprecate")
      },
      s = require("./internal/streams/stream"),
      u = require("buffer").Buffer,
      f = t.Uint8Array || function() {};

    function a(e) {
      return u.from(e)
    }

    function c(e) {
      return u.isBuffer(e) || e instanceof f
    }
    var l, d = require("./internal/streams/destroy"),
      h = require("./internal/streams/state"),
      b = h.getHighWaterMark,
      p = require("../errors").codes,
      y = p.ERR_INVALID_ARG_TYPE,
      w = p.ERR_METHOD_NOT_IMPLEMENTED,
      g = p.ERR_MULTIPLE_CALLBACK,
      _ = p.ERR_STREAM_CANNOT_PIPE,
      R = p.ERR_STREAM_DESTROYED,
      k = p.ERR_STREAM_NULL_VALUES,
      E = p.ERR_STREAM_WRITE_AFTER_END,
      S = p.ERR_UNKNOWN_ENCODING,
      q = d.errorOrDestroy;

    function v() {}

    function m(t, n, r) {
      e = e || require("./_stream_duplex"), t = t || {}, "boolean" != typeof r && (r = n instanceof e), this.objectMode = !!t.objectMode, r && (this.objectMode = this.objectMode || !!t.writableObjectMode), this.highWaterMark = b(this, t, "writableHighWaterMark", r), this.finalCalled = !1, this.needDrain = !1, this.ending = !1, this.ended = !1, this.finished = !1, this.destroyed = !1;
      var o = !1 === t.decodeStrings;
      this.decodeStrings = !o, this.defaultEncoding = t.defaultEncoding || "utf8", this.length = 0, this.writing = !1, this.corked = 0, this.sync = !0, this.bufferProcessing = !1, this.onwrite = function(e) {
        O(n, e)
      }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = !1, this.errorEmitted = !1, this.emitClose = !1 !== t.emitClose, this.autoDestroy = !!t.autoDestroy, this.bufferedRequestCount = 0, this.corkedRequestsFree = new i(this)
    }

    function x(t) {
      var n = this instanceof(e = e || require("./_stream_duplex"));
      if (!n && !l.call(x, this)) return new x(t);
      this._writableState = new m(t, this, n), this.writable = !0, t && ("function" == typeof t.write && (this._write = t.write), "function" == typeof t.writev && (this._writev = t.writev), "function" == typeof t.destroy && (this._destroy = t.destroy), "function" == typeof t.final && (this._final = t.final)), s.call(this)
    }

    function M(e, t) {
      var r = new E;
      q(e, r), n.nextTick(t, r)
    }

    function B(e, t, r, i) {
      var o;
      return null === r ? o = new k : "string" == typeof r || t.objectMode || (o = new y("chunk", ["string", "Buffer"], r)), !o || (q(e, o), n.nextTick(i, o), !1)
    }

    function T(e, t, n) {
      return e.objectMode || !1 === e.decodeStrings || "string" != typeof t || (t = u.from(t, n)), t
    }

    function D(e, t, n, r, i, o) {
      if (!n) {
        var s = T(t, r, i);
        r !== s && (n = !0, i = "buffer", r = s)
      }
      var u = t.objectMode ? 1 : r.length;
      t.length += u;
      var f = t.length < t.highWaterMark;
      if (f || (t.needDrain = !0), t.writing || t.corked) {
        var a = t.lastBufferedRequest;
        t.lastBufferedRequest = {
          chunk: r,
          encoding: i,
          isBuf: n,
          callback: o,
          next: null
        }, a ? a.next = t.lastBufferedRequest : t.bufferedRequest = t.lastBufferedRequest, t.bufferedRequestCount += 1
      } else P(e, t, !1, u, r, i, o);
      return f
    }

    function P(e, t, n, r, i, o, s) {
      t.writelen = r, t.writecb = s, t.writing = !0, t.sync = !0, t.destroyed ? t.onwrite(new R("write")) : n ? e._writev(i, t.onwrite) : e._write(i, o, t.onwrite), t.sync = !1
    }

    function j(e, t, r, i, o) {
      --t.pendingcb, r ? (n.nextTick(o, i), n.nextTick(U, e, t), e._writableState.errorEmitted = !0, q(e, i)) : (o(i), e._writableState.errorEmitted = !0, q(e, i), U(e, t))
    }

    function C(e) {
      e.writing = !1, e.writecb = null, e.length -= e.writelen, e.writelen = 0
    }

    function O(e, t) {
      var r = e._writableState,
        i = r.sync,
        o = r.writecb;
      if ("function" != typeof o) throw new g;
      if (C(r), t) j(e, r, i, t, o);
      else {
        var s = I(r) || e.destroyed;
        s || r.corked || r.bufferProcessing || !r.bufferedRequest || N(e, r), i ? n.nextTick(A, e, r, s, o) : A(e, r, s, o)
      }
    }

    function A(e, t, n, r) {
      n || L(e, t), t.pendingcb--, r(), U(e, t)
    }

    function L(e, t) {
      0 === t.length && t.needDrain && (t.needDrain = !1, e.emit("drain"))
    }

    function N(e, t) {
      t.bufferProcessing = !0;
      var n = t.bufferedRequest;
      if (e._writev && n && n.next) {
        var r = t.bufferedRequestCount,
          o = new Array(r),
          s = t.corkedRequestsFree;
        s.entry = n;
        for (var u = 0, f = !0; n;) o[u] = n, n.isBuf || (f = !1), n = n.next, u += 1;
        o.allBuffers = f, P(e, t, !0, t.length, o, "", s.finish), t.pendingcb++, t.lastBufferedRequest = null, s.next ? (t.corkedRequestsFree = s.next, s.next = null) : t.corkedRequestsFree = new i(t), t.bufferedRequestCount = 0
      } else {
        for (; n;) {
          var a = n.chunk,
            c = n.encoding,
            l = n.callback;
          if (P(e, t, !1, t.objectMode ? 1 : a.length, a, c, l), n = n.next, t.bufferedRequestCount--, t.writing) break
        }
        null === n && (t.lastBufferedRequest = null)
      }
      t.bufferedRequest = n, t.bufferProcessing = !1
    }

    function I(e) {
      return e.ending && 0 === e.length && null === e.bufferedRequest && !e.finished && !e.writing
    }

    function W(e, t) {
      e._final(function(n) {
        t.pendingcb--, n && q(e, n), t.prefinished = !0, e.emit("prefinish"), U(e, t)
      })
    }

    function F(e, t) {
      t.prefinished || t.finalCalled || ("function" != typeof e._final || t.destroyed ? (t.prefinished = !0, e.emit("prefinish")) : (t.pendingcb++, t.finalCalled = !0, n.nextTick(W, e, t)))
    }

    function U(e, t) {
      var n = I(t);
      if (n && (F(e, t), 0 === t.pendingcb && (t.finished = !0, e.emit("finish"), t.autoDestroy))) {
        var r = e._readableState;
        (!r || r.autoDestroy && r.endEmitted) && e.destroy()
      }
      return n
    }

    function H(e, t, r) {
      t.ending = !0, U(e, t), r && (t.finished ? n.nextTick(r) : e.once("finish", r)), t.ended = !0, e.writable = !1
    }

    function G(e, t, n) {
      var r = e.entry;
      for (e.entry = null; r;) {
        var i = r.callback;
        t.pendingcb--, i(n), r = r.next
      }
      t.corkedRequestsFree.next = e
    }
    require("inherits")(x, s), m.prototype.getBuffer = function() {
        for (var e = this.bufferedRequest, t = []; e;) t.push(e), e = e.next;
        return t
      },
      function() {
        try {
          Object.defineProperty(m.prototype, "buffer", {
            get: o.deprecate(function() {
              return this.getBuffer()
            }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
          })
        } catch (e) {}
      }(), "function" == typeof Symbol && Symbol.hasInstance && "function" == typeof Function.prototype[Symbol.hasInstance] ? (l = Function.prototype[Symbol.hasInstance], Object.defineProperty(x, Symbol.hasInstance, {
        value: function(e) {
          return !!l.call(this, e) || this === x && (e && e._writableState instanceof m)
        }
      })) : l = function(e) {
        return e instanceof this
      }, x.prototype.pipe = function() {
        q(this, new _)
      }, x.prototype.write = function(e, t, n) {
        var r = this._writableState,
          i = !1,
          o = !r.objectMode && c(e);
        return o && !u.isBuffer(e) && (e = a(e)), "function" == typeof t && (n = t, t = null), o ? t = "buffer" : t || (t = r.defaultEncoding), "function" != typeof n && (n = v), r.ending ? M(this, n) : (o || B(this, r, e, n)) && (r.pendingcb++, i = D(this, r, o, e, t, n)), i
      }, x.prototype.cork = function() {
        this._writableState.corked++
      }, x.prototype.uncork = function() {
        var e = this._writableState;
        e.corked && (e.corked--, e.writing || e.corked || e.bufferProcessing || !e.bufferedRequest || N(this, e))
      }, x.prototype.setDefaultEncoding = function(e) {
        if ("string" == typeof e && (e = e.toLowerCase()), !(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((e + "").toLowerCase()) > -1)) throw new S(e);
        return this._writableState.defaultEncoding = e, this
      }, Object.defineProperty(x.prototype, "writableBuffer", {
        enumerable: !1,
        get: function() {
          return this._writableState && this._writableState.getBuffer()
        }
      }), Object.defineProperty(x.prototype, "writableHighWaterMark", {
        enumerable: !1,
        get: function() {
          return this._writableState.highWaterMark
        }
      }), x.prototype._write = function(e, t, n) {
        n(new w("_write()"))
      }, x.prototype._writev = null, x.prototype.end = function(e, t, n) {
        var r = this._writableState;
        return "function" == typeof e ? (n = e, e = null, t = null) : "function" == typeof t && (n = t, t = null), null != e && this.write(e, t), r.corked && (r.corked = 1, this.uncork()), r.ending || H(this, r, n), this
      }, Object.defineProperty(x.prototype, "writableLength", {
        enumerable: !1,
        get: function() {
          return this._writableState.length
        }
      }), Object.defineProperty(x.prototype, "destroyed", {
        enumerable: !1,
        get: function() {
          return void 0 !== this._writableState && this._writableState.destroyed
        },
        set: function(e) {
          this._writableState && (this._writableState.destroyed = e)
        }
      }), x.prototype.destroy = d.destroy, x.prototype._undestroy = d.undestroy, x.prototype._destroy = function(e, t) {
        t(e)
      };
  }, {
    "util-deprecate": "yM1o",
    "./internal/streams/stream": "ExO1",
    "buffer": "dskh",
    "./internal/streams/destroy": "DoEV",
    "./internal/streams/state": "nks4",
    "../errors": "eV81",
    "inherits": "Bm0n",
    "./_stream_duplex": "DaSy",
    "process": "pBGv"
  }],
  "DaSy": [function(require, module, exports) {
    var process = require("process");
    var e = require("process"),
      t = Object.keys || function(e) {
        var t = [];
        for (var r in e) t.push(r);
        return t
      };
    module.exports = l;
    var r = require("./_stream_readable"),
      a = require("./_stream_writable");
    require("inherits")(l, r);
    for (var i = t(a.prototype), n = 0; n < i.length; n++) {
      var o = i[n];
      l.prototype[o] || (l.prototype[o] = a.prototype[o])
    }

    function l(e) {
      if (!(this instanceof l)) return new l(e);
      r.call(this, e), a.call(this, e), this.allowHalfOpen = !0, e && (!1 === e.readable && (this.readable = !1), !1 === e.writable && (this.writable = !1), !1 === e.allowHalfOpen && (this.allowHalfOpen = !1, this.once("end", s)))
    }

    function s() {
      this._writableState.ended || e.nextTick(b, this)
    }

    function b(e) {
      e.end()
    }
    Object.defineProperty(l.prototype, "writableHighWaterMark", {
      enumerable: !1,
      get: function() {
        return this._writableState.highWaterMark
      }
    }), Object.defineProperty(l.prototype, "writableBuffer", {
      enumerable: !1,
      get: function() {
        return this._writableState && this._writableState.getBuffer()
      }
    }), Object.defineProperty(l.prototype, "writableLength", {
      enumerable: !1,
      get: function() {
        return this._writableState.length
      }
    }), Object.defineProperty(l.prototype, "destroyed", {
      enumerable: !1,
      get: function() {
        return void 0 !== this._readableState && void 0 !== this._writableState && (this._readableState.destroyed && this._writableState.destroyed)
      },
      set: function(e) {
        void 0 !== this._readableState && void 0 !== this._writableState && (this._readableState.destroyed = e, this._writableState.destroyed = e)
      }
    });
  }, {
    "./_stream_readable": "KcKo",
    "./_stream_writable": "zgAi",
    "inherits": "Bm0n",
    "process": "pBGv"
  }],
  "z0rv": [function(require, module, exports) {

    "use strict";
    var t = require("safe-buffer").Buffer,
      e = t.isEncoding || function(t) {
        switch ((t = "" + t) && t.toLowerCase()) {
          case "hex":
          case "utf8":
          case "utf-8":
          case "ascii":
          case "binary":
          case "base64":
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
          case "raw":
            return !0;
          default:
            return !1
        }
      };

    function s(t) {
      if (!t) return "utf8";
      for (var e;;) switch (t) {
        case "utf8":
        case "utf-8":
          return "utf8";
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return "utf16le";
        case "latin1":
        case "binary":
          return "latin1";
        case "base64":
        case "ascii":
        case "hex":
          return t;
        default:
          if (e) return;
          t = ("" + t).toLowerCase(), e = !0
      }
    }

    function i(i) {
      var a = s(i);
      if ("string" != typeof a && (t.isEncoding === e || !e(i))) throw new Error("Unknown encoding: " + i);
      return a || i
    }

    function a(e) {
      var s;
      switch (this.encoding = i(e), this.encoding) {
        case "utf16le":
          this.text = c, this.end = f, s = 4;
          break;
        case "utf8":
          this.fillLast = l, s = 4;
          break;
        case "base64":
          this.text = d, this.end = g, s = 3;
          break;
        default:
          return this.write = N, void(this.end = v)
      }
      this.lastNeed = 0, this.lastTotal = 0, this.lastChar = t.allocUnsafe(s)
    }

    function r(t) {
      return t <= 127 ? 0 : t >> 5 == 6 ? 2 : t >> 4 == 14 ? 3 : t >> 3 == 30 ? 4 : t >> 6 == 2 ? -1 : -2
    }

    function n(t, e, s) {
      var i = e.length - 1;
      if (i < s) return 0;
      var a = r(e[i]);
      return a >= 0 ? (a > 0 && (t.lastNeed = a - 1), a) : --i < s || -2 === a ? 0 : (a = r(e[i])) >= 0 ? (a > 0 && (t.lastNeed = a - 2), a) : --i < s || -2 === a ? 0 : (a = r(e[i])) >= 0 ? (a > 0 && (2 === a ? a = 0 : t.lastNeed = a - 3), a) : 0
    }

    function h(t, e, s) {
      if (128 != (192 & e[0])) return t.lastNeed = 0, "";
      if (t.lastNeed > 1 && e.length > 1) {
        if (128 != (192 & e[1])) return t.lastNeed = 1, "";
        if (t.lastNeed > 2 && e.length > 2 && 128 != (192 & e[2])) return t.lastNeed = 2, ""
      }
    }

    function l(t) {
      var e = this.lastTotal - this.lastNeed,
        s = h(this, t, e);
      return void 0 !== s ? s : this.lastNeed <= t.length ? (t.copy(this.lastChar, e, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal)) : (t.copy(this.lastChar, e, 0, t.length), void(this.lastNeed -= t.length))
    }

    function u(t, e) {
      var s = n(this, t, e);
      if (!this.lastNeed) return t.toString("utf8", e);
      this.lastTotal = s;
      var i = t.length - (s - this.lastNeed);
      return t.copy(this.lastChar, 0, i), t.toString("utf8", e, i)
    }

    function o(t) {
      var e = t && t.length ? this.write(t) : "";
      return this.lastNeed ? e + "" : e
    }

    function c(t, e) {
      if ((t.length - e) % 2 == 0) {
        var s = t.toString("utf16le", e);
        if (s) {
          var i = s.charCodeAt(s.length - 1);
          if (i >= 55296 && i <= 56319) return this.lastNeed = 2, this.lastTotal = 4, this.lastChar[0] = t[t.length - 2], this.lastChar[1] = t[t.length - 1], s.slice(0, -1)
        }
        return s
      }
      return this.lastNeed = 1, this.lastTotal = 2, this.lastChar[0] = t[t.length - 1], t.toString("utf16le", e, t.length - 1)
    }

    function f(t) {
      var e = t && t.length ? this.write(t) : "";
      if (this.lastNeed) {
        var s = this.lastTotal - this.lastNeed;
        return e + this.lastChar.toString("utf16le", 0, s)
      }
      return e
    }

    function d(t, e) {
      var s = (t.length - e) % 3;
      return 0 === s ? t.toString("base64", e) : (this.lastNeed = 3 - s, this.lastTotal = 3, 1 === s ? this.lastChar[0] = t[t.length - 1] : (this.lastChar[0] = t[t.length - 2], this.lastChar[1] = t[t.length - 1]), t.toString("base64", e, t.length - s))
    }

    function g(t) {
      var e = t && t.length ? this.write(t) : "";
      return this.lastNeed ? e + this.lastChar.toString("base64", 0, 3 - this.lastNeed) : e
    }

    function N(t) {
      return t.toString(this.encoding)
    }

    function v(t) {
      return t && t.length ? this.write(t) : ""
    }
    exports.StringDecoder = a, a.prototype.write = function(t) {
      if (0 === t.length) return "";
      var e, s;
      if (this.lastNeed) {
        if (void 0 === (e = this.fillLast(t))) return "";
        s = this.lastNeed, this.lastNeed = 0
      } else s = 0;
      return s < t.length ? e ? e + this.text(t, s) : this.text(t, s) : e || ""
    }, a.prototype.end = o, a.prototype.text = u, a.prototype.fillLast = function(t) {
      if (this.lastNeed <= t.length) return t.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
      t.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, t.length), this.lastNeed -= t.length
    };
  }, {
    "safe-buffer": "wyv4"
  }],
  "P4rJ": [function(require, module, exports) {
    "use strict";
    var e = require("../../../errors").codes.ERR_STREAM_PREMATURE_CLOSE;

    function r(e) {
      var r = !1;
      return function() {
        if (!r) {
          r = !0;
          for (var t = arguments.length, n = new Array(t), o = 0; o < t; o++) n[o] = arguments[o];
          e.apply(this, n)
        }
      }
    }

    function t() {}

    function n(e) {
      return e.setHeader && "function" == typeof e.abort
    }

    function o(i, a, l) {
      if ("function" == typeof a) return o(i, null, a);
      a || (a = {}), l = r(l || t);
      var s = a.readable || !1 !== a.readable && i.readable,
        c = a.writable || !1 !== a.writable && i.writable,
        u = function() {
          i.writable || d()
        },
        f = i._writableState && i._writableState.finished,
        d = function() {
          c = !1, f = !0, s || l.call(i)
        },
        b = i._readableState && i._readableState.endEmitted,
        v = function() {
          s = !1, b = !0, c || l.call(i)
        },
        m = function(e) {
          l.call(i, e)
        },
        w = function() {
          var r;
          return s && !b ? (i._readableState && i._readableState.ended || (r = new e), l.call(i, r)) : c && !f ? (i._writableState && i._writableState.ended || (r = new e), l.call(i, r)) : void 0
        },
        _ = function() {
          i.req.on("finish", d)
        };
      return n(i) ? (i.on("complete", d), i.on("abort", w), i.req ? _() : i.on("request", _)) : c && !i._writableState && (i.on("end", u), i.on("close", u)), i.on("end", v), i.on("finish", d), !1 !== a.error && i.on("error", m), i.on("close", w),
        function() {
          i.removeListener("complete", d), i.removeListener("abort", w), i.removeListener("request", _), i.req && i.req.removeListener("finish", d), i.removeListener("end", u), i.removeListener("close", u), i.removeListener("finish", d), i.removeListener("end", v), i.removeListener("error", m), i.removeListener("close", w)
        }
    }
    module.exports = o;
  }, {
    "../../../errors": "eV81"
  }],
  "WOaN": [function(require, module, exports) {
    var process = require("process");
    var e, n = require("process");

    function r(e, n, r) {
      return n in e ? Object.defineProperty(e, n, {
        value: r,
        enumerable: !0,
        configurable: !0,
        writable: !0
      }) : e[n] = r, e
    }
    var t = require("./end-of-stream"),
      l = Symbol("lastResolve"),
      u = Symbol("lastReject"),
      i = Symbol("error"),
      o = Symbol("ended"),
      a = Symbol("lastPromise"),
      s = Symbol("handlePromise"),
      c = Symbol("stream");

    function f(e, n) {
      return {
        value: e,
        done: n
      }
    }

    function v(e) {
      var n = e[l];
      if (null !== n) {
        var r = e[c].read();
        null !== r && (e[a] = null, e[l] = null, e[u] = null, n(f(r, !1)))
      }
    }

    function d(e) {
      n.nextTick(v, e)
    }

    function b(e, n) {
      return function(r, t) {
        e.then(function() {
          n[o] ? r(f(void 0, !0)) : n[s](r, t)
        }, t)
      }
    }
    var m = Object.getPrototypeOf(function() {}),
      h = Object.setPrototypeOf((r(e = {
        get stream() {
          return this[c]
        },
        next: function() {
          var e = this,
            r = this[i];
          if (null !== r) return Promise.reject(r);
          if (this[o]) return Promise.resolve(f(void 0, !0));
          if (this[c].destroyed) return new Promise(function(r, t) {
            n.nextTick(function() {
              e[i] ? t(e[i]) : r(f(void 0, !0))
            })
          });
          var t, l = this[a];
          if (l) t = new Promise(b(l, this));
          else {
            var u = this[c].read();
            if (null !== u) return Promise.resolve(f(u, !1));
            t = new Promise(this[s])
          }
          return this[a] = t, t
        }
      }, Symbol.asyncIterator, function() {
        return this
      }), r(e, "return", function() {
        var e = this;
        return new Promise(function(n, r) {
          e[c].destroy(null, function(e) {
            e ? r(e) : n(f(void 0, !0))
          })
        })
      }), e), m),
      y = function(e) {
        var n, v = Object.create(h, (r(n = {}, c, {
          value: e,
          writable: !0
        }), r(n, l, {
          value: null,
          writable: !0
        }), r(n, u, {
          value: null,
          writable: !0
        }), r(n, i, {
          value: null,
          writable: !0
        }), r(n, o, {
          value: e._readableState.endEmitted,
          writable: !0
        }), r(n, s, {
          value: function(e, n) {
            var r = v[c].read();
            r ? (v[a] = null, v[l] = null, v[u] = null, e(f(r, !1))) : (v[l] = e, v[u] = n)
          },
          writable: !0
        }), n));
        return v[a] = null, t(e, function(e) {
          if (e && "ERR_STREAM_PREMATURE_CLOSE" !== e.code) {
            var n = v[u];
            return null !== n && (v[a] = null, v[l] = null, v[u] = null, n(e)), void(v[i] = e)
          }
          var r = v[l];
          null !== r && (v[a] = null, v[l] = null, v[u] = null, r(f(void 0, !0))), v[o] = !0
        }), e.on("readable", d.bind(null, v)), v
      };
    module.exports = y;
  }, {
    "./end-of-stream": "P4rJ",
    "process": "pBGv"
  }],
  "pIwT": [function(require, module, exports) {
    module.exports = function() {
      throw new Error("Readable.from is not available in the browser")
    };
  }, {}],
  "KcKo": [function(require, module, exports) {

    var global = arguments[3];
    var process = require("process");
    var e, t = arguments[3],
      n = require("process");
    module.exports = j, j.ReadableState = L;
    var r = require("events").EventEmitter,
      i = function(e, t) {
        return e.listeners(t).length
      },
      a = require("./internal/streams/stream"),
      d = require("buffer").Buffer,
      o = t.Uint8Array || function() {};

    function s(e) {
      return d.from(e)
    }

    function l(e) {
      return d.isBuffer(e) || e instanceof o
    }
    var u, h = require("util");
    u = h && h.debuglog ? h.debuglog("stream") : function() {};
    var p, f, c, b = require("./internal/streams/buffer_list"),
      g = require("./internal/streams/destroy"),
      m = require("./internal/streams/state"),
      y = m.getHighWaterMark,
      _ = require("../errors").codes,
      v = _.ERR_INVALID_ARG_TYPE,
      w = _.ERR_STREAM_PUSH_AFTER_EOF,
      S = _.ERR_METHOD_NOT_IMPLEMENTED,
      R = _.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;
    require("inherits")(j, a);
    var M = g.errorOrDestroy,
      E = ["error", "close", "destroy", "pause", "resume"];

    function k(e, t, n) {
      if ("function" == typeof e.prependListener) return e.prependListener(t, n);
      e._events && e._events[t] ? Array.isArray(e._events[t]) ? e._events[t].unshift(n) : e._events[t] = [n, e._events[t]] : e.on(t, n)
    }

    function L(t, n, r) {
      e = e || require("./_stream_duplex"), t = t || {}, "boolean" != typeof r && (r = n instanceof e), this.objectMode = !!t.objectMode, r && (this.objectMode = this.objectMode || !!t.readableObjectMode), this.highWaterMark = y(this, t, "readableHighWaterMark", r), this.buffer = new b, this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = !1, this.endEmitted = !1, this.reading = !1, this.sync = !0, this.needReadable = !1, this.emittedReadable = !1, this.readableListening = !1, this.resumeScheduled = !1, this.paused = !0, this.emitClose = !1 !== t.emitClose, this.autoDestroy = !!t.autoDestroy, this.destroyed = !1, this.defaultEncoding = t.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore = !1, this.decoder = null, this.encoding = null, t.encoding && (p || (p = require("string_decoder/").StringDecoder), this.decoder = new p(t.encoding), this.encoding = t.encoding)
    }

    function j(t) {
      if (e = e || require("./_stream_duplex"), !(this instanceof j)) return new j(t);
      var n = this instanceof e;
      this._readableState = new L(t, this, n), this.readable = !0, t && ("function" == typeof t.read && (this._read = t.read), "function" == typeof t.destroy && (this._destroy = t.destroy)), a.call(this)
    }

    function D(e, t, n, r, i) {
      u("readableAddChunk", t);
      var a, o = e._readableState;
      if (null === t) o.reading = !1, A(e, o);
      else if (i || (a = T(o, t)), a) M(e, a);
      else if (o.objectMode || t && t.length > 0)
        if ("string" == typeof t || o.objectMode || Object.getPrototypeOf(t) === d.prototype || (t = s(t)), r) o.endEmitted ? M(e, new R) : C(e, o, t, !0);
        else if (o.ended) M(e, new w);
      else {
        if (o.destroyed) return !1;
        o.reading = !1, o.decoder && !n ? (t = o.decoder.write(t), o.objectMode || 0 !== t.length ? C(e, o, t, !1) : U(e, o)) : C(e, o, t, !1)
      } else r || (o.reading = !1, U(e, o));
      return !o.ended && (o.length < o.highWaterMark || 0 === o.length)
    }

    function C(e, t, n, r) {
      t.flowing && 0 === t.length && !t.sync ? (t.awaitDrain = 0, e.emit("data", n)) : (t.length += t.objectMode ? 1 : n.length, r ? t.buffer.unshift(n) : t.buffer.push(n), t.needReadable && O(e)), U(e, t)
    }

    function T(e, t) {
      var n;
      return l(t) || "string" == typeof t || void 0 === t || e.objectMode || (n = new v("chunk", ["string", "Buffer", "Uint8Array"], t)), n
    }
    Object.defineProperty(j.prototype, "destroyed", {
      enumerable: !1,
      get: function() {
        return void 0 !== this._readableState && this._readableState.destroyed
      },
      set: function(e) {
        this._readableState && (this._readableState.destroyed = e)
      }
    }), j.prototype.destroy = g.destroy, j.prototype._undestroy = g.undestroy, j.prototype._destroy = function(e, t) {
      t(e)
    }, j.prototype.push = function(e, t) {
      var n, r = this._readableState;
      return r.objectMode ? n = !0 : "string" == typeof e && ((t = t || r.defaultEncoding) !== r.encoding && (e = d.from(e, t), t = ""), n = !0), D(this, e, t, !1, n)
    }, j.prototype.unshift = function(e) {
      return D(this, e, null, !0, !1)
    }, j.prototype.isPaused = function() {
      return !1 === this._readableState.flowing
    }, j.prototype.setEncoding = function(e) {
      p || (p = require("string_decoder/").StringDecoder);
      var t = new p(e);
      this._readableState.decoder = t, this._readableState.encoding = this._readableState.decoder.encoding;
      for (var n = this._readableState.buffer.head, r = ""; null !== n;) r += t.write(n.data), n = n.next;
      return this._readableState.buffer.clear(), "" !== r && this._readableState.buffer.push(r), this._readableState.length = r.length, this
    };
    var q = 1073741824;

    function W(e) {
      return e >= q ? e = q : (e--, e |= e >>> 1, e |= e >>> 2, e |= e >>> 4, e |= e >>> 8, e |= e >>> 16, e++), e
    }

    function x(e, t) {
      return e <= 0 || 0 === t.length && t.ended ? 0 : t.objectMode ? 1 : e != e ? t.flowing && t.length ? t.buffer.head.data.length : t.length : (e > t.highWaterMark && (t.highWaterMark = W(e)), e <= t.length ? e : t.ended ? t.length : (t.needReadable = !0, 0))
    }

    function A(e, t) {
      if (u("onEofChunk"), !t.ended) {
        if (t.decoder) {
          var n = t.decoder.end();
          n && n.length && (t.buffer.push(n), t.length += t.objectMode ? 1 : n.length)
        }
        t.ended = !0, t.sync ? O(e) : (t.needReadable = !1, t.emittedReadable || (t.emittedReadable = !0, P(e)))
      }
    }

    function O(e) {
      var t = e._readableState;
      u("emitReadable", t.needReadable, t.emittedReadable), t.needReadable = !1, t.emittedReadable || (u("emitReadable", t.flowing), t.emittedReadable = !0, n.nextTick(P, e))
    }

    function P(e) {
      var t = e._readableState;
      u("emitReadable_", t.destroyed, t.length, t.ended), t.destroyed || !t.length && !t.ended || (e.emit("readable"), t.emittedReadable = !1), t.needReadable = !t.flowing && !t.ended && t.length <= t.highWaterMark, G(e)
    }

    function U(e, t) {
      t.readingMore || (t.readingMore = !0, n.nextTick(N, e, t))
    }

    function N(e, t) {
      for (; !t.reading && !t.ended && (t.length < t.highWaterMark || t.flowing && 0 === t.length);) {
        var n = t.length;
        if (u("maybeReadMore read 0"), e.read(0), n === t.length) break
      }
      t.readingMore = !1
    }

    function H(e) {
      return function() {
        var t = e._readableState;
        u("pipeOnDrain", t.awaitDrain), t.awaitDrain && t.awaitDrain--, 0 === t.awaitDrain && i(e, "data") && (t.flowing = !0, G(e))
      }
    }

    function I(e) {
      var t = e._readableState;
      t.readableListening = e.listenerCount("readable") > 0, t.resumeScheduled && !t.paused ? t.flowing = !0 : e.listenerCount("data") > 0 && e.resume()
    }

    function F(e) {
      u("readable nexttick read 0"), e.read(0)
    }

    function B(e, t) {
      t.resumeScheduled || (t.resumeScheduled = !0, n.nextTick(V, e, t))
    }

    function V(e, t) {
      u("resume", t.reading), t.reading || e.read(0), t.resumeScheduled = !1, e.emit("resume"), G(e), t.flowing && !t.reading && e.read(0)
    }

    function G(e) {
      var t = e._readableState;
      for (u("flow", t.flowing); t.flowing && null !== e.read(););
    }

    function Y(e, t) {
      return 0 === t.length ? null : (t.objectMode ? n = t.buffer.shift() : !e || e >= t.length ? (n = t.decoder ? t.buffer.join("") : 1 === t.buffer.length ? t.buffer.first() : t.buffer.concat(t.length), t.buffer.clear()) : n = t.buffer.consume(e, t.decoder), n);
      var n
    }

    function z(e) {
      var t = e._readableState;
      u("endReadable", t.endEmitted), t.endEmitted || (t.ended = !0, n.nextTick(J, t, e))
    }

    function J(e, t) {
      if (u("endReadableNT", e.endEmitted, e.length), !e.endEmitted && 0 === e.length && (e.endEmitted = !0, t.readable = !1, t.emit("end"), e.autoDestroy)) {
        var n = t._writableState;
        (!n || n.autoDestroy && n.finished) && t.destroy()
      }
    }

    function K(e, t) {
      for (var n = 0, r = e.length; n < r; n++)
        if (e[n] === t) return n;
      return -1
    }
    j.prototype.read = function(e) {
      u("read", e), e = parseInt(e, 10);
      var t = this._readableState,
        n = e;
      if (0 !== e && (t.emittedReadable = !1), 0 === e && t.needReadable && ((0 !== t.highWaterMark ? t.length >= t.highWaterMark : t.length > 0) || t.ended)) return u("read: emitReadable", t.length, t.ended), 0 === t.length && t.ended ? z(this) : O(this), null;
      if (0 === (e = x(e, t)) && t.ended) return 0 === t.length && z(this), null;
      var r, i = t.needReadable;
      return u("need readable", i), (0 === t.length || t.length - e < t.highWaterMark) && u("length less than watermark", i = !0), t.ended || t.reading ? u("reading or ended", i = !1) : i && (u("do read"), t.reading = !0, t.sync = !0, 0 === t.length && (t.needReadable = !0), this._read(t.highWaterMark), t.sync = !1, t.reading || (e = x(n, t))), null === (r = e > 0 ? Y(e, t) : null) ? (t.needReadable = t.length <= t.highWaterMark, e = 0) : (t.length -= e, t.awaitDrain = 0), 0 === t.length && (t.ended || (t.needReadable = !0), n !== e && t.ended && z(this)), null !== r && this.emit("data", r), r
    }, j.prototype._read = function(e) {
      M(this, new S("_read()"))
    }, j.prototype.pipe = function(e, t) {
      var r = this,
        a = this._readableState;
      switch (a.pipesCount) {
        case 0:
          a.pipes = e;
          break;
        case 1:
          a.pipes = [a.pipes, e];
          break;
        default:
          a.pipes.push(e)
      }
      a.pipesCount += 1, u("pipe count=%d opts=%j", a.pipesCount, t);
      var d = (!t || !1 !== t.end) && e !== n.stdout && e !== n.stderr ? s : g;

      function o(t, n) {
        u("onunpipe"), t === r && n && !1 === n.hasUnpiped && (n.hasUnpiped = !0, u("cleanup"), e.removeListener("close", c), e.removeListener("finish", b), e.removeListener("drain", l), e.removeListener("error", f), e.removeListener("unpipe", o), r.removeListener("end", s), r.removeListener("end", g), r.removeListener("data", p), h = !0, !a.awaitDrain || e._writableState && !e._writableState.needDrain || l())
      }

      function s() {
        u("onend"), e.end()
      }
      a.endEmitted ? n.nextTick(d) : r.once("end", d), e.on("unpipe", o);
      var l = H(r);
      e.on("drain", l);
      var h = !1;

      function p(t) {
        u("ondata");
        var n = e.write(t);
        u("dest.write", n), !1 === n && ((1 === a.pipesCount && a.pipes === e || a.pipesCount > 1 && -1 !== K(a.pipes, e)) && !h && (u("false write response, pause", a.awaitDrain), a.awaitDrain++), r.pause())
      }

      function f(t) {
        u("onerror", t), g(), e.removeListener("error", f), 0 === i(e, "error") && M(e, t)
      }

      function c() {
        e.removeListener("finish", b), g()
      }

      function b() {
        u("onfinish"), e.removeListener("close", c), g()
      }

      function g() {
        u("unpipe"), r.unpipe(e)
      }
      return r.on("data", p), k(e, "error", f), e.once("close", c), e.once("finish", b), e.emit("pipe", r), a.flowing || (u("pipe resume"), r.resume()), e
    }, j.prototype.unpipe = function(e) {
      var t = this._readableState,
        n = {
          hasUnpiped: !1
        };
      if (0 === t.pipesCount) return this;
      if (1 === t.pipesCount) return e && e !== t.pipes ? this : (e || (e = t.pipes), t.pipes = null, t.pipesCount = 0, t.flowing = !1, e && e.emit("unpipe", this, n), this);
      if (!e) {
        var r = t.pipes,
          i = t.pipesCount;
        t.pipes = null, t.pipesCount = 0, t.flowing = !1;
        for (var a = 0; a < i; a++) r[a].emit("unpipe", this, {
          hasUnpiped: !1
        });
        return this
      }
      var d = K(t.pipes, e);
      return -1 === d ? this : (t.pipes.splice(d, 1), t.pipesCount -= 1, 1 === t.pipesCount && (t.pipes = t.pipes[0]), e.emit("unpipe", this, n), this)
    }, j.prototype.on = function(e, t) {
      var r = a.prototype.on.call(this, e, t),
        i = this._readableState;
      return "data" === e ? (i.readableListening = this.listenerCount("readable") > 0, !1 !== i.flowing && this.resume()) : "readable" === e && (i.endEmitted || i.readableListening || (i.readableListening = i.needReadable = !0, i.flowing = !1, i.emittedReadable = !1, u("on readable", i.length, i.reading), i.length ? O(this) : i.reading || n.nextTick(F, this))), r
    }, j.prototype.addListener = j.prototype.on, j.prototype.removeListener = function(e, t) {
      var r = a.prototype.removeListener.call(this, e, t);
      return "readable" === e && n.nextTick(I, this), r
    }, j.prototype.removeAllListeners = function(e) {
      var t = a.prototype.removeAllListeners.apply(this, arguments);
      return "readable" !== e && void 0 !== e || n.nextTick(I, this), t
    }, j.prototype.resume = function() {
      var e = this._readableState;
      return e.flowing || (u("resume"), e.flowing = !e.readableListening, B(this, e)), e.paused = !1, this
    }, j.prototype.pause = function() {
      return u("call pause flowing=%j", this._readableState.flowing), !1 !== this._readableState.flowing && (u("pause"), this._readableState.flowing = !1, this.emit("pause")), this._readableState.paused = !0, this
    }, j.prototype.wrap = function(e) {
      var t = this,
        n = this._readableState,
        r = !1;
      for (var i in e.on("end", function() {
          if (u("wrapped end"), n.decoder && !n.ended) {
            var e = n.decoder.end();
            e && e.length && t.push(e)
          }
          t.push(null)
        }), e.on("data", function(i) {
          (u("wrapped data"), n.decoder && (i = n.decoder.write(i)), n.objectMode && null == i) || (n.objectMode || i && i.length) && (t.push(i) || (r = !0, e.pause()))
        }), e) void 0 === this[i] && "function" == typeof e[i] && (this[i] = function(t) {
        return function() {
          return e[t].apply(e, arguments)
        }
      }(i));
      for (var a = 0; a < E.length; a++) e.on(E[a], this.emit.bind(this, E[a]));
      return this._read = function(t) {
        u("wrapped _read", t), r && (r = !1, e.resume())
      }, this
    }, "function" == typeof Symbol && (j.prototype[Symbol.asyncIterator] = function() {
      return void 0 === f && (f = require("./internal/streams/async_iterator")), f(this)
    }), Object.defineProperty(j.prototype, "readableHighWaterMark", {
      enumerable: !1,
      get: function() {
        return this._readableState.highWaterMark
      }
    }), Object.defineProperty(j.prototype, "readableBuffer", {
      enumerable: !1,
      get: function() {
        return this._readableState && this._readableState.buffer
      }
    }), Object.defineProperty(j.prototype, "readableFlowing", {
      enumerable: !1,
      get: function() {
        return this._readableState.flowing
      },
      set: function(e) {
        this._readableState && (this._readableState.flowing = e)
      }
    }), j._fromList = Y, Object.defineProperty(j.prototype, "readableLength", {
      enumerable: !1,
      get: function() {
        return this._readableState.length
      }
    }), "function" == typeof Symbol && (j.from = function(e, t) {
      return void 0 === c && (c = require("./internal/streams/from")), c(j, e, t)
    });
  }, {
    "events": "FRpO",
    "./internal/streams/stream": "ExO1",
    "buffer": "dskh",
    "util": "rDCW",
    "./internal/streams/buffer_list": "bUoY",
    "./internal/streams/destroy": "DoEV",
    "./internal/streams/state": "nks4",
    "../errors": "eV81",
    "inherits": "Bm0n",
    "./_stream_duplex": "DaSy",
    "string_decoder/": "z0rv",
    "./internal/streams/async_iterator": "WOaN",
    "./internal/streams/from": "pIwT",
    "process": "pBGv"
  }],
  "pm66": [function(require, module, exports) {
    "use strict";
    module.exports = o;
    var t = require("../errors").codes,
      r = t.ERR_METHOD_NOT_IMPLEMENTED,
      e = t.ERR_MULTIPLE_CALLBACK,
      n = t.ERR_TRANSFORM_ALREADY_TRANSFORMING,
      i = t.ERR_TRANSFORM_WITH_LENGTH_0,
      a = require("./_stream_duplex");

    function s(t, r) {
      var n = this._transformState;
      n.transforming = !1;
      var i = n.writecb;
      if (null === i) return this.emit("error", new e);
      n.writechunk = null, n.writecb = null, null != r && this.push(r), i(t);
      var a = this._readableState;
      a.reading = !1, (a.needReadable || a.length < a.highWaterMark) && this._read(a.highWaterMark)
    }

    function o(t) {
      if (!(this instanceof o)) return new o(t);
      a.call(this, t), this._transformState = {
        afterTransform: s.bind(this),
        needTransform: !1,
        transforming: !1,
        writecb: null,
        writechunk: null,
        writeencoding: null
      }, this._readableState.needReadable = !0, this._readableState.sync = !1, t && ("function" == typeof t.transform && (this._transform = t.transform), "function" == typeof t.flush && (this._flush = t.flush)), this.on("prefinish", h)
    }

    function h() {
      var t = this;
      "function" != typeof this._flush || this._readableState.destroyed ? f(this, null, null) : this._flush(function(r, e) {
        f(t, r, e)
      })
    }

    function f(t, r, e) {
      if (r) return t.emit("error", r);
      if (null != e && t.push(e), t._writableState.length) throw new i;
      if (t._transformState.transforming) throw new n;
      return t.push(null)
    }
    require("inherits")(o, a), o.prototype.push = function(t, r) {
      return this._transformState.needTransform = !1, a.prototype.push.call(this, t, r)
    }, o.prototype._transform = function(t, e, n) {
      n(new r("_transform()"))
    }, o.prototype._write = function(t, r, e) {
      var n = this._transformState;
      if (n.writecb = e, n.writechunk = t, n.writeencoding = r, !n.transforming) {
        var i = this._readableState;
        (n.needTransform || i.needReadable || i.length < i.highWaterMark) && this._read(i.highWaterMark)
      }
    }, o.prototype._read = function(t) {
      var r = this._transformState;
      null === r.writechunk || r.transforming ? r.needTransform = !0 : (r.transforming = !0, this._transform(r.writechunk, r.writeencoding, r.afterTransform))
    }, o.prototype._destroy = function(t, r) {
      a.prototype._destroy.call(this, t, function(t) {
        r(t)
      })
    };
  }, {
    "../errors": "eV81",
    "./_stream_duplex": "DaSy",
    "inherits": "Bm0n"
  }],
  "eQKX": [function(require, module, exports) {
    "use strict";
    module.exports = t;
    var r = require("./_stream_transform");

    function t(e) {
      if (!(this instanceof t)) return new t(e);
      r.call(this, e)
    }
    require("inherits")(t, r), t.prototype._transform = function(r, t, e) {
      e(null, r)
    };
  }, {
    "./_stream_transform": "pm66",
    "inherits": "Bm0n"
  }],
  "Qv1H": [function(require, module, exports) {
    "use strict";
    var r;

    function n(r) {
      var n = !1;
      return function() {
        n || (n = !0, r.apply(void 0, arguments))
      }
    }
    var t = require("../../../errors").codes,
      e = t.ERR_MISSING_ARGS,
      o = t.ERR_STREAM_DESTROYED;

    function i(r) {
      if (r) throw r
    }

    function u(r) {
      return r.setHeader && "function" == typeof r.abort
    }

    function f(t, e, i, f) {
      f = n(f);
      var a = !1;
      t.on("close", function() {
        a = !0
      }), void 0 === r && (r = require("./end-of-stream")), r(t, {
        readable: e,
        writable: i
      }, function(r) {
        if (r) return f(r);
        a = !0, f()
      });
      var c = !1;
      return function(r) {
        if (!a && !c) return c = !0, u(t) ? t.abort() : "function" == typeof t.destroy ? t.destroy() : void f(r || new o("pipe"))
      }
    }

    function a(r) {
      r()
    }

    function c(r, n) {
      return r.pipe(n)
    }

    function p(r) {
      return r.length ? "function" != typeof r[r.length - 1] ? i : r.pop() : i
    }

    function s() {
      for (var r = arguments.length, n = new Array(r), t = 0; t < r; t++) n[t] = arguments[t];
      var o, i = p(n);
      if (Array.isArray(n[0]) && (n = n[0]), n.length < 2) throw new e("streams");
      var u = n.map(function(r, t) {
        var e = t < n.length - 1;
        return f(r, e, t > 0, function(r) {
          o || (o = r), r && u.forEach(a), e || (u.forEach(a), i(o))
        })
      });
      return n.reduce(c)
    }
    module.exports = s;
  }, {
    "../../../errors": "eV81",
    "./end-of-stream": "P4rJ"
  }],
  "FEG8": [function(require, module, exports) {
    exports = module.exports = require("./lib/_stream_readable.js"), exports.Stream = exports, exports.Readable = exports, exports.Writable = require("./lib/_stream_writable.js"), exports.Duplex = require("./lib/_stream_duplex.js"), exports.Transform = require("./lib/_stream_transform.js"), exports.PassThrough = require("./lib/_stream_passthrough.js"), exports.finished = require("./lib/internal/streams/end-of-stream.js"), exports.pipeline = require("./lib/internal/streams/pipeline.js");
  }, {
    "./lib/_stream_readable.js": "KcKo",
    "./lib/_stream_writable.js": "zgAi",
    "./lib/_stream_duplex.js": "DaSy",
    "./lib/_stream_transform.js": "pm66",
    "./lib/_stream_passthrough.js": "eQKX",
    "./lib/internal/streams/end-of-stream.js": "P4rJ",
    "./lib/internal/streams/pipeline.js": "Qv1H"
  }],
  "UcQW": [function(require, module, exports) {

    "use strict";
    var t = require("safe-buffer").Buffer,
      e = require("readable-stream").Transform,
      i = require("inherits");

    function r(e, i) {
      if (!t.isBuffer(e) && "string" != typeof e) throw new TypeError(i + " must be a string or a buffer")
    }

    function o(i) {
      e.call(this), this._block = t.allocUnsafe(i), this._blockSize = i, this._blockOffset = 0, this._length = [0, 0, 0, 0], this._finalized = !1
    }
    i(o, e), o.prototype._transform = function(t, e, i) {
      var r = null;
      try {
        this.update(t, e)
      } catch (o) {
        r = o
      }
      i(r)
    }, o.prototype._flush = function(t) {
      var e = null;
      try {
        this.push(this.digest())
      } catch (i) {
        e = i
      }
      t(e)
    }, o.prototype.update = function(e, i) {
      if (r(e, "Data"), this._finalized) throw new Error("Digest already called");
      t.isBuffer(e) || (e = t.from(e, i));
      for (var o = this._block, s = 0; this._blockOffset + e.length - s >= this._blockSize;) {
        for (var f = this._blockOffset; f < this._blockSize;) o[f++] = e[s++];
        this._update(), this._blockOffset = 0
      }
      for (; s < e.length;) o[this._blockOffset++] = e[s++];
      for (var n = 0, h = 8 * e.length; h > 0; ++n) this._length[n] += h, (h = this._length[n] / 4294967296 | 0) > 0 && (this._length[n] -= 4294967296 * h);
      return this
    }, o.prototype._update = function() {
      throw new Error("_update is not implemented")
    }, o.prototype.digest = function(t) {
      if (this._finalized) throw new Error("Digest already called");
      this._finalized = !0;
      var e = this._digest();
      void 0 !== t && (e = e.toString(t)), this._block.fill(0), this._blockOffset = 0;
      for (var i = 0; i < 4; ++i) this._length[i] = 0;
      return e
    }, o.prototype._digest = function() {
      throw new Error("_digest is not implemented")
    }, module.exports = o;
  }, {
    "safe-buffer": "wyv4",
    "readable-stream": "FEG8",
    "inherits": "Bm0n"
  }],
  "OP64": [function(require, module, exports) {

    "use strict";
    var t = require("inherits"),
      i = require("hash-base"),
      s = require("safe-buffer").Buffer,
      e = new Array(16);

    function h() {
      i.call(this, 64), this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878
    }

    function r(t, i) {
      return t << i | t >>> 32 - i
    }

    function _(t, i, s, e, h, _, n) {
      return r(t + (i & s | ~i & e) + h + _ | 0, n) + i | 0
    }

    function n(t, i, s, e, h, _, n) {
      return r(t + (i & e | s & ~e) + h + _ | 0, n) + i | 0
    }

    function c(t, i, s, e, h, _, n) {
      return r(t + (i ^ s ^ e) + h + _ | 0, n) + i | 0
    }

    function f(t, i, s, e, h, _, n) {
      return r(t + (s ^ (i | ~e)) + h + _ | 0, n) + i | 0
    }
    t(h, i), h.prototype._update = function() {
      for (var t = e, i = 0; i < 16; ++i) t[i] = this._block.readInt32LE(4 * i);
      var s = this._a,
        h = this._b,
        r = this._c,
        o = this._d;
      s = _(s, h, r, o, t[0], 3614090360, 7), o = _(o, s, h, r, t[1], 3905402710, 12), r = _(r, o, s, h, t[2], 606105819, 17), h = _(h, r, o, s, t[3], 3250441966, 22), s = _(s, h, r, o, t[4], 4118548399, 7), o = _(o, s, h, r, t[5], 1200080426, 12), r = _(r, o, s, h, t[6], 2821735955, 17), h = _(h, r, o, s, t[7], 4249261313, 22), s = _(s, h, r, o, t[8], 1770035416, 7), o = _(o, s, h, r, t[9], 2336552879, 12), r = _(r, o, s, h, t[10], 4294925233, 17), h = _(h, r, o, s, t[11], 2304563134, 22), s = _(s, h, r, o, t[12], 1804603682, 7), o = _(o, s, h, r, t[13], 4254626195, 12), r = _(r, o, s, h, t[14], 2792965006, 17), s = n(s, h = _(h, r, o, s, t[15], 1236535329, 22), r, o, t[1], 4129170786, 5), o = n(o, s, h, r, t[6], 3225465664, 9), r = n(r, o, s, h, t[11], 643717713, 14), h = n(h, r, o, s, t[0], 3921069994, 20), s = n(s, h, r, o, t[5], 3593408605, 5), o = n(o, s, h, r, t[10], 38016083, 9), r = n(r, o, s, h, t[15], 3634488961, 14), h = n(h, r, o, s, t[4], 3889429448, 20), s = n(s, h, r, o, t[9], 568446438, 5), o = n(o, s, h, r, t[14], 3275163606, 9), r = n(r, o, s, h, t[3], 4107603335, 14), h = n(h, r, o, s, t[8], 1163531501, 20), s = n(s, h, r, o, t[13], 2850285829, 5), o = n(o, s, h, r, t[2], 4243563512, 9), r = n(r, o, s, h, t[7], 1735328473, 14), s = c(s, h = n(h, r, o, s, t[12], 2368359562, 20), r, o, t[5], 4294588738, 4), o = c(o, s, h, r, t[8], 2272392833, 11), r = c(r, o, s, h, t[11], 1839030562, 16), h = c(h, r, o, s, t[14], 4259657740, 23), s = c(s, h, r, o, t[1], 2763975236, 4), o = c(o, s, h, r, t[4], 1272893353, 11), r = c(r, o, s, h, t[7], 4139469664, 16), h = c(h, r, o, s, t[10], 3200236656, 23), s = c(s, h, r, o, t[13], 681279174, 4), o = c(o, s, h, r, t[0], 3936430074, 11), r = c(r, o, s, h, t[3], 3572445317, 16), h = c(h, r, o, s, t[6], 76029189, 23), s = c(s, h, r, o, t[9], 3654602809, 4), o = c(o, s, h, r, t[12], 3873151461, 11), r = c(r, o, s, h, t[15], 530742520, 16), s = f(s, h = c(h, r, o, s, t[2], 3299628645, 23), r, o, t[0], 4096336452, 6), o = f(o, s, h, r, t[7], 1126891415, 10), r = f(r, o, s, h, t[14], 2878612391, 15), h = f(h, r, o, s, t[5], 4237533241, 21), s = f(s, h, r, o, t[12], 1700485571, 6), o = f(o, s, h, r, t[3], 2399980690, 10), r = f(r, o, s, h, t[10], 4293915773, 15), h = f(h, r, o, s, t[1], 2240044497, 21), s = f(s, h, r, o, t[8], 1873313359, 6), o = f(o, s, h, r, t[15], 4264355552, 10), r = f(r, o, s, h, t[6], 2734768916, 15), h = f(h, r, o, s, t[13], 1309151649, 21), s = f(s, h, r, o, t[4], 4149444226, 6), o = f(o, s, h, r, t[11], 3174756917, 10), r = f(r, o, s, h, t[2], 718787259, 15), h = f(h, r, o, s, t[9], 3951481745, 21), this._a = this._a + s | 0, this._b = this._b + h | 0, this._c = this._c + r | 0, this._d = this._d + o | 0
    }, h.prototype._digest = function() {
      this._block[this._blockOffset++] = 128, this._blockOffset > 56 && (this._block.fill(0, this._blockOffset, 64), this._update(), this._blockOffset = 0), this._block.fill(0, this._blockOffset, 56), this._block.writeUInt32LE(this._length[0], 56), this._block.writeUInt32LE(this._length[1], 60), this._update();
      var t = s.allocUnsafe(16);
      return t.writeInt32LE(this._a, 0), t.writeInt32LE(this._b, 4), t.writeInt32LE(this._c, 8), t.writeInt32LE(this._d, 12), t
    }, module.exports = h;
  }, {
    "inherits": "Bm0n",
    "hash-base": "UcQW",
    "safe-buffer": "Wugr"
  }],
  "quyi": [function(require, module, exports) {

    "use strict";
    var t = require("buffer").Buffer,
      i = require("inherits"),
      s = require("hash-base"),
      h = new Array(16),
      e = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8, 3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12, 1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2, 4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13],
      _ = [5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12, 6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2, 15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13, 8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14, 12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11],
      r = [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8, 7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12, 11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5, 11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12, 9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6],
      n = [8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6, 9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11, 9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5, 15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8, 8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11],
      c = [0, 1518500249, 1859775393, 2400959708, 2840853838],
      o = [1352829926, 1548603684, 1836072691, 2053994217, 0];

    function f() {
      s.call(this, 64), this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520
    }

    function u(t, i) {
      return t << i | t >>> 32 - i
    }

    function l(t, i, s, h, e, _, r, n) {
      return u(t + (i ^ s ^ h) + _ + r | 0, n) + e | 0
    }

    function a(t, i, s, h, e, _, r, n) {
      return u(t + (i & s | ~i & h) + _ + r | 0, n) + e | 0
    }

    function b(t, i, s, h, e, _, r, n) {
      return u(t + ((i | ~s) ^ h) + _ + r | 0, n) + e | 0
    }

    function d(t, i, s, h, e, _, r, n) {
      return u(t + (i & h | s & ~h) + _ + r | 0, n) + e | 0
    }

    function k(t, i, s, h, e, _, r, n) {
      return u(t + (i ^ (s | ~h)) + _ + r | 0, n) + e | 0
    }
    i(f, s), f.prototype._update = function() {
      for (var t = h, i = 0; i < 16; ++i) t[i] = this._block.readInt32LE(4 * i);
      for (var s = 0 | this._a, f = 0 | this._b, w = 0 | this._c, p = 0 | this._d, E = 0 | this._e, I = 0 | this._a, L = 0 | this._b, v = 0 | this._c, O = 0 | this._d, g = 0 | this._e, q = 0; q < 80; q += 1) {
        var y, U;
        q < 16 ? (y = l(s, f, w, p, E, t[e[q]], c[0], r[q]), U = k(I, L, v, O, g, t[_[q]], o[0], n[q])) : q < 32 ? (y = a(s, f, w, p, E, t[e[q]], c[1], r[q]), U = d(I, L, v, O, g, t[_[q]], o[1], n[q])) : q < 48 ? (y = b(s, f, w, p, E, t[e[q]], c[2], r[q]), U = b(I, L, v, O, g, t[_[q]], o[2], n[q])) : q < 64 ? (y = d(s, f, w, p, E, t[e[q]], c[3], r[q]), U = a(I, L, v, O, g, t[_[q]], o[3], n[q])) : (y = k(s, f, w, p, E, t[e[q]], c[4], r[q]), U = l(I, L, v, O, g, t[_[q]], o[4], n[q])), s = E, E = p, p = u(w, 10), w = f, f = y, I = g, g = O, O = u(v, 10), v = L, L = U
      }
      var m = this._b + w + O | 0;
      this._b = this._c + p + g | 0, this._c = this._d + E + I | 0, this._d = this._e + s + L | 0, this._e = this._a + f + v | 0, this._a = m
    }, f.prototype._digest = function() {
      this._block[this._blockOffset++] = 128, this._blockOffset > 56 && (this._block.fill(0, this._blockOffset, 64), this._update(), this._blockOffset = 0), this._block.fill(0, this._blockOffset, 56), this._block.writeUInt32LE(this._length[0], 56), this._block.writeUInt32LE(this._length[1], 60), this._update();
      var i = t.alloc ? t.alloc(20) : new t(20);
      return i.writeInt32LE(this._a, 0), i.writeInt32LE(this._b, 4), i.writeInt32LE(this._c, 8), i.writeInt32LE(this._d, 12), i.writeInt32LE(this._e, 16), i
    }, module.exports = f;
  }, {
    "buffer": "dskh",
    "inherits": "Bm0n",
    "hash-base": "UcQW"
  }],
  "VHby": [function(require, module, exports) {

    var t = require("safe-buffer").Buffer;

    function i(i, e) {
      this._block = t.alloc(i), this._finalSize = e, this._blockSize = i, this._len = 0
    }
    i.prototype.update = function(i, e) {
      "string" == typeof i && (e = e || "utf8", i = t.from(i, e));
      for (var s = this._block, o = this._blockSize, l = i.length, h = this._len, r = 0; r < l;) {
        for (var _ = h % o, n = Math.min(l - r, o - _), c = 0; c < n; c++) s[_ + c] = i[r + c];
        r += n, (h += n) % o == 0 && this._update(s)
      }
      return this._len += l, this
    }, i.prototype.digest = function(t) {
      var i = this._len % this._blockSize;
      this._block[i] = 128, this._block.fill(0, i + 1), i >= this._finalSize && (this._update(this._block), this._block.fill(0));
      var e = 8 * this._len;
      if (e <= 4294967295) this._block.writeUInt32BE(e, this._blockSize - 4);
      else {
        var s = (4294967295 & e) >>> 0,
          o = (e - s) / 4294967296;
        this._block.writeUInt32BE(o, this._blockSize - 8), this._block.writeUInt32BE(s, this._blockSize - 4)
      }
      this._update(this._block);
      var l = this._hash();
      return t ? l.toString(t) : l
    }, i.prototype._update = function() {
      throw new Error("_update must be implemented by subclass")
    }, module.exports = i;
  }, {
    "safe-buffer": "Wugr"
  }],
  "j9dE": [function(require, module, exports) {

    var t = require("inherits"),
      i = require("./hash"),
      r = require("safe-buffer").Buffer,
      s = [1518500249, 1859775393, -1894007588, -899497514],
      h = new Array(80);

    function e() {
      this.init(), this._w = h, i.call(this, 64, 56)
    }

    function n(t) {
      return t << 5 | t >>> 27
    }

    function _(t) {
      return t << 30 | t >>> 2
    }

    function a(t, i, r, s) {
      return 0 === t ? i & r | ~i & s : 2 === t ? i & r | i & s | r & s : i ^ r ^ s
    }
    t(e, i), e.prototype.init = function() {
      return this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520, this
    }, e.prototype._update = function(t) {
      for (var i = this._w, r = 0 | this._a, h = 0 | this._b, e = 0 | this._c, o = 0 | this._d, u = 0 | this._e, f = 0; f < 16; ++f) i[f] = t.readInt32BE(4 * f);
      for (; f < 80; ++f) i[f] = i[f - 3] ^ i[f - 8] ^ i[f - 14] ^ i[f - 16];
      for (var c = 0; c < 80; ++c) {
        var d = ~~(c / 20),
          p = n(r) + a(d, h, e, o) + u + i[c] + s[d] | 0;
        u = o, o = e, e = _(h), h = r, r = p
      }
      this._a = r + this._a | 0, this._b = h + this._b | 0, this._c = e + this._c | 0, this._d = o + this._d | 0, this._e = u + this._e | 0
    }, e.prototype._hash = function() {
      var t = r.allocUnsafe(20);
      return t.writeInt32BE(0 | this._a, 0), t.writeInt32BE(0 | this._b, 4), t.writeInt32BE(0 | this._c, 8), t.writeInt32BE(0 | this._d, 12), t.writeInt32BE(0 | this._e, 16), t
    }, module.exports = e;
  }, {
    "inherits": "Bm0n",
    "./hash": "VHby",
    "safe-buffer": "Wugr"
  }],
  "oPH4": [function(require, module, exports) {

    var t = require("inherits"),
      i = require("./hash"),
      r = require("safe-buffer").Buffer,
      s = [1518500249, 1859775393, -1894007588, -899497514],
      e = new Array(80);

    function h() {
      this.init(), this._w = e, i.call(this, 64, 56)
    }

    function n(t) {
      return t << 1 | t >>> 31
    }

    function _(t) {
      return t << 5 | t >>> 27
    }

    function u(t) {
      return t << 30 | t >>> 2
    }

    function o(t, i, r, s) {
      return 0 === t ? i & r | ~i & s : 2 === t ? i & r | i & s | r & s : i ^ r ^ s
    }
    t(h, i), h.prototype.init = function() {
      return this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520, this
    }, h.prototype._update = function(t) {
      for (var i = this._w, r = 0 | this._a, e = 0 | this._b, h = 0 | this._c, a = 0 | this._d, f = 0 | this._e, c = 0; c < 16; ++c) i[c] = t.readInt32BE(4 * c);
      for (; c < 80; ++c) i[c] = n(i[c - 3] ^ i[c - 8] ^ i[c - 14] ^ i[c - 16]);
      for (var d = 0; d < 80; ++d) {
        var p = ~~(d / 20),
          w = _(r) + o(p, e, h, a) + f + i[d] + s[p] | 0;
        f = a, a = h, h = u(e), e = r, r = w
      }
      this._a = r + this._a | 0, this._b = e + this._b | 0, this._c = h + this._c | 0, this._d = a + this._d | 0, this._e = f + this._e | 0
    }, h.prototype._hash = function() {
      var t = r.allocUnsafe(20);
      return t.writeInt32BE(0 | this._a, 0), t.writeInt32BE(0 | this._b, 4), t.writeInt32BE(0 | this._c, 8), t.writeInt32BE(0 | this._d, 12), t.writeInt32BE(0 | this._e, 16), t
    }, module.exports = h;
  }, {
    "inherits": "Bm0n",
    "./hash": "VHby",
    "safe-buffer": "Wugr"
  }],
  "IUSb": [function(require, module, exports) {

    var t = require("inherits"),
      i = require("./hash"),
      h = require("safe-buffer").Buffer,
      s = [1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298],
      r = new Array(64);

    function _() {
      this.init(), this._w = r, i.call(this, 64, 56)
    }

    function n(t, i, h) {
      return h ^ t & (i ^ h)
    }

    function e(t, i, h) {
      return t & i | h & (t | i)
    }

    function u(t) {
      return (t >>> 2 | t << 30) ^ (t >>> 13 | t << 19) ^ (t >>> 22 | t << 10)
    }

    function f(t) {
      return (t >>> 6 | t << 26) ^ (t >>> 11 | t << 21) ^ (t >>> 25 | t << 7)
    }

    function o(t) {
      return (t >>> 7 | t << 25) ^ (t >>> 18 | t << 14) ^ t >>> 3
    }

    function a(t) {
      return (t >>> 17 | t << 15) ^ (t >>> 19 | t << 13) ^ t >>> 10
    }
    t(_, i), _.prototype.init = function() {
      return this._a = 1779033703, this._b = 3144134277, this._c = 1013904242, this._d = 2773480762, this._e = 1359893119, this._f = 2600822924, this._g = 528734635, this._h = 1541459225, this
    }, _.prototype._update = function(t) {
      for (var i = this._w, h = 0 | this._a, r = 0 | this._b, _ = 0 | this._c, c = 0 | this._d, w = 0 | this._e, B = 0 | this._f, E = 0 | this._g, I = 0 | this._h, d = 0; d < 16; ++d) i[d] = t.readInt32BE(4 * d);
      for (; d < 64; ++d) i[d] = a(i[d - 2]) + i[d - 7] + o(i[d - 15]) + i[d - 16] | 0;
      for (var p = 0; p < 64; ++p) {
        var b = I + f(w) + n(w, B, E) + s[p] + i[p] | 0,
          g = u(h) + e(h, r, _) | 0;
        I = E, E = B, B = w, w = c + b | 0, c = _, _ = r, r = h, h = b + g | 0
      }
      this._a = h + this._a | 0, this._b = r + this._b | 0, this._c = _ + this._c | 0, this._d = c + this._d | 0, this._e = w + this._e | 0, this._f = B + this._f | 0, this._g = E + this._g | 0, this._h = I + this._h | 0
    }, _.prototype._hash = function() {
      var t = h.allocUnsafe(32);
      return t.writeInt32BE(this._a, 0), t.writeInt32BE(this._b, 4), t.writeInt32BE(this._c, 8), t.writeInt32BE(this._d, 12), t.writeInt32BE(this._e, 16), t.writeInt32BE(this._f, 20), t.writeInt32BE(this._g, 24), t.writeInt32BE(this._h, 28), t
    }, module.exports = _;
  }, {
    "inherits": "Bm0n",
    "./hash": "VHby",
    "safe-buffer": "Wugr"
  }],
  "MeLE": [function(require, module, exports) {

    var t = require("inherits"),
      i = require("./sha256"),
      e = require("./hash"),
      r = require("safe-buffer").Buffer,
      h = new Array(64);

    function s() {
      this.init(), this._w = h, e.call(this, 64, 56)
    }
    t(s, i), s.prototype.init = function() {
      return this._a = 3238371032, this._b = 914150663, this._c = 812702999, this._d = 4144912697, this._e = 4290775857, this._f = 1750603025, this._g = 1694076839, this._h = 3204075428, this
    }, s.prototype._hash = function() {
      var t = r.allocUnsafe(28);
      return t.writeInt32BE(this._a, 0), t.writeInt32BE(this._b, 4), t.writeInt32BE(this._c, 8), t.writeInt32BE(this._d, 12), t.writeInt32BE(this._e, 16), t.writeInt32BE(this._f, 20), t.writeInt32BE(this._g, 24), t
    }, module.exports = s;
  }, {
    "inherits": "Bm0n",
    "./sha256": "IUSb",
    "./hash": "VHby",
    "safe-buffer": "Wugr"
  }],
  "sILY": [function(require, module, exports) {

    var h = require("inherits"),
      t = require("./hash"),
      i = require("safe-buffer").Buffer,
      s = [1116352408, 3609767458, 1899447441, 602891725, 3049323471, 3964484399, 3921009573, 2173295548, 961987163, 4081628472, 1508970993, 3053834265, 2453635748, 2937671579, 2870763221, 3664609560, 3624381080, 2734883394, 310598401, 1164996542, 607225278, 1323610764, 1426881987, 3590304994, 1925078388, 4068182383, 2162078206, 991336113, 2614888103, 633803317, 3248222580, 3479774868, 3835390401, 2666613458, 4022224774, 944711139, 264347078, 2341262773, 604807628, 2007800933, 770255983, 1495990901, 1249150122, 1856431235, 1555081692, 3175218132, 1996064986, 2198950837, 2554220882, 3999719339, 2821834349, 766784016, 2952996808, 2566594879, 3210313671, 3203337956, 3336571891, 1034457026, 3584528711, 2466948901, 113926993, 3758326383, 338241895, 168717936, 666307205, 1188179964, 773529912, 1546045734, 1294757372, 1522805485, 1396182291, 2643833823, 1695183700, 2343527390, 1986661051, 1014477480, 2177026350, 1206759142, 2456956037, 344077627, 2730485921, 1290863460, 2820302411, 3158454273, 3259730800, 3505952657, 3345764771, 106217008, 3516065817, 3606008344, 3600352804, 1432725776, 4094571909, 1467031594, 275423344, 851169720, 430227734, 3100823752, 506948616, 1363258195, 659060556, 3750685593, 883997877, 3785050280, 958139571, 3318307427, 1322822218, 3812723403, 1537002063, 2003034995, 1747873779, 3602036899, 1955562222, 1575990012, 2024104815, 1125592928, 2227730452, 2716904306, 2361852424, 442776044, 2428436474, 593698344, 2756734187, 3733110249, 3204031479, 2999351573, 3329325298, 3815920427, 3391569614, 3928383900, 3515267271, 566280711, 3940187606, 3454069534, 4118630271, 4000239992, 116418474, 1914138554, 174292421, 2731055270, 289380356, 3203993006, 460393269, 320620315, 685471733, 587496836, 852142971, 1086792851, 1017036298, 365543100, 1126000580, 2618297676, 1288033470, 3409855158, 1501505948, 4234509866, 1607167915, 987167468, 1816402316, 1246189591],
      _ = new Array(160);

    function l() {
      this.init(), this._w = _, t.call(this, 128, 112)
    }

    function r(h, t, i) {
      return i ^ h & (t ^ i)
    }

    function n(h, t, i) {
      return h & t | i & (h | t)
    }

    function e(h, t) {
      return (h >>> 28 | t << 4) ^ (t >>> 2 | h << 30) ^ (t >>> 7 | h << 25)
    }

    function f(h, t) {
      return (h >>> 14 | t << 18) ^ (h >>> 18 | t << 14) ^ (t >>> 9 | h << 23)
    }

    function u(h, t) {
      return (h >>> 1 | t << 31) ^ (h >>> 8 | t << 24) ^ h >>> 7
    }

    function a(h, t) {
      return (h >>> 1 | t << 31) ^ (h >>> 8 | t << 24) ^ (h >>> 7 | t << 25)
    }

    function c(h, t) {
      return (h >>> 19 | t << 13) ^ (t >>> 29 | h << 3) ^ h >>> 6
    }

    function o(h, t) {
      return (h >>> 19 | t << 13) ^ (t >>> 29 | h << 3) ^ (h >>> 6 | t << 26)
    }

    function d(h, t) {
      return h >>> 0 < t >>> 0 ? 1 : 0
    }
    h(l, t), l.prototype.init = function() {
      return this._ah = 1779033703, this._bh = 3144134277, this._ch = 1013904242, this._dh = 2773480762, this._eh = 1359893119, this._fh = 2600822924, this._gh = 528734635, this._hh = 1541459225, this._al = 4089235720, this._bl = 2227873595, this._cl = 4271175723, this._dl = 1595750129, this._el = 2917565137, this._fl = 725511199, this._gl = 4215389547, this._hl = 327033209, this
    }, l.prototype._update = function(h) {
      for (var t = this._w, i = 0 | this._ah, _ = 0 | this._bh, l = 0 | this._ch, b = 0 | this._dh, g = 0 | this._eh, p = 0 | this._fh, v = 0 | this._gh, w = 0 | this._hh, B = 0 | this._al, y = 0 | this._bl, E = 0 | this._cl, I = 0 | this._dl, q = 0 | this._el, m = 0 | this._fl, x = 0 | this._gl, A = 0 | this._hl, U = 0; U < 32; U += 2) t[U] = h.readInt32BE(4 * U), t[U + 1] = h.readInt32BE(4 * U + 4);
      for (; U < 160; U += 2) {
        var j = t[U - 30],
          k = t[U - 30 + 1],
          z = u(j, k),
          C = a(k, j),
          D = c(j = t[U - 4], k = t[U - 4 + 1]),
          F = o(k, j),
          G = t[U - 14],
          H = t[U - 14 + 1],
          J = t[U - 32],
          K = t[U - 32 + 1],
          L = C + H | 0,
          M = z + G + d(L, C) | 0;
        M = (M = M + D + d(L = L + F | 0, F) | 0) + J + d(L = L + K | 0, K) | 0, t[U] = M, t[U + 1] = L
      }
      for (var N = 0; N < 160; N += 2) {
        M = t[N], L = t[N + 1];
        var O = n(i, _, l),
          P = n(B, y, E),
          Q = e(i, B),
          R = e(B, i),
          S = f(g, q),
          T = f(q, g),
          V = s[N],
          W = s[N + 1],
          X = r(g, p, v),
          Y = r(q, m, x),
          Z = A + T | 0,
          $ = w + S + d(Z, A) | 0;
        $ = ($ = ($ = $ + X + d(Z = Z + Y | 0, Y) | 0) + V + d(Z = Z + W | 0, W) | 0) + M + d(Z = Z + L | 0, L) | 0;
        var hh = R + P | 0,
          th = Q + O + d(hh, R) | 0;
        w = v, A = x, v = p, x = m, p = g, m = q, g = b + $ + d(q = I + Z | 0, I) | 0, b = l, I = E, l = _, E = y, _ = i, y = B, i = $ + th + d(B = Z + hh | 0, Z) | 0
      }
      this._al = this._al + B | 0, this._bl = this._bl + y | 0, this._cl = this._cl + E | 0, this._dl = this._dl + I | 0, this._el = this._el + q | 0, this._fl = this._fl + m | 0, this._gl = this._gl + x | 0, this._hl = this._hl + A | 0, this._ah = this._ah + i + d(this._al, B) | 0, this._bh = this._bh + _ + d(this._bl, y) | 0, this._ch = this._ch + l + d(this._cl, E) | 0, this._dh = this._dh + b + d(this._dl, I) | 0, this._eh = this._eh + g + d(this._el, q) | 0, this._fh = this._fh + p + d(this._fl, m) | 0, this._gh = this._gh + v + d(this._gl, x) | 0, this._hh = this._hh + w + d(this._hl, A) | 0
    }, l.prototype._hash = function() {
      var h = i.allocUnsafe(64);

      function t(t, i, s) {
        h.writeInt32BE(t, s), h.writeInt32BE(i, s + 4)
      }
      return t(this._ah, this._al, 0), t(this._bh, this._bl, 8), t(this._ch, this._cl, 16), t(this._dh, this._dl, 24), t(this._eh, this._el, 32), t(this._fh, this._fl, 40), t(this._gh, this._gl, 48), t(this._hh, this._hl, 56), h
    }, module.exports = l;
  }, {
    "inherits": "Bm0n",
    "./hash": "VHby",
    "safe-buffer": "Wugr"
  }],
  "V2o3": [function(require, module, exports) {

    var h = require("inherits"),
      t = require("./sha512"),
      i = require("./hash"),
      s = require("safe-buffer").Buffer,
      _ = new Array(160);

    function e() {
      this.init(), this._w = _, i.call(this, 128, 112)
    }
    h(e, t), e.prototype.init = function() {
      return this._ah = 3418070365, this._bh = 1654270250, this._ch = 2438529370, this._dh = 355462360, this._eh = 1731405415, this._fh = 2394180231, this._gh = 3675008525, this._hh = 1203062813, this._al = 3238371032, this._bl = 914150663, this._cl = 812702999, this._dl = 4144912697, this._el = 4290775857, this._fl = 1750603025, this._gl = 1694076839, this._hl = 3204075428, this
    }, e.prototype._hash = function() {
      var h = s.allocUnsafe(48);

      function t(t, i, s) {
        h.writeInt32BE(t, s), h.writeInt32BE(i, s + 4)
      }
      return t(this._ah, this._al, 0), t(this._bh, this._bl, 8), t(this._ch, this._cl, 16), t(this._dh, this._dl, 24), t(this._eh, this._el, 32), t(this._fh, this._fl, 40), h
    }, module.exports = e;
  }, {
    "inherits": "Bm0n",
    "./sha512": "sILY",
    "./hash": "VHby",
    "safe-buffer": "Wugr"
  }],
  "t0b9": [function(require, module, exports) {
    var e = module.exports = function(r) {
      r = r.toLowerCase();
      var s = e[r];
      if (!s) throw new Error(r + " is not supported (we accept pull requests)");
      return new s
    };
    e.sha = require("./sha"), e.sha1 = require("./sha1"), e.sha224 = require("./sha224"), e.sha256 = require("./sha256"), e.sha384 = require("./sha384"), e.sha512 = require("./sha512");
  }, {
    "./sha": "j9dE",
    "./sha1": "oPH4",
    "./sha224": "MeLE",
    "./sha256": "IUSb",
    "./sha384": "V2o3",
    "./sha512": "sILY"
  }],
  "LnjZ": [function(require, module, exports) {
    module.exports = require("./lib/_stream_writable.js");
  }, {
    "./lib/_stream_writable.js": "WSyY"
  }],
  "kT1X": [function(require, module, exports) {
    module.exports = require("./lib/_stream_duplex.js");
  }, {
    "./lib/_stream_duplex.js": "Hba0"
  }],
  "A9KG": [function(require, module, exports) {
    module.exports = require("./readable").Transform;
  }, {
    "./readable": "tzeh"
  }],
  "C6nS": [function(require, module, exports) {
    module.exports = require("./readable").PassThrough;
  }, {
    "./readable": "tzeh"
  }],
  "fnRj": [function(require, module, exports) {
    module.exports = n;
    var e = require("events").EventEmitter,
      r = require("inherits");

    function n() {
      e.call(this)
    }
    r(n, e), n.Readable = require("readable-stream/readable.js"), n.Writable = require("readable-stream/writable.js"), n.Duplex = require("readable-stream/duplex.js"), n.Transform = require("readable-stream/transform.js"), n.PassThrough = require("readable-stream/passthrough.js"), n.Stream = n, n.prototype.pipe = function(r, n) {
      var o = this;

      function t(e) {
        r.writable && !1 === r.write(e) && o.pause && o.pause()
      }

      function s() {
        o.readable && o.resume && o.resume()
      }
      o.on("data", t), r.on("drain", s), r._isStdio || n && !1 === n.end || (o.on("end", a), o.on("close", u));
      var i = !1;

      function a() {
        i || (i = !0, r.end())
      }

      function u() {
        i || (i = !0, "function" == typeof r.destroy && r.destroy())
      }

      function d(r) {
        if (l(), 0 === e.listenerCount(this, "error")) throw r
      }

      function l() {
        o.removeListener("data", t), r.removeListener("drain", s), o.removeListener("end", a), o.removeListener("close", u), o.removeListener("error", d), r.removeListener("error", d), o.removeListener("end", l), o.removeListener("close", l), r.removeListener("close", l)
      }
      return o.on("error", d), r.on("error", d), o.on("end", l), o.on("close", l), r.on("close", l), r.emit("pipe", o), r
    };
  }, {
    "events": "FRpO",
    "inherits": "Bm0n",
    "readable-stream/readable.js": "tzeh",
    "readable-stream/writable.js": "LnjZ",
    "readable-stream/duplex.js": "kT1X",
    "readable-stream/transform.js": "A9KG",
    "readable-stream/passthrough.js": "C6nS"
  }],
  "bjfr": [function(require, module, exports) {

    var t = require("safe-buffer").Buffer,
      i = require("stream").Transform,
      r = require("string_decoder").StringDecoder,
      e = require("inherits");

    function n(t) {
      i.call(this), this.hashMode = "string" == typeof t, this.hashMode ? this[t] = this._finalOrDigest : this.final = this._finalOrDigest, this._final && (this.__final = this._final, this._final = null), this._decoder = null, this._encoding = null
    }
    e(n, i), n.prototype.update = function(i, r, e) {
      "string" == typeof i && (i = t.from(i, r));
      var n = this._update(i);
      return this.hashMode ? this : (e && (n = this._toString(n, e)), n)
    }, n.prototype.setAutoPadding = function() {}, n.prototype.getAuthTag = function() {
      throw new Error("trying to get auth tag in unsupported state")
    }, n.prototype.setAuthTag = function() {
      throw new Error("trying to set auth tag in unsupported state")
    }, n.prototype.setAAD = function() {
      throw new Error("trying to set aad in unsupported state")
    }, n.prototype._transform = function(t, i, r) {
      var e;
      try {
        this.hashMode ? this._update(t) : this.push(this._update(t))
      } catch (n) {
        e = n
      } finally {
        r(e)
      }
    }, n.prototype._flush = function(t) {
      var i;
      try {
        this.push(this.__final())
      } catch (r) {
        i = r
      }
      t(i)
    }, n.prototype._finalOrDigest = function(i) {
      var r = this.__final() || t.alloc(0);
      return i && (r = this._toString(r, i, !0)), r
    }, n.prototype._toString = function(t, i, e) {
      if (this._decoder || (this._decoder = new r(i), this._encoding = i), this._encoding !== i) throw new Error("can't switch encodings");
      var n = this._decoder.write(t);
      return e && (n += this._decoder.end()), n
    }, module.exports = n;
  }, {
    "safe-buffer": "Wugr",
    "stream": "fnRj",
    "string_decoder": "z0rv",
    "inherits": "Bm0n"
  }],
  "LF8r": [function(require, module, exports) {
    "use strict";
    var e = require("inherits"),
      r = require("md5.js"),
      t = require("ripemd160"),
      i = require("sha.js"),
      s = require("cipher-base");

    function n(e) {
      s.call(this, "digest"), this._hash = e
    }
    e(n, s), n.prototype._update = function(e) {
      this._hash.update(e)
    }, n.prototype._final = function() {
      return this._hash.digest()
    }, module.exports = function(e) {
      return "md5" === (e = e.toLowerCase()) ? new r : "rmd160" === e || "ripemd160" === e ? new t : new n(i(e))
    };
  }, {
    "inherits": "Bm0n",
    "md5.js": "OP64",
    "ripemd160": "quyi",
    "sha.js": "t0b9",
    "cipher-base": "bjfr"
  }],
  "aHbo": [function(require, module, exports) {

    "use strict";
    var t = require("inherits"),
      e = require("safe-buffer").Buffer,
      a = require("cipher-base"),
      i = e.alloc(128),
      s = 64;

    function h(t, h) {
      a.call(this, "digest"), "string" == typeof h && (h = e.from(h)), this._alg = t, this._key = h, h.length > s ? h = t(h) : h.length < s && (h = e.concat([h, i], s));
      for (var r = this._ipad = e.allocUnsafe(s), o = this._opad = e.allocUnsafe(s), n = 0; n < s; n++) r[n] = 54 ^ h[n], o[n] = 92 ^ h[n];
      this._hash = [r]
    }
    t(h, a), h.prototype._update = function(t) {
      this._hash.push(t)
    }, h.prototype._final = function() {
      var t = this._alg(e.concat(this._hash));
      return this._alg(e.concat([this._opad, t]))
    }, module.exports = h;
  }, {
    "inherits": "Bm0n",
    "safe-buffer": "Wugr",
    "cipher-base": "bjfr"
  }],
  "Mobq": [function(require, module, exports) {
    var e = require("md5.js");
    module.exports = function(r) {
      return (new e).update(r).digest()
    };
  }, {
    "md5.js": "OP64"
  }],
  "Cx6S": [function(require, module, exports) {

    "use strict";
    var e = require("inherits"),
      t = require("./legacy"),
      r = require("cipher-base"),
      a = require("safe-buffer").Buffer,
      i = require("create-hash/md5"),
      s = require("ripemd160"),
      h = require("sha.js"),
      n = a.alloc(128);

    function d(e, t) {
      r.call(this, "digest"), "string" == typeof t && (t = a.from(t));
      var i = "sha512" === e || "sha384" === e ? 128 : 64;
      (this._alg = e, this._key = t, t.length > i) ? t = ("rmd160" === e ? new s : h(e)).update(t).digest(): t.length < i && (t = a.concat([t, n], i));
      for (var d = this._ipad = a.allocUnsafe(i), u = this._opad = a.allocUnsafe(i), o = 0; o < i; o++) d[o] = 54 ^ t[o], u[o] = 92 ^ t[o];
      this._hash = "rmd160" === e ? new s : h(e), this._hash.update(d)
    }
    e(d, r), d.prototype._update = function(e) {
      this._hash.update(e)
    }, d.prototype._final = function() {
      var e = this._hash.digest();
      return ("rmd160" === this._alg ? new s : h(this._alg)).update(this._opad).update(e).digest()
    }, module.exports = function(e, r) {
      return "rmd160" === (e = e.toLowerCase()) || "ripemd160" === e ? new d("rmd160", r) : "md5" === e ? new t(i, r) : new d(e, r)
    };
  }, {
    "inherits": "Bm0n",
    "./legacy": "aHbo",
    "cipher-base": "bjfr",
    "safe-buffer": "Wugr",
    "create-hash/md5": "Mobq",
    "ripemd160": "quyi",
    "sha.js": "t0b9"
  }],
  "WoCp": [function(require, module, exports) {
    module.exports = {
      sha224WithRSAEncryption: {
        sign: "rsa",
        hash: "sha224",
        id: "302d300d06096086480165030402040500041c"
      },
      "RSA-SHA224": {
        sign: "ecdsa/rsa",
        hash: "sha224",
        id: "302d300d06096086480165030402040500041c"
      },
      sha256WithRSAEncryption: {
        sign: "rsa",
        hash: "sha256",
        id: "3031300d060960864801650304020105000420"
      },
      "RSA-SHA256": {
        sign: "ecdsa/rsa",
        hash: "sha256",
        id: "3031300d060960864801650304020105000420"
      },
      sha384WithRSAEncryption: {
        sign: "rsa",
        hash: "sha384",
        id: "3041300d060960864801650304020205000430"
      },
      "RSA-SHA384": {
        sign: "ecdsa/rsa",
        hash: "sha384",
        id: "3041300d060960864801650304020205000430"
      },
      sha512WithRSAEncryption: {
        sign: "rsa",
        hash: "sha512",
        id: "3051300d060960864801650304020305000440"
      },
      "RSA-SHA512": {
        sign: "ecdsa/rsa",
        hash: "sha512",
        id: "3051300d060960864801650304020305000440"
      },
      "RSA-SHA1": {
        sign: "rsa",
        hash: "sha1",
        id: "3021300906052b0e03021a05000414"
      },
      "ecdsa-with-SHA1": {
        sign: "ecdsa",
        hash: "sha1",
        id: ""
      },
      sha256: {
        sign: "ecdsa",
        hash: "sha256",
        id: ""
      },
      sha224: {
        sign: "ecdsa",
        hash: "sha224",
        id: ""
      },
      sha384: {
        sign: "ecdsa",
        hash: "sha384",
        id: ""
      },
      sha512: {
        sign: "ecdsa",
        hash: "sha512",
        id: ""
      },
      "DSA-SHA": {
        sign: "dsa",
        hash: "sha1",
        id: ""
      },
      "DSA-SHA1": {
        sign: "dsa",
        hash: "sha1",
        id: ""
      },
      DSA: {
        sign: "dsa",
        hash: "sha1",
        id: ""
      },
      "DSA-WITH-SHA224": {
        sign: "dsa",
        hash: "sha224",
        id: ""
      },
      "DSA-SHA224": {
        sign: "dsa",
        hash: "sha224",
        id: ""
      },
      "DSA-WITH-SHA256": {
        sign: "dsa",
        hash: "sha256",
        id: ""
      },
      "DSA-SHA256": {
        sign: "dsa",
        hash: "sha256",
        id: ""
      },
      "DSA-WITH-SHA384": {
        sign: "dsa",
        hash: "sha384",
        id: ""
      },
      "DSA-SHA384": {
        sign: "dsa",
        hash: "sha384",
        id: ""
      },
      "DSA-WITH-SHA512": {
        sign: "dsa",
        hash: "sha512",
        id: ""
      },
      "DSA-SHA512": {
        sign: "dsa",
        hash: "sha512",
        id: ""
      },
      "DSA-RIPEMD160": {
        sign: "dsa",
        hash: "rmd160",
        id: ""
      },
      ripemd160WithRSA: {
        sign: "rsa",
        hash: "rmd160",
        id: "3021300906052b2403020105000414"
      },
      "RSA-RIPEMD160": {
        sign: "rsa",
        hash: "rmd160",
        id: "3021300906052b2403020105000414"
      },
      md5WithRSAEncryption: {
        sign: "rsa",
        hash: "md5",
        id: "3020300c06082a864886f70d020505000410"
      },
      "RSA-MD5": {
        sign: "rsa",
        hash: "md5",
        id: "3020300c06082a864886f70d020505000410"
      }
    };
  }, {}],
  "YKr5": [function(require, module, exports) {
    module.exports = require("./browser/algorithms.json");
  }, {
    "./browser/algorithms.json": "WoCp"
  }],
  "Zu0X": [function(require, module, exports) {
    var r = Math.pow(2, 30) - 1;
    module.exports = function(e, o) {
      if ("number" != typeof e) throw new TypeError("Iterations not a number");
      if (e < 0) throw new TypeError("Bad iterations");
      if ("number" != typeof o) throw new TypeError("Key length not a number");
      if (o < 0 || o > r || o != o) throw new TypeError("Bad key length")
    };
  }, {}],
  "ATA7": [function(require, module, exports) {
    var global = arguments[3];
    var process = require("process");
    var s, e = arguments[3],
      r = require("process");
    if (e.process && e.process.browser) s = "utf-8";
    else if (e.process && e.process.version) {
      var o = parseInt(r.version.split(".")[0].slice(1), 10);
      s = o >= 6 ? "utf-8" : "binary"
    } else s = "utf-8";
    module.exports = s;
  }, {
    "process": "pBGv"
  }],
  "amCB": [function(require, module, exports) {

    var r = require("safe-buffer").Buffer;
    module.exports = function(e, f, u) {
      if (r.isBuffer(e)) return e;
      if ("string" == typeof e) return r.from(e, f);
      if (ArrayBuffer.isView(e)) return r.from(e.buffer);
      throw new TypeError(u + " must be a string, a Buffer, a typed array or a DataView")
    };
  }, {
    "safe-buffer": "Wugr"
  }],
  "yOuH": [function(require, module, exports) {

    var e = require("create-hash/md5"),
      r = require("ripemd160"),
      a = require("sha.js"),
      t = require("safe-buffer").Buffer,
      i = require("./precondition"),
      s = require("./default-encoding"),
      n = require("./to-buffer"),
      h = t.alloc(128),
      o = {
        md5: 16,
        sha1: 20,
        sha224: 28,
        sha256: 32,
        sha384: 48,
        sha512: 64,
        rmd160: 20,
        ripemd160: 20
      };

    function u(e, r, a) {
      var i = c(e),
        s = "sha512" === e || "sha384" === e ? 128 : 64;
      r.length > s ? r = i(r) : r.length < s && (r = t.concat([r, h], s));
      for (var n = t.allocUnsafe(s + o[e]), u = t.allocUnsafe(s + o[e]), l = 0; l < s; l++) n[l] = 54 ^ r[l], u[l] = 92 ^ r[l];
      var d = t.allocUnsafe(s + a + 4);
      n.copy(d, 0, 0, s), this.ipad1 = d, this.ipad2 = n, this.opad = u, this.alg = e, this.blocksize = s, this.hash = i, this.size = o[e]
    }

    function c(t) {
      return "rmd160" === t || "ripemd160" === t ? function(e) {
        return (new r).update(e).digest()
      } : "md5" === t ? e : function(e) {
        return a(t).update(e).digest()
      }
    }

    function l(e, r, a, h, c) {
      i(a, h);
      var l = new u(c = c || "sha1", e = n(e, s, "Password"), (r = n(r, s, "Salt")).length),
        d = t.allocUnsafe(h),
        f = t.allocUnsafe(r.length + 4);
      r.copy(f, 0, 0, r.length);
      for (var p = 0, g = o[c], m = Math.ceil(h / g), v = 1; v <= m; v++) {
        f.writeUInt32BE(v, r.length);
        for (var q = l.run(f, l.ipad1), y = q, U = 1; U < a; U++) {
          y = l.run(y, l.ipad2);
          for (var b = 0; b < g; b++) q[b] ^= y[b]
        }
        q.copy(d, p), p += g
      }
      return d
    }
    u.prototype.run = function(e, r) {
      return e.copy(r, this.blocksize), this.hash(r).copy(this.opad, this.blocksize), this.hash(this.opad)
    }, module.exports = l;
  }, {
    "create-hash/md5": "Mobq",
    "ripemd160": "quyi",
    "sha.js": "t0b9",
    "safe-buffer": "Wugr",
    "./precondition": "Zu0X",
    "./default-encoding": "ATA7",
    "./to-buffer": "amCB"
  }],
  "Q3c6": [function(require, module, exports) {

    var global = arguments[3];
    var e, r, t = arguments[3],
      n = require("safe-buffer").Buffer,
      o = require("./precondition"),
      i = require("./default-encoding"),
      u = require("./sync"),
      s = require("./to-buffer"),
      c = t.crypto && t.crypto.subtle,
      a = {
        sha: "SHA-1",
        "sha-1": "SHA-1",
        sha1: "SHA-1",
        sha256: "SHA-256",
        "sha-256": "SHA-256",
        sha384: "SHA-384",
        "sha-384": "SHA-384",
        "sha-512": "SHA-512",
        sha512: "SHA-512"
      },
      f = [];

    function h(r) {
      if (t.process && !t.process.browser) return Promise.resolve(!1);
      if (!c || !c.importKey || !c.deriveBits) return Promise.resolve(!1);
      if (void 0 !== f[r]) return f[r];
      var o = m(e = e || n.alloc(8), e, 10, 128, r).then(function() {
        return !0
      }).catch(function() {
        return !1
      });
      return f[r] = o, o
    }

    function l() {
      return r || (r = t.process && t.process.nextTick ? t.process.nextTick : t.queueMicrotask ? t.queueMicrotask : t.setImmediate ? t.setImmediate : t.setTimeout)
    }

    function m(e, r, t, o, i) {
      return c.importKey("raw", e, {
        name: "PBKDF2"
      }, !1, ["deriveBits"]).then(function(e) {
        return c.deriveBits({
          name: "PBKDF2",
          salt: r,
          iterations: t,
          hash: {
            name: i
          }
        }, e, o << 3)
      }).then(function(e) {
        return n.from(e)
      })
    }

    function p(e, r) {
      e.then(function(e) {
        l()(function() {
          r(null, e)
        })
      }, function(e) {
        l()(function() {
          r(e)
        })
      })
    }
    module.exports = function(e, r, n, c, f, d) {
      "function" == typeof f && (d = f, f = void 0);
      var v = a[(f = f || "sha1").toLowerCase()];
      if (v && "function" == typeof t.Promise) {
        if (o(n, c), e = s(e, i, "Password"), r = s(r, i, "Salt"), "function" != typeof d) throw new Error("No callback provided to pbkdf2");
        p(h(v).then(function(t) {
          return t ? m(e, r, n, c, v) : u(e, r, n, c, f)
        }), d)
      } else l()(function() {
        var t;
        try {
          t = u(e, r, n, c, f)
        } catch (o) {
          return d(o)
        }
        d(null, t)
      })
    };
  }, {
    "safe-buffer": "Wugr",
    "./precondition": "Zu0X",
    "./default-encoding": "ATA7",
    "./sync": "yOuH",
    "./to-buffer": "amCB"
  }],
  "BKdu": [function(require, module, exports) {
    exports.pbkdf2 = require("./lib/async"), exports.pbkdf2Sync = require("./lib/sync");
  }, {
    "./lib/async": "Q3c6",
    "./lib/sync": "yOuH"
  }],
  "a957": [function(require, module, exports) {
    "use strict";
    exports.readUInt32BE = function(r, o) {
      return (r[0 + o] << 24 | r[1 + o] << 16 | r[2 + o] << 8 | r[3 + o]) >>> 0
    }, exports.writeUInt32BE = function(r, o, t) {
      r[0 + t] = o >>> 24, r[1 + t] = o >>> 16 & 255, r[2 + t] = o >>> 8 & 255, r[3 + t] = 255 & o
    }, exports.ip = function(r, o, t, f) {
      for (var n = 0, e = 0, u = 6; u >= 0; u -= 2) {
        for (var i = 0; i <= 24; i += 8) n <<= 1, n |= o >>> i + u & 1;
        for (i = 0; i <= 24; i += 8) n <<= 1, n |= r >>> i + u & 1
      }
      for (u = 6; u >= 0; u -= 2) {
        for (i = 1; i <= 25; i += 8) e <<= 1, e |= o >>> i + u & 1;
        for (i = 1; i <= 25; i += 8) e <<= 1, e |= r >>> i + u & 1
      }
      t[f + 0] = n >>> 0, t[f + 1] = e >>> 0
    }, exports.rip = function(r, o, t, f) {
      for (var n = 0, e = 0, u = 0; u < 4; u++)
        for (var i = 24; i >= 0; i -= 8) n <<= 1, n |= o >>> i + u & 1, n <<= 1, n |= r >>> i + u & 1;
      for (u = 4; u < 8; u++)
        for (i = 24; i >= 0; i -= 8) e <<= 1, e |= o >>> i + u & 1, e <<= 1, e |= r >>> i + u & 1;
      t[f + 0] = n >>> 0, t[f + 1] = e >>> 0
    }, exports.pc1 = function(r, o, t, f) {
      for (var n = 0, e = 0, u = 7; u >= 5; u--) {
        for (var i = 0; i <= 24; i += 8) n <<= 1, n |= o >> i + u & 1;
        for (i = 0; i <= 24; i += 8) n <<= 1, n |= r >> i + u & 1
      }
      for (i = 0; i <= 24; i += 8) n <<= 1, n |= o >> i + u & 1;
      for (u = 1; u <= 3; u++) {
        for (i = 0; i <= 24; i += 8) e <<= 1, e |= o >> i + u & 1;
        for (i = 0; i <= 24; i += 8) e <<= 1, e |= r >> i + u & 1
      }
      for (i = 0; i <= 24; i += 8) e <<= 1, e |= r >> i + u & 1;
      t[f + 0] = n >>> 0, t[f + 1] = e >>> 0
    }, exports.r28shl = function(r, o) {
      return r << o & 268435455 | r >>> 28 - o
    };
    var r = [14, 11, 17, 4, 27, 23, 25, 0, 13, 22, 7, 18, 5, 9, 16, 24, 2, 20, 12, 21, 1, 8, 15, 26, 15, 4, 25, 19, 9, 1, 26, 16, 5, 11, 23, 8, 12, 7, 17, 0, 22, 3, 10, 14, 6, 20, 27, 24];
    exports.pc2 = function(o, t, f, n) {
      for (var e = 0, u = 0, i = r.length >>> 1, p = 0; p < i; p++) e <<= 1, e |= o >>> r[p] & 1;
      for (p = i; p < r.length; p++) u <<= 1, u |= t >>> r[p] & 1;
      f[n + 0] = e >>> 0, f[n + 1] = u >>> 0
    }, exports.expand = function(r, o, t) {
      var f = 0,
        n = 0;
      f = (1 & r) << 5 | r >>> 27;
      for (var e = 23; e >= 15; e -= 4) f <<= 6, f |= r >>> e & 63;
      for (e = 11; e >= 3; e -= 4) n |= r >>> e & 63, n <<= 6;
      n |= (31 & r) << 1 | r >>> 31, o[t + 0] = f >>> 0, o[t + 1] = n >>> 0
    };
    var o = [14, 0, 4, 15, 13, 7, 1, 4, 2, 14, 15, 2, 11, 13, 8, 1, 3, 10, 10, 6, 6, 12, 12, 11, 5, 9, 9, 5, 0, 3, 7, 8, 4, 15, 1, 12, 14, 8, 8, 2, 13, 4, 6, 9, 2, 1, 11, 7, 15, 5, 12, 11, 9, 3, 7, 14, 3, 10, 10, 0, 5, 6, 0, 13, 15, 3, 1, 13, 8, 4, 14, 7, 6, 15, 11, 2, 3, 8, 4, 14, 9, 12, 7, 0, 2, 1, 13, 10, 12, 6, 0, 9, 5, 11, 10, 5, 0, 13, 14, 8, 7, 10, 11, 1, 10, 3, 4, 15, 13, 4, 1, 2, 5, 11, 8, 6, 12, 7, 6, 12, 9, 0, 3, 5, 2, 14, 15, 9, 10, 13, 0, 7, 9, 0, 14, 9, 6, 3, 3, 4, 15, 6, 5, 10, 1, 2, 13, 8, 12, 5, 7, 14, 11, 12, 4, 11, 2, 15, 8, 1, 13, 1, 6, 10, 4, 13, 9, 0, 8, 6, 15, 9, 3, 8, 0, 7, 11, 4, 1, 15, 2, 14, 12, 3, 5, 11, 10, 5, 14, 2, 7, 12, 7, 13, 13, 8, 14, 11, 3, 5, 0, 6, 6, 15, 9, 0, 10, 3, 1, 4, 2, 7, 8, 2, 5, 12, 11, 1, 12, 10, 4, 14, 15, 9, 10, 3, 6, 15, 9, 0, 0, 6, 12, 10, 11, 1, 7, 13, 13, 8, 15, 9, 1, 4, 3, 5, 14, 11, 5, 12, 2, 7, 8, 2, 4, 14, 2, 14, 12, 11, 4, 2, 1, 12, 7, 4, 10, 7, 11, 13, 6, 1, 8, 5, 5, 0, 3, 15, 15, 10, 13, 3, 0, 9, 14, 8, 9, 6, 4, 11, 2, 8, 1, 12, 11, 7, 10, 1, 13, 14, 7, 2, 8, 13, 15, 6, 9, 15, 12, 0, 5, 9, 6, 10, 3, 4, 0, 5, 14, 3, 12, 10, 1, 15, 10, 4, 15, 2, 9, 7, 2, 12, 6, 9, 8, 5, 0, 6, 13, 1, 3, 13, 4, 14, 14, 0, 7, 11, 5, 3, 11, 8, 9, 4, 14, 3, 15, 2, 5, 12, 2, 9, 8, 5, 12, 15, 3, 10, 7, 11, 0, 14, 4, 1, 10, 7, 1, 6, 13, 0, 11, 8, 6, 13, 4, 13, 11, 0, 2, 11, 14, 7, 15, 4, 0, 9, 8, 1, 13, 10, 3, 14, 12, 3, 9, 5, 7, 12, 5, 2, 10, 15, 6, 8, 1, 6, 1, 6, 4, 11, 11, 13, 13, 8, 12, 1, 3, 4, 7, 10, 14, 7, 10, 9, 15, 5, 6, 0, 8, 15, 0, 14, 5, 2, 9, 3, 2, 12, 13, 1, 2, 15, 8, 13, 4, 8, 6, 10, 15, 3, 11, 7, 1, 4, 10, 12, 9, 5, 3, 6, 14, 11, 5, 0, 0, 14, 12, 9, 7, 2, 7, 2, 11, 1, 4, 14, 1, 7, 9, 4, 12, 10, 14, 8, 2, 13, 0, 15, 6, 12, 10, 9, 13, 0, 15, 3, 3, 5, 5, 6, 8, 11];
    exports.substitute = function(r, t) {
      for (var f = 0, n = 0; n < 4; n++) {
        f <<= 4, f |= o[64 * n + (r >>> 18 - 6 * n & 63)]
      }
      for (n = 0; n < 4; n++) {
        f <<= 4, f |= o[256 + 64 * n + (t >>> 18 - 6 * n & 63)]
      }
      return f >>> 0
    };
    var t = [16, 25, 12, 11, 3, 20, 4, 15, 31, 17, 9, 6, 27, 14, 1, 22, 30, 24, 8, 18, 0, 5, 29, 23, 13, 19, 2, 26, 10, 21, 28, 7];
    exports.permute = function(r) {
      for (var o = 0, f = 0; f < t.length; f++) o <<= 1, o |= r >>> t[f] & 1;
      return o >>> 0
    }, exports.padSplit = function(r, o, t) {
      for (var f = r.toString(2); f.length < o;) f = "0" + f;
      for (var n = [], e = 0; e < o; e += t) n.push(f.slice(e, e + t));
      return n.join(" ")
    };
  }, {}],
  "eTzy": [function(require, module, exports) {
    "use strict";
    var t = require("minimalistic-assert");

    function f(t) {
      this.options = t, this.type = this.options.type, this.blockSize = 8, this._init(), this.buffer = new Array(this.blockSize), this.bufferOff = 0
    }
    module.exports = f, f.prototype._init = function() {}, f.prototype.update = function(t) {
      return 0 === t.length ? [] : "decrypt" === this.type ? this._updateDecrypt(t) : this._updateEncrypt(t)
    }, f.prototype._buffer = function(t, f) {
      for (var e = Math.min(this.buffer.length - this.bufferOff, t.length - f), r = 0; r < e; r++) this.buffer[this.bufferOff + r] = t[f + r];
      return this.bufferOff += e, e
    }, f.prototype._flushBuffer = function(t, f) {
      return this._update(this.buffer, 0, t, f), this.bufferOff = 0, this.blockSize
    }, f.prototype._updateEncrypt = function(t) {
      var f = 0,
        e = 0,
        r = (this.bufferOff + t.length) / this.blockSize | 0,
        i = new Array(r * this.blockSize);
      0 !== this.bufferOff && (f += this._buffer(t, f), this.bufferOff === this.buffer.length && (e += this._flushBuffer(i, e)));
      for (var h = t.length - (t.length - f) % this.blockSize; f < h; f += this.blockSize) this._update(t, f, i, e), e += this.blockSize;
      for (; f < t.length; f++, this.bufferOff++) this.buffer[this.bufferOff] = t[f];
      return i
    }, f.prototype._updateDecrypt = function(t) {
      for (var f = 0, e = 0, r = Math.ceil((this.bufferOff + t.length) / this.blockSize) - 1, i = new Array(r * this.blockSize); r > 0; r--) f += this._buffer(t, f), e += this._flushBuffer(i, e);
      return f += this._buffer(t, f), i
    }, f.prototype.final = function(t) {
      var f, e;
      return t && (f = this.update(t)), e = "encrypt" === this.type ? this._finalEncrypt() : this._finalDecrypt(), f ? f.concat(e) : e
    }, f.prototype._pad = function(t, f) {
      if (0 === f) return !1;
      for (; f < t.length;) t[f++] = 0;
      return !0
    }, f.prototype._finalEncrypt = function() {
      if (!this._pad(this.buffer, this.bufferOff)) return [];
      var t = new Array(this.blockSize);
      return this._update(this.buffer, 0, t, 0), t
    }, f.prototype._unpad = function(t) {
      return t
    }, f.prototype._finalDecrypt = function() {
      t.equal(this.bufferOff, this.blockSize, "Not enough data to decrypt");
      var f = new Array(this.blockSize);
      return this._flushBuffer(f, 0), this._unpad(f)
    };
  }, {
    "minimalistic-assert": "MpuC"
  }],
  "UVxA": [function(require, module, exports) {
    "use strict";
    var t = require("minimalistic-assert"),
      e = require("inherits"),
      r = require("./utils"),
      n = require("./cipher");

    function p() {
      this.tmp = new Array(2), this.keys = null
    }

    function i(t) {
      n.call(this, t);
      var e = new p;
      this._desState = e, this.deriveKeys(e, t.key)
    }
    e(i, n), module.exports = i, i.create = function(t) {
      return new i(t)
    };
    var s = [1, 1, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 1];
    i.prototype.deriveKeys = function(e, n) {
      e.keys = new Array(32), t.equal(n.length, this.blockSize, "Invalid key length");
      var p = r.readUInt32BE(n, 0),
        i = r.readUInt32BE(n, 4);
      r.pc1(p, i, e.tmp, 0), p = e.tmp[0], i = e.tmp[1];
      for (var a = 0; a < e.keys.length; a += 2) {
        var u = s[a >>> 1];
        p = r.r28shl(p, u), i = r.r28shl(i, u), r.pc2(p, i, e.keys, a)
      }
    }, i.prototype._update = function(t, e, n, p) {
      var i = this._desState,
        s = r.readUInt32BE(t, e),
        a = r.readUInt32BE(t, e + 4);
      r.ip(s, a, i.tmp, 0), s = i.tmp[0], a = i.tmp[1], "encrypt" === this.type ? this._encrypt(i, s, a, i.tmp, 0) : this._decrypt(i, s, a, i.tmp, 0), s = i.tmp[0], a = i.tmp[1], r.writeUInt32BE(n, s, p), r.writeUInt32BE(n, a, p + 4)
    }, i.prototype._pad = function(t, e) {
      for (var r = t.length - e, n = e; n < t.length; n++) t[n] = r;
      return !0
    }, i.prototype._unpad = function(e) {
      for (var r = e[e.length - 1], n = e.length - r; n < e.length; n++) t.equal(e[n], r);
      return e.slice(0, e.length - r)
    }, i.prototype._encrypt = function(t, e, n, p, i) {
      for (var s = e, a = n, u = 0; u < t.keys.length; u += 2) {
        var o = t.keys[u],
          y = t.keys[u + 1];
        r.expand(a, t.tmp, 0), o ^= t.tmp[0], y ^= t.tmp[1];
        var h = r.substitute(o, y),
          l = a;
        a = (s ^ r.permute(h)) >>> 0, s = l
      }
      r.rip(a, s, p, i)
    }, i.prototype._decrypt = function(t, e, n, p, i) {
      for (var s = n, a = e, u = t.keys.length - 2; u >= 0; u -= 2) {
        var o = t.keys[u],
          y = t.keys[u + 1];
        r.expand(s, t.tmp, 0), o ^= t.tmp[0], y ^= t.tmp[1];
        var h = r.substitute(o, y),
          l = s;
        s = (a ^ r.permute(h)) >>> 0, a = l
      }
      r.rip(s, a, p, i)
    };
  }, {
    "minimalistic-assert": "MpuC",
    "inherits": "Bm0n",
    "./utils": "a957",
    "./cipher": "eTzy"
  }],
  "NN3V": [function(require, module, exports) {
    "use strict";
    var t = require("minimalistic-assert"),
      i = require("inherits"),
      e = {};

    function r(i) {
      t.equal(i.length, 8, "Invalid IV length"), this.iv = new Array(8);
      for (var e = 0; e < this.iv.length; e++) this.iv[e] = i[e]
    }

    function n(t) {
      function r(i) {
        t.call(this, i), this._cbcInit()
      }
      i(r, t);
      for (var n = Object.keys(e), s = 0; s < n.length; s++) {
        var c = n[s];
        r.prototype[c] = e[c]
      }
      return r.create = function(t) {
        return new r(t)
      }, r
    }
    exports.instantiate = n, e._cbcInit = function() {
      var t = new r(this.options.iv);
      this._cbcState = t
    }, e._update = function(t, i, e, r) {
      var n = this._cbcState,
        s = this.constructor.super_.prototype,
        c = n.iv;
      if ("encrypt" === this.type) {
        for (var o = 0; o < this.blockSize; o++) c[o] ^= t[i + o];
        s._update.call(this, c, 0, e, r);
        for (o = 0; o < this.blockSize; o++) c[o] = e[r + o]
      } else {
        s._update.call(this, t, i, e, r);
        for (o = 0; o < this.blockSize; o++) e[r + o] ^= c[o];
        for (o = 0; o < this.blockSize; o++) c[o] = t[i + o]
      }
    };
  }, {
    "minimalistic-assert": "MpuC",
    "inherits": "Bm0n"
  }],
  "jkwx": [function(require, module, exports) {
    "use strict";
    var e = require("minimalistic-assert"),
      t = require("inherits"),
      r = require("./cipher"),
      p = require("./des");

    function i(t, r) {
      e.equal(r.length, 24, "Invalid key length");
      var i = r.slice(0, 8),
        c = r.slice(8, 16),
        y = r.slice(16, 24);
      this.ciphers = "encrypt" === t ? [p.create({
        type: "encrypt",
        key: i
      }), p.create({
        type: "decrypt",
        key: c
      }), p.create({
        type: "encrypt",
        key: y
      })] : [p.create({
        type: "decrypt",
        key: y
      }), p.create({
        type: "encrypt",
        key: c
      }), p.create({
        type: "decrypt",
        key: i
      })]
    }

    function c(e) {
      r.call(this, e);
      var t = new i(this.type, this.options.key);
      this._edeState = t
    }
    t(c, r), module.exports = c, c.create = function(e) {
      return new c(e)
    }, c.prototype._update = function(e, t, r, p) {
      var i = this._edeState;
      i.ciphers[0]._update(e, t, r, p), i.ciphers[1]._update(r, p, r, p), i.ciphers[2]._update(r, p, r, p)
    }, c.prototype._pad = p.prototype._pad, c.prototype._unpad = p.prototype._unpad;
  }, {
    "minimalistic-assert": "MpuC",
    "inherits": "Bm0n",
    "./cipher": "eTzy",
    "./des": "UVxA"
  }],
  "Tikc": [function(require, module, exports) {
    "use strict";
    exports.utils = require("./des/utils"), exports.Cipher = require("./des/cipher"), exports.DES = require("./des/des"), exports.CBC = require("./des/cbc"), exports.EDE = require("./des/ede");
  }, {
    "./des/utils": "a957",
    "./des/cipher": "eTzy",
    "./des/des": "UVxA",
    "./des/cbc": "NN3V",
    "./des/ede": "jkwx"
  }],
  "sKVA": [function(require, module, exports) {

    var e = require("cipher-base"),
      r = require("des.js"),
      t = require("inherits"),
      s = require("safe-buffer").Buffer,
      d = {
        "des-ede3-cbc": r.CBC.instantiate(r.EDE),
        "des-ede3": r.EDE,
        "des-ede-cbc": r.CBC.instantiate(r.EDE),
        "des-ede": r.EDE,
        "des-cbc": r.CBC.instantiate(r.DES),
        "des-ecb": r.DES
      };

    function i(r) {
      e.call(this);
      var t, i = r.mode.toLowerCase(),
        c = d[i];
      t = r.decrypt ? "decrypt" : "encrypt";
      var a = r.key;
      s.isBuffer(a) || (a = s.from(a)), "des-ede" !== i && "des-ede-cbc" !== i || (a = s.concat([a, a.slice(0, 8)]));
      var n = r.iv;
      s.isBuffer(n) || (n = s.from(n)), this._des = c.create({
        key: a,
        iv: n,
        type: t
      })
    }
    d.des = d["des-cbc"], d.des3 = d["des-ede3-cbc"], module.exports = i, t(i, e), i.prototype._update = function(e) {
      return s.from(this._des.update(e))
    }, i.prototype._final = function() {
      return s.from(this._des.final())
    };
  }, {
    "cipher-base": "bjfr",
    "des.js": "Tikc",
    "inherits": "Bm0n",
    "safe-buffer": "Wugr"
  }],
  "deTC": [function(require, module, exports) {
    exports.encrypt = function(r, c) {
      return r._cipher.encryptBlock(c)
    }, exports.decrypt = function(r, c) {
      return r._cipher.decryptBlock(c)
    };
  }, {}],
  "Bi15": [function(require, module, exports) {
    var Buffer = require("buffer").Buffer;
    var e = require("buffer").Buffer;
    module.exports = function(r, n) {
      for (var f = Math.min(r.length, n.length), t = new e(f), u = 0; u < f; ++u) t[u] = r[u] ^ n[u];
      return t
    };
  }, {
    "buffer": "dskh"
  }],
  "n4Db": [function(require, module, exports) {
    var r = require("buffer-xor");
    exports.encrypt = function(e, p) {
      var c = r(p, e._prev);
      return e._prev = e._cipher.encryptBlock(c), e._prev
    }, exports.decrypt = function(e, p) {
      var c = e._prev;
      e._prev = p;
      var t = e._cipher.decryptBlock(p);
      return r(t, c)
    };
  }, {
    "buffer-xor": "Bi15"
  }],
  "G0zN": [function(require, module, exports) {

    var e = require("safe-buffer").Buffer,
      c = require("buffer-xor");

    function r(r, a, n) {
      var t = a.length,
        h = c(a, r._cache);
      return r._cache = r._cache.slice(t), r._prev = e.concat([r._prev, n ? a : h]), h
    }
    exports.encrypt = function(c, a, n) {
      for (var t, h = e.allocUnsafe(0); a.length;) {
        if (0 === c._cache.length && (c._cache = c._cipher.encryptBlock(c._prev), c._prev = e.allocUnsafe(0)), !(c._cache.length <= a.length)) {
          h = e.concat([h, r(c, a, n)]);
          break
        }
        t = c._cache.length, h = e.concat([h, r(c, a.slice(0, t), n)]), a = a.slice(t)
      }
      return h
    };
  }, {
    "safe-buffer": "Wugr",
    "buffer-xor": "Bi15"
  }],
  "GBMF": [function(require, module, exports) {

    var r = require("safe-buffer").Buffer;

    function e(e, n, c) {
      var f = e._cipher.encryptBlock(e._prev)[0] ^ n;
      return e._prev = r.concat([e._prev.slice(1), r.from([c ? n : f])]), f
    }
    exports.encrypt = function(n, c, f) {
      for (var t = c.length, o = r.allocUnsafe(t), a = -1; ++a < t;) o[a] = e(n, c[a], f);
      return o
    };
  }, {
    "safe-buffer": "Wugr"
  }],
  "JZn9": [function(require, module, exports) {

    var r = require("safe-buffer").Buffer;

    function e(r, e, f) {
      for (var t, o, c = -1, a = 0; ++c < 8;) t = e & 1 << 7 - c ? 128 : 0, a += (128 & (o = r._cipher.encryptBlock(r._prev)[0] ^ t)) >> c % 8, r._prev = n(r._prev, f ? t : o);
      return a
    }

    function n(e, n) {
      var f = e.length,
        t = -1,
        o = r.allocUnsafe(e.length);
      for (e = r.concat([e, r.from([n])]); ++t < f;) o[t] = e[t] << 1 | e[t + 1] >> 7;
      return o
    }
    exports.encrypt = function(n, f, t) {
      for (var o = f.length, c = r.allocUnsafe(o), a = -1; ++a < o;) c[a] = e(n, f[a], t);
      return c
    };
  }, {
    "safe-buffer": "Wugr"
  }],
  "fJ7E": [function(require, module, exports) {
    var Buffer = require("buffer").Buffer;
    var e = require("buffer").Buffer,
      c = require("buffer-xor");

    function r(e) {
      return e._prev = e._cipher.encryptBlock(e._prev), e._prev
    }
    exports.encrypt = function(n, t) {
      for (; n._cache.length < t.length;) n._cache = e.concat([n._cache, r(n)]);
      var h = n._cache.slice(0, t.length);
      return n._cache = n._cache.slice(t.length), c(t, h)
    };
  }, {
    "buffer-xor": "Bi15",
    "buffer": "dskh"
  }],
  "EFOV": [function(require, module, exports) {
    function t(t) {
      for (var e, r = t.length; r--;) {
        if (255 !== (e = t.readUInt8(r))) {
          e++, t.writeUInt8(e, r);
          break
        }
        t.writeUInt8(0, r)
      }
    }
    module.exports = t;
  }, {}],
  "Iyxz": [function(require, module, exports) {

    var e = require("buffer-xor"),
      c = require("safe-buffer").Buffer,
      r = require("../incr32");

    function a(e) {
      var c = e._cipher.encryptBlockRaw(e._prev);
      return r(e._prev), c
    }
    var t = 16;
    exports.encrypt = function(r, n) {
      var h = Math.ceil(n.length / t),
        i = r._cache.length;
      r._cache = c.concat([r._cache, c.allocUnsafe(h * t)]);
      for (var _ = 0; _ < h; _++) {
        var f = a(r),
          l = i + _ * t;
        r._cache.writeUInt32BE(f[0], l + 0), r._cache.writeUInt32BE(f[1], l + 4), r._cache.writeUInt32BE(f[2], l + 8), r._cache.writeUInt32BE(f[3], l + 12)
      }
      var u = r._cache.slice(0, n.length);
      return r._cache = r._cache.slice(n.length), e(n, u)
    };
  }, {
    "buffer-xor": "Bi15",
    "safe-buffer": "Wugr",
    "../incr32": "EFOV"
  }],
  "veqz": [function(require, module, exports) {
    module.exports = {
      "aes-128-ecb": {
        cipher: "AES",
        key: 128,
        iv: 0,
        mode: "ECB",
        type: "block"
      },
      "aes-192-ecb": {
        cipher: "AES",
        key: 192,
        iv: 0,
        mode: "ECB",
        type: "block"
      },
      "aes-256-ecb": {
        cipher: "AES",
        key: 256,
        iv: 0,
        mode: "ECB",
        type: "block"
      },
      "aes-128-cbc": {
        cipher: "AES",
        key: 128,
        iv: 16,
        mode: "CBC",
        type: "block"
      },
      "aes-192-cbc": {
        cipher: "AES",
        key: 192,
        iv: 16,
        mode: "CBC",
        type: "block"
      },
      "aes-256-cbc": {
        cipher: "AES",
        key: 256,
        iv: 16,
        mode: "CBC",
        type: "block"
      },
      aes128: {
        cipher: "AES",
        key: 128,
        iv: 16,
        mode: "CBC",
        type: "block"
      },
      aes192: {
        cipher: "AES",
        key: 192,
        iv: 16,
        mode: "CBC",
        type: "block"
      },
      aes256: {
        cipher: "AES",
        key: 256,
        iv: 16,
        mode: "CBC",
        type: "block"
      },
      "aes-128-cfb": {
        cipher: "AES",
        key: 128,
        iv: 16,
        mode: "CFB",
        type: "stream"
      },
      "aes-192-cfb": {
        cipher: "AES",
        key: 192,
        iv: 16,
        mode: "CFB",
        type: "stream"
      },
      "aes-256-cfb": {
        cipher: "AES",
        key: 256,
        iv: 16,
        mode: "CFB",
        type: "stream"
      },
      "aes-128-cfb8": {
        cipher: "AES",
        key: 128,
        iv: 16,
        mode: "CFB8",
        type: "stream"
      },
      "aes-192-cfb8": {
        cipher: "AES",
        key: 192,
        iv: 16,
        mode: "CFB8",
        type: "stream"
      },
      "aes-256-cfb8": {
        cipher: "AES",
        key: 256,
        iv: 16,
        mode: "CFB8",
        type: "stream"
      },
      "aes-128-cfb1": {
        cipher: "AES",
        key: 128,
        iv: 16,
        mode: "CFB1",
        type: "stream"
      },
      "aes-192-cfb1": {
        cipher: "AES",
        key: 192,
        iv: 16,
        mode: "CFB1",
        type: "stream"
      },
      "aes-256-cfb1": {
        cipher: "AES",
        key: 256,
        iv: 16,
        mode: "CFB1",
        type: "stream"
      },
      "aes-128-ofb": {
        cipher: "AES",
        key: 128,
        iv: 16,
        mode: "OFB",
        type: "stream"
      },
      "aes-192-ofb": {
        cipher: "AES",
        key: 192,
        iv: 16,
        mode: "OFB",
        type: "stream"
      },
      "aes-256-ofb": {
        cipher: "AES",
        key: 256,
        iv: 16,
        mode: "OFB",
        type: "stream"
      },
      "aes-128-ctr": {
        cipher: "AES",
        key: 128,
        iv: 16,
        mode: "CTR",
        type: "stream"
      },
      "aes-192-ctr": {
        cipher: "AES",
        key: 192,
        iv: 16,
        mode: "CTR",
        type: "stream"
      },
      "aes-256-ctr": {
        cipher: "AES",
        key: 256,
        iv: 16,
        mode: "CTR",
        type: "stream"
      },
      "aes-128-gcm": {
        cipher: "AES",
        key: 128,
        iv: 12,
        mode: "GCM",
        type: "auth"
      },
      "aes-192-gcm": {
        cipher: "AES",
        key: 192,
        iv: 12,
        mode: "GCM",
        type: "auth"
      },
      "aes-256-gcm": {
        cipher: "AES",
        key: 256,
        iv: 12,
        mode: "GCM",
        type: "auth"
      }
    };
  }, {}],
  "zdSg": [function(require, module, exports) {
    var r = {
        ECB: require("./ecb"),
        CBC: require("./cbc"),
        CFB: require("./cfb"),
        CFB8: require("./cfb8"),
        CFB1: require("./cfb1"),
        OFB: require("./ofb"),
        CTR: require("./ctr"),
        GCM: require("./ctr")
      },
      e = require("./list.json");
    for (var i in e) e[i].module = r[e[i].mode];
    module.exports = e;
  }, {
    "./ecb": "deTC",
    "./cbc": "n4Db",
    "./cfb": "G0zN",
    "./cfb8": "GBMF",
    "./cfb1": "JZn9",
    "./ofb": "fJ7E",
    "./ctr": "Iyxz",
    "./list.json": "veqz"
  }],
  "dNn4": [function(require, module, exports) {

    var e = require("safe-buffer").Buffer;

    function t(t) {
      e.isBuffer(t) || (t = e.from(t));
      for (var r = t.length / 4 | 0, n = new Array(r), o = 0; o < r; o++) n[o] = t.readUInt32BE(4 * o);
      return n
    }

    function r(e) {
      for (; 0 < e.length; e++) e[0] = 0
    }

    function n(e, t, r, n, o) {
      for (var i, B, S, u, c = r[0], _ = r[1], f = r[2], a = r[3], s = e[0] ^ t[0], y = e[1] ^ t[1], I = e[2] ^ t[2], X = e[3] ^ t[3], h = 4, l = 1; l < o; l++) i = c[s >>> 24] ^ _[y >>> 16 & 255] ^ f[I >>> 8 & 255] ^ a[255 & X] ^ t[h++], B = c[y >>> 24] ^ _[I >>> 16 & 255] ^ f[X >>> 8 & 255] ^ a[255 & s] ^ t[h++], S = c[I >>> 24] ^ _[X >>> 16 & 255] ^ f[s >>> 8 & 255] ^ a[255 & y] ^ t[h++], u = c[X >>> 24] ^ _[s >>> 16 & 255] ^ f[y >>> 8 & 255] ^ a[255 & I] ^ t[h++], s = i, y = B, I = S, X = u;
      return i = (n[s >>> 24] << 24 | n[y >>> 16 & 255] << 16 | n[I >>> 8 & 255] << 8 | n[255 & X]) ^ t[h++], B = (n[y >>> 24] << 24 | n[I >>> 16 & 255] << 16 | n[X >>> 8 & 255] << 8 | n[255 & s]) ^ t[h++], S = (n[I >>> 24] << 24 | n[X >>> 16 & 255] << 16 | n[s >>> 8 & 255] << 8 | n[255 & y]) ^ t[h++], u = (n[X >>> 24] << 24 | n[s >>> 16 & 255] << 16 | n[y >>> 8 & 255] << 8 | n[255 & I]) ^ t[h++], [i >>>= 0, B >>>= 0, S >>>= 0, u >>>= 0]
    }
    var o = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54],
      i = function() {
        for (var e = new Array(256), t = 0; t < 256; t++) e[t] = t < 128 ? t << 1 : t << 1 ^ 283;
        for (var r = [], n = [], o = [
            [],
            [],
            [],
            []
          ], i = [
            [],
            [],
            [],
            []
          ], B = 0, S = 0, u = 0; u < 256; ++u) {
          var c = S ^ S << 1 ^ S << 2 ^ S << 3 ^ S << 4;
          c = c >>> 8 ^ 255 & c ^ 99, r[B] = c, n[c] = B;
          var _ = e[B],
            f = e[_],
            a = e[f],
            s = 257 * e[c] ^ 16843008 * c;
          o[0][B] = s << 24 | s >>> 8, o[1][B] = s << 16 | s >>> 16, o[2][B] = s << 8 | s >>> 24, o[3][B] = s, s = 16843009 * a ^ 65537 * f ^ 257 * _ ^ 16843008 * B, i[0][c] = s << 24 | s >>> 8, i[1][c] = s << 16 | s >>> 16, i[2][c] = s << 8 | s >>> 24, i[3][c] = s, 0 === B ? B = S = 1 : (B = _ ^ e[e[e[a ^ _]]], S ^= e[e[S]])
        }
        return {
          SBOX: r,
          INV_SBOX: n,
          SUB_MIX: o,
          INV_SUB_MIX: i
        }
      }();

    function B(e) {
      this._key = t(e), this._reset()
    }
    B.blockSize = 16, B.keySize = 32, B.prototype.blockSize = B.blockSize, B.prototype.keySize = B.keySize, B.prototype._reset = function() {
      for (var e = this._key, t = e.length, r = t + 6, n = 4 * (r + 1), B = [], S = 0; S < t; S++) B[S] = e[S];
      for (S = t; S < n; S++) {
        var u = B[S - 1];
        S % t == 0 ? (u = u << 8 | u >>> 24, u = i.SBOX[u >>> 24] << 24 | i.SBOX[u >>> 16 & 255] << 16 | i.SBOX[u >>> 8 & 255] << 8 | i.SBOX[255 & u], u ^= o[S / t | 0] << 24) : t > 6 && S % t == 4 && (u = i.SBOX[u >>> 24] << 24 | i.SBOX[u >>> 16 & 255] << 16 | i.SBOX[u >>> 8 & 255] << 8 | i.SBOX[255 & u]), B[S] = B[S - t] ^ u
      }
      for (var c = [], _ = 0; _ < n; _++) {
        var f = n - _,
          a = B[f - (_ % 4 ? 0 : 4)];
        c[_] = _ < 4 || f <= 4 ? a : i.INV_SUB_MIX[0][i.SBOX[a >>> 24]] ^ i.INV_SUB_MIX[1][i.SBOX[a >>> 16 & 255]] ^ i.INV_SUB_MIX[2][i.SBOX[a >>> 8 & 255]] ^ i.INV_SUB_MIX[3][i.SBOX[255 & a]]
      }
      this._nRounds = r, this._keySchedule = B, this._invKeySchedule = c
    }, B.prototype.encryptBlockRaw = function(e) {
      return n(e = t(e), this._keySchedule, i.SUB_MIX, i.SBOX, this._nRounds)
    }, B.prototype.encryptBlock = function(t) {
      var r = this.encryptBlockRaw(t),
        n = e.allocUnsafe(16);
      return n.writeUInt32BE(r[0], 0), n.writeUInt32BE(r[1], 4), n.writeUInt32BE(r[2], 8), n.writeUInt32BE(r[3], 12), n
    }, B.prototype.decryptBlock = function(r) {
      var o = (r = t(r))[1];
      r[1] = r[3], r[3] = o;
      var B = n(r, this._invKeySchedule, i.INV_SUB_MIX, i.INV_SBOX, this._nRounds),
        S = e.allocUnsafe(16);
      return S.writeUInt32BE(B[0], 0), S.writeUInt32BE(B[3], 4), S.writeUInt32BE(B[2], 8), S.writeUInt32BE(B[1], 12), S
    }, B.prototype.scrub = function() {
      r(this._keySchedule), r(this._invKeySchedule), r(this._key)
    }, module.exports.AES = B;
  }, {
    "safe-buffer": "Wugr"
  }],
  "vgFu": [function(require, module, exports) {

    var t = require("safe-buffer").Buffer,
      e = t.alloc(16, 0);

    function h(t) {
      return [t.readUInt32BE(0), t.readUInt32BE(4), t.readUInt32BE(8), t.readUInt32BE(12)]
    }

    function a(e) {
      var h = t.allocUnsafe(16);
      return h.writeUInt32BE(e[0] >>> 0, 0), h.writeUInt32BE(e[1] >>> 0, 4), h.writeUInt32BE(e[2] >>> 0, 8), h.writeUInt32BE(e[3] >>> 0, 12), h
    }

    function i(e) {
      this.h = e, this.state = t.alloc(16, 0), this.cache = t.allocUnsafe(0)
    }
    i.prototype.ghash = function(t) {
      for (var e = -1; ++e < t.length;) this.state[e] ^= t[e];
      this._multiply()
    }, i.prototype._multiply = function() {
      for (var t, e, i = h(this.h), c = [0, 0, 0, 0], s = -1; ++s < 128;) {
        for (0 != (this.state[~~(s / 8)] & 1 << 7 - s % 8) && (c[0] ^= i[0], c[1] ^= i[1], c[2] ^= i[2], c[3] ^= i[3]), e = 0 != (1 & i[3]), t = 3; t > 0; t--) i[t] = i[t] >>> 1 | (1 & i[t - 1]) << 31;
        i[0] = i[0] >>> 1, e && (i[0] = i[0] ^ 225 << 24)
      }
      this.state = a(c)
    }, i.prototype.update = function(e) {
      var h;
      for (this.cache = t.concat([this.cache, e]); this.cache.length >= 16;) h = this.cache.slice(0, 16), this.cache = this.cache.slice(16), this.ghash(h)
    }, i.prototype.final = function(h, i) {
      return this.cache.length && this.ghash(t.concat([this.cache, e], 16)), this.ghash(a([0, h, 0, i])), this.state
    }, module.exports = i;
  }, {
    "safe-buffer": "Wugr"
  }],
  "KDZf": [function(require, module, exports) {

    var t = require("./aes"),
      e = require("safe-buffer").Buffer,
      r = require("cipher-base"),
      h = require("inherits"),
      a = require("./ghash"),
      i = require("buffer-xor"),
      n = require("./incr32");

    function s(t, e) {
      var r = 0;
      t.length !== e.length && r++;
      for (var h = Math.min(t.length, e.length), a = 0; a < h; ++a) r += t[a] ^ e[a];
      return r
    }

    function o(t, r, h) {
      if (12 === r.length) return t._finID = e.concat([r, e.from([0, 0, 0, 1])]), e.concat([r, e.from([0, 0, 0, 2])]);
      var i = new a(h),
        s = r.length,
        o = s % 16;
      i.update(r), o && (o = 16 - o, i.update(e.alloc(o, 0))), i.update(e.alloc(8, 0));
      var u = 8 * s,
        l = e.alloc(8);
      l.writeUIntBE(u, 0, 8), i.update(l), t._finID = i.state;
      var c = e.from(t._finID);
      return n(c), c
    }

    function u(h, i, n, s) {
      r.call(this);
      var u = e.alloc(4, 0);
      this._cipher = new t.AES(i);
      var l = this._cipher.encryptBlock(u);
      this._ghash = new a(l), n = o(this, n, l), this._prev = e.from(n), this._cache = e.allocUnsafe(0), this._secCache = e.allocUnsafe(0), this._decrypt = s, this._alen = 0, this._len = 0, this._mode = h, this._authTag = null, this._called = !1
    }
    h(u, r), u.prototype._update = function(t) {
      if (!this._called && this._alen) {
        var r = 16 - this._alen % 16;
        r < 16 && (r = e.alloc(r, 0), this._ghash.update(r))
      }
      this._called = !0;
      var h = this._mode.encrypt(this, t);
      return this._decrypt ? this._ghash.update(t) : this._ghash.update(h), this._len += t.length, h
    }, u.prototype._final = function() {
      if (this._decrypt && !this._authTag) throw new Error("Unsupported state or unable to authenticate data");
      var t = i(this._ghash.final(8 * this._alen, 8 * this._len), this._cipher.encryptBlock(this._finID));
      if (this._decrypt && s(t, this._authTag)) throw new Error("Unsupported state or unable to authenticate data");
      this._authTag = t, this._cipher.scrub()
    }, u.prototype.getAuthTag = function() {
      if (this._decrypt || !e.isBuffer(this._authTag)) throw new Error("Attempting to get auth tag in unsupported state");
      return this._authTag
    }, u.prototype.setAuthTag = function(t) {
      if (!this._decrypt) throw new Error("Attempting to set auth tag in unsupported state");
      this._authTag = t
    }, u.prototype.setAAD = function(t) {
      if (this._called) throw new Error("Attempting to set AAD in unsupported state");
      this._ghash.update(t), this._alen += t.length
    }, module.exports = u;
  }, {
    "./aes": "dNn4",
    "safe-buffer": "Wugr",
    "cipher-base": "bjfr",
    "inherits": "Bm0n",
    "./ghash": "vgFu",
    "buffer-xor": "Bi15",
    "./incr32": "EFOV"
  }],
  "XmsB": [function(require, module, exports) {

    var e = require("./aes"),
      r = require("safe-buffer").Buffer,
      t = require("cipher-base"),
      i = require("inherits");

    function s(i, s, c, h) {
      t.call(this), this._cipher = new e.AES(s), this._prev = r.from(c), this._cache = r.allocUnsafe(0), this._secCache = r.allocUnsafe(0), this._decrypt = h, this._mode = i
    }
    i(s, t), s.prototype._update = function(e) {
      return this._mode.encrypt(this, e, this._decrypt)
    }, s.prototype._final = function() {
      this._cipher.scrub()
    }, module.exports = s;
  }, {
    "./aes": "dNn4",
    "safe-buffer": "Wugr",
    "cipher-base": "bjfr",
    "inherits": "Bm0n"
  }],
  "exU6": [function(require, module, exports) {

    var e = require("safe-buffer").Buffer,
      r = require("md5.js");

    function t(t, a, f, l) {
      if (e.isBuffer(t) || (t = e.from(t, "binary")), a && (e.isBuffer(a) || (a = e.from(a, "binary")), 8 !== a.length)) throw new RangeError("salt should be Buffer with 8 byte length");
      for (var n = f / 8, i = e.alloc(n), o = e.alloc(l || 0), u = e.alloc(0); n > 0 || l > 0;) {
        var h = new r;
        h.update(u), h.update(t), a && h.update(a), u = h.digest();
        var g = 0;
        if (n > 0) {
          var s = i.length - n;
          g = Math.min(n, u.length), u.copy(i, s, 0, g), n -= g
        }
        if (g < u.length && l > 0) {
          var d = o.length - l,
            v = Math.min(l, u.length - g);
          u.copy(o, d, g, g + v), l -= v
        }
      }
      return u.fill(0), {
        key: i,
        iv: o
      }
    }
    module.exports = t;
  }, {
    "safe-buffer": "Wugr",
    "md5.js": "OP64"
  }],
  "zRzx": [function(require, module, exports) {

    var e = require("./modes"),
      t = require("./authCipher"),
      r = require("safe-buffer").Buffer,
      i = require("./streamCipher"),
      n = require("cipher-base"),
      h = require("./aes"),
      o = require("evp_bytestokey"),
      a = require("inherits");

    function c(e, t, i) {
      n.call(this), this._cache = new u, this._cipher = new h.AES(t), this._prev = r.from(i), this._mode = e, this._autopadding = !0
    }
    a(c, n), c.prototype._update = function(e) {
      var t, i;
      this._cache.add(e);
      for (var n = []; t = this._cache.get();) i = this._mode.encrypt(this, t), n.push(i);
      return r.concat(n)
    };
    var s = r.alloc(16, 16);

    function u() {
      this.cache = r.allocUnsafe(0)
    }

    function p(n, h, o) {
      var a = e[n.toLowerCase()];
      if (!a) throw new TypeError("invalid suite type");
      if ("string" == typeof h && (h = r.from(h)), h.length !== a.key / 8) throw new TypeError("invalid key length " + h.length);
      if ("string" == typeof o && (o = r.from(o)), "GCM" !== a.mode && o.length !== a.iv) throw new TypeError("invalid iv length " + o.length);
      return "stream" === a.type ? new i(a.module, h, o) : "auth" === a.type ? new t(a.module, h, o) : new c(a.module, h, o)
    }

    function f(t, r) {
      var i = e[t.toLowerCase()];
      if (!i) throw new TypeError("invalid suite type");
      var n = o(r, !1, i.key, i.iv);
      return p(t, n.key, n.iv)
    }
    c.prototype._final = function() {
      var e = this._cache.flush();
      if (this._autopadding) return e = this._mode.encrypt(this, e), this._cipher.scrub(), e;
      if (!e.equals(s)) throw this._cipher.scrub(), new Error("data not multiple of block length")
    }, c.prototype.setAutoPadding = function(e) {
      return this._autopadding = !!e, this
    }, u.prototype.add = function(e) {
      this.cache = r.concat([this.cache, e])
    }, u.prototype.get = function() {
      if (this.cache.length > 15) {
        var e = this.cache.slice(0, 16);
        return this.cache = this.cache.slice(16), e
      }
      return null
    }, u.prototype.flush = function() {
      for (var e = 16 - this.cache.length, t = r.allocUnsafe(e), i = -1; ++i < e;) t.writeUInt8(e, i);
      return r.concat([this.cache, t])
    }, exports.createCipheriv = p, exports.createCipher = f;
  }, {
    "./modes": "zdSg",
    "./authCipher": "KDZf",
    "safe-buffer": "Wugr",
    "./streamCipher": "XmsB",
    "cipher-base": "bjfr",
    "./aes": "dNn4",
    "evp_bytestokey": "exU6",
    "inherits": "Bm0n"
  }],
  "qK8d": [function(require, module, exports) {

    var e = require("./authCipher"),
      t = require("safe-buffer").Buffer,
      r = require("./modes"),
      i = require("./streamCipher"),
      h = require("cipher-base"),
      n = require("./aes"),
      o = require("evp_bytestokey"),
      a = require("inherits");

    function c(e, r, i) {
      h.call(this), this._cache = new s, this._last = void 0, this._cipher = new n.AES(r), this._prev = t.from(i), this._mode = e, this._autopadding = !0
    }

    function s() {
      this.cache = t.allocUnsafe(0)
    }

    function u(e) {
      var t = e[15];
      if (t < 1 || t > 16) throw new Error("unable to decrypt data");
      for (var r = -1; ++r < t;)
        if (e[r + (16 - t)] !== t) throw new Error("unable to decrypt data");
      if (16 !== t) return e.slice(0, 16 - t)
    }

    function p(h, n, o) {
      var a = r[h.toLowerCase()];
      if (!a) throw new TypeError("invalid suite type");
      if ("string" == typeof o && (o = t.from(o)), "GCM" !== a.mode && o.length !== a.iv) throw new TypeError("invalid iv length " + o.length);
      if ("string" == typeof n && (n = t.from(n)), n.length !== a.key / 8) throw new TypeError("invalid key length " + n.length);
      return "stream" === a.type ? new i(a.module, n, o, !0) : "auth" === a.type ? new e(a.module, n, o, !0) : new c(a.module, n, o)
    }

    function f(e, t) {
      var i = r[e.toLowerCase()];
      if (!i) throw new TypeError("invalid suite type");
      var h = o(t, !1, i.key, i.iv);
      return p(e, h.key, h.iv)
    }
    a(c, h), c.prototype._update = function(e) {
      var r, i;
      this._cache.add(e);
      for (var h = []; r = this._cache.get(this._autopadding);) i = this._mode.decrypt(this, r), h.push(i);
      return t.concat(h)
    }, c.prototype._final = function() {
      var e = this._cache.flush();
      if (this._autopadding) return u(this._mode.decrypt(this, e));
      if (e) throw new Error("data not multiple of block length")
    }, c.prototype.setAutoPadding = function(e) {
      return this._autopadding = !!e, this
    }, s.prototype.add = function(e) {
      this.cache = t.concat([this.cache, e])
    }, s.prototype.get = function(e) {
      var t;
      if (e) {
        if (this.cache.length > 16) return t = this.cache.slice(0, 16), this.cache = this.cache.slice(16), t
      } else if (this.cache.length >= 16) return t = this.cache.slice(0, 16), this.cache = this.cache.slice(16), t;
      return null
    }, s.prototype.flush = function() {
      if (this.cache.length) return this.cache
    }, exports.createDecipher = f, exports.createDecipheriv = p;
  }, {
    "./authCipher": "KDZf",
    "safe-buffer": "Wugr",
    "./modes": "zdSg",
    "./streamCipher": "XmsB",
    "cipher-base": "bjfr",
    "./aes": "dNn4",
    "evp_bytestokey": "exU6",
    "inherits": "Bm0n"
  }],
  "hisC": [function(require, module, exports) {
    var e = require("./encrypter"),
      r = require("./decrypter"),
      i = require("./modes/list.json");

    function p() {
      return Object.keys(i)
    }
    exports.createCipher = exports.Cipher = e.createCipher, exports.createCipheriv = exports.Cipheriv = e.createCipheriv, exports.createDecipher = exports.Decipher = r.createDecipher, exports.createDecipheriv = exports.Decipheriv = r.createDecipheriv, exports.listCiphers = exports.getCiphers = p;
  }, {
    "./encrypter": "zRzx",
    "./decrypter": "qK8d",
    "./modes/list.json": "veqz"
  }],
  "V0IC": [function(require, module, exports) {
    exports["des-ecb"] = {
      key: 8,
      iv: 0
    }, exports["des-cbc"] = exports.des = {
      key: 8,
      iv: 8
    }, exports["des-ede3-cbc"] = exports.des3 = {
      key: 24,
      iv: 8
    }, exports["des-ede3"] = {
      key: 24,
      iv: 0
    }, exports["des-ede-cbc"] = {
      key: 16,
      iv: 8
    }, exports["des-ede"] = {
      key: 16,
      iv: 0
    };
  }, {}],
  "KTbn": [function(require, module, exports) {
    var e = require("browserify-des"),
      r = require("browserify-aes/browser"),
      i = require("browserify-aes/modes"),
      t = require("browserify-des/modes"),
      o = require("evp_bytestokey");

    function s(e, r) {
      var s, p;
      if (e = e.toLowerCase(), i[e]) s = i[e].key, p = i[e].iv;
      else {
        if (!t[e]) throw new TypeError("invalid suite type");
        s = 8 * t[e].key, p = t[e].iv
      }
      var v = o(r, !1, s, p);
      return n(e, v.key, v.iv)
    }

    function p(e, r) {
      var s, p;
      if (e = e.toLowerCase(), i[e]) s = i[e].key, p = i[e].iv;
      else {
        if (!t[e]) throw new TypeError("invalid suite type");
        s = 8 * t[e].key, p = t[e].iv
      }
      var n = o(r, !1, s, p);
      return v(e, n.key, n.iv)
    }

    function n(o, s, p) {
      if (o = o.toLowerCase(), i[o]) return r.createCipheriv(o, s, p);
      if (t[o]) return new e({
        key: s,
        iv: p,
        mode: o
      });
      throw new TypeError("invalid suite type")
    }

    function v(o, s, p) {
      if (o = o.toLowerCase(), i[o]) return r.createDecipheriv(o, s, p);
      if (t[o]) return new e({
        key: s,
        iv: p,
        mode: o,
        decrypt: !0
      });
      throw new TypeError("invalid suite type")
    }

    function y() {
      return Object.keys(t).concat(r.getCiphers())
    }
    exports.createCipher = exports.Cipher = s, exports.createCipheriv = exports.Cipheriv = n, exports.createDecipher = exports.Decipher = p, exports.createDecipheriv = exports.Decipheriv = v, exports.listCiphers = exports.getCiphers = y;
  }, {
    "browserify-des": "sKVA",
    "browserify-aes/browser": "hisC",
    "browserify-aes/modes": "zdSg",
    "browserify-des/modes": "V0IC",
    "evp_bytestokey": "exU6"
  }],
  "VQun": [function(require, module, exports) {
    var r = require("bn.js"),
      e = require("brorand");

    function n(r) {
      this.rand = r || new e.Rand
    }
    module.exports = n, n.create = function(r) {
      return new n(r)
    }, n.prototype._randbelow = function(e) {
      var n = e.bitLength(),
        t = Math.ceil(n / 8);
      do {
        var o = new r(this.rand.generate(t))
      } while (o.cmp(e) >= 0);
      return o
    }, n.prototype._randrange = function(r, e) {
      var n = e.sub(r);
      return r.add(this._randbelow(n))
    }, n.prototype.test = function(e, n, t) {
      var o = e.bitLength(),
        a = r.mont(e),
        d = new r(1).toRed(a);
      n || (n = Math.max(1, o / 48 | 0));
      for (var i = e.subn(1), u = 0; !i.testn(u); u++);
      for (var f = e.shrn(u), c = i.toRed(a); n > 0; n--) {
        var p = this._randrange(new r(2), i);
        t && t(p);
        var s = p.toRed(a).redPow(f);
        if (0 !== s.cmp(d) && 0 !== s.cmp(c)) {
          for (var m = 1; m < u; m++) {
            if (0 === (s = s.redSqr()).cmp(d)) return !1;
            if (0 === s.cmp(c)) break
          }
          if (m === u) return !1
        }
      }
      return !0
    }, n.prototype.getDivisor = function(e, n) {
      var t = e.bitLength(),
        o = r.mont(e),
        a = new r(1).toRed(o);
      n || (n = Math.max(1, t / 48 | 0));
      for (var d = e.subn(1), i = 0; !d.testn(i); i++);
      for (var u = e.shrn(i), f = d.toRed(o); n > 0; n--) {
        var c = this._randrange(new r(2), d),
          p = e.gcd(c);
        if (0 !== p.cmpn(1)) return p;
        var s = c.toRed(o).redPow(u);
        if (0 !== s.cmp(a) && 0 !== s.cmp(f)) {
          for (var m = 1; m < i; m++) {
            if (0 === (s = s.redSqr()).cmp(a)) return s.fromRed().subn(1).gcd(e);
            if (0 === s.cmp(f)) break
          }
          if (m === i) return (s = s.redSqr()).fromRed().subn(1).gcd(e)
        }
      }
      return !1
    };
  }, {
    "bn.js": "AGD1",
    "brorand": "e03B"
  }],
  "Lj8n": [function(require, module, exports) {
    var e = require("randombytes");
    module.exports = M, M.simpleSieve = b, M.fermatTest = q;
    var n = require("bn.js"),
      r = new n(24),
      t = require("miller-rabin"),
      i = new t,
      o = new n(1),
      f = new n(2),
      a = new n(5),
      u = new n(16),
      w = new n(8),
      d = new n(10),
      m = new n(3),
      s = new n(7),
      c = new n(11),
      l = new n(4),
      v = new n(12),
      p = null;

    function h() {
      if (null !== p) return p;
      var e = [];
      e[0] = 2;
      for (var n = 1, r = 3; r < 1048576; r += 2) {
        for (var t = Math.ceil(Math.sqrt(r)), i = 0; i < n && e[i] <= t && r % e[i] != 0; i++);
        n !== i && e[i] <= t || (e[n++] = r)
      }
      return p = e, e
    }

    function b(e) {
      for (var n = h(), r = 0; r < n.length; r++)
        if (0 === e.modn(n[r])) return 0 === e.cmpn(n[r]);
      return !0
    }

    function q(e) {
      var r = n.mont(e);
      return 0 === f.toRed(r).redPow(e.subn(1)).fromRed().cmpn(1)
    }

    function M(t, u) {
      if (t < 16) return new n(2 === u || 5 === u ? [140, 123] : [140, 39]);
      var w, s;
      for (u = new n(u);;) {
        for (w = new n(e(Math.ceil(t / 8))); w.bitLength() > t;) w.ishrn(1);
        if (w.isEven() && w.iadd(o), w.testn(1) || w.iadd(f), u.cmp(f)) {
          if (!u.cmp(a))
            for (; w.mod(d).cmp(m);) w.iadd(l)
        } else
          for (; w.mod(r).cmp(c);) w.iadd(l);
        if (b(s = w.shrn(1)) && b(w) && q(s) && q(w) && i.test(s) && i.test(w)) return w
      }
    }
  }, {
    "randombytes": "XJNj",
    "bn.js": "AGD1",
    "miller-rabin": "VQun"
  }],
  "nq14": [function(require, module, exports) {
    module.exports = {
      modp1: {
        gen: "02",
        prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a63a3620ffffffffffffffff"
      },
      modp2: {
        gen: "02",
        prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece65381ffffffffffffffff"
      },
      modp5: {
        gen: "02",
        prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca237327ffffffffffffffff"
      },
      modp14: {
        gen: "02",
        prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aacaa68ffffffffffffffff"
      },
      modp15: {
        gen: "02",
        prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a93ad2caffffffffffffffff"
      },
      modp16: {
        gen: "02",
        prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c934063199ffffffffffffffff"
      },
      modp17: {
        gen: "02",
        prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dcc4024ffffffffffffffff"
      },
      modp18: {
        gen: "02",
        prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dbe115974a3926f12fee5e438777cb6a932df8cd8bec4d073b931ba3bc832b68d9dd300741fa7bf8afc47ed2576f6936ba424663aab639c5ae4f5683423b4742bf1c978238f16cbe39d652de3fdb8befc848ad922222e04a4037c0713eb57a81a23f0c73473fc646cea306b4bcbc8862f8385ddfa9d4b7fa2c087e879683303ed5bdd3a062b3cf5b3a278a66d2a13f83f44f82ddf310ee074ab6a364597e899a0255dc164f31cc50846851df9ab48195ded7ea1b1d510bd7ee74d73faf36bc31ecfa268359046f4eb879f924009438b481c6cd7889a002ed5ee382bc9190da6fc026e479558e4475677e9aa9e3050e2765694dfc81f56e880b96e7160c980dd98edd3dfffffffffffffffff"
      }
    };
  }, {}],
  "SXPn": [function(require, module, exports) {
    var Buffer = require("buffer").Buffer;
    var e = require("buffer").Buffer,
      t = require("bn.js"),
      r = require("miller-rabin"),
      i = new r,
      n = new t(24),
      o = new t(11),
      s = new t(10),
      u = new t(3),
      p = new t(7),
      h = require("./generatePrime"),
      f = require("randombytes");

    function _(r, i) {
      return i = i || "utf8", e.isBuffer(r) || (r = new e(r, i)), this._pub = new t(r), this
    }

    function m(r, i) {
      return i = i || "utf8", e.isBuffer(r) || (r = new e(r, i)), this._priv = new t(r), this
    }
    module.exports = g;
    var c = {};

    function a(e, t) {
      var r = t.toString("hex"),
        f = [r, e.toString(16)].join("_");
      if (f in c) return c[f];
      var _, m = 0;
      if (e.isEven() || !h.simpleSieve || !h.fermatTest(e) || !i.test(e)) return m += 1, m += "02" === r || "05" === r ? 8 : 4, c[f] = m, m;
      switch (i.test(e.shrn(1)) || (m += 2), r) {
        case "02":
          e.mod(n).cmp(o) && (m += 8);
          break;
        case "05":
          (_ = e.mod(s)).cmp(u) && _.cmp(p) && (m += 8);
          break;
        default:
          m += 4
      }
      return c[f] = m, m
    }

    function g(e, r, i) {
      this.setGenerator(r), this.__prime = new t(e), this._prime = t.mont(this.__prime), this._primeLen = e.length, this._pub = void 0, this._priv = void 0, this._primeCode = void 0, i ? (this.setPublicKey = _, this.setPrivateKey = m) : this._primeCode = 8
    }

    function v(t, r) {
      var i = new e(t.toArray());
      return r ? i.toString(r) : i
    }
    Object.defineProperty(g.prototype, "verifyError", {
      enumerable: !0,
      get: function() {
        return "number" != typeof this._primeCode && (this._primeCode = a(this.__prime, this.__gen)), this._primeCode
      }
    }), g.prototype.generateKeys = function() {
      return this._priv || (this._priv = new t(f(this._primeLen))), this._pub = this._gen.toRed(this._prime).redPow(this._priv).fromRed(), this.getPublicKey()
    }, g.prototype.computeSecret = function(r) {
      var i = (r = (r = new t(r)).toRed(this._prime)).redPow(this._priv).fromRed(),
        n = new e(i.toArray()),
        o = this.getPrime();
      if (n.length < o.length) {
        var s = new e(o.length - n.length);
        s.fill(0), n = e.concat([s, n])
      }
      return n
    }, g.prototype.getPublicKey = function(e) {
      return v(this._pub, e)
    }, g.prototype.getPrivateKey = function(e) {
      return v(this._priv, e)
    }, g.prototype.getPrime = function(e) {
      return v(this.__prime, e)
    }, g.prototype.getGenerator = function(e) {
      return v(this._gen, e)
    }, g.prototype.setGenerator = function(r, i) {
      return i = i || "utf8", e.isBuffer(r) || (r = new e(r, i)), this.__gen = r, this._gen = new t(r), this
    };
  }, {
    "bn.js": "AGD1",
    "miller-rabin": "VQun",
    "./generatePrime": "Lj8n",
    "randombytes": "XJNj",
    "buffer": "dskh"
  }],
  "WFL2": [function(require, module, exports) {
    var Buffer = require("buffer").Buffer;
    var e = require("buffer").Buffer,
      r = require("./lib/generatePrime"),
      i = require("./lib/primes.json"),
      n = require("./lib/dh");

    function f(r) {
      var f = new e(i[r].prime, "hex"),
        a = new e(i[r].gen, "hex");
      return new n(f, a)
    }
    var a = {
      binary: !0,
      hex: !0,
      base64: !0
    };

    function u(i, f, t, l) {
      return e.isBuffer(f) || void 0 === a[f] ? u(i, "binary", f, t) : (f = f || "binary", l = l || "binary", t = t || new e([2]), e.isBuffer(t) || (t = new e(t, l)), "number" == typeof i ? new n(r(i, t), t, !0) : (e.isBuffer(i) || (i = new e(i, f)), new n(i, t, !0)))
    }
    exports.DiffieHellmanGroup = exports.createDiffieHellmanGroup = exports.getDiffieHellman = f, exports.createDiffieHellman = exports.DiffieHellman = u;
  }, {
    "./lib/generatePrime": "Lj8n",
    "./lib/primes.json": "nq14",
    "./lib/dh": "SXPn",
    "buffer": "dskh"
  }],
  "PBOR": [function(require, module, exports) {
    "use strict";
    var r = require("../../../errors").codes.ERR_INVALID_OPT_VALUE;

    function e(r, e, t) {
      return null != r.highWaterMark ? r.highWaterMark : e ? r[t] : null
    }

    function t(t, i, o, a) {
      var n = e(i, a, o);
      if (null != n) {
        if (!isFinite(n) || Math.floor(n) !== n || n < 0) throw new r(a ? o : "highWaterMark", n);
        return Math.floor(n)
      }
      return t.objectMode ? 16 : 16384
    }
    module.exports = {
      getHighWaterMark: t
    };
  }, {
    "../../../errors": "eV81"
  }],
  "CFrt": [function(require, module, exports) {

    var global = arguments[3];
    var process = require("process");
    var e, t = arguments[3],
      n = require("process");

    function r(e, t, n) {
      this.chunk = e, this.encoding = t, this.callback = n, this.next = null
    }

    function i(e) {
      var t = this;
      this.next = null, this.entry = null, this.finish = function() {
        G(t, e)
      }
    }
    module.exports = x, x.WritableState = m;
    var o = {
        deprecate: require("util-deprecate")
      },
      s = require("./internal/streams/stream"),
      u = require("buffer").Buffer,
      f = t.Uint8Array || function() {};

    function a(e) {
      return u.from(e)
    }

    function c(e) {
      return u.isBuffer(e) || e instanceof f
    }
    var l, d = require("./internal/streams/destroy"),
      h = require("./internal/streams/state"),
      b = h.getHighWaterMark,
      p = require("../errors").codes,
      y = p.ERR_INVALID_ARG_TYPE,
      w = p.ERR_METHOD_NOT_IMPLEMENTED,
      g = p.ERR_MULTIPLE_CALLBACK,
      _ = p.ERR_STREAM_CANNOT_PIPE,
      R = p.ERR_STREAM_DESTROYED,
      k = p.ERR_STREAM_NULL_VALUES,
      E = p.ERR_STREAM_WRITE_AFTER_END,
      S = p.ERR_UNKNOWN_ENCODING,
      q = d.errorOrDestroy;

    function v() {}

    function m(t, n, r) {
      e = e || require("./_stream_duplex"), t = t || {}, "boolean" != typeof r && (r = n instanceof e), this.objectMode = !!t.objectMode, r && (this.objectMode = this.objectMode || !!t.writableObjectMode), this.highWaterMark = b(this, t, "writableHighWaterMark", r), this.finalCalled = !1, this.needDrain = !1, this.ending = !1, this.ended = !1, this.finished = !1, this.destroyed = !1;
      var o = !1 === t.decodeStrings;
      this.decodeStrings = !o, this.defaultEncoding = t.defaultEncoding || "utf8", this.length = 0, this.writing = !1, this.corked = 0, this.sync = !0, this.bufferProcessing = !1, this.onwrite = function(e) {
        O(n, e)
      }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = !1, this.errorEmitted = !1, this.emitClose = !1 !== t.emitClose, this.autoDestroy = !!t.autoDestroy, this.bufferedRequestCount = 0, this.corkedRequestsFree = new i(this)
    }

    function x(t) {
      var n = this instanceof(e = e || require("./_stream_duplex"));
      if (!n && !l.call(x, this)) return new x(t);
      this._writableState = new m(t, this, n), this.writable = !0, t && ("function" == typeof t.write && (this._write = t.write), "function" == typeof t.writev && (this._writev = t.writev), "function" == typeof t.destroy && (this._destroy = t.destroy), "function" == typeof t.final && (this._final = t.final)), s.call(this)
    }

    function M(e, t) {
      var r = new E;
      q(e, r), n.nextTick(t, r)
    }

    function B(e, t, r, i) {
      var o;
      return null === r ? o = new k : "string" == typeof r || t.objectMode || (o = new y("chunk", ["string", "Buffer"], r)), !o || (q(e, o), n.nextTick(i, o), !1)
    }

    function T(e, t, n) {
      return e.objectMode || !1 === e.decodeStrings || "string" != typeof t || (t = u.from(t, n)), t
    }

    function D(e, t, n, r, i, o) {
      if (!n) {
        var s = T(t, r, i);
        r !== s && (n = !0, i = "buffer", r = s)
      }
      var u = t.objectMode ? 1 : r.length;
      t.length += u;
      var f = t.length < t.highWaterMark;
      if (f || (t.needDrain = !0), t.writing || t.corked) {
        var a = t.lastBufferedRequest;
        t.lastBufferedRequest = {
          chunk: r,
          encoding: i,
          isBuf: n,
          callback: o,
          next: null
        }, a ? a.next = t.lastBufferedRequest : t.bufferedRequest = t.lastBufferedRequest, t.bufferedRequestCount += 1
      } else P(e, t, !1, u, r, i, o);
      return f
    }

    function P(e, t, n, r, i, o, s) {
      t.writelen = r, t.writecb = s, t.writing = !0, t.sync = !0, t.destroyed ? t.onwrite(new R("write")) : n ? e._writev(i, t.onwrite) : e._write(i, o, t.onwrite), t.sync = !1
    }

    function j(e, t, r, i, o) {
      --t.pendingcb, r ? (n.nextTick(o, i), n.nextTick(U, e, t), e._writableState.errorEmitted = !0, q(e, i)) : (o(i), e._writableState.errorEmitted = !0, q(e, i), U(e, t))
    }

    function C(e) {
      e.writing = !1, e.writecb = null, e.length -= e.writelen, e.writelen = 0
    }

    function O(e, t) {
      var r = e._writableState,
        i = r.sync,
        o = r.writecb;
      if ("function" != typeof o) throw new g;
      if (C(r), t) j(e, r, i, t, o);
      else {
        var s = I(r) || e.destroyed;
        s || r.corked || r.bufferProcessing || !r.bufferedRequest || N(e, r), i ? n.nextTick(A, e, r, s, o) : A(e, r, s, o)
      }
    }

    function A(e, t, n, r) {
      n || L(e, t), t.pendingcb--, r(), U(e, t)
    }

    function L(e, t) {
      0 === t.length && t.needDrain && (t.needDrain = !1, e.emit("drain"))
    }

    function N(e, t) {
      t.bufferProcessing = !0;
      var n = t.bufferedRequest;
      if (e._writev && n && n.next) {
        var r = t.bufferedRequestCount,
          o = new Array(r),
          s = t.corkedRequestsFree;
        s.entry = n;
        for (var u = 0, f = !0; n;) o[u] = n, n.isBuf || (f = !1), n = n.next, u += 1;
        o.allBuffers = f, P(e, t, !0, t.length, o, "", s.finish), t.pendingcb++, t.lastBufferedRequest = null, s.next ? (t.corkedRequestsFree = s.next, s.next = null) : t.corkedRequestsFree = new i(t), t.bufferedRequestCount = 0
      } else {
        for (; n;) {
          var a = n.chunk,
            c = n.encoding,
            l = n.callback;
          if (P(e, t, !1, t.objectMode ? 1 : a.length, a, c, l), n = n.next, t.bufferedRequestCount--, t.writing) break
        }
        null === n && (t.lastBufferedRequest = null)
      }
      t.bufferedRequest = n, t.bufferProcessing = !1
    }

    function I(e) {
      return e.ending && 0 === e.length && null === e.bufferedRequest && !e.finished && !e.writing
    }

    function W(e, t) {
      e._final(function(n) {
        t.pendingcb--, n && q(e, n), t.prefinished = !0, e.emit("prefinish"), U(e, t)
      })
    }

    function F(e, t) {
      t.prefinished || t.finalCalled || ("function" != typeof e._final || t.destroyed ? (t.prefinished = !0, e.emit("prefinish")) : (t.pendingcb++, t.finalCalled = !0, n.nextTick(W, e, t)))
    }

    function U(e, t) {
      var n = I(t);
      if (n && (F(e, t), 0 === t.pendingcb && (t.finished = !0, e.emit("finish"), t.autoDestroy))) {
        var r = e._readableState;
        (!r || r.autoDestroy && r.endEmitted) && e.destroy()
      }
      return n
    }

    function H(e, t, r) {
      t.ending = !0, U(e, t), r && (t.finished ? n.nextTick(r) : e.once("finish", r)), t.ended = !0, e.writable = !1
    }

    function G(e, t, n) {
      var r = e.entry;
      for (e.entry = null; r;) {
        var i = r.callback;
        t.pendingcb--, i(n), r = r.next
      }
      t.corkedRequestsFree.next = e
    }
    require("inherits")(x, s), m.prototype.getBuffer = function() {
        for (var e = this.bufferedRequest, t = []; e;) t.push(e), e = e.next;
        return t
      },
      function() {
        try {
          Object.defineProperty(m.prototype, "buffer", {
            get: o.deprecate(function() {
              return this.getBuffer()
            }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
          })
        } catch (e) {}
      }(), "function" == typeof Symbol && Symbol.hasInstance && "function" == typeof Function.prototype[Symbol.hasInstance] ? (l = Function.prototype[Symbol.hasInstance], Object.defineProperty(x, Symbol.hasInstance, {
        value: function(e) {
          return !!l.call(this, e) || this === x && (e && e._writableState instanceof m)
        }
      })) : l = function(e) {
        return e instanceof this
      }, x.prototype.pipe = function() {
        q(this, new _)
      }, x.prototype.write = function(e, t, n) {
        var r = this._writableState,
          i = !1,
          o = !r.objectMode && c(e);
        return o && !u.isBuffer(e) && (e = a(e)), "function" == typeof t && (n = t, t = null), o ? t = "buffer" : t || (t = r.defaultEncoding), "function" != typeof n && (n = v), r.ending ? M(this, n) : (o || B(this, r, e, n)) && (r.pendingcb++, i = D(this, r, o, e, t, n)), i
      }, x.prototype.cork = function() {
        this._writableState.corked++
      }, x.prototype.uncork = function() {
        var e = this._writableState;
        e.corked && (e.corked--, e.writing || e.corked || e.bufferProcessing || !e.bufferedRequest || N(this, e))
      }, x.prototype.setDefaultEncoding = function(e) {
        if ("string" == typeof e && (e = e.toLowerCase()), !(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((e + "").toLowerCase()) > -1)) throw new S(e);
        return this._writableState.defaultEncoding = e, this
      }, Object.defineProperty(x.prototype, "writableBuffer", {
        enumerable: !1,
        get: function() {
          return this._writableState && this._writableState.getBuffer()
        }
      }), Object.defineProperty(x.prototype, "writableHighWaterMark", {
        enumerable: !1,
        get: function() {
          return this._writableState.highWaterMark
        }
      }), x.prototype._write = function(e, t, n) {
        n(new w("_write()"))
      }, x.prototype._writev = null, x.prototype.end = function(e, t, n) {
        var r = this._writableState;
        return "function" == typeof e ? (n = e, e = null, t = null) : "function" == typeof t && (n = t, t = null), null != e && this.write(e, t), r.corked && (r.corked = 1, this.uncork()), r.ending || H(this, r, n), this
      }, Object.defineProperty(x.prototype, "writableLength", {
        enumerable: !1,
        get: function() {
          return this._writableState.length
        }
      }), Object.defineProperty(x.prototype, "destroyed", {
        enumerable: !1,
        get: function() {
          return void 0 !== this._writableState && this._writableState.destroyed
        },
        set: function(e) {
          this._writableState && (this._writableState.destroyed = e)
        }
      }), x.prototype.destroy = d.destroy, x.prototype._undestroy = d.undestroy, x.prototype._destroy = function(e, t) {
        t(e)
      };
  }, {
    "util-deprecate": "yM1o",
    "./internal/streams/stream": "ExO1",
    "buffer": "dskh",
    "./internal/streams/destroy": "DoEV",
    "./internal/streams/state": "PBOR",
    "../errors": "eV81",
    "inherits": "Bm0n",
    "./_stream_duplex": "fJIH",
    "process": "pBGv"
  }],
  "fJIH": [function(require, module, exports) {
    var process = require("process");
    var e = require("process"),
      t = Object.keys || function(e) {
        var t = [];
        for (var r in e) t.push(r);
        return t
      };
    module.exports = l;
    var r = require("./_stream_readable"),
      a = require("./_stream_writable");
    require("inherits")(l, r);
    for (var i = t(a.prototype), n = 0; n < i.length; n++) {
      var o = i[n];
      l.prototype[o] || (l.prototype[o] = a.prototype[o])
    }

    function l(e) {
      if (!(this instanceof l)) return new l(e);
      r.call(this, e), a.call(this, e), this.allowHalfOpen = !0, e && (!1 === e.readable && (this.readable = !1), !1 === e.writable && (this.writable = !1), !1 === e.allowHalfOpen && (this.allowHalfOpen = !1, this.once("end", s)))
    }

    function s() {
      this._writableState.ended || e.nextTick(b, this)
    }

    function b(e) {
      e.end()
    }
    Object.defineProperty(l.prototype, "writableHighWaterMark", {
      enumerable: !1,
      get: function() {
        return this._writableState.highWaterMark
      }
    }), Object.defineProperty(l.prototype, "writableBuffer", {
      enumerable: !1,
      get: function() {
        return this._writableState && this._writableState.getBuffer()
      }
    }), Object.defineProperty(l.prototype, "writableLength", {
      enumerable: !1,
      get: function() {
        return this._writableState.length
      }
    }), Object.defineProperty(l.prototype, "destroyed", {
      enumerable: !1,
      get: function() {
        return void 0 !== this._readableState && void 0 !== this._writableState && (this._readableState.destroyed && this._writableState.destroyed)
      },
      set: function(e) {
        void 0 !== this._readableState && void 0 !== this._writableState && (this._readableState.destroyed = e, this._writableState.destroyed = e)
      }
    });
  }, {
    "./_stream_readable": "BtJo",
    "./_stream_writable": "CFrt",
    "inherits": "Bm0n",
    "process": "pBGv"
  }],
  "b912": [function(require, module, exports) {
    "use strict";
    var e = require("../../../errors").codes.ERR_STREAM_PREMATURE_CLOSE;

    function r(e) {
      var r = !1;
      return function() {
        if (!r) {
          r = !0;
          for (var t = arguments.length, n = new Array(t), o = 0; o < t; o++) n[o] = arguments[o];
          e.apply(this, n)
        }
      }
    }

    function t() {}

    function n(e) {
      return e.setHeader && "function" == typeof e.abort
    }

    function o(i, a, l) {
      if ("function" == typeof a) return o(i, null, a);
      a || (a = {}), l = r(l || t);
      var s = a.readable || !1 !== a.readable && i.readable,
        c = a.writable || !1 !== a.writable && i.writable,
        u = function() {
          i.writable || d()
        },
        f = i._writableState && i._writableState.finished,
        d = function() {
          c = !1, f = !0, s || l.call(i)
        },
        b = i._readableState && i._readableState.endEmitted,
        v = function() {
          s = !1, b = !0, c || l.call(i)
        },
        m = function(e) {
          l.call(i, e)
        },
        w = function() {
          var r;
          return s && !b ? (i._readableState && i._readableState.ended || (r = new e), l.call(i, r)) : c && !f ? (i._writableState && i._writableState.ended || (r = new e), l.call(i, r)) : void 0
        },
        _ = function() {
          i.req.on("finish", d)
        };
      return n(i) ? (i.on("complete", d), i.on("abort", w), i.req ? _() : i.on("request", _)) : c && !i._writableState && (i.on("end", u), i.on("close", u)), i.on("end", v), i.on("finish", d), !1 !== a.error && i.on("error", m), i.on("close", w),
        function() {
          i.removeListener("complete", d), i.removeListener("abort", w), i.removeListener("request", _), i.req && i.req.removeListener("finish", d), i.removeListener("end", u), i.removeListener("close", u), i.removeListener("finish", d), i.removeListener("end", v), i.removeListener("error", m), i.removeListener("close", w)
        }
    }
    module.exports = o;
  }, {
    "../../../errors": "eV81"
  }],
  "aAIV": [function(require, module, exports) {
    var process = require("process");
    var e, n = require("process");

    function r(e, n, r) {
      return n in e ? Object.defineProperty(e, n, {
        value: r,
        enumerable: !0,
        configurable: !0,
        writable: !0
      }) : e[n] = r, e
    }
    var t = require("./end-of-stream"),
      l = Symbol("lastResolve"),
      u = Symbol("lastReject"),
      i = Symbol("error"),
      o = Symbol("ended"),
      a = Symbol("lastPromise"),
      s = Symbol("handlePromise"),
      c = Symbol("stream");

    function f(e, n) {
      return {
        value: e,
        done: n
      }
    }

    function v(e) {
      var n = e[l];
      if (null !== n) {
        var r = e[c].read();
        null !== r && (e[a] = null, e[l] = null, e[u] = null, n(f(r, !1)))
      }
    }

    function d(e) {
      n.nextTick(v, e)
    }

    function b(e, n) {
      return function(r, t) {
        e.then(function() {
          n[o] ? r(f(void 0, !0)) : n[s](r, t)
        }, t)
      }
    }
    var m = Object.getPrototypeOf(function() {}),
      h = Object.setPrototypeOf((r(e = {
        get stream() {
          return this[c]
        },
        next: function() {
          var e = this,
            r = this[i];
          if (null !== r) return Promise.reject(r);
          if (this[o]) return Promise.resolve(f(void 0, !0));
          if (this[c].destroyed) return new Promise(function(r, t) {
            n.nextTick(function() {
              e[i] ? t(e[i]) : r(f(void 0, !0))
            })
          });
          var t, l = this[a];
          if (l) t = new Promise(b(l, this));
          else {
            var u = this[c].read();
            if (null !== u) return Promise.resolve(f(u, !1));
            t = new Promise(this[s])
          }
          return this[a] = t, t
        }
      }, Symbol.asyncIterator, function() {
        return this
      }), r(e, "return", function() {
        var e = this;
        return new Promise(function(n, r) {
          e[c].destroy(null, function(e) {
            e ? r(e) : n(f(void 0, !0))
          })
        })
      }), e), m),
      y = function(e) {
        var n, v = Object.create(h, (r(n = {}, c, {
          value: e,
          writable: !0
        }), r(n, l, {
          value: null,
          writable: !0
        }), r(n, u, {
          value: null,
          writable: !0
        }), r(n, i, {
          value: null,
          writable: !0
        }), r(n, o, {
          value: e._readableState.endEmitted,
          writable: !0
        }), r(n, s, {
          value: function(e, n) {
            var r = v[c].read();
            r ? (v[a] = null, v[l] = null, v[u] = null, e(f(r, !1))) : (v[l] = e, v[u] = n)
          },
          writable: !0
        }), n));
        return v[a] = null, t(e, function(e) {
          if (e && "ERR_STREAM_PREMATURE_CLOSE" !== e.code) {
            var n = v[u];
            return null !== n && (v[a] = null, v[l] = null, v[u] = null, n(e)), void(v[i] = e)
          }
          var r = v[l];
          null !== r && (v[a] = null, v[l] = null, v[u] = null, r(f(void 0, !0))), v[o] = !0
        }), e.on("readable", d.bind(null, v)), v
      };
    module.exports = y;
  }, {
    "./end-of-stream": "b912",
    "process": "pBGv"
  }],
  "BtJo": [function(require, module, exports) {

    var global = arguments[3];
    var process = require("process");
    var e, t = arguments[3],
      n = require("process");
    module.exports = j, j.ReadableState = L;
    var r = require("events").EventEmitter,
      i = function(e, t) {
        return e.listeners(t).length
      },
      a = require("./internal/streams/stream"),
      d = require("buffer").Buffer,
      o = t.Uint8Array || function() {};

    function s(e) {
      return d.from(e)
    }

    function l(e) {
      return d.isBuffer(e) || e instanceof o
    }
    var u, h = require("util");
    u = h && h.debuglog ? h.debuglog("stream") : function() {};
    var p, f, c, b = require("./internal/streams/buffer_list"),
      g = require("./internal/streams/destroy"),
      m = require("./internal/streams/state"),
      y = m.getHighWaterMark,
      _ = require("../errors").codes,
      v = _.ERR_INVALID_ARG_TYPE,
      w = _.ERR_STREAM_PUSH_AFTER_EOF,
      S = _.ERR_METHOD_NOT_IMPLEMENTED,
      R = _.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;
    require("inherits")(j, a);
    var M = g.errorOrDestroy,
      E = ["error", "close", "destroy", "pause", "resume"];

    function k(e, t, n) {
      if ("function" == typeof e.prependListener) return e.prependListener(t, n);
      e._events && e._events[t] ? Array.isArray(e._events[t]) ? e._events[t].unshift(n) : e._events[t] = [n, e._events[t]] : e.on(t, n)
    }

    function L(t, n, r) {
      e = e || require("./_stream_duplex"), t = t || {}, "boolean" != typeof r && (r = n instanceof e), this.objectMode = !!t.objectMode, r && (this.objectMode = this.objectMode || !!t.readableObjectMode), this.highWaterMark = y(this, t, "readableHighWaterMark", r), this.buffer = new b, this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = !1, this.endEmitted = !1, this.reading = !1, this.sync = !0, this.needReadable = !1, this.emittedReadable = !1, this.readableListening = !1, this.resumeScheduled = !1, this.paused = !0, this.emitClose = !1 !== t.emitClose, this.autoDestroy = !!t.autoDestroy, this.destroyed = !1, this.defaultEncoding = t.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore = !1, this.decoder = null, this.encoding = null, t.encoding && (p || (p = require("string_decoder/").StringDecoder), this.decoder = new p(t.encoding), this.encoding = t.encoding)
    }

    function j(t) {
      if (e = e || require("./_stream_duplex"), !(this instanceof j)) return new j(t);
      var n = this instanceof e;
      this._readableState = new L(t, this, n), this.readable = !0, t && ("function" == typeof t.read && (this._read = t.read), "function" == typeof t.destroy && (this._destroy = t.destroy)), a.call(this)
    }

    function D(e, t, n, r, i) {
      u("readableAddChunk", t);
      var a, o = e._readableState;
      if (null === t) o.reading = !1, A(e, o);
      else if (i || (a = T(o, t)), a) M(e, a);
      else if (o.objectMode || t && t.length > 0)
        if ("string" == typeof t || o.objectMode || Object.getPrototypeOf(t) === d.prototype || (t = s(t)), r) o.endEmitted ? M(e, new R) : C(e, o, t, !0);
        else if (o.ended) M(e, new w);
      else {
        if (o.destroyed) return !1;
        o.reading = !1, o.decoder && !n ? (t = o.decoder.write(t), o.objectMode || 0 !== t.length ? C(e, o, t, !1) : U(e, o)) : C(e, o, t, !1)
      } else r || (o.reading = !1, U(e, o));
      return !o.ended && (o.length < o.highWaterMark || 0 === o.length)
    }

    function C(e, t, n, r) {
      t.flowing && 0 === t.length && !t.sync ? (t.awaitDrain = 0, e.emit("data", n)) : (t.length += t.objectMode ? 1 : n.length, r ? t.buffer.unshift(n) : t.buffer.push(n), t.needReadable && O(e)), U(e, t)
    }

    function T(e, t) {
      var n;
      return l(t) || "string" == typeof t || void 0 === t || e.objectMode || (n = new v("chunk", ["string", "Buffer", "Uint8Array"], t)), n
    }
    Object.defineProperty(j.prototype, "destroyed", {
      enumerable: !1,
      get: function() {
        return void 0 !== this._readableState && this._readableState.destroyed
      },
      set: function(e) {
        this._readableState && (this._readableState.destroyed = e)
      }
    }), j.prototype.destroy = g.destroy, j.prototype._undestroy = g.undestroy, j.prototype._destroy = function(e, t) {
      t(e)
    }, j.prototype.push = function(e, t) {
      var n, r = this._readableState;
      return r.objectMode ? n = !0 : "string" == typeof e && ((t = t || r.defaultEncoding) !== r.encoding && (e = d.from(e, t), t = ""), n = !0), D(this, e, t, !1, n)
    }, j.prototype.unshift = function(e) {
      return D(this, e, null, !0, !1)
    }, j.prototype.isPaused = function() {
      return !1 === this._readableState.flowing
    }, j.prototype.setEncoding = function(e) {
      p || (p = require("string_decoder/").StringDecoder);
      var t = new p(e);
      this._readableState.decoder = t, this._readableState.encoding = this._readableState.decoder.encoding;
      for (var n = this._readableState.buffer.head, r = ""; null !== n;) r += t.write(n.data), n = n.next;
      return this._readableState.buffer.clear(), "" !== r && this._readableState.buffer.push(r), this._readableState.length = r.length, this
    };
    var q = 1073741824;

    function W(e) {
      return e >= q ? e = q : (e--, e |= e >>> 1, e |= e >>> 2, e |= e >>> 4, e |= e >>> 8, e |= e >>> 16, e++), e
    }

    function x(e, t) {
      return e <= 0 || 0 === t.length && t.ended ? 0 : t.objectMode ? 1 : e != e ? t.flowing && t.length ? t.buffer.head.data.length : t.length : (e > t.highWaterMark && (t.highWaterMark = W(e)), e <= t.length ? e : t.ended ? t.length : (t.needReadable = !0, 0))
    }

    function A(e, t) {
      if (u("onEofChunk"), !t.ended) {
        if (t.decoder) {
          var n = t.decoder.end();
          n && n.length && (t.buffer.push(n), t.length += t.objectMode ? 1 : n.length)
        }
        t.ended = !0, t.sync ? O(e) : (t.needReadable = !1, t.emittedReadable || (t.emittedReadable = !0, P(e)))
      }
    }

    function O(e) {
      var t = e._readableState;
      u("emitReadable", t.needReadable, t.emittedReadable), t.needReadable = !1, t.emittedReadable || (u("emitReadable", t.flowing), t.emittedReadable = !0, n.nextTick(P, e))
    }

    function P(e) {
      var t = e._readableState;
      u("emitReadable_", t.destroyed, t.length, t.ended), t.destroyed || !t.length && !t.ended || (e.emit("readable"), t.emittedReadable = !1), t.needReadable = !t.flowing && !t.ended && t.length <= t.highWaterMark, G(e)
    }

    function U(e, t) {
      t.readingMore || (t.readingMore = !0, n.nextTick(N, e, t))
    }

    function N(e, t) {
      for (; !t.reading && !t.ended && (t.length < t.highWaterMark || t.flowing && 0 === t.length);) {
        var n = t.length;
        if (u("maybeReadMore read 0"), e.read(0), n === t.length) break
      }
      t.readingMore = !1
    }

    function H(e) {
      return function() {
        var t = e._readableState;
        u("pipeOnDrain", t.awaitDrain), t.awaitDrain && t.awaitDrain--, 0 === t.awaitDrain && i(e, "data") && (t.flowing = !0, G(e))
      }
    }

    function I(e) {
      var t = e._readableState;
      t.readableListening = e.listenerCount("readable") > 0, t.resumeScheduled && !t.paused ? t.flowing = !0 : e.listenerCount("data") > 0 && e.resume()
    }

    function F(e) {
      u("readable nexttick read 0"), e.read(0)
    }

    function B(e, t) {
      t.resumeScheduled || (t.resumeScheduled = !0, n.nextTick(V, e, t))
    }

    function V(e, t) {
      u("resume", t.reading), t.reading || e.read(0), t.resumeScheduled = !1, e.emit("resume"), G(e), t.flowing && !t.reading && e.read(0)
    }

    function G(e) {
      var t = e._readableState;
      for (u("flow", t.flowing); t.flowing && null !== e.read(););
    }

    function Y(e, t) {
      return 0 === t.length ? null : (t.objectMode ? n = t.buffer.shift() : !e || e >= t.length ? (n = t.decoder ? t.buffer.join("") : 1 === t.buffer.length ? t.buffer.first() : t.buffer.concat(t.length), t.buffer.clear()) : n = t.buffer.consume(e, t.decoder), n);
      var n
    }

    function z(e) {
      var t = e._readableState;
      u("endReadable", t.endEmitted), t.endEmitted || (t.ended = !0, n.nextTick(J, t, e))
    }

    function J(e, t) {
      if (u("endReadableNT", e.endEmitted, e.length), !e.endEmitted && 0 === e.length && (e.endEmitted = !0, t.readable = !1, t.emit("end"), e.autoDestroy)) {
        var n = t._writableState;
        (!n || n.autoDestroy && n.finished) && t.destroy()
      }
    }

    function K(e, t) {
      for (var n = 0, r = e.length; n < r; n++)
        if (e[n] === t) return n;
      return -1
    }
    j.prototype.read = function(e) {
      u("read", e), e = parseInt(e, 10);
      var t = this._readableState,
        n = e;
      if (0 !== e && (t.emittedReadable = !1), 0 === e && t.needReadable && ((0 !== t.highWaterMark ? t.length >= t.highWaterMark : t.length > 0) || t.ended)) return u("read: emitReadable", t.length, t.ended), 0 === t.length && t.ended ? z(this) : O(this), null;
      if (0 === (e = x(e, t)) && t.ended) return 0 === t.length && z(this), null;
      var r, i = t.needReadable;
      return u("need readable", i), (0 === t.length || t.length - e < t.highWaterMark) && u("length less than watermark", i = !0), t.ended || t.reading ? u("reading or ended", i = !1) : i && (u("do read"), t.reading = !0, t.sync = !0, 0 === t.length && (t.needReadable = !0), this._read(t.highWaterMark), t.sync = !1, t.reading || (e = x(n, t))), null === (r = e > 0 ? Y(e, t) : null) ? (t.needReadable = t.length <= t.highWaterMark, e = 0) : (t.length -= e, t.awaitDrain = 0), 0 === t.length && (t.ended || (t.needReadable = !0), n !== e && t.ended && z(this)), null !== r && this.emit("data", r), r
    }, j.prototype._read = function(e) {
      M(this, new S("_read()"))
    }, j.prototype.pipe = function(e, t) {
      var r = this,
        a = this._readableState;
      switch (a.pipesCount) {
        case 0:
          a.pipes = e;
          break;
        case 1:
          a.pipes = [a.pipes, e];
          break;
        default:
          a.pipes.push(e)
      }
      a.pipesCount += 1, u("pipe count=%d opts=%j", a.pipesCount, t);
      var d = (!t || !1 !== t.end) && e !== n.stdout && e !== n.stderr ? s : g;

      function o(t, n) {
        u("onunpipe"), t === r && n && !1 === n.hasUnpiped && (n.hasUnpiped = !0, u("cleanup"), e.removeListener("close", c), e.removeListener("finish", b), e.removeListener("drain", l), e.removeListener("error", f), e.removeListener("unpipe", o), r.removeListener("end", s), r.removeListener("end", g), r.removeListener("data", p), h = !0, !a.awaitDrain || e._writableState && !e._writableState.needDrain || l())
      }

      function s() {
        u("onend"), e.end()
      }
      a.endEmitted ? n.nextTick(d) : r.once("end", d), e.on("unpipe", o);
      var l = H(r);
      e.on("drain", l);
      var h = !1;

      function p(t) {
        u("ondata");
        var n = e.write(t);
        u("dest.write", n), !1 === n && ((1 === a.pipesCount && a.pipes === e || a.pipesCount > 1 && -1 !== K(a.pipes, e)) && !h && (u("false write response, pause", a.awaitDrain), a.awaitDrain++), r.pause())
      }

      function f(t) {
        u("onerror", t), g(), e.removeListener("error", f), 0 === i(e, "error") && M(e, t)
      }

      function c() {
        e.removeListener("finish", b), g()
      }

      function b() {
        u("onfinish"), e.removeListener("close", c), g()
      }

      function g() {
        u("unpipe"), r.unpipe(e)
      }
      return r.on("data", p), k(e, "error", f), e.once("close", c), e.once("finish", b), e.emit("pipe", r), a.flowing || (u("pipe resume"), r.resume()), e
    }, j.prototype.unpipe = function(e) {
      var t = this._readableState,
        n = {
          hasUnpiped: !1
        };
      if (0 === t.pipesCount) return this;
      if (1 === t.pipesCount) return e && e !== t.pipes ? this : (e || (e = t.pipes), t.pipes = null, t.pipesCount = 0, t.flowing = !1, e && e.emit("unpipe", this, n), this);
      if (!e) {
        var r = t.pipes,
          i = t.pipesCount;
        t.pipes = null, t.pipesCount = 0, t.flowing = !1;
        for (var a = 0; a < i; a++) r[a].emit("unpipe", this, {
          hasUnpiped: !1
        });
        return this
      }
      var d = K(t.pipes, e);
      return -1 === d ? this : (t.pipes.splice(d, 1), t.pipesCount -= 1, 1 === t.pipesCount && (t.pipes = t.pipes[0]), e.emit("unpipe", this, n), this)
    }, j.prototype.on = function(e, t) {
      var r = a.prototype.on.call(this, e, t),
        i = this._readableState;
      return "data" === e ? (i.readableListening = this.listenerCount("readable") > 0, !1 !== i.flowing && this.resume()) : "readable" === e && (i.endEmitted || i.readableListening || (i.readableListening = i.needReadable = !0, i.flowing = !1, i.emittedReadable = !1, u("on readable", i.length, i.reading), i.length ? O(this) : i.reading || n.nextTick(F, this))), r
    }, j.prototype.addListener = j.prototype.on, j.prototype.removeListener = function(e, t) {
      var r = a.prototype.removeListener.call(this, e, t);
      return "readable" === e && n.nextTick(I, this), r
    }, j.prototype.removeAllListeners = function(e) {
      var t = a.prototype.removeAllListeners.apply(this, arguments);
      return "readable" !== e && void 0 !== e || n.nextTick(I, this), t
    }, j.prototype.resume = function() {
      var e = this._readableState;
      return e.flowing || (u("resume"), e.flowing = !e.readableListening, B(this, e)), e.paused = !1, this
    }, j.prototype.pause = function() {
      return u("call pause flowing=%j", this._readableState.flowing), !1 !== this._readableState.flowing && (u("pause"), this._readableState.flowing = !1, this.emit("pause")), this._readableState.paused = !0, this
    }, j.prototype.wrap = function(e) {
      var t = this,
        n = this._readableState,
        r = !1;
      for (var i in e.on("end", function() {
          if (u("wrapped end"), n.decoder && !n.ended) {
            var e = n.decoder.end();
            e && e.length && t.push(e)
          }
          t.push(null)
        }), e.on("data", function(i) {
          (u("wrapped data"), n.decoder && (i = n.decoder.write(i)), n.objectMode && null == i) || (n.objectMode || i && i.length) && (t.push(i) || (r = !0, e.pause()))
        }), e) void 0 === this[i] && "function" == typeof e[i] && (this[i] = function(t) {
        return function() {
          return e[t].apply(e, arguments)
        }
      }(i));
      for (var a = 0; a < E.length; a++) e.on(E[a], this.emit.bind(this, E[a]));
      return this._read = function(t) {
        u("wrapped _read", t), r && (r = !1, e.resume())
      }, this
    }, "function" == typeof Symbol && (j.prototype[Symbol.asyncIterator] = function() {
      return void 0 === f && (f = require("./internal/streams/async_iterator")), f(this)
    }), Object.defineProperty(j.prototype, "readableHighWaterMark", {
      enumerable: !1,
      get: function() {
        return this._readableState.highWaterMark
      }
    }), Object.defineProperty(j.prototype, "readableBuffer", {
      enumerable: !1,
      get: function() {
        return this._readableState && this._readableState.buffer
      }
    }), Object.defineProperty(j.prototype, "readableFlowing", {
      enumerable: !1,
      get: function() {
        return this._readableState.flowing
      },
      set: function(e) {
        this._readableState && (this._readableState.flowing = e)
      }
    }), j._fromList = Y, Object.defineProperty(j.prototype, "readableLength", {
      enumerable: !1,
      get: function() {
        return this._readableState.length
      }
    }), "function" == typeof Symbol && (j.from = function(e, t) {
      return void 0 === c && (c = require("./internal/streams/from")), c(j, e, t)
    });
  }, {
    "events": "FRpO",
    "./internal/streams/stream": "ExO1",
    "buffer": "dskh",
    "util": "rDCW",
    "./internal/streams/buffer_list": "bUoY",
    "./internal/streams/destroy": "DoEV",
    "./internal/streams/state": "PBOR",
    "../errors": "eV81",
    "inherits": "Bm0n",
    "./_stream_duplex": "fJIH",
    "string_decoder/": "z0rv",
    "./internal/streams/async_iterator": "aAIV",
    "./internal/streams/from": "pIwT",
    "process": "pBGv"
  }],
  "krU2": [function(require, module, exports) {
    "use strict";
    module.exports = o;
    var t = require("../errors").codes,
      r = t.ERR_METHOD_NOT_IMPLEMENTED,
      e = t.ERR_MULTIPLE_CALLBACK,
      n = t.ERR_TRANSFORM_ALREADY_TRANSFORMING,
      i = t.ERR_TRANSFORM_WITH_LENGTH_0,
      a = require("./_stream_duplex");

    function s(t, r) {
      var n = this._transformState;
      n.transforming = !1;
      var i = n.writecb;
      if (null === i) return this.emit("error", new e);
      n.writechunk = null, n.writecb = null, null != r && this.push(r), i(t);
      var a = this._readableState;
      a.reading = !1, (a.needReadable || a.length < a.highWaterMark) && this._read(a.highWaterMark)
    }

    function o(t) {
      if (!(this instanceof o)) return new o(t);
      a.call(this, t), this._transformState = {
        afterTransform: s.bind(this),
        needTransform: !1,
        transforming: !1,
        writecb: null,
        writechunk: null,
        writeencoding: null
      }, this._readableState.needReadable = !0, this._readableState.sync = !1, t && ("function" == typeof t.transform && (this._transform = t.transform), "function" == typeof t.flush && (this._flush = t.flush)), this.on("prefinish", h)
    }

    function h() {
      var t = this;
      "function" != typeof this._flush || this._readableState.destroyed ? f(this, null, null) : this._flush(function(r, e) {
        f(t, r, e)
      })
    }

    function f(t, r, e) {
      if (r) return t.emit("error", r);
      if (null != e && t.push(e), t._writableState.length) throw new i;
      if (t._transformState.transforming) throw new n;
      return t.push(null)
    }
    require("inherits")(o, a), o.prototype.push = function(t, r) {
      return this._transformState.needTransform = !1, a.prototype.push.call(this, t, r)
    }, o.prototype._transform = function(t, e, n) {
      n(new r("_transform()"))
    }, o.prototype._write = function(t, r, e) {
      var n = this._transformState;
      if (n.writecb = e, n.writechunk = t, n.writeencoding = r, !n.transforming) {
        var i = this._readableState;
        (n.needTransform || i.needReadable || i.length < i.highWaterMark) && this._read(i.highWaterMark)
      }
    }, o.prototype._read = function(t) {
      var r = this._transformState;
      null === r.writechunk || r.transforming ? r.needTransform = !0 : (r.transforming = !0, this._transform(r.writechunk, r.writeencoding, r.afterTransform))
    }, o.prototype._destroy = function(t, r) {
      a.prototype._destroy.call(this, t, function(t) {
        r(t)
      })
    };
  }, {
    "../errors": "eV81",
    "./_stream_duplex": "fJIH",
    "inherits": "Bm0n"
  }],
  "fqM0": [function(require, module, exports) {
    "use strict";
    module.exports = t;
    var r = require("./_stream_transform");

    function t(e) {
      if (!(this instanceof t)) return new t(e);
      r.call(this, e)
    }
    require("inherits")(t, r), t.prototype._transform = function(r, t, e) {
      e(null, r)
    };
  }, {
    "./_stream_transform": "krU2",
    "inherits": "Bm0n"
  }],
  "CFn3": [function(require, module, exports) {
    "use strict";
    var r;

    function n(r) {
      var n = !1;
      return function() {
        n || (n = !0, r.apply(void 0, arguments))
      }
    }
    var t = require("../../../errors").codes,
      e = t.ERR_MISSING_ARGS,
      o = t.ERR_STREAM_DESTROYED;

    function i(r) {
      if (r) throw r
    }

    function u(r) {
      return r.setHeader && "function" == typeof r.abort
    }

    function f(t, e, i, f) {
      f = n(f);
      var a = !1;
      t.on("close", function() {
        a = !0
      }), void 0 === r && (r = require("./end-of-stream")), r(t, {
        readable: e,
        writable: i
      }, function(r) {
        if (r) return f(r);
        a = !0, f()
      });
      var c = !1;
      return function(r) {
        if (!a && !c) return c = !0, u(t) ? t.abort() : "function" == typeof t.destroy ? t.destroy() : void f(r || new o("pipe"))
      }
    }

    function a(r) {
      r()
    }

    function c(r, n) {
      return r.pipe(n)
    }

    function p(r) {
      return r.length ? "function" != typeof r[r.length - 1] ? i : r.pop() : i
    }

    function s() {
      for (var r = arguments.length, n = new Array(r), t = 0; t < r; t++) n[t] = arguments[t];
      var o, i = p(n);
      if (Array.isArray(n[0]) && (n = n[0]), n.length < 2) throw new e("streams");
      var u = n.map(function(r, t) {
        var e = t < n.length - 1;
        return f(r, e, t > 0, function(r) {
          o || (o = r), r && u.forEach(a), e || (u.forEach(a), i(o))
        })
      });
      return n.reduce(c)
    }
    module.exports = s;
  }, {
    "../../../errors": "eV81",
    "./end-of-stream": "b912"
  }],
  "TgzV": [function(require, module, exports) {
    exports = module.exports = require("./lib/_stream_readable.js"), exports.Stream = exports, exports.Readable = exports, exports.Writable = require("./lib/_stream_writable.js"), exports.Duplex = require("./lib/_stream_duplex.js"), exports.Transform = require("./lib/_stream_transform.js"), exports.PassThrough = require("./lib/_stream_passthrough.js"), exports.finished = require("./lib/internal/streams/end-of-stream.js"), exports.pipeline = require("./lib/internal/streams/pipeline.js");
  }, {
    "./lib/_stream_readable.js": "BtJo",
    "./lib/_stream_writable.js": "CFrt",
    "./lib/_stream_duplex.js": "fJIH",
    "./lib/_stream_transform.js": "krU2",
    "./lib/_stream_passthrough.js": "fqM0",
    "./lib/internal/streams/end-of-stream.js": "b912",
    "./lib/internal/streams/pipeline.js": "CFn3"
  }],
  "BOxy": [function(require, module, exports) {
    var Buffer = require("buffer").Buffer;
    var t = require("buffer").Buffer;
    ! function(t, i) {
      "use strict";

      function r(t, i) {
        if (!t) throw new Error(i || "Assertion failed")
      }

      function n(t, i) {
        t.super_ = i;
        var r = function() {};
        r.prototype = i.prototype, t.prototype = new r, t.prototype.constructor = t
      }

      function h(t, i, r) {
        if (h.isBN(t)) return t;
        this.negative = 0, this.words = null, this.length = 0, this.red = null, null !== t && ("le" !== i && "be" !== i || (r = i, i = 10), this._init(t || 0, i || 10, r || "be"))
      }
      var e;
      "object" == typeof t ? t.exports = h : i.BN = h, h.BN = h, h.wordSize = 26;
      try {
        e = "undefined" != typeof window && void 0 !== window.Buffer ? window.Buffer : require("buffer").Buffer
      } catch (B) {}

      function o(t, i) {
        var n = t.charCodeAt(i);
        return n >= 48 && n <= 57 ? n - 48 : n >= 65 && n <= 70 ? n - 55 : n >= 97 && n <= 102 ? n - 87 : void r(!1, "Invalid character in " + t)
      }

      function s(t, i, r) {
        var n = o(t, r);
        return r - 1 >= i && (n |= o(t, r - 1) << 4), n
      }

      function u(t, i, n, h) {
        for (var e = 0, o = 0, s = Math.min(t.length, n), u = i; u < s; u++) {
          var a = t.charCodeAt(u) - 48;
          e *= h, o = a >= 49 ? a - 49 + 10 : a >= 17 ? a - 17 + 10 : a, r(a >= 0 && o < h, "Invalid character"), e += o
        }
        return e
      }

      function a(t, i) {
        t.words = i.words, t.length = i.length, t.negative = i.negative, t.red = i.red
      }
      if (h.isBN = function(t) {
          return t instanceof h || null !== t && "object" == typeof t && t.constructor.wordSize === h.wordSize && Array.isArray(t.words)
        }, h.max = function(t, i) {
          return t.cmp(i) > 0 ? t : i
        }, h.min = function(t, i) {
          return t.cmp(i) < 0 ? t : i
        }, h.prototype._init = function(t, i, n) {
          if ("number" == typeof t) return this._initNumber(t, i, n);
          if ("object" == typeof t) return this._initArray(t, i, n);
          "hex" === i && (i = 16), r(i === (0 | i) && i >= 2 && i <= 36);
          var h = 0;
          "-" === (t = t.toString().replace(/\s+/g, ""))[0] && (h++, this.negative = 1), h < t.length && (16 === i ? this._parseHex(t, h, n) : (this._parseBase(t, i, h), "le" === n && this._initArray(this.toArray(), i, n)))
        }, h.prototype._initNumber = function(t, i, n) {
          t < 0 && (this.negative = 1, t = -t), t < 67108864 ? (this.words = [67108863 & t], this.length = 1) : t < 4503599627370496 ? (this.words = [67108863 & t, t / 67108864 & 67108863], this.length = 2) : (r(t < 9007199254740992), this.words = [67108863 & t, t / 67108864 & 67108863, 1], this.length = 3), "le" === n && this._initArray(this.toArray(), i, n)
        }, h.prototype._initArray = function(t, i, n) {
          if (r("number" == typeof t.length), t.length <= 0) return this.words = [0], this.length = 1, this;
          this.length = Math.ceil(t.length / 3), this.words = new Array(this.length);
          for (var h = 0; h < this.length; h++) this.words[h] = 0;
          var e, o, s = 0;
          if ("be" === n)
            for (h = t.length - 1, e = 0; h >= 0; h -= 3) o = t[h] | t[h - 1] << 8 | t[h - 2] << 16, this.words[e] |= o << s & 67108863, this.words[e + 1] = o >>> 26 - s & 67108863, (s += 24) >= 26 && (s -= 26, e++);
          else if ("le" === n)
            for (h = 0, e = 0; h < t.length; h += 3) o = t[h] | t[h + 1] << 8 | t[h + 2] << 16, this.words[e] |= o << s & 67108863, this.words[e + 1] = o >>> 26 - s & 67108863, (s += 24) >= 26 && (s -= 26, e++);
          return this._strip()
        }, h.prototype._parseHex = function(t, i, r) {
          this.length = Math.ceil((t.length - i) / 6), this.words = new Array(this.length);
          for (var n = 0; n < this.length; n++) this.words[n] = 0;
          var h, e = 0,
            o = 0;
          if ("be" === r)
            for (n = t.length - 1; n >= i; n -= 2) h = s(t, i, n) << e, this.words[o] |= 67108863 & h, e >= 18 ? (e -= 18, o += 1, this.words[o] |= h >>> 26) : e += 8;
          else
            for (n = (t.length - i) % 2 == 0 ? i + 1 : i; n < t.length; n += 2) h = s(t, i, n) << e, this.words[o] |= 67108863 & h, e >= 18 ? (e -= 18, o += 1, this.words[o] |= h >>> 26) : e += 8;
          this._strip()
        }, h.prototype._parseBase = function(t, i, r) {
          this.words = [0], this.length = 1;
          for (var n = 0, h = 1; h <= 67108863; h *= i) n++;
          n--, h = h / i | 0;
          for (var e = t.length - r, o = e % n, s = Math.min(e, e - o) + r, a = 0, l = r; l < s; l += n) a = u(t, l, l + n, i), this.imuln(h), this.words[0] + a < 67108864 ? this.words[0] += a : this._iaddn(a);
          if (0 !== o) {
            var m = 1;
            for (a = u(t, l, t.length, i), l = 0; l < o; l++) m *= i;
            this.imuln(m), this.words[0] + a < 67108864 ? this.words[0] += a : this._iaddn(a)
          }
          this._strip()
        }, h.prototype.copy = function(t) {
          t.words = new Array(this.length);
          for (var i = 0; i < this.length; i++) t.words[i] = this.words[i];
          t.length = this.length, t.negative = this.negative, t.red = this.red
        }, h.prototype._move = function(t) {
          a(t, this)
        }, h.prototype.clone = function() {
          var t = new h(null);
          return this.copy(t), t
        }, h.prototype._expand = function(t) {
          for (; this.length < t;) this.words[this.length++] = 0;
          return this
        }, h.prototype._strip = function() {
          for (; this.length > 1 && 0 === this.words[this.length - 1];) this.length--;
          return this._normSign()
        }, h.prototype._normSign = function() {
          return 1 === this.length && 0 === this.words[0] && (this.negative = 0), this
        }, "undefined" != typeof Symbol && "function" == typeof Symbol.for) try {
        h.prototype[Symbol.for("nodejs.util.inspect.custom")] = l
      } catch (B) {
        h.prototype.inspect = l
      } else h.prototype.inspect = l;

      function l() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">"
      }
      var m = ["", "0", "00", "000", "0000", "00000", "000000", "0000000", "00000000", "000000000", "0000000000", "00000000000", "000000000000", "0000000000000", "00000000000000", "000000000000000", "0000000000000000", "00000000000000000", "000000000000000000", "0000000000000000000", "00000000000000000000", "000000000000000000000", "0000000000000000000000", "00000000000000000000000", "000000000000000000000000", "0000000000000000000000000"],
        f = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5],
        d = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64e6, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 243e5, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176];
      h.prototype.toString = function(t, i) {
        var n;
        if (i = 0 | i || 1, 16 === (t = t || 10) || "hex" === t) {
          n = "";
          for (var h = 0, e = 0, o = 0; o < this.length; o++) {
            var s = this.words[o],
              u = (16777215 & (s << h | e)).toString(16);
            n = 0 !== (e = s >>> 24 - h & 16777215) || o !== this.length - 1 ? m[6 - u.length] + u + n : u + n, (h += 2) >= 26 && (h -= 26, o--)
          }
          for (0 !== e && (n = e.toString(16) + n); n.length % i != 0;) n = "0" + n;
          return 0 !== this.negative && (n = "-" + n), n
        }
        if (t === (0 | t) && t >= 2 && t <= 36) {
          var a = f[t],
            l = d[t];
          n = "";
          var p = this.clone();
          for (p.negative = 0; !p.isZero();) {
            var M = p.modrn(l).toString(t);
            n = (p = p.idivn(l)).isZero() ? M + n : m[a - M.length] + M + n
          }
          for (this.isZero() && (n = "0" + n); n.length % i != 0;) n = "0" + n;
          return 0 !== this.negative && (n = "-" + n), n
        }
        r(!1, "Base should be between 2 and 36")
      }, h.prototype.toNumber = function() {
        var t = this.words[0];
        return 2 === this.length ? t += 67108864 * this.words[1] : 3 === this.length && 1 === this.words[2] ? t += 4503599627370496 + 67108864 * this.words[1] : this.length > 2 && r(!1, "Number can only safely store up to 53 bits"), 0 !== this.negative ? -t : t
      }, h.prototype.toJSON = function() {
        return this.toString(16, 2)
      }, e && (h.prototype.toBuffer = function(t, i) {
        return this.toArrayLike(e, t, i)
      }), h.prototype.toArray = function(t, i) {
        return this.toArrayLike(Array, t, i)
      };

      function p(t, i, r) {
        r.negative = i.negative ^ t.negative;
        var n = t.length + i.length | 0;
        r.length = n, n = n - 1 | 0;
        var h = 0 | t.words[0],
          e = 0 | i.words[0],
          o = h * e,
          s = 67108863 & o,
          u = o / 67108864 | 0;
        r.words[0] = s;
        for (var a = 1; a < n; a++) {
          for (var l = u >>> 26, m = 67108863 & u, f = Math.min(a, i.length - 1), d = Math.max(0, a - t.length + 1); d <= f; d++) {
            var p = a - d | 0;
            l += (o = (h = 0 | t.words[p]) * (e = 0 | i.words[d]) + m) / 67108864 | 0, m = 67108863 & o
          }
          r.words[a] = 0 | m, u = 0 | l
        }
        return 0 !== u ? r.words[a] = 0 | u : r.length--, r._strip()
      }
      h.prototype.toArrayLike = function(t, i, n) {
        this._strip();
        var h = this.byteLength(),
          e = n || Math.max(1, h);
        r(h <= e, "byte array longer than desired length"), r(e > 0, "Requested array length <= 0");
        var o = function(t, i) {
          return t.allocUnsafe ? t.allocUnsafe(i) : new t(i)
        }(t, e);
        return this["_toArrayLike" + ("le" === i ? "LE" : "BE")](o, h), o
      }, h.prototype._toArrayLikeLE = function(t, i) {
        for (var r = 0, n = 0, h = 0, e = 0; h < this.length; h++) {
          var o = this.words[h] << e | n;
          t[r++] = 255 & o, r < t.length && (t[r++] = o >> 8 & 255), r < t.length && (t[r++] = o >> 16 & 255), 6 === e ? (r < t.length && (t[r++] = o >> 24 & 255), n = 0, e = 0) : (n = o >>> 24, e += 2)
        }
        if (r < t.length)
          for (t[r++] = n; r < t.length;) t[r++] = 0
      }, h.prototype._toArrayLikeBE = function(t, i) {
        for (var r = t.length - 1, n = 0, h = 0, e = 0; h < this.length; h++) {
          var o = this.words[h] << e | n;
          t[r--] = 255 & o, r >= 0 && (t[r--] = o >> 8 & 255), r >= 0 && (t[r--] = o >> 16 & 255), 6 === e ? (r >= 0 && (t[r--] = o >> 24 & 255), n = 0, e = 0) : (n = o >>> 24, e += 2)
        }
        if (r >= 0)
          for (t[r--] = n; r >= 0;) t[r--] = 0
      }, Math.clz32 ? h.prototype._countBits = function(t) {
        return 32 - Math.clz32(t)
      } : h.prototype._countBits = function(t) {
        var i = t,
          r = 0;
        return i >= 4096 && (r += 13, i >>>= 13), i >= 64 && (r += 7, i >>>= 7), i >= 8 && (r += 4, i >>>= 4), i >= 2 && (r += 2, i >>>= 2), r + i
      }, h.prototype._zeroBits = function(t) {
        if (0 === t) return 26;
        var i = t,
          r = 0;
        return 0 == (8191 & i) && (r += 13, i >>>= 13), 0 == (127 & i) && (r += 7, i >>>= 7), 0 == (15 & i) && (r += 4, i >>>= 4), 0 == (3 & i) && (r += 2, i >>>= 2), 0 == (1 & i) && r++, r
      }, h.prototype.bitLength = function() {
        var t = this.words[this.length - 1],
          i = this._countBits(t);
        return 26 * (this.length - 1) + i
      }, h.prototype.zeroBits = function() {
        if (this.isZero()) return 0;
        for (var t = 0, i = 0; i < this.length; i++) {
          var r = this._zeroBits(this.words[i]);
          if (t += r, 26 !== r) break
        }
        return t
      }, h.prototype.byteLength = function() {
        return Math.ceil(this.bitLength() / 8)
      }, h.prototype.toTwos = function(t) {
        return 0 !== this.negative ? this.abs().inotn(t).iaddn(1) : this.clone()
      }, h.prototype.fromTwos = function(t) {
        return this.testn(t - 1) ? this.notn(t).iaddn(1).ineg() : this.clone()
      }, h.prototype.isNeg = function() {
        return 0 !== this.negative
      }, h.prototype.neg = function() {
        return this.clone().ineg()
      }, h.prototype.ineg = function() {
        return this.isZero() || (this.negative ^= 1), this
      }, h.prototype.iuor = function(t) {
        for (; this.length < t.length;) this.words[this.length++] = 0;
        for (var i = 0; i < t.length; i++) this.words[i] = this.words[i] | t.words[i];
        return this._strip()
      }, h.prototype.ior = function(t) {
        return r(0 == (this.negative | t.negative)), this.iuor(t)
      }, h.prototype.or = function(t) {
        return this.length > t.length ? this.clone().ior(t) : t.clone().ior(this)
      }, h.prototype.uor = function(t) {
        return this.length > t.length ? this.clone().iuor(t) : t.clone().iuor(this)
      }, h.prototype.iuand = function(t) {
        var i;
        i = this.length > t.length ? t : this;
        for (var r = 0; r < i.length; r++) this.words[r] = this.words[r] & t.words[r];
        return this.length = i.length, this._strip()
      }, h.prototype.iand = function(t) {
        return r(0 == (this.negative | t.negative)), this.iuand(t)
      }, h.prototype.and = function(t) {
        return this.length > t.length ? this.clone().iand(t) : t.clone().iand(this)
      }, h.prototype.uand = function(t) {
        return this.length > t.length ? this.clone().iuand(t) : t.clone().iuand(this)
      }, h.prototype.iuxor = function(t) {
        var i, r;
        this.length > t.length ? (i = this, r = t) : (i = t, r = this);
        for (var n = 0; n < r.length; n++) this.words[n] = i.words[n] ^ r.words[n];
        if (this !== i)
          for (; n < i.length; n++) this.words[n] = i.words[n];
        return this.length = i.length, this._strip()
      }, h.prototype.ixor = function(t) {
        return r(0 == (this.negative | t.negative)), this.iuxor(t)
      }, h.prototype.xor = function(t) {
        return this.length > t.length ? this.clone().ixor(t) : t.clone().ixor(this)
      }, h.prototype.uxor = function(t) {
        return this.length > t.length ? this.clone().iuxor(t) : t.clone().iuxor(this)
      }, h.prototype.inotn = function(t) {
        r("number" == typeof t && t >= 0);
        var i = 0 | Math.ceil(t / 26),
          n = t % 26;
        this._expand(i), n > 0 && i--;
        for (var h = 0; h < i; h++) this.words[h] = 67108863 & ~this.words[h];
        return n > 0 && (this.words[h] = ~this.words[h] & 67108863 >> 26 - n), this._strip()
      }, h.prototype.notn = function(t) {
        return this.clone().inotn(t)
      }, h.prototype.setn = function(t, i) {
        r("number" == typeof t && t >= 0);
        var n = t / 26 | 0,
          h = t % 26;
        return this._expand(n + 1), this.words[n] = i ? this.words[n] | 1 << h : this.words[n] & ~(1 << h), this._strip()
      }, h.prototype.iadd = function(t) {
        var i, r, n;
        if (0 !== this.negative && 0 === t.negative) return this.negative = 0, i = this.isub(t), this.negative ^= 1, this._normSign();
        if (0 === this.negative && 0 !== t.negative) return t.negative = 0, i = this.isub(t), t.negative = 1, i._normSign();
        this.length > t.length ? (r = this, n = t) : (r = t, n = this);
        for (var h = 0, e = 0; e < n.length; e++) i = (0 | r.words[e]) + (0 | n.words[e]) + h, this.words[e] = 67108863 & i, h = i >>> 26;
        for (; 0 !== h && e < r.length; e++) i = (0 | r.words[e]) + h, this.words[e] = 67108863 & i, h = i >>> 26;
        if (this.length = r.length, 0 !== h) this.words[this.length] = h, this.length++;
        else if (r !== this)
          for (; e < r.length; e++) this.words[e] = r.words[e];
        return this
      }, h.prototype.add = function(t) {
        var i;
        return 0 !== t.negative && 0 === this.negative ? (t.negative = 0, i = this.sub(t), t.negative ^= 1, i) : 0 === t.negative && 0 !== this.negative ? (this.negative = 0, i = t.sub(this), this.negative = 1, i) : this.length > t.length ? this.clone().iadd(t) : t.clone().iadd(this)
      }, h.prototype.isub = function(t) {
        if (0 !== t.negative) {
          t.negative = 0;
          var i = this.iadd(t);
          return t.negative = 1, i._normSign()
        }
        if (0 !== this.negative) return this.negative = 0, this.iadd(t), this.negative = 1, this._normSign();
        var r, n, h = this.cmp(t);
        if (0 === h) return this.negative = 0, this.length = 1, this.words[0] = 0, this;
        h > 0 ? (r = this, n = t) : (r = t, n = this);
        for (var e = 0, o = 0; o < n.length; o++) e = (i = (0 | r.words[o]) - (0 | n.words[o]) + e) >> 26, this.words[o] = 67108863 & i;
        for (; 0 !== e && o < r.length; o++) e = (i = (0 | r.words[o]) + e) >> 26, this.words[o] = 67108863 & i;
        if (0 === e && o < r.length && r !== this)
          for (; o < r.length; o++) this.words[o] = r.words[o];
        return this.length = Math.max(this.length, o), r !== this && (this.negative = 1), this._strip()
      }, h.prototype.sub = function(t) {
        return this.clone().isub(t)
      };
      var M = function(t, i, r) {
        var n, h, e, o = t.words,
          s = i.words,
          u = r.words,
          a = 0,
          l = 0 | o[0],
          m = 8191 & l,
          f = l >>> 13,
          d = 0 | o[1],
          p = 8191 & d,
          M = d >>> 13,
          v = 0 | o[2],
          g = 8191 & v,
          c = v >>> 13,
          w = 0 | o[3],
          y = 8191 & w,
          b = w >>> 13,
          _ = 0 | o[4],
          k = 8191 & _,
          A = _ >>> 13,
          S = 0 | o[5],
          x = 8191 & S,
          B = S >>> 13,
          q = 0 | o[6],
          R = 8191 & q,
          Z = q >>> 13,
          L = 0 | o[7],
          N = 8191 & L,
          I = L >>> 13,
          E = 0 | o[8],
          z = 8191 & E,
          T = E >>> 13,
          O = 0 | o[9],
          j = 8191 & O,
          K = O >>> 13,
          P = 0 | s[0],
          F = 8191 & P,
          U = P >>> 13,
          C = 0 | s[1],
          D = 8191 & C,
          H = C >>> 13,
          J = 0 | s[2],
          G = 8191 & J,
          Q = J >>> 13,
          V = 0 | s[3],
          W = 8191 & V,
          X = V >>> 13,
          Y = 0 | s[4],
          $ = 8191 & Y,
          tt = Y >>> 13,
          it = 0 | s[5],
          rt = 8191 & it,
          nt = it >>> 13,
          ht = 0 | s[6],
          et = 8191 & ht,
          ot = ht >>> 13,
          st = 0 | s[7],
          ut = 8191 & st,
          at = st >>> 13,
          lt = 0 | s[8],
          mt = 8191 & lt,
          ft = lt >>> 13,
          dt = 0 | s[9],
          pt = 8191 & dt,
          Mt = dt >>> 13;
        r.negative = t.negative ^ i.negative, r.length = 19;
        var vt = (a + (n = Math.imul(m, F)) | 0) + ((8191 & (h = (h = Math.imul(m, U)) + Math.imul(f, F) | 0)) << 13) | 0;
        a = ((e = Math.imul(f, U)) + (h >>> 13) | 0) + (vt >>> 26) | 0, vt &= 67108863, n = Math.imul(p, F), h = (h = Math.imul(p, U)) + Math.imul(M, F) | 0, e = Math.imul(M, U);
        var gt = (a + (n = n + Math.imul(m, D) | 0) | 0) + ((8191 & (h = (h = h + Math.imul(m, H) | 0) + Math.imul(f, D) | 0)) << 13) | 0;
        a = ((e = e + Math.imul(f, H) | 0) + (h >>> 13) | 0) + (gt >>> 26) | 0, gt &= 67108863, n = Math.imul(g, F), h = (h = Math.imul(g, U)) + Math.imul(c, F) | 0, e = Math.imul(c, U), n = n + Math.imul(p, D) | 0, h = (h = h + Math.imul(p, H) | 0) + Math.imul(M, D) | 0, e = e + Math.imul(M, H) | 0;
        var ct = (a + (n = n + Math.imul(m, G) | 0) | 0) + ((8191 & (h = (h = h + Math.imul(m, Q) | 0) + Math.imul(f, G) | 0)) << 13) | 0;
        a = ((e = e + Math.imul(f, Q) | 0) + (h >>> 13) | 0) + (ct >>> 26) | 0, ct &= 67108863, n = Math.imul(y, F), h = (h = Math.imul(y, U)) + Math.imul(b, F) | 0, e = Math.imul(b, U), n = n + Math.imul(g, D) | 0, h = (h = h + Math.imul(g, H) | 0) + Math.imul(c, D) | 0, e = e + Math.imul(c, H) | 0, n = n + Math.imul(p, G) | 0, h = (h = h + Math.imul(p, Q) | 0) + Math.imul(M, G) | 0, e = e + Math.imul(M, Q) | 0;
        var wt = (a + (n = n + Math.imul(m, W) | 0) | 0) + ((8191 & (h = (h = h + Math.imul(m, X) | 0) + Math.imul(f, W) | 0)) << 13) | 0;
        a = ((e = e + Math.imul(f, X) | 0) + (h >>> 13) | 0) + (wt >>> 26) | 0, wt &= 67108863, n = Math.imul(k, F), h = (h = Math.imul(k, U)) + Math.imul(A, F) | 0, e = Math.imul(A, U), n = n + Math.imul(y, D) | 0, h = (h = h + Math.imul(y, H) | 0) + Math.imul(b, D) | 0, e = e + Math.imul(b, H) | 0, n = n + Math.imul(g, G) | 0, h = (h = h + Math.imul(g, Q) | 0) + Math.imul(c, G) | 0, e = e + Math.imul(c, Q) | 0, n = n + Math.imul(p, W) | 0, h = (h = h + Math.imul(p, X) | 0) + Math.imul(M, W) | 0, e = e + Math.imul(M, X) | 0;
        var yt = (a + (n = n + Math.imul(m, $) | 0) | 0) + ((8191 & (h = (h = h + Math.imul(m, tt) | 0) + Math.imul(f, $) | 0)) << 13) | 0;
        a = ((e = e + Math.imul(f, tt) | 0) + (h >>> 13) | 0) + (yt >>> 26) | 0, yt &= 67108863, n = Math.imul(x, F), h = (h = Math.imul(x, U)) + Math.imul(B, F) | 0, e = Math.imul(B, U), n = n + Math.imul(k, D) | 0, h = (h = h + Math.imul(k, H) | 0) + Math.imul(A, D) | 0, e = e + Math.imul(A, H) | 0, n = n + Math.imul(y, G) | 0, h = (h = h + Math.imul(y, Q) | 0) + Math.imul(b, G) | 0, e = e + Math.imul(b, Q) | 0, n = n + Math.imul(g, W) | 0, h = (h = h + Math.imul(g, X) | 0) + Math.imul(c, W) | 0, e = e + Math.imul(c, X) | 0, n = n + Math.imul(p, $) | 0, h = (h = h + Math.imul(p, tt) | 0) + Math.imul(M, $) | 0, e = e + Math.imul(M, tt) | 0;
        var bt = (a + (n = n + Math.imul(m, rt) | 0) | 0) + ((8191 & (h = (h = h + Math.imul(m, nt) | 0) + Math.imul(f, rt) | 0)) << 13) | 0;
        a = ((e = e + Math.imul(f, nt) | 0) + (h >>> 13) | 0) + (bt >>> 26) | 0, bt &= 67108863, n = Math.imul(R, F), h = (h = Math.imul(R, U)) + Math.imul(Z, F) | 0, e = Math.imul(Z, U), n = n + Math.imul(x, D) | 0, h = (h = h + Math.imul(x, H) | 0) + Math.imul(B, D) | 0, e = e + Math.imul(B, H) | 0, n = n + Math.imul(k, G) | 0, h = (h = h + Math.imul(k, Q) | 0) + Math.imul(A, G) | 0, e = e + Math.imul(A, Q) | 0, n = n + Math.imul(y, W) | 0, h = (h = h + Math.imul(y, X) | 0) + Math.imul(b, W) | 0, e = e + Math.imul(b, X) | 0, n = n + Math.imul(g, $) | 0, h = (h = h + Math.imul(g, tt) | 0) + Math.imul(c, $) | 0, e = e + Math.imul(c, tt) | 0, n = n + Math.imul(p, rt) | 0, h = (h = h + Math.imul(p, nt) | 0) + Math.imul(M, rt) | 0, e = e + Math.imul(M, nt) | 0;
        var _t = (a + (n = n + Math.imul(m, et) | 0) | 0) + ((8191 & (h = (h = h + Math.imul(m, ot) | 0) + Math.imul(f, et) | 0)) << 13) | 0;
        a = ((e = e + Math.imul(f, ot) | 0) + (h >>> 13) | 0) + (_t >>> 26) | 0, _t &= 67108863, n = Math.imul(N, F), h = (h = Math.imul(N, U)) + Math.imul(I, F) | 0, e = Math.imul(I, U), n = n + Math.imul(R, D) | 0, h = (h = h + Math.imul(R, H) | 0) + Math.imul(Z, D) | 0, e = e + Math.imul(Z, H) | 0, n = n + Math.imul(x, G) | 0, h = (h = h + Math.imul(x, Q) | 0) + Math.imul(B, G) | 0, e = e + Math.imul(B, Q) | 0, n = n + Math.imul(k, W) | 0, h = (h = h + Math.imul(k, X) | 0) + Math.imul(A, W) | 0, e = e + Math.imul(A, X) | 0, n = n + Math.imul(y, $) | 0, h = (h = h + Math.imul(y, tt) | 0) + Math.imul(b, $) | 0, e = e + Math.imul(b, tt) | 0, n = n + Math.imul(g, rt) | 0, h = (h = h + Math.imul(g, nt) | 0) + Math.imul(c, rt) | 0, e = e + Math.imul(c, nt) | 0, n = n + Math.imul(p, et) | 0, h = (h = h + Math.imul(p, ot) | 0) + Math.imul(M, et) | 0, e = e + Math.imul(M, ot) | 0;
        var kt = (a + (n = n + Math.imul(m, ut) | 0) | 0) + ((8191 & (h = (h = h + Math.imul(m, at) | 0) + Math.imul(f, ut) | 0)) << 13) | 0;
        a = ((e = e + Math.imul(f, at) | 0) + (h >>> 13) | 0) + (kt >>> 26) | 0, kt &= 67108863, n = Math.imul(z, F), h = (h = Math.imul(z, U)) + Math.imul(T, F) | 0, e = Math.imul(T, U), n = n + Math.imul(N, D) | 0, h = (h = h + Math.imul(N, H) | 0) + Math.imul(I, D) | 0, e = e + Math.imul(I, H) | 0, n = n + Math.imul(R, G) | 0, h = (h = h + Math.imul(R, Q) | 0) + Math.imul(Z, G) | 0, e = e + Math.imul(Z, Q) | 0, n = n + Math.imul(x, W) | 0, h = (h = h + Math.imul(x, X) | 0) + Math.imul(B, W) | 0, e = e + Math.imul(B, X) | 0, n = n + Math.imul(k, $) | 0, h = (h = h + Math.imul(k, tt) | 0) + Math.imul(A, $) | 0, e = e + Math.imul(A, tt) | 0, n = n + Math.imul(y, rt) | 0, h = (h = h + Math.imul(y, nt) | 0) + Math.imul(b, rt) | 0, e = e + Math.imul(b, nt) | 0, n = n + Math.imul(g, et) | 0, h = (h = h + Math.imul(g, ot) | 0) + Math.imul(c, et) | 0, e = e + Math.imul(c, ot) | 0, n = n + Math.imul(p, ut) | 0, h = (h = h + Math.imul(p, at) | 0) + Math.imul(M, ut) | 0, e = e + Math.imul(M, at) | 0;
        var At = (a + (n = n + Math.imul(m, mt) | 0) | 0) + ((8191 & (h = (h = h + Math.imul(m, ft) | 0) + Math.imul(f, mt) | 0)) << 13) | 0;
        a = ((e = e + Math.imul(f, ft) | 0) + (h >>> 13) | 0) + (At >>> 26) | 0, At &= 67108863, n = Math.imul(j, F), h = (h = Math.imul(j, U)) + Math.imul(K, F) | 0, e = Math.imul(K, U), n = n + Math.imul(z, D) | 0, h = (h = h + Math.imul(z, H) | 0) + Math.imul(T, D) | 0, e = e + Math.imul(T, H) | 0, n = n + Math.imul(N, G) | 0, h = (h = h + Math.imul(N, Q) | 0) + Math.imul(I, G) | 0, e = e + Math.imul(I, Q) | 0, n = n + Math.imul(R, W) | 0, h = (h = h + Math.imul(R, X) | 0) + Math.imul(Z, W) | 0, e = e + Math.imul(Z, X) | 0, n = n + Math.imul(x, $) | 0, h = (h = h + Math.imul(x, tt) | 0) + Math.imul(B, $) | 0, e = e + Math.imul(B, tt) | 0, n = n + Math.imul(k, rt) | 0, h = (h = h + Math.imul(k, nt) | 0) + Math.imul(A, rt) | 0, e = e + Math.imul(A, nt) | 0, n = n + Math.imul(y, et) | 0, h = (h = h + Math.imul(y, ot) | 0) + Math.imul(b, et) | 0, e = e + Math.imul(b, ot) | 0, n = n + Math.imul(g, ut) | 0, h = (h = h + Math.imul(g, at) | 0) + Math.imul(c, ut) | 0, e = e + Math.imul(c, at) | 0, n = n + Math.imul(p, mt) | 0, h = (h = h + Math.imul(p, ft) | 0) + Math.imul(M, mt) | 0, e = e + Math.imul(M, ft) | 0;
        var St = (a + (n = n + Math.imul(m, pt) | 0) | 0) + ((8191 & (h = (h = h + Math.imul(m, Mt) | 0) + Math.imul(f, pt) | 0)) << 13) | 0;
        a = ((e = e + Math.imul(f, Mt) | 0) + (h >>> 13) | 0) + (St >>> 26) | 0, St &= 67108863, n = Math.imul(j, D), h = (h = Math.imul(j, H)) + Math.imul(K, D) | 0, e = Math.imul(K, H), n = n + Math.imul(z, G) | 0, h = (h = h + Math.imul(z, Q) | 0) + Math.imul(T, G) | 0, e = e + Math.imul(T, Q) | 0, n = n + Math.imul(N, W) | 0, h = (h = h + Math.imul(N, X) | 0) + Math.imul(I, W) | 0, e = e + Math.imul(I, X) | 0, n = n + Math.imul(R, $) | 0, h = (h = h + Math.imul(R, tt) | 0) + Math.imul(Z, $) | 0, e = e + Math.imul(Z, tt) | 0, n = n + Math.imul(x, rt) | 0, h = (h = h + Math.imul(x, nt) | 0) + Math.imul(B, rt) | 0, e = e + Math.imul(B, nt) | 0, n = n + Math.imul(k, et) | 0, h = (h = h + Math.imul(k, ot) | 0) + Math.imul(A, et) | 0, e = e + Math.imul(A, ot) | 0, n = n + Math.imul(y, ut) | 0, h = (h = h + Math.imul(y, at) | 0) + Math.imul(b, ut) | 0, e = e + Math.imul(b, at) | 0, n = n + Math.imul(g, mt) | 0, h = (h = h + Math.imul(g, ft) | 0) + Math.imul(c, mt) | 0, e = e + Math.imul(c, ft) | 0;
        var xt = (a + (n = n + Math.imul(p, pt) | 0) | 0) + ((8191 & (h = (h = h + Math.imul(p, Mt) | 0) + Math.imul(M, pt) | 0)) << 13) | 0;
        a = ((e = e + Math.imul(M, Mt) | 0) + (h >>> 13) | 0) + (xt >>> 26) | 0, xt &= 67108863, n = Math.imul(j, G), h = (h = Math.imul(j, Q)) + Math.imul(K, G) | 0, e = Math.imul(K, Q), n = n + Math.imul(z, W) | 0, h = (h = h + Math.imul(z, X) | 0) + Math.imul(T, W) | 0, e = e + Math.imul(T, X) | 0, n = n + Math.imul(N, $) | 0, h = (h = h + Math.imul(N, tt) | 0) + Math.imul(I, $) | 0, e = e + Math.imul(I, tt) | 0, n = n + Math.imul(R, rt) | 0, h = (h = h + Math.imul(R, nt) | 0) + Math.imul(Z, rt) | 0, e = e + Math.imul(Z, nt) | 0, n = n + Math.imul(x, et) | 0, h = (h = h + Math.imul(x, ot) | 0) + Math.imul(B, et) | 0, e = e + Math.imul(B, ot) | 0, n = n + Math.imul(k, ut) | 0, h = (h = h + Math.imul(k, at) | 0) + Math.imul(A, ut) | 0, e = e + Math.imul(A, at) | 0, n = n + Math.imul(y, mt) | 0, h = (h = h + Math.imul(y, ft) | 0) + Math.imul(b, mt) | 0, e = e + Math.imul(b, ft) | 0;
        var Bt = (a + (n = n + Math.imul(g, pt) | 0) | 0) + ((8191 & (h = (h = h + Math.imul(g, Mt) | 0) + Math.imul(c, pt) | 0)) << 13) | 0;
        a = ((e = e + Math.imul(c, Mt) | 0) + (h >>> 13) | 0) + (Bt >>> 26) | 0, Bt &= 67108863, n = Math.imul(j, W), h = (h = Math.imul(j, X)) + Math.imul(K, W) | 0, e = Math.imul(K, X), n = n + Math.imul(z, $) | 0, h = (h = h + Math.imul(z, tt) | 0) + Math.imul(T, $) | 0, e = e + Math.imul(T, tt) | 0, n = n + Math.imul(N, rt) | 0, h = (h = h + Math.imul(N, nt) | 0) + Math.imul(I, rt) | 0, e = e + Math.imul(I, nt) | 0, n = n + Math.imul(R, et) | 0, h = (h = h + Math.imul(R, ot) | 0) + Math.imul(Z, et) | 0, e = e + Math.imul(Z, ot) | 0, n = n + Math.imul(x, ut) | 0, h = (h = h + Math.imul(x, at) | 0) + Math.imul(B, ut) | 0, e = e + Math.imul(B, at) | 0, n = n + Math.imul(k, mt) | 0, h = (h = h + Math.imul(k, ft) | 0) + Math.imul(A, mt) | 0, e = e + Math.imul(A, ft) | 0;
        var qt = (a + (n = n + Math.imul(y, pt) | 0) | 0) + ((8191 & (h = (h = h + Math.imul(y, Mt) | 0) + Math.imul(b, pt) | 0)) << 13) | 0;
        a = ((e = e + Math.imul(b, Mt) | 0) + (h >>> 13) | 0) + (qt >>> 26) | 0, qt &= 67108863, n = Math.imul(j, $), h = (h = Math.imul(j, tt)) + Math.imul(K, $) | 0, e = Math.imul(K, tt), n = n + Math.imul(z, rt) | 0, h = (h = h + Math.imul(z, nt) | 0) + Math.imul(T, rt) | 0, e = e + Math.imul(T, nt) | 0, n = n + Math.imul(N, et) | 0, h = (h = h + Math.imul(N, ot) | 0) + Math.imul(I, et) | 0, e = e + Math.imul(I, ot) | 0, n = n + Math.imul(R, ut) | 0, h = (h = h + Math.imul(R, at) | 0) + Math.imul(Z, ut) | 0, e = e + Math.imul(Z, at) | 0, n = n + Math.imul(x, mt) | 0, h = (h = h + Math.imul(x, ft) | 0) + Math.imul(B, mt) | 0, e = e + Math.imul(B, ft) | 0;
        var Rt = (a + (n = n + Math.imul(k, pt) | 0) | 0) + ((8191 & (h = (h = h + Math.imul(k, Mt) | 0) + Math.imul(A, pt) | 0)) << 13) | 0;
        a = ((e = e + Math.imul(A, Mt) | 0) + (h >>> 13) | 0) + (Rt >>> 26) | 0, Rt &= 67108863, n = Math.imul(j, rt), h = (h = Math.imul(j, nt)) + Math.imul(K, rt) | 0, e = Math.imul(K, nt), n = n + Math.imul(z, et) | 0, h = (h = h + Math.imul(z, ot) | 0) + Math.imul(T, et) | 0, e = e + Math.imul(T, ot) | 0, n = n + Math.imul(N, ut) | 0, h = (h = h + Math.imul(N, at) | 0) + Math.imul(I, ut) | 0, e = e + Math.imul(I, at) | 0, n = n + Math.imul(R, mt) | 0, h = (h = h + Math.imul(R, ft) | 0) + Math.imul(Z, mt) | 0, e = e + Math.imul(Z, ft) | 0;
        var Zt = (a + (n = n + Math.imul(x, pt) | 0) | 0) + ((8191 & (h = (h = h + Math.imul(x, Mt) | 0) + Math.imul(B, pt) | 0)) << 13) | 0;
        a = ((e = e + Math.imul(B, Mt) | 0) + (h >>> 13) | 0) + (Zt >>> 26) | 0, Zt &= 67108863, n = Math.imul(j, et), h = (h = Math.imul(j, ot)) + Math.imul(K, et) | 0, e = Math.imul(K, ot), n = n + Math.imul(z, ut) | 0, h = (h = h + Math.imul(z, at) | 0) + Math.imul(T, ut) | 0, e = e + Math.imul(T, at) | 0, n = n + Math.imul(N, mt) | 0, h = (h = h + Math.imul(N, ft) | 0) + Math.imul(I, mt) | 0, e = e + Math.imul(I, ft) | 0;
        var Lt = (a + (n = n + Math.imul(R, pt) | 0) | 0) + ((8191 & (h = (h = h + Math.imul(R, Mt) | 0) + Math.imul(Z, pt) | 0)) << 13) | 0;
        a = ((e = e + Math.imul(Z, Mt) | 0) + (h >>> 13) | 0) + (Lt >>> 26) | 0, Lt &= 67108863, n = Math.imul(j, ut), h = (h = Math.imul(j, at)) + Math.imul(K, ut) | 0, e = Math.imul(K, at), n = n + Math.imul(z, mt) | 0, h = (h = h + Math.imul(z, ft) | 0) + Math.imul(T, mt) | 0, e = e + Math.imul(T, ft) | 0;
        var Nt = (a + (n = n + Math.imul(N, pt) | 0) | 0) + ((8191 & (h = (h = h + Math.imul(N, Mt) | 0) + Math.imul(I, pt) | 0)) << 13) | 0;
        a = ((e = e + Math.imul(I, Mt) | 0) + (h >>> 13) | 0) + (Nt >>> 26) | 0, Nt &= 67108863, n = Math.imul(j, mt), h = (h = Math.imul(j, ft)) + Math.imul(K, mt) | 0, e = Math.imul(K, ft);
        var It = (a + (n = n + Math.imul(z, pt) | 0) | 0) + ((8191 & (h = (h = h + Math.imul(z, Mt) | 0) + Math.imul(T, pt) | 0)) << 13) | 0;
        a = ((e = e + Math.imul(T, Mt) | 0) + (h >>> 13) | 0) + (It >>> 26) | 0, It &= 67108863;
        var Et = (a + (n = Math.imul(j, pt)) | 0) + ((8191 & (h = (h = Math.imul(j, Mt)) + Math.imul(K, pt) | 0)) << 13) | 0;
        return a = ((e = Math.imul(K, Mt)) + (h >>> 13) | 0) + (Et >>> 26) | 0, Et &= 67108863, u[0] = vt, u[1] = gt, u[2] = ct, u[3] = wt, u[4] = yt, u[5] = bt, u[6] = _t, u[7] = kt, u[8] = At, u[9] = St, u[10] = xt, u[11] = Bt, u[12] = qt, u[13] = Rt, u[14] = Zt, u[15] = Lt, u[16] = Nt, u[17] = It, u[18] = Et, 0 !== a && (u[19] = a, r.length++), r
      };

      function v(t, i, r) {
        r.negative = i.negative ^ t.negative, r.length = t.length + i.length;
        for (var n = 0, h = 0, e = 0; e < r.length - 1; e++) {
          var o = h;
          h = 0;
          for (var s = 67108863 & n, u = Math.min(e, i.length - 1), a = Math.max(0, e - t.length + 1); a <= u; a++) {
            var l = e - a,
              m = (0 | t.words[l]) * (0 | i.words[a]),
              f = 67108863 & m;
            s = 67108863 & (f = f + s | 0), h += (o = (o = o + (m / 67108864 | 0) | 0) + (f >>> 26) | 0) >>> 26, o &= 67108863
          }
          r.words[e] = s, n = o, o = h
        }
        return 0 !== n ? r.words[e] = n : r.length--, r._strip()
      }

      function g(t, i, r) {
        return v(t, i, r)
      }

      function c(t, i) {
        this.x = t, this.y = i
      }
      Math.imul || (M = p), h.prototype.mulTo = function(t, i) {
        var r = this.length + t.length;
        return 10 === this.length && 10 === t.length ? M(this, t, i) : r < 63 ? p(this, t, i) : r < 1024 ? v(this, t, i) : g(this, t, i)
      }, c.prototype.makeRBT = function(t) {
        for (var i = new Array(t), r = h.prototype._countBits(t) - 1, n = 0; n < t; n++) i[n] = this.revBin(n, r, t);
        return i
      }, c.prototype.revBin = function(t, i, r) {
        if (0 === t || t === r - 1) return t;
        for (var n = 0, h = 0; h < i; h++) n |= (1 & t) << i - h - 1, t >>= 1;
        return n
      }, c.prototype.permute = function(t, i, r, n, h, e) {
        for (var o = 0; o < e; o++) n[o] = i[t[o]], h[o] = r[t[o]]
      }, c.prototype.transform = function(t, i, r, n, h, e) {
        this.permute(e, t, i, r, n, h);
        for (var o = 1; o < h; o <<= 1)
          for (var s = o << 1, u = Math.cos(2 * Math.PI / s), a = Math.sin(2 * Math.PI / s), l = 0; l < h; l += s)
            for (var m = u, f = a, d = 0; d < o; d++) {
              var p = r[l + d],
                M = n[l + d],
                v = r[l + d + o],
                g = n[l + d + o],
                c = m * v - f * g;
              g = m * g + f * v, v = c, r[l + d] = p + v, n[l + d] = M + g, r[l + d + o] = p - v, n[l + d + o] = M - g, d !== s && (c = u * m - a * f, f = u * f + a * m, m = c)
            }
      }, c.prototype.guessLen13b = function(t, i) {
        var r = 1 | Math.max(i, t),
          n = 1 & r,
          h = 0;
        for (r = r / 2 | 0; r; r >>>= 1) h++;
        return 1 << h + 1 + n
      }, c.prototype.conjugate = function(t, i, r) {
        if (!(r <= 1))
          for (var n = 0; n < r / 2; n++) {
            var h = t[n];
            t[n] = t[r - n - 1], t[r - n - 1] = h, h = i[n], i[n] = -i[r - n - 1], i[r - n - 1] = -h
          }
      }, c.prototype.normalize13b = function(t, i) {
        for (var r = 0, n = 0; n < i / 2; n++) {
          var h = 8192 * Math.round(t[2 * n + 1] / i) + Math.round(t[2 * n] / i) + r;
          t[n] = 67108863 & h, r = h < 67108864 ? 0 : h / 67108864 | 0
        }
        return t
      }, c.prototype.convert13b = function(t, i, n, h) {
        for (var e = 0, o = 0; o < i; o++) e += 0 | t[o], n[2 * o] = 8191 & e, e >>>= 13, n[2 * o + 1] = 8191 & e, e >>>= 13;
        for (o = 2 * i; o < h; ++o) n[o] = 0;
        r(0 === e), r(0 == (-8192 & e))
      }, c.prototype.stub = function(t) {
        for (var i = new Array(t), r = 0; r < t; r++) i[r] = 0;
        return i
      }, c.prototype.mulp = function(t, i, r) {
        var n = 2 * this.guessLen13b(t.length, i.length),
          h = this.makeRBT(n),
          e = this.stub(n),
          o = new Array(n),
          s = new Array(n),
          u = new Array(n),
          a = new Array(n),
          l = new Array(n),
          m = new Array(n),
          f = r.words;
        f.length = n, this.convert13b(t.words, t.length, o, n), this.convert13b(i.words, i.length, a, n), this.transform(o, e, s, u, n, h), this.transform(a, e, l, m, n, h);
        for (var d = 0; d < n; d++) {
          var p = s[d] * l[d] - u[d] * m[d];
          u[d] = s[d] * m[d] + u[d] * l[d], s[d] = p
        }
        return this.conjugate(s, u, n), this.transform(s, u, f, e, n, h), this.conjugate(f, e, n), this.normalize13b(f, n), r.negative = t.negative ^ i.negative, r.length = t.length + i.length, r._strip()
      }, h.prototype.mul = function(t) {
        var i = new h(null);
        return i.words = new Array(this.length + t.length), this.mulTo(t, i)
      }, h.prototype.mulf = function(t) {
        var i = new h(null);
        return i.words = new Array(this.length + t.length), g(this, t, i)
      }, h.prototype.imul = function(t) {
        return this.clone().mulTo(t, this)
      }, h.prototype.imuln = function(t) {
        var i = t < 0;
        i && (t = -t), r("number" == typeof t), r(t < 67108864);
        for (var n = 0, h = 0; h < this.length; h++) {
          var e = (0 | this.words[h]) * t,
            o = (67108863 & e) + (67108863 & n);
          n >>= 26, n += e / 67108864 | 0, n += o >>> 26, this.words[h] = 67108863 & o
        }
        return 0 !== n && (this.words[h] = n, this.length++), i ? this.ineg() : this
      }, h.prototype.muln = function(t) {
        return this.clone().imuln(t)
      }, h.prototype.sqr = function() {
        return this.mul(this)
      }, h.prototype.isqr = function() {
        return this.imul(this.clone())
      }, h.prototype.pow = function(t) {
        var i = function(t) {
          for (var i = new Array(t.bitLength()), r = 0; r < i.length; r++) {
            var n = r / 26 | 0,
              h = r % 26;
            i[r] = t.words[n] >>> h & 1
          }
          return i
        }(t);
        if (0 === i.length) return new h(1);
        for (var r = this, n = 0; n < i.length && 0 === i[n]; n++, r = r.sqr());
        if (++n < i.length)
          for (var e = r.sqr(); n < i.length; n++, e = e.sqr()) 0 !== i[n] && (r = r.mul(e));
        return r
      }, h.prototype.iushln = function(t) {
        r("number" == typeof t && t >= 0);
        var i, n = t % 26,
          h = (t - n) / 26,
          e = 67108863 >>> 26 - n << 26 - n;
        if (0 !== n) {
          var o = 0;
          for (i = 0; i < this.length; i++) {
            var s = this.words[i] & e,
              u = (0 | this.words[i]) - s << n;
            this.words[i] = u | o, o = s >>> 26 - n
          }
          o && (this.words[i] = o, this.length++)
        }
        if (0 !== h) {
          for (i = this.length - 1; i >= 0; i--) this.words[i + h] = this.words[i];
          for (i = 0; i < h; i++) this.words[i] = 0;
          this.length += h
        }
        return this._strip()
      }, h.prototype.ishln = function(t) {
        return r(0 === this.negative), this.iushln(t)
      }, h.prototype.iushrn = function(t, i, n) {
        var h;
        r("number" == typeof t && t >= 0), h = i ? (i - i % 26) / 26 : 0;
        var e = t % 26,
          o = Math.min((t - e) / 26, this.length),
          s = 67108863 ^ 67108863 >>> e << e,
          u = n;
        if (h -= o, h = Math.max(0, h), u) {
          for (var a = 0; a < o; a++) u.words[a] = this.words[a];
          u.length = o
        }
        if (0 === o);
        else if (this.length > o)
          for (this.length -= o, a = 0; a < this.length; a++) this.words[a] = this.words[a + o];
        else this.words[0] = 0, this.length = 1;
        var l = 0;
        for (a = this.length - 1; a >= 0 && (0 !== l || a >= h); a--) {
          var m = 0 | this.words[a];
          this.words[a] = l << 26 - e | m >>> e, l = m & s
        }
        return u && 0 !== l && (u.words[u.length++] = l), 0 === this.length && (this.words[0] = 0, this.length = 1), this._strip()
      }, h.prototype.ishrn = function(t, i, n) {
        return r(0 === this.negative), this.iushrn(t, i, n)
      }, h.prototype.shln = function(t) {
        return this.clone().ishln(t)
      }, h.prototype.ushln = function(t) {
        return this.clone().iushln(t)
      }, h.prototype.shrn = function(t) {
        return this.clone().ishrn(t)
      }, h.prototype.ushrn = function(t) {
        return this.clone().iushrn(t)
      }, h.prototype.testn = function(t) {
        r("number" == typeof t && t >= 0);
        var i = t % 26,
          n = (t - i) / 26,
          h = 1 << i;
        return !(this.length <= n) && !!(this.words[n] & h)
      }, h.prototype.imaskn = function(t) {
        r("number" == typeof t && t >= 0);
        var i = t % 26,
          n = (t - i) / 26;
        if (r(0 === this.negative, "imaskn works only with positive numbers"), this.length <= n) return this;
        if (0 !== i && n++, this.length = Math.min(n, this.length), 0 !== i) {
          var h = 67108863 ^ 67108863 >>> i << i;
          this.words[this.length - 1] &= h
        }
        return this._strip()
      }, h.prototype.maskn = function(t) {
        return this.clone().imaskn(t)
      }, h.prototype.iaddn = function(t) {
        return r("number" == typeof t), r(t < 67108864), t < 0 ? this.isubn(-t) : 0 !== this.negative ? 1 === this.length && (0 | this.words[0]) <= t ? (this.words[0] = t - (0 | this.words[0]), this.negative = 0, this) : (this.negative = 0, this.isubn(t), this.negative = 1, this) : this._iaddn(t)
      }, h.prototype._iaddn = function(t) {
        this.words[0] += t;
        for (var i = 0; i < this.length && this.words[i] >= 67108864; i++) this.words[i] -= 67108864, i === this.length - 1 ? this.words[i + 1] = 1 : this.words[i + 1]++;
        return this.length = Math.max(this.length, i + 1), this
      }, h.prototype.isubn = function(t) {
        if (r("number" == typeof t), r(t < 67108864), t < 0) return this.iaddn(-t);
        if (0 !== this.negative) return this.negative = 0, this.iaddn(t), this.negative = 1, this;
        if (this.words[0] -= t, 1 === this.length && this.words[0] < 0) this.words[0] = -this.words[0], this.negative = 1;
        else
          for (var i = 0; i < this.length && this.words[i] < 0; i++) this.words[i] += 67108864, this.words[i + 1] -= 1;
        return this._strip()
      }, h.prototype.addn = function(t) {
        return this.clone().iaddn(t)
      }, h.prototype.subn = function(t) {
        return this.clone().isubn(t)
      }, h.prototype.iabs = function() {
        return this.negative = 0, this
      }, h.prototype.abs = function() {
        return this.clone().iabs()
      }, h.prototype._ishlnsubmul = function(t, i, n) {
        var h, e, o = t.length + n;
        this._expand(o);
        var s = 0;
        for (h = 0; h < t.length; h++) {
          e = (0 | this.words[h + n]) + s;
          var u = (0 | t.words[h]) * i;
          s = ((e -= 67108863 & u) >> 26) - (u / 67108864 | 0), this.words[h + n] = 67108863 & e
        }
        for (; h < this.length - n; h++) s = (e = (0 | this.words[h + n]) + s) >> 26, this.words[h + n] = 67108863 & e;
        if (0 === s) return this._strip();
        for (r(-1 === s), s = 0, h = 0; h < this.length; h++) s = (e = -(0 | this.words[h]) + s) >> 26, this.words[h] = 67108863 & e;
        return this.negative = 1, this._strip()
      }, h.prototype._wordDiv = function(t, i) {
        var r = (this.length, t.length),
          n = this.clone(),
          e = t,
          o = 0 | e.words[e.length - 1];
        0 !== (r = 26 - this._countBits(o)) && (e = e.ushln(r), n.iushln(r), o = 0 | e.words[e.length - 1]);
        var s, u = n.length - e.length;
        if ("mod" !== i) {
          (s = new h(null)).length = u + 1, s.words = new Array(s.length);
          for (var a = 0; a < s.length; a++) s.words[a] = 0
        }
        var l = n.clone()._ishlnsubmul(e, 1, u);
        0 === l.negative && (n = l, s && (s.words[u] = 1));
        for (var m = u - 1; m >= 0; m--) {
          var f = 67108864 * (0 | n.words[e.length + m]) + (0 | n.words[e.length + m - 1]);
          for (f = Math.min(f / o | 0, 67108863), n._ishlnsubmul(e, f, m); 0 !== n.negative;) f--, n.negative = 0, n._ishlnsubmul(e, 1, m), n.isZero() || (n.negative ^= 1);
          s && (s.words[m] = f)
        }
        return s && s._strip(), n._strip(), "div" !== i && 0 !== r && n.iushrn(r), {
          div: s || null,
          mod: n
        }
      }, h.prototype.divmod = function(t, i, n) {
        return r(!t.isZero()), this.isZero() ? {
          div: new h(0),
          mod: new h(0)
        } : 0 !== this.negative && 0 === t.negative ? (s = this.neg().divmod(t, i), "mod" !== i && (e = s.div.neg()), "div" !== i && (o = s.mod.neg(), n && 0 !== o.negative && o.iadd(t)), {
          div: e,
          mod: o
        }) : 0 === this.negative && 0 !== t.negative ? (s = this.divmod(t.neg(), i), "mod" !== i && (e = s.div.neg()), {
          div: e,
          mod: s.mod
        }) : 0 != (this.negative & t.negative) ? (s = this.neg().divmod(t.neg(), i), "div" !== i && (o = s.mod.neg(), n && 0 !== o.negative && o.isub(t)), {
          div: s.div,
          mod: o
        }) : t.length > this.length || this.cmp(t) < 0 ? {
          div: new h(0),
          mod: this
        } : 1 === t.length ? "div" === i ? {
          div: this.divn(t.words[0]),
          mod: null
        } : "mod" === i ? {
          div: null,
          mod: new h(this.modrn(t.words[0]))
        } : {
          div: this.divn(t.words[0]),
          mod: new h(this.modrn(t.words[0]))
        } : this._wordDiv(t, i);
        var e, o, s
      }, h.prototype.div = function(t) {
        return this.divmod(t, "div", !1).div
      }, h.prototype.mod = function(t) {
        return this.divmod(t, "mod", !1).mod
      }, h.prototype.umod = function(t) {
        return this.divmod(t, "mod", !0).mod
      }, h.prototype.divRound = function(t) {
        var i = this.divmod(t);
        if (i.mod.isZero()) return i.div;
        var r = 0 !== i.div.negative ? i.mod.isub(t) : i.mod,
          n = t.ushrn(1),
          h = t.andln(1),
          e = r.cmp(n);
        return e < 0 || 1 === h && 0 === e ? i.div : 0 !== i.div.negative ? i.div.isubn(1) : i.div.iaddn(1)
      }, h.prototype.modrn = function(t) {
        var i = t < 0;
        i && (t = -t), r(t <= 67108863);
        for (var n = (1 << 26) % t, h = 0, e = this.length - 1; e >= 0; e--) h = (n * h + (0 | this.words[e])) % t;
        return i ? -h : h
      }, h.prototype.modn = function(t) {
        return this.modrn(t)
      }, h.prototype.idivn = function(t) {
        var i = t < 0;
        i && (t = -t), r(t <= 67108863);
        for (var n = 0, h = this.length - 1; h >= 0; h--) {
          var e = (0 | this.words[h]) + 67108864 * n;
          this.words[h] = e / t | 0, n = e % t
        }
        return this._strip(), i ? this.ineg() : this
      }, h.prototype.divn = function(t) {
        return this.clone().idivn(t)
      }, h.prototype.egcd = function(t) {
        r(0 === t.negative), r(!t.isZero());
        var i = this,
          n = t.clone();
        i = 0 !== i.negative ? i.umod(t) : i.clone();
        for (var e = new h(1), o = new h(0), s = new h(0), u = new h(1), a = 0; i.isEven() && n.isEven();) i.iushrn(1), n.iushrn(1), ++a;
        for (var l = n.clone(), m = i.clone(); !i.isZero();) {
          for (var f = 0, d = 1; 0 == (i.words[0] & d) && f < 26; ++f, d <<= 1);
          if (f > 0)
            for (i.iushrn(f); f-- > 0;)(e.isOdd() || o.isOdd()) && (e.iadd(l), o.isub(m)), e.iushrn(1), o.iushrn(1);
          for (var p = 0, M = 1; 0 == (n.words[0] & M) && p < 26; ++p, M <<= 1);
          if (p > 0)
            for (n.iushrn(p); p-- > 0;)(s.isOdd() || u.isOdd()) && (s.iadd(l), u.isub(m)), s.iushrn(1), u.iushrn(1);
          i.cmp(n) >= 0 ? (i.isub(n), e.isub(s), o.isub(u)) : (n.isub(i), s.isub(e), u.isub(o))
        }
        return {
          a: s,
          b: u,
          gcd: n.iushln(a)
        }
      }, h.prototype._invmp = function(t) {
        r(0 === t.negative), r(!t.isZero());
        var i = this,
          n = t.clone();
        i = 0 !== i.negative ? i.umod(t) : i.clone();
        for (var e, o = new h(1), s = new h(0), u = n.clone(); i.cmpn(1) > 0 && n.cmpn(1) > 0;) {
          for (var a = 0, l = 1; 0 == (i.words[0] & l) && a < 26; ++a, l <<= 1);
          if (a > 0)
            for (i.iushrn(a); a-- > 0;) o.isOdd() && o.iadd(u), o.iushrn(1);
          for (var m = 0, f = 1; 0 == (n.words[0] & f) && m < 26; ++m, f <<= 1);
          if (m > 0)
            for (n.iushrn(m); m-- > 0;) s.isOdd() && s.iadd(u), s.iushrn(1);
          i.cmp(n) >= 0 ? (i.isub(n), o.isub(s)) : (n.isub(i), s.isub(o))
        }
        return (e = 0 === i.cmpn(1) ? o : s).cmpn(0) < 0 && e.iadd(t), e
      }, h.prototype.gcd = function(t) {
        if (this.isZero()) return t.abs();
        if (t.isZero()) return this.abs();
        var i = this.clone(),
          r = t.clone();
        i.negative = 0, r.negative = 0;
        for (var n = 0; i.isEven() && r.isEven(); n++) i.iushrn(1), r.iushrn(1);
        for (;;) {
          for (; i.isEven();) i.iushrn(1);
          for (; r.isEven();) r.iushrn(1);
          var h = i.cmp(r);
          if (h < 0) {
            var e = i;
            i = r, r = e
          } else if (0 === h || 0 === r.cmpn(1)) break;
          i.isub(r)
        }
        return r.iushln(n)
      }, h.prototype.invm = function(t) {
        return this.egcd(t).a.umod(t)
      }, h.prototype.isEven = function() {
        return 0 == (1 & this.words[0])
      }, h.prototype.isOdd = function() {
        return 1 == (1 & this.words[0])
      }, h.prototype.andln = function(t) {
        return this.words[0] & t
      }, h.prototype.bincn = function(t) {
        r("number" == typeof t);
        var i = t % 26,
          n = (t - i) / 26,
          h = 1 << i;
        if (this.length <= n) return this._expand(n + 1), this.words[n] |= h, this;
        for (var e = h, o = n; 0 !== e && o < this.length; o++) {
          var s = 0 | this.words[o];
          e = (s += e) >>> 26, s &= 67108863, this.words[o] = s
        }
        return 0 !== e && (this.words[o] = e, this.length++), this
      }, h.prototype.isZero = function() {
        return 1 === this.length && 0 === this.words[0]
      }, h.prototype.cmpn = function(t) {
        var i, n = t < 0;
        if (0 !== this.negative && !n) return -1;
        if (0 === this.negative && n) return 1;
        if (this._strip(), this.length > 1) i = 1;
        else {
          n && (t = -t), r(t <= 67108863, "Number is too big");
          var h = 0 | this.words[0];
          i = h === t ? 0 : h < t ? -1 : 1
        }
        return 0 !== this.negative ? 0 | -i : i
      }, h.prototype.cmp = function(t) {
        if (0 !== this.negative && 0 === t.negative) return -1;
        if (0 === this.negative && 0 !== t.negative) return 1;
        var i = this.ucmp(t);
        return 0 !== this.negative ? 0 | -i : i
      }, h.prototype.ucmp = function(t) {
        if (this.length > t.length) return 1;
        if (this.length < t.length) return -1;
        for (var i = 0, r = this.length - 1; r >= 0; r--) {
          var n = 0 | this.words[r],
            h = 0 | t.words[r];
          if (n !== h) {
            n < h ? i = -1 : n > h && (i = 1);
            break
          }
        }
        return i
      }, h.prototype.gtn = function(t) {
        return 1 === this.cmpn(t)
      }, h.prototype.gt = function(t) {
        return 1 === this.cmp(t)
      }, h.prototype.gten = function(t) {
        return this.cmpn(t) >= 0
      }, h.prototype.gte = function(t) {
        return this.cmp(t) >= 0
      }, h.prototype.ltn = function(t) {
        return -1 === this.cmpn(t)
      }, h.prototype.lt = function(t) {
        return -1 === this.cmp(t)
      }, h.prototype.lten = function(t) {
        return this.cmpn(t) <= 0
      }, h.prototype.lte = function(t) {
        return this.cmp(t) <= 0
      }, h.prototype.eqn = function(t) {
        return 0 === this.cmpn(t)
      }, h.prototype.eq = function(t) {
        return 0 === this.cmp(t)
      }, h.red = function(t) {
        return new S(t)
      }, h.prototype.toRed = function(t) {
        return r(!this.red, "Already a number in reduction context"), r(0 === this.negative, "red works only with positives"), t.convertTo(this)._forceRed(t)
      }, h.prototype.fromRed = function() {
        return r(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this)
      }, h.prototype._forceRed = function(t) {
        return this.red = t, this
      }, h.prototype.forceRed = function(t) {
        return r(!this.red, "Already a number in reduction context"), this._forceRed(t)
      }, h.prototype.redAdd = function(t) {
        return r(this.red, "redAdd works only with red numbers"), this.red.add(this, t)
      }, h.prototype.redIAdd = function(t) {
        return r(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, t)
      }, h.prototype.redSub = function(t) {
        return r(this.red, "redSub works only with red numbers"), this.red.sub(this, t)
      }, h.prototype.redISub = function(t) {
        return r(this.red, "redISub works only with red numbers"), this.red.isub(this, t)
      }, h.prototype.redShl = function(t) {
        return r(this.red, "redShl works only with red numbers"), this.red.shl(this, t)
      }, h.prototype.redMul = function(t) {
        return r(this.red, "redMul works only with red numbers"), this.red._verify2(this, t), this.red.mul(this, t)
      }, h.prototype.redIMul = function(t) {
        return r(this.red, "redMul works only with red numbers"), this.red._verify2(this, t), this.red.imul(this, t)
      }, h.prototype.redSqr = function() {
        return r(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this)
      }, h.prototype.redISqr = function() {
        return r(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this)
      }, h.prototype.redSqrt = function() {
        return r(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this)
      }, h.prototype.redInvm = function() {
        return r(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this)
      }, h.prototype.redNeg = function() {
        return r(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this)
      }, h.prototype.redPow = function(t) {
        return r(this.red && !t.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, t)
      };
      var w = {
        k256: null,
        p224: null,
        p192: null,
        p25519: null
      };

      function y(t, i) {
        this.name = t, this.p = new h(i, 16), this.n = this.p.bitLength(), this.k = new h(1).iushln(this.n).isub(this.p), this.tmp = this._tmp()
      }

      function b() {
        y.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f")
      }

      function _() {
        y.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001")
      }

      function k() {
        y.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff")
      }

      function A() {
        y.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed")
      }

      function S(t) {
        if ("string" == typeof t) {
          var i = h._prime(t);
          this.m = i.p, this.prime = i
        } else r(t.gtn(1), "modulus must be greater than 1"), this.m = t, this.prime = null
      }

      function x(t) {
        S.call(this, t), this.shift = this.m.bitLength(), this.shift % 26 != 0 && (this.shift += 26 - this.shift % 26), this.r = new h(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv)
      }
      y.prototype._tmp = function() {
        var t = new h(null);
        return t.words = new Array(Math.ceil(this.n / 13)), t
      }, y.prototype.ireduce = function(t) {
        var i, r = t;
        do {
          this.split(r, this.tmp), i = (r = (r = this.imulK(r)).iadd(this.tmp)).bitLength()
        } while (i > this.n);
        var n = i < this.n ? -1 : r.ucmp(this.p);
        return 0 === n ? (r.words[0] = 0, r.length = 1) : n > 0 ? r.isub(this.p) : void 0 !== r.strip ? r.strip() : r._strip(), r
      }, y.prototype.split = function(t, i) {
        t.iushrn(this.n, 0, i)
      }, y.prototype.imulK = function(t) {
        return t.imul(this.k)
      }, n(b, y), b.prototype.split = function(t, i) {
        for (var r = Math.min(t.length, 9), n = 0; n < r; n++) i.words[n] = t.words[n];
        if (i.length = r, t.length <= 9) return t.words[0] = 0, void(t.length = 1);
        var h = t.words[9];
        for (i.words[i.length++] = 4194303 & h, n = 10; n < t.length; n++) {
          var e = 0 | t.words[n];
          t.words[n - 10] = (4194303 & e) << 4 | h >>> 22, h = e
        }
        h >>>= 22, t.words[n - 10] = h, 0 === h && t.length > 10 ? t.length -= 10 : t.length -= 9
      }, b.prototype.imulK = function(t) {
        t.words[t.length] = 0, t.words[t.length + 1] = 0, t.length += 2;
        for (var i = 0, r = 0; r < t.length; r++) {
          var n = 0 | t.words[r];
          i += 977 * n, t.words[r] = 67108863 & i, i = 64 * n + (i / 67108864 | 0)
        }
        return 0 === t.words[t.length - 1] && (t.length--, 0 === t.words[t.length - 1] && t.length--), t
      }, n(_, y), n(k, y), n(A, y), A.prototype.imulK = function(t) {
        for (var i = 0, r = 0; r < t.length; r++) {
          var n = 19 * (0 | t.words[r]) + i,
            h = 67108863 & n;
          n >>>= 26, t.words[r] = h, i = n
        }
        return 0 !== i && (t.words[t.length++] = i), t
      }, h._prime = function(t) {
        if (w[t]) return w[t];
        var i;
        if ("k256" === t) i = new b;
        else if ("p224" === t) i = new _;
        else if ("p192" === t) i = new k;
        else {
          if ("p25519" !== t) throw new Error("Unknown prime " + t);
          i = new A
        }
        return w[t] = i, i
      }, S.prototype._verify1 = function(t) {
        r(0 === t.negative, "red works only with positives"), r(t.red, "red works only with red numbers")
      }, S.prototype._verify2 = function(t, i) {
        r(0 == (t.negative | i.negative), "red works only with positives"), r(t.red && t.red === i.red, "red works only with red numbers")
      }, S.prototype.imod = function(t) {
        return this.prime ? this.prime.ireduce(t)._forceRed(this) : (a(t, t.umod(this.m)._forceRed(this)), t)
      }, S.prototype.neg = function(t) {
        return t.isZero() ? t.clone() : this.m.sub(t)._forceRed(this)
      }, S.prototype.add = function(t, i) {
        this._verify2(t, i);
        var r = t.add(i);
        return r.cmp(this.m) >= 0 && r.isub(this.m), r._forceRed(this)
      }, S.prototype.iadd = function(t, i) {
        this._verify2(t, i);
        var r = t.iadd(i);
        return r.cmp(this.m) >= 0 && r.isub(this.m), r
      }, S.prototype.sub = function(t, i) {
        this._verify2(t, i);
        var r = t.sub(i);
        return r.cmpn(0) < 0 && r.iadd(this.m), r._forceRed(this)
      }, S.prototype.isub = function(t, i) {
        this._verify2(t, i);
        var r = t.isub(i);
        return r.cmpn(0) < 0 && r.iadd(this.m), r
      }, S.prototype.shl = function(t, i) {
        return this._verify1(t), this.imod(t.ushln(i))
      }, S.prototype.imul = function(t, i) {
        return this._verify2(t, i), this.imod(t.imul(i))
      }, S.prototype.mul = function(t, i) {
        return this._verify2(t, i), this.imod(t.mul(i))
      }, S.prototype.isqr = function(t) {
        return this.imul(t, t.clone())
      }, S.prototype.sqr = function(t) {
        return this.mul(t, t)
      }, S.prototype.sqrt = function(t) {
        if (t.isZero()) return t.clone();
        var i = this.m.andln(3);
        if (r(i % 2 == 1), 3 === i) {
          var n = this.m.add(new h(1)).iushrn(2);
          return this.pow(t, n)
        }
        for (var e = this.m.subn(1), o = 0; !e.isZero() && 0 === e.andln(1);) o++, e.iushrn(1);
        r(!e.isZero());
        var s = new h(1).toRed(this),
          u = s.redNeg(),
          a = this.m.subn(1).iushrn(1),
          l = this.m.bitLength();
        for (l = new h(2 * l * l).toRed(this); 0 !== this.pow(l, a).cmp(u);) l.redIAdd(u);
        for (var m = this.pow(l, e), f = this.pow(t, e.addn(1).iushrn(1)), d = this.pow(t, e), p = o; 0 !== d.cmp(s);) {
          for (var M = d, v = 0; 0 !== M.cmp(s); v++) M = M.redSqr();
          r(v < p);
          var g = this.pow(m, new h(1).iushln(p - v - 1));
          f = f.redMul(g), m = g.redSqr(), d = d.redMul(m), p = v
        }
        return f
      }, S.prototype.invm = function(t) {
        var i = t._invmp(this.m);
        return 0 !== i.negative ? (i.negative = 0, this.imod(i).redNeg()) : this.imod(i)
      }, S.prototype.pow = function(t, i) {
        if (i.isZero()) return new h(1).toRed(this);
        if (0 === i.cmpn(1)) return t.clone();
        var r = new Array(16);
        r[0] = new h(1).toRed(this), r[1] = t;
        for (var n = 2; n < r.length; n++) r[n] = this.mul(r[n - 1], t);
        var e = r[0],
          o = 0,
          s = 0,
          u = i.bitLength() % 26;
        for (0 === u && (u = 26), n = i.length - 1; n >= 0; n--) {
          for (var a = i.words[n], l = u - 1; l >= 0; l--) {
            var m = a >> l & 1;
            e !== r[0] && (e = this.sqr(e)), 0 !== m || 0 !== o ? (o <<= 1, o |= m, (4 === ++s || 0 === n && 0 === l) && (e = this.mul(e, r[o]), s = 0, o = 0)) : s = 0
          }
          u = 26
        }
        return e
      }, S.prototype.convertTo = function(t) {
        var i = t.umod(this.m);
        return i === t ? i.clone() : i
      }, S.prototype.convertFrom = function(t) {
        var i = t.clone();
        return i.red = null, i
      }, h.mont = function(t) {
        return new x(t)
      }, n(x, S), x.prototype.convertTo = function(t) {
        return this.imod(t.ushln(this.shift))
      }, x.prototype.convertFrom = function(t) {
        var i = this.imod(t.mul(this.rinv));
        return i.red = null, i
      }, x.prototype.imul = function(t, i) {
        if (t.isZero() || i.isZero()) return t.words[0] = 0, t.length = 1, t;
        var r = t.imul(i),
          n = r.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m),
          h = r.isub(n).iushrn(this.shift),
          e = h;
        return h.cmp(this.m) >= 0 ? e = h.isub(this.m) : h.cmpn(0) < 0 && (e = h.iadd(this.m)), e._forceRed(this)
      }, x.prototype.mul = function(t, i) {
        if (t.isZero() || i.isZero()) return new h(0)._forceRed(this);
        var r = t.mul(i),
          n = r.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m),
          e = r.isub(n).iushrn(this.shift),
          o = e;
        return e.cmp(this.m) >= 0 ? o = e.isub(this.m) : e.cmpn(0) < 0 && (o = e.iadd(this.m)), o._forceRed(this)
      }, x.prototype.invm = function(t) {
        return this.imod(t._invmp(this.m).mul(this.r2))._forceRed(this)
      }
    }("undefined" == typeof module || module, this);
  }, {
    "buffer": "rDCW"
  }],
  "Aukv": [function(require, module, exports) {
    var Buffer = require("buffer").Buffer;
    var e = require("buffer").Buffer,
      r = require("bn.js"),
      u = require("randombytes");

    function o(e) {
      var u = n(e);
      return {
        blinder: u.toRed(r.mont(e.modulus)).redPow(new r(e.publicExponent)).fromRed(),
        unblinder: u.invm(e.modulus)
      }
    }

    function n(e) {
      var o, n = e.modulus.byteLength();
      do {
        o = new r(u(n))
      } while (o.cmp(e.modulus) >= 0 || !o.umod(e.prime1) || !o.umod(e.prime2));
      return o
    }

    function m(u, n) {
      var m = o(n),
        d = n.modulus.byteLength(),
        i = new r(u).mul(m.blinder).umod(n.modulus),
        t = i.toRed(r.mont(n.prime1)),
        l = i.toRed(r.mont(n.prime2)),
        b = n.coefficient,
        f = n.prime1,
        p = n.prime2,
        s = t.redPow(n.exponent1).fromRed(),
        a = l.redPow(n.exponent2).fromRed(),
        c = s.isub(a).imul(b).umod(f).imul(p);
      return a.iadd(c).imul(m.unblinder).umod(n.modulus).toArrayLike(e, "be", d)
    }
    m.getr = n, module.exports = m;
  }, {
    "bn.js": "BOxy",
    "randombytes": "XJNj",
    "buffer": "dskh"
  }],
  "rE8J": [function(require, module, exports) {

    var process = require("process");
    var e, r = require("process"),
      t = require("buffer"),
      n = t.Buffer,
      o = {};
    for (e in t) t.hasOwnProperty(e) && "SlowBuffer" !== e && "Buffer" !== e && (o[e] = t[e]);
    var f = o.Buffer = {};
    for (e in n) n.hasOwnProperty(e) && "allocUnsafe" !== e && "allocUnsafeSlow" !== e && (f[e] = n[e]);
    if (o.Buffer.prototype = n.prototype, f.from && f.from !== Uint8Array.from || (f.from = function(e, r, t) {
        if ("number" == typeof e) throw new TypeError('The "value" argument must not be of type number. Received type ' + typeof e);
        if (e && void 0 === e.length) throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof e);
        return n(e, r, t)
      }), f.alloc || (f.alloc = function(e, r, t) {
        if ("number" != typeof e) throw new TypeError('The "size" argument must be of type number. Received type ' + typeof e);
        if (e < 0 || e >= 2 * (1 << 30)) throw new RangeError('The value "' + e + '" is invalid for option "size"');
        var o = n(e);
        return r && 0 !== r.length ? "string" == typeof t ? o.fill(r, t) : o.fill(r) : o.fill(0), o
      }), !o.kStringMaxLength) try {
      o.kStringMaxLength = r.binding("buffer").kStringMaxLength
    } catch (i) {}
    o.constants || (o.constants = {
      MAX_LENGTH: o.kMaxLength
    }, o.kStringMaxLength && (o.constants.MAX_STRING_LENGTH = o.kStringMaxLength)), module.exports = o;
  }, {
    "buffer": "dskh",
    "process": "pBGv"
  }],
  "BhoU": [function(require, module, exports) {
    "use strict";
    const t = require("inherits");

    function r(t) {
      this._reporterState = {
        obj: null,
        path: [],
        options: t || {},
        errors: []
      }
    }

    function e(t, r) {
      this.path = t, this.rethrow(r)
    }
    exports.Reporter = r, r.prototype.isError = function(t) {
      return t instanceof e
    }, r.prototype.save = function() {
      const t = this._reporterState;
      return {
        obj: t.obj,
        pathLen: t.path.length
      }
    }, r.prototype.restore = function(t) {
      const r = this._reporterState;
      r.obj = t.obj, r.path = r.path.slice(0, t.pathLen)
    }, r.prototype.enterKey = function(t) {
      return this._reporterState.path.push(t)
    }, r.prototype.exitKey = function(t) {
      const r = this._reporterState;
      r.path = r.path.slice(0, t - 1)
    }, r.prototype.leaveKey = function(t, r, e) {
      const o = this._reporterState;
      this.exitKey(t), null !== o.obj && (o.obj[r] = e)
    }, r.prototype.path = function() {
      return this._reporterState.path.join("/")
    }, r.prototype.enterObject = function() {
      const t = this._reporterState,
        r = t.obj;
      return t.obj = {}, r
    }, r.prototype.leaveObject = function(t) {
      const r = this._reporterState,
        e = r.obj;
      return r.obj = t, e
    }, r.prototype.error = function(t) {
      let r;
      const o = this._reporterState,
        n = t instanceof e;
      if (r = n ? t : new e(o.path.map(function(t) {
          return "[" + JSON.stringify(t) + "]"
        }).join(""), t.message || t, t.stack), !o.options.partial) throw r;
      return n || o.errors.push(r), r
    }, r.prototype.wrapResult = function(t) {
      const r = this._reporterState;
      return r.options.partial ? {
        result: this.isError(t) ? null : t,
        errors: r.errors
      } : t
    }, t(e, Error), e.prototype.rethrow = function(t) {
      if (this.message = t + " at: " + (this.path || "(shallow)"), Error.captureStackTrace && Error.captureStackTrace(this, e), !this.stack) try {
        throw new Error(this.message)
      } catch (r) {
        this.stack = r.stack
      }
      return this
    };
  }, {
    "inherits": "Bm0n"
  }],
  "JJX4": [function(require, module, exports) {

    "use strict";
    const e = require("inherits"),
      t = require("../base/reporter").Reporter,
      r = require("safer-buffer").Buffer;

    function o(e, o) {
      t.call(this, o), r.isBuffer(e) ? (this.base = e, this.offset = 0, this.length = e.length) : this.error("Input not Buffer")
    }

    function f(e, t) {
      if (Array.isArray(e)) this.length = 0, this.value = e.map(function(e) {
        return f.isEncoderBuffer(e) || (e = new f(e, t)), this.length += e.length, e
      }, this);
      else if ("number" == typeof e) {
        if (!(0 <= e && e <= 255)) return t.error("non-byte EncoderBuffer value");
        this.value = e, this.length = 1
      } else if ("string" == typeof e) this.value = e, this.length = r.byteLength(e);
      else {
        if (!r.isBuffer(e)) return t.error("Unsupported type: " + typeof e);
        this.value = e, this.length = e.length
      }
    }
    e(o, t), exports.DecoderBuffer = o, o.isDecoderBuffer = function(e) {
      if (e instanceof o) return !0;
      return "object" == typeof e && r.isBuffer(e.base) && "DecoderBuffer" === e.constructor.name && "number" == typeof e.offset && "number" == typeof e.length && "function" == typeof e.save && "function" == typeof e.restore && "function" == typeof e.isEmpty && "function" == typeof e.readUInt8 && "function" == typeof e.skip && "function" == typeof e.raw
    }, o.prototype.save = function() {
      return {
        offset: this.offset,
        reporter: t.prototype.save.call(this)
      }
    }, o.prototype.restore = function(e) {
      const r = new o(this.base);
      return r.offset = e.offset, r.length = this.offset, this.offset = e.offset, t.prototype.restore.call(this, e.reporter), r
    }, o.prototype.isEmpty = function() {
      return this.offset === this.length
    }, o.prototype.readUInt8 = function(e) {
      return this.offset + 1 <= this.length ? this.base.readUInt8(this.offset++, !0) : this.error(e || "DecoderBuffer overrun")
    }, o.prototype.skip = function(e, t) {
      if (!(this.offset + e <= this.length)) return this.error(t || "DecoderBuffer overrun");
      const r = new o(this.base);
      return r._reporterState = this._reporterState, r.offset = this.offset, r.length = this.offset + e, this.offset += e, r
    }, o.prototype.raw = function(e) {
      return this.base.slice(e ? e.offset : this.offset, this.length)
    }, exports.EncoderBuffer = f, f.isEncoderBuffer = function(e) {
      if (e instanceof f) return !0;
      return "object" == typeof e && "EncoderBuffer" === e.constructor.name && "number" == typeof e.length && "function" == typeof e.join
    }, f.prototype.join = function(e, t) {
      return e || (e = r.alloc(this.length)), t || (t = 0), 0 === this.length ? e : (Array.isArray(this.value) ? this.value.forEach(function(r) {
        r.join(e, t), t += r.length
      }) : ("number" == typeof this.value ? e[t] = this.value : "string" == typeof this.value ? e.write(this.value, t) : r.isBuffer(this.value) && this.value.copy(e, t), t += this.length), e)
    };
  }, {
    "inherits": "Bm0n",
    "../base/reporter": "BhoU",
    "safer-buffer": "rE8J"
  }],
  "kZXB": [function(require, module, exports) {
    "use strict";
    const e = require("../base/reporter").Reporter,
      t = require("../base/buffer").EncoderBuffer,
      n = require("../base/buffer").DecoderBuffer,
      i = require("minimalistic-assert"),
      o = ["seq", "seqof", "set", "setof", "objid", "bool", "gentime", "utctime", "null_", "enum", "int", "objDesc", "bitstr", "bmpstr", "charstr", "genstr", "graphstr", "ia5str", "iso646str", "numstr", "octstr", "printstr", "t61str", "unistr", "utf8str", "videostr"],
      r = ["key", "obj", "use", "optional", "explicit", "implicit", "def", "choice", "any", "contains"].concat(o),
      s = ["_peekTag", "_decodeTag", "_use", "_decodeStr", "_decodeObjid", "_decodeTime", "_decodeNull", "_decodeInt", "_decodeBool", "_decodeList", "_encodeComposite", "_encodeStr", "_encodeObjid", "_encodeTime", "_encodeNull", "_encodeInt", "_encodeBool"];

    function c(e, t, n) {
      const i = {};
      this._baseState = i, i.name = n, i.enc = e, i.parent = t || null, i.children = null, i.tag = null, i.args = null, i.reverseArgs = null, i.choice = null, i.optional = !1, i.any = !1, i.obj = !1, i.use = null, i.useDecoder = null, i.key = null, i.default = null, i.explicit = null, i.implicit = null, i.contains = null, i.parent || (i.children = [], this._wrap())
    }
    module.exports = c;
    const l = ["enc", "parent", "children", "tag", "args", "reverseArgs", "choice", "optional", "any", "obj", "use", "alteredUse", "key", "default", "explicit", "implicit", "contains"];
    c.prototype.clone = function() {
      const e = this._baseState,
        t = {};
      l.forEach(function(n) {
        t[n] = e[n]
      });
      const n = new this.constructor(t.parent);
      return n._baseState = t, n
    }, c.prototype._wrap = function() {
      const e = this._baseState;
      r.forEach(function(t) {
        this[t] = function() {
          const n = new this.constructor(this);
          return e.children.push(n), n[t].apply(n, arguments)
        }
      }, this)
    }, c.prototype._init = function(e) {
      const t = this._baseState;
      i(null === t.parent), e.call(this), t.children = t.children.filter(function(e) {
        return e._baseState.parent === this
      }, this), i.equal(t.children.length, 1, "Root node can have only one child")
    }, c.prototype._useArgs = function(e) {
      const t = this._baseState,
        n = e.filter(function(e) {
          return e instanceof this.constructor
        }, this);
      e = e.filter(function(e) {
        return !(e instanceof this.constructor)
      }, this), 0 !== n.length && (i(null === t.children), t.children = n, n.forEach(function(e) {
        e._baseState.parent = this
      }, this)), 0 !== e.length && (i(null === t.args), t.args = e, t.reverseArgs = e.map(function(e) {
        if ("object" != typeof e || e.constructor !== Object) return e;
        const t = {};
        return Object.keys(e).forEach(function(n) {
          n == (0 | n) && (n |= 0);
          const i = e[n];
          t[i] = n
        }), t
      }))
    }, s.forEach(function(e) {
      c.prototype[e] = function() {
        const t = this._baseState;
        throw new Error(e + " not implemented for encoding: " + t.enc)
      }
    }), o.forEach(function(e) {
      c.prototype[e] = function() {
        const t = this._baseState,
          n = Array.prototype.slice.call(arguments);
        return i(null === t.tag), t.tag = e, this._useArgs(n), this
      }
    }), c.prototype.use = function(e) {
      i(e);
      const t = this._baseState;
      return i(null === t.use), t.use = e, this
    }, c.prototype.optional = function() {
      return this._baseState.optional = !0, this
    }, c.prototype.def = function(e) {
      const t = this._baseState;
      return i(null === t.default), t.default = e, t.optional = !0, this
    }, c.prototype.explicit = function(e) {
      const t = this._baseState;
      return i(null === t.explicit && null === t.implicit), t.explicit = e, this
    }, c.prototype.implicit = function(e) {
      const t = this._baseState;
      return i(null === t.explicit && null === t.implicit), t.implicit = e, this
    }, c.prototype.obj = function() {
      const e = this._baseState,
        t = Array.prototype.slice.call(arguments);
      return e.obj = !0, 0 !== t.length && this._useArgs(t), this
    }, c.prototype.key = function(e) {
      const t = this._baseState;
      return i(null === t.key), t.key = e, this
    }, c.prototype.any = function() {
      return this._baseState.any = !0, this
    }, c.prototype.choice = function(e) {
      const t = this._baseState;
      return i(null === t.choice), t.choice = e, this._useArgs(Object.keys(e).map(function(t) {
        return e[t]
      })), this
    }, c.prototype.contains = function(e) {
      const t = this._baseState;
      return i(null === t.use), t.contains = e, this
    }, c.prototype._decode = function(e, t) {
      const i = this._baseState;
      if (null === i.parent) return e.wrapResult(i.children[0]._decode(e, t));
      let o, r = i.default,
        s = !0,
        c = null;
      if (null !== i.key && (c = e.enterKey(i.key)), i.optional) {
        let n = null;
        if (null !== i.explicit ? n = i.explicit : null !== i.implicit ? n = i.implicit : null !== i.tag && (n = i.tag), null !== n || i.any) {
          if (s = this._peekTag(e, n, i.any), e.isError(s)) return s
        } else {
          const n = e.save();
          try {
            null === i.choice ? this._decodeGeneric(i.tag, e, t) : this._decodeChoice(e, t), s = !0
          } catch (l) {
            s = !1
          }
          e.restore(n)
        }
      }
      if (i.obj && s && (o = e.enterObject()), s) {
        if (null !== i.explicit) {
          const t = this._decodeTag(e, i.explicit);
          if (e.isError(t)) return t;
          e = t
        }
        const o = e.offset;
        if (null === i.use && null === i.choice) {
          let t;
          i.any && (t = e.save());
          const n = this._decodeTag(e, null !== i.implicit ? i.implicit : i.tag, i.any);
          if (e.isError(n)) return n;
          i.any ? r = e.raw(t) : e = n
        }
        if (t && t.track && null !== i.tag && t.track(e.path(), o, e.length, "tagged"), t && t.track && null !== i.tag && t.track(e.path(), e.offset, e.length, "content"), i.any || (r = null === i.choice ? this._decodeGeneric(i.tag, e, t) : this._decodeChoice(e, t)), e.isError(r)) return r;
        if (i.any || null !== i.choice || null === i.children || i.children.forEach(function(n) {
            n._decode(e, t)
          }), i.contains && ("octstr" === i.tag || "bitstr" === i.tag)) {
          const o = new n(r);
          r = this._getUse(i.contains, e._reporterState.obj)._decode(o, t)
        }
      }
      return i.obj && s && (r = e.leaveObject(o)), null === i.key || null === r && !0 !== s ? null !== c && e.exitKey(c) : e.leaveKey(c, i.key, r), r
    }, c.prototype._decodeGeneric = function(e, t, n) {
      const i = this._baseState;
      return "seq" === e || "set" === e ? null : "seqof" === e || "setof" === e ? this._decodeList(t, e, i.args[0], n) : /str$/.test(e) ? this._decodeStr(t, e, n) : "objid" === e && i.args ? this._decodeObjid(t, i.args[0], i.args[1], n) : "objid" === e ? this._decodeObjid(t, null, null, n) : "gentime" === e || "utctime" === e ? this._decodeTime(t, e, n) : "null_" === e ? this._decodeNull(t, n) : "bool" === e ? this._decodeBool(t, n) : "objDesc" === e ? this._decodeStr(t, e, n) : "int" === e || "enum" === e ? this._decodeInt(t, i.args && i.args[0], n) : null !== i.use ? this._getUse(i.use, t._reporterState.obj)._decode(t, n) : t.error("unknown tag: " + e)
    }, c.prototype._getUse = function(e, t) {
      const n = this._baseState;
      return n.useDecoder = this._use(e, t), i(null === n.useDecoder._baseState.parent), n.useDecoder = n.useDecoder._baseState.children[0], n.implicit !== n.useDecoder._baseState.implicit && (n.useDecoder = n.useDecoder.clone(), n.useDecoder._baseState.implicit = n.implicit), n.useDecoder
    }, c.prototype._decodeChoice = function(e, t) {
      const n = this._baseState;
      let i = null,
        o = !1;
      return Object.keys(n.choice).some(function(r) {
        const s = e.save(),
          c = n.choice[r];
        try {
          const n = c._decode(e, t);
          if (e.isError(n)) return !1;
          i = {
            type: r,
            value: n
          }, o = !0
        } catch (l) {
          return e.restore(s), !1
        }
        return !0
      }, this), o ? i : e.error("Choice not matched")
    }, c.prototype._createEncoderBuffer = function(e) {
      return new t(e, this.reporter)
    }, c.prototype._encode = function(e, t, n) {
      const i = this._baseState;
      if (null !== i.default && i.default === e) return;
      const o = this._encodeValue(e, t, n);
      return void 0 === o || this._skipDefault(o, t, n) ? void 0 : o
    }, c.prototype._encodeValue = function(t, n, i) {
      const o = this._baseState;
      if (null === o.parent) return o.children[0]._encode(t, n || new e);
      let r = null;
      if (this.reporter = n, o.optional && void 0 === t) {
        if (null === o.default) return;
        t = o.default
      }
      let s = null,
        c = !1;
      if (o.any) r = this._createEncoderBuffer(t);
      else if (o.choice) r = this._encodeChoice(t, n);
      else if (o.contains) s = this._getUse(o.contains, i)._encode(t, n), c = !0;
      else if (o.children) s = o.children.map(function(e) {
        if ("null_" === e._baseState.tag) return e._encode(null, n, t);
        if (null === e._baseState.key) return n.error("Child should have a key");
        const i = n.enterKey(e._baseState.key);
        if ("object" != typeof t) return n.error("Child expected, but input is not object");
        const o = e._encode(t[e._baseState.key], n, t);
        return n.leaveKey(i), o
      }, this).filter(function(e) {
        return e
      }), s = this._createEncoderBuffer(s);
      else if ("seqof" === o.tag || "setof" === o.tag) {
        if (!o.args || 1 !== o.args.length) return n.error("Too many args for : " + o.tag);
        if (!Array.isArray(t)) return n.error("seqof/setof, but data is not Array");
        const e = this.clone();
        e._baseState.implicit = null, s = this._createEncoderBuffer(t.map(function(e) {
          const i = this._baseState;
          return this._getUse(i.args[0], t)._encode(e, n)
        }, e))
      } else null !== o.use ? r = this._getUse(o.use, i)._encode(t, n) : (s = this._encodePrimitive(o.tag, t), c = !0);
      if (!o.any && null === o.choice) {
        const e = null !== o.implicit ? o.implicit : o.tag,
          t = null === o.implicit ? "universal" : "context";
        null === e ? null === o.use && n.error("Tag could be omitted only for .use()") : null === o.use && (r = this._encodeComposite(e, c, t, s))
      }
      return null !== o.explicit && (r = this._encodeComposite(o.explicit, !1, "context", r)), r
    }, c.prototype._encodeChoice = function(e, t) {
      const n = this._baseState,
        o = n.choice[e.type];
      return o || i(!1, e.type + " not found in " + JSON.stringify(Object.keys(n.choice))), o._encode(e.value, t)
    }, c.prototype._encodePrimitive = function(e, t) {
      const n = this._baseState;
      if (/str$/.test(e)) return this._encodeStr(t, e);
      if ("objid" === e && n.args) return this._encodeObjid(t, n.reverseArgs[0], n.args[1]);
      if ("objid" === e) return this._encodeObjid(t, null, null);
      if ("gentime" === e || "utctime" === e) return this._encodeTime(t, e);
      if ("null_" === e) return this._encodeNull();
      if ("int" === e || "enum" === e) return this._encodeInt(t, n.args && n.reverseArgs[0]);
      if ("bool" === e) return this._encodeBool(t);
      if ("objDesc" === e) return this._encodeStr(t, e);
      throw new Error("Unsupported tag: " + e)
    }, c.prototype._isNumstr = function(e) {
      return /^[0-9 ]*$/.test(e)
    }, c.prototype._isPrintstr = function(e) {
      return /^[A-Za-z0-9 '()+,-./:=?]*$/.test(e)
    };
  }, {
    "../base/reporter": "BhoU",
    "../base/buffer": "JJX4",
    "minimalistic-assert": "MpuC"
  }],
  "psPF": [function(require, module, exports) {
    "use strict";

    function t(t) {
      const s = {};
      return Object.keys(t).forEach(function(e) {
        (0 | e) == e && (e |= 0);
        const r = t[e];
        s[r] = e
      }), s
    }
    exports.tagClass = {
      0: "universal",
      1: "application",
      2: "context",
      3: "private"
    }, exports.tagClassByName = t(exports.tagClass), exports.tag = {
      0: "end",
      1: "bool",
      2: "int",
      3: "bitstr",
      4: "octstr",
      5: "null_",
      6: "objid",
      7: "objDesc",
      8: "external",
      9: "real",
      10: "enum",
      11: "embed",
      12: "utf8str",
      13: "relativeOid",
      16: "seq",
      17: "set",
      18: "numstr",
      19: "printstr",
      20: "t61str",
      21: "videostr",
      22: "ia5str",
      23: "utctime",
      24: "gentime",
      25: "graphstr",
      26: "iso646str",
      27: "genstr",
      28: "unistr",
      29: "charstr",
      30: "bmpstr"
    }, exports.tagByName = t(exports.tag);
  }, {}],
  "adTp": [function(require, module, exports) {

    "use strict";
    const e = require("inherits"),
      t = require("safer-buffer").Buffer,
      r = require("../base/node"),
      n = require("../constants/der");

    function o(e) {
      this.enc = "der", this.name = e.name, this.entity = e, this.tree = new i, this.tree._init(e.body)
    }

    function i(e) {
      r.call(this, "der", e)
    }

    function s(e) {
      return e < 10 ? "0" + e : e
    }

    function f(e, t, r, o) {
      let i;
      if ("seqof" === e ? e = "seq" : "setof" === e && (e = "set"), n.tagByName.hasOwnProperty(e)) i = n.tagByName[e];
      else {
        if ("number" != typeof e || (0 | e) !== e) return o.error("Unknown tag: " + e);
        i = e
      }
      return i >= 31 ? o.error("Multi-octet tag encoding unsupported") : (t || (i |= 32), i |= n.tagClassByName[r || "universal"] << 6)
    }
    module.exports = o, o.prototype.encode = function(e, t) {
      return this.tree._encode(e, t).join()
    }, e(i, r), i.prototype._encodeComposite = function(e, r, n, o) {
      const i = f(e, r, n, this.reporter);
      if (o.length < 128) {
        const e = t.alloc(2);
        return e[0] = i, e[1] = o.length, this._createEncoderBuffer([e, o])
      }
      let s = 1;
      for (let t = o.length; t >= 256; t >>= 8) s++;
      const u = t.alloc(2 + s);
      u[0] = i, u[1] = 128 | s;
      for (let t = 1 + s, f = o.length; f > 0; t--, f >>= 8) u[t] = 255 & f;
      return this._createEncoderBuffer([u, o])
    }, i.prototype._encodeStr = function(e, r) {
      if ("bitstr" === r) return this._createEncoderBuffer([0 | e.unused, e.data]);
      if ("bmpstr" === r) {
        const r = t.alloc(2 * e.length);
        for (let t = 0; t < e.length; t++) r.writeUInt16BE(e.charCodeAt(t), 2 * t);
        return this._createEncoderBuffer(r)
      }
      return "numstr" === r ? this._isNumstr(e) ? this._createEncoderBuffer(e) : this.reporter.error("Encoding of string type: numstr supports only digits and space") : "printstr" === r ? this._isPrintstr(e) ? this._createEncoderBuffer(e) : this.reporter.error("Encoding of string type: printstr supports only latin upper and lower case letters, digits, space, apostrophe, left and rigth parenthesis, plus sign, comma, hyphen, dot, slash, colon, equal sign, question mark") : /str$/.test(r) ? this._createEncoderBuffer(e) : "objDesc" === r ? this._createEncoderBuffer(e) : this.reporter.error("Encoding of string type: " + r + " unsupported")
    }, i.prototype._encodeObjid = function(e, r, n) {
      if ("string" == typeof e) {
        if (!r) return this.reporter.error("string objid given, but no values map found");
        if (!r.hasOwnProperty(e)) return this.reporter.error("objid not found in values map");
        e = r[e].split(/[\s.]+/g);
        for (let t = 0; t < e.length; t++) e[t] |= 0
      } else if (Array.isArray(e)) {
        e = e.slice();
        for (let t = 0; t < e.length; t++) e[t] |= 0
      }
      if (!Array.isArray(e)) return this.reporter.error("objid() should be either array or string, got: " + JSON.stringify(e));
      if (!n) {
        if (e[1] >= 40) return this.reporter.error("Second objid identifier OOB");
        e.splice(0, 2, 40 * e[0] + e[1])
      }
      let o = 0;
      for (let t = 0; t < e.length; t++) {
        let r = e[t];
        for (o++; r >= 128; r >>= 7) o++
      }
      const i = t.alloc(o);
      let s = i.length - 1;
      for (let t = e.length - 1; t >= 0; t--) {
        let r = e[t];
        for (i[s--] = 127 & r;
          (r >>= 7) > 0;) i[s--] = 128 | 127 & r
      }
      return this._createEncoderBuffer(i)
    }, i.prototype._encodeTime = function(e, t) {
      let r;
      const n = new Date(e);
      return "gentime" === t ? r = [s(n.getUTCFullYear()), s(n.getUTCMonth() + 1), s(n.getUTCDate()), s(n.getUTCHours()), s(n.getUTCMinutes()), s(n.getUTCSeconds()), "Z"].join("") : "utctime" === t ? r = [s(n.getUTCFullYear() % 100), s(n.getUTCMonth() + 1), s(n.getUTCDate()), s(n.getUTCHours()), s(n.getUTCMinutes()), s(n.getUTCSeconds()), "Z"].join("") : this.reporter.error("Encoding " + t + " time is not supported yet"), this._encodeStr(r, "octstr")
    }, i.prototype._encodeNull = function() {
      return this._createEncoderBuffer("")
    }, i.prototype._encodeInt = function(e, r) {
      if ("string" == typeof e) {
        if (!r) return this.reporter.error("String int or enum given, but no values map");
        if (!r.hasOwnProperty(e)) return this.reporter.error("Values map doesn't contain: " + JSON.stringify(e));
        e = r[e]
      }
      if ("number" != typeof e && !t.isBuffer(e)) {
        const r = e.toArray();
        !e.sign && 128 & r[0] && r.unshift(0), e = t.from(r)
      }
      if (t.isBuffer(e)) {
        let r = e.length;
        0 === e.length && r++;
        const n = t.alloc(r);
        return e.copy(n), 0 === e.length && (n[0] = 0), this._createEncoderBuffer(n)
      }
      if (e < 128) return this._createEncoderBuffer(e);
      if (e < 256) return this._createEncoderBuffer([0, e]);
      let n = 1;
      for (let t = e; t >= 256; t >>= 8) n++;
      const o = new Array(n);
      for (let t = o.length - 1; t >= 0; t--) o[t] = 255 & e, e >>= 8;
      return 128 & o[0] && o.unshift(0), this._createEncoderBuffer(t.from(o))
    }, i.prototype._encodeBool = function(e) {
      return this._createEncoderBuffer(e ? 255 : 0)
    }, i.prototype._use = function(e, t) {
      return "function" == typeof e && (e = e(t)), e._getEncoder("der").tree
    }, i.prototype._skipDefault = function(e, t, r) {
      const n = this._baseState;
      let o;
      if (null === n.default) return !1;
      const i = e.join();
      if (void 0 === n.defaultBuffer && (n.defaultBuffer = this._encodeValue(n.default, t, r).join()), i.length !== n.defaultBuffer.length) return !1;
      for (o = 0; o < i.length; o++)
        if (i[o] !== n.defaultBuffer[o]) return !1;
      return !0
    };
  }, {
    "inherits": "Bm0n",
    "safer-buffer": "rE8J",
    "../base/node": "kZXB",
    "../constants/der": "psPF"
  }],
  "Yqnf": [function(require, module, exports) {
    "use strict";
    const e = require("inherits"),
      t = require("./der");

    function n(e) {
      t.call(this, e), this.enc = "pem"
    }
    e(n, t), module.exports = n, n.prototype.encode = function(e, n) {
      const o = t.prototype.encode.call(this, e).toString("base64"),
        r = ["-----BEGIN " + n.label + "-----"];
      for (let t = 0; t < o.length; t += 64) r.push(o.slice(t, t + 64));
      return r.push("-----END " + n.label + "-----"), r.join("\n")
    };
  }, {
    "inherits": "Bm0n",
    "./der": "adTp"
  }],
  "YGCS": [function(require, module, exports) {
    "use strict";
    const e = exports;
    e.der = require("./der"), e.pem = require("./pem");
  }, {
    "./der": "adTp",
    "./pem": "Yqnf"
  }],
  "Hd0I": [function(require, module, exports) {
    "use strict";
    const t = require("inherits"),
      r = require("bn.js"),
      e = require("../base/buffer").DecoderBuffer,
      i = require("../base/node"),
      o = require("../constants/der");

    function n(t) {
      this.enc = "der", this.name = t.name, this.entity = t, this.tree = new s, this.tree._init(t.body)
    }

    function s(t) {
      i.call(this, "der", t)
    }

    function c(t, r) {
      let e = t.readUInt8(r);
      if (t.isError(e)) return e;
      const i = o.tagClass[e >> 6],
        n = 0 == (32 & e);
      if (31 == (31 & e)) {
        let i = e;
        for (e = 0; 128 == (128 & i);) {
          if (i = t.readUInt8(r), t.isError(i)) return i;
          e <<= 7, e |= 127 & i
        }
      } else e &= 31;
      return {
        cls: i,
        primitive: n,
        tag: e,
        tagStr: o.tag[e]
      }
    }

    function u(t, r, e) {
      let i = t.readUInt8(e);
      if (t.isError(i)) return i;
      if (!r && 128 === i) return null;
      if (0 == (128 & i)) return i;
      const o = 127 & i;
      if (o > 4) return t.error("length octect is too long");
      i = 0;
      for (let n = 0; n < o; n++) {
        i <<= 8;
        const r = t.readUInt8(e);
        if (t.isError(r)) return r;
        i |= r
      }
      return i
    }
    module.exports = n, n.prototype.decode = function(t, r) {
      return e.isDecoderBuffer(t) || (t = new e(t, r)), this.tree._decode(t, r)
    }, t(s, i), s.prototype._peekTag = function(t, r, e) {
      if (t.isEmpty()) return !1;
      const i = t.save(),
        o = c(t, 'Failed to peek tag: "' + r + '"');
      return t.isError(o) ? o : (t.restore(i), o.tag === r || o.tagStr === r || o.tagStr + "of" === r || e)
    }, s.prototype._decodeTag = function(t, r, e) {
      const i = c(t, 'Failed to decode tag of "' + r + '"');
      if (t.isError(i)) return i;
      let o = u(t, i.primitive, 'Failed to get length of "' + r + '"');
      if (t.isError(o)) return o;
      if (!e && i.tag !== r && i.tagStr !== r && i.tagStr + "of" !== r) return t.error('Failed to match tag: "' + r + '"');
      if (i.primitive || null !== o) return t.skip(o, 'Failed to match body of: "' + r + '"');
      const n = t.save(),
        s = this._skipUntilEnd(t, 'Failed to skip indefinite length body: "' + this.tag + '"');
      return t.isError(s) ? s : (o = t.offset - n.offset, t.restore(n), t.skip(o, 'Failed to match body of: "' + r + '"'))
    }, s.prototype._skipUntilEnd = function(t, r) {
      for (;;) {
        const e = c(t, r);
        if (t.isError(e)) return e;
        const i = u(t, e.primitive, r);
        if (t.isError(i)) return i;
        let o;
        if (o = e.primitive || null !== i ? t.skip(i) : this._skipUntilEnd(t, r), t.isError(o)) return o;
        if ("end" === e.tagStr) break
      }
    }, s.prototype._decodeList = function(t, r, e, i) {
      const o = [];
      for (; !t.isEmpty();) {
        const r = this._peekTag(t, "end");
        if (t.isError(r)) return r;
        const n = e.decode(t, "der", i);
        if (t.isError(n) && r) break;
        o.push(n)
      }
      return o
    }, s.prototype._decodeStr = function(t, r) {
      if ("bitstr" === r) {
        const r = t.readUInt8();
        return t.isError(r) ? r : {
          unused: r,
          data: t.raw()
        }
      }
      if ("bmpstr" === r) {
        const r = t.raw();
        if (r.length % 2 == 1) return t.error("Decoding of string type: bmpstr length mismatch");
        let e = "";
        for (let t = 0; t < r.length / 2; t++) e += String.fromCharCode(r.readUInt16BE(2 * t));
        return e
      }
      if ("numstr" === r) {
        const r = t.raw().toString("ascii");
        return this._isNumstr(r) ? r : t.error("Decoding of string type: numstr unsupported characters")
      }
      if ("octstr" === r) return t.raw();
      if ("objDesc" === r) return t.raw();
      if ("printstr" === r) {
        const r = t.raw().toString("ascii");
        return this._isPrintstr(r) ? r : t.error("Decoding of string type: printstr unsupported characters")
      }
      return /str$/.test(r) ? t.raw().toString() : t.error("Decoding of string type: " + r + " unsupported")
    }, s.prototype._decodeObjid = function(t, r, e) {
      let i;
      const o = [];
      let n = 0,
        s = 0;
      for (; !t.isEmpty();) n <<= 7, n |= 127 & (s = t.readUInt8()), 0 == (128 & s) && (o.push(n), n = 0);
      128 & s && o.push(n);
      const c = o[0] / 40 | 0,
        u = o[0] % 40;
      if (i = e ? o : [c, u].concat(o.slice(1)), r) {
        let t = r[i.join(" ")];
        void 0 === t && (t = r[i.join(".")]), void 0 !== t && (i = t)
      }
      return i
    }, s.prototype._decodeTime = function(t, r) {
      const e = t.raw().toString();
      let i, o, n, s, c, u;
      if ("gentime" === r) i = 0 | e.slice(0, 4), o = 0 | e.slice(4, 6), n = 0 | e.slice(6, 8), s = 0 | e.slice(8, 10), c = 0 | e.slice(10, 12), u = 0 | e.slice(12, 14);
      else {
        if ("utctime" !== r) return t.error("Decoding " + r + " time is not supported yet");
        i = 0 | e.slice(0, 2), o = 0 | e.slice(2, 4), n = 0 | e.slice(4, 6), s = 0 | e.slice(6, 8), c = 0 | e.slice(8, 10), u = 0 | e.slice(10, 12), i = i < 70 ? 2e3 + i : 1900 + i
      }
      return Date.UTC(i, o - 1, n, s, c, u, 0)
    }, s.prototype._decodeNull = function() {
      return null
    }, s.prototype._decodeBool = function(t) {
      const r = t.readUInt8();
      return t.isError(r) ? r : 0 !== r
    }, s.prototype._decodeInt = function(t, e) {
      const i = t.raw();
      let o = new r(i);
      return e && (o = e[o.toString(10)] || o), o
    }, s.prototype._use = function(t, r) {
      return "function" == typeof t && (t = t(r)), t._getDecoder("der").tree
    };
  }, {
    "inherits": "Bm0n",
    "bn.js": "AGD1",
    "../base/buffer": "JJX4",
    "../base/node": "kZXB",
    "../constants/der": "psPF"
  }],
  "byl7": [function(require, module, exports) {

    "use strict";
    const e = require("inherits"),
      r = require("safer-buffer").Buffer,
      t = require("./der");

    function o(e) {
      t.call(this, e), this.enc = "pem"
    }
    e(o, t), module.exports = o, o.prototype.decode = function(e, o) {
      const i = e.toString().split(/[\r\n]+/g),
        n = o.label.toUpperCase(),
        s = /^-----(BEGIN|END) ([^-]+)-----$/;
      let c = -1,
        f = -1;
      for (let r = 0; r < i.length; r++) {
        const e = i[r].match(s);
        if (null !== e && e[2] === n) {
          if (-1 !== c) {
            if ("END" !== e[1]) break;
            f = r;
            break
          }
          if ("BEGIN" !== e[1]) break;
          c = r
        }
      }
      if (-1 === c || -1 === f) throw new Error("PEM section not found for: " + n);
      const l = i.slice(c + 1, f).join("");
      l.replace(/[^a-z0-9+/=]+/gi, "");
      const a = r.from(l, "base64");
      return t.prototype.decode.call(this, a, o)
    };
  }, {
    "inherits": "Bm0n",
    "safer-buffer": "rE8J",
    "./der": "Hd0I"
  }],
  "Sn5H": [function(require, module, exports) {
    "use strict";
    const e = exports;
    e.der = require("./der"), e.pem = require("./pem");
  }, {
    "./der": "Hd0I",
    "./pem": "byl7"
  }],
  "gOko": [function(require, module, exports) {
    "use strict";
    const e = require("./encoders"),
      t = require("./decoders"),
      r = require("inherits"),
      n = exports;

    function o(e, t) {
      this.name = e, this.body = t, this.decoders = {}, this.encoders = {}
    }
    n.define = function(e, t) {
      return new o(e, t)
    }, o.prototype._createNamed = function(e) {
      const t = this.name;

      function n(e) {
        this._initNamed(e, t)
      }
      return r(n, e), n.prototype._initNamed = function(t, r) {
        e.call(this, t, r)
      }, new n(this)
    }, o.prototype._getDecoder = function(e) {
      return e = e || "der", this.decoders.hasOwnProperty(e) || (this.decoders[e] = this._createNamed(t[e])), this.decoders[e]
    }, o.prototype.decode = function(e, t, r) {
      return this._getDecoder(t).decode(e, r)
    }, o.prototype._getEncoder = function(t) {
      return t = t || "der", this.encoders.hasOwnProperty(t) || (this.encoders[t] = this._createNamed(e[t])), this.encoders[t]
    }, o.prototype.encode = function(e, t, r) {
      return this._getEncoder(t).encode(e, r)
    };
  }, {
    "./encoders": "YGCS",
    "./decoders": "Sn5H",
    "inherits": "Bm0n"
  }],
  "G4cX": [function(require, module, exports) {
    "use strict";
    const e = exports;
    e.Reporter = require("./reporter").Reporter, e.DecoderBuffer = require("./buffer").DecoderBuffer, e.EncoderBuffer = require("./buffer").EncoderBuffer, e.Node = require("./node");
  }, {
    "./reporter": "BhoU",
    "./buffer": "JJX4",
    "./node": "kZXB"
  }],
  "yW9S": [function(require, module, exports) {
    "use strict";
    const e = exports;
    e._reverse = function(e) {
      const r = {};
      return Object.keys(e).forEach(function(t) {
        (0 | t) == t && (t |= 0);
        const c = e[t];
        r[c] = t
      }), r
    }, e.der = require("./der");
  }, {
    "./der": "psPF"
  }],
  "NNmB": [function(require, module, exports) {
    "use strict";
    const e = exports;
    e.bignum = require("bn.js"), e.define = require("./asn1/api").define, e.base = require("./asn1/base"), e.constants = require("./asn1/constants"), e.decoders = require("./asn1/decoders"), e.encoders = require("./asn1/encoders");
  }, {
    "bn.js": "AGD1",
    "./asn1/api": "gOko",
    "./asn1/base": "G4cX",
    "./asn1/constants": "yW9S",
    "./asn1/decoders": "Sn5H",
    "./asn1/encoders": "YGCS"
  }],
  "XsN6": [function(require, module, exports) {
    "use strict";
    var e = require("asn1.js"),
      i = e.define("Time", function() {
        this.choice({
          utcTime: this.utctime(),
          generalTime: this.gentime()
        })
      }),
      t = e.define("AttributeTypeValue", function() {
        this.seq().obj(this.key("type").objid(), this.key("value").any())
      }),
      s = e.define("AlgorithmIdentifier", function() {
        this.seq().obj(this.key("algorithm").objid(), this.key("parameters").optional(), this.key("curve").objid().optional())
      }),
      n = e.define("SubjectPublicKeyInfo", function() {
        this.seq().obj(this.key("algorithm").use(s), this.key("subjectPublicKey").bitstr())
      }),
      o = e.define("RelativeDistinguishedName", function() {
        this.setof(t)
      }),
      u = e.define("RDNSequence", function() {
        this.seqof(o)
      }),
      h = e.define("Name", function() {
        this.choice({
          rdnSequence: this.use(u)
        })
      }),
      c = e.define("Validity", function() {
        this.seq().obj(this.key("notBefore").use(i), this.key("notAfter").use(i))
      }),
      r = e.define("Extension", function() {
        this.seq().obj(this.key("extnID").objid(), this.key("critical").bool().def(!1), this.key("extnValue").octstr())
      }),
      f = e.define("TBSCertificate", function() {
        this.seq().obj(this.key("version").explicit(0).int().optional(), this.key("serialNumber").int(), this.key("signature").use(s), this.key("issuer").use(h), this.key("validity").use(c), this.key("subject").use(h), this.key("subjectPublicKeyInfo").use(n), this.key("issuerUniqueID").implicit(1).bitstr().optional(), this.key("subjectUniqueID").implicit(2).bitstr().optional(), this.key("extensions").explicit(3).seqof(r).optional())
      }),
      y = e.define("X509Certificate", function() {
        this.seq().obj(this.key("tbsCertificate").use(f), this.key("signatureAlgorithm").use(s), this.key("signatureValue").bitstr())
      });
    module.exports = y;
  }, {
    "asn1.js": "NNmB"
  }],
  "hfk5": [function(require, module, exports) {
    "use strict";
    var e = require("asn1.js");
    exports.certificate = require("./certificate");
    var i = e.define("RSAPrivateKey", function() {
      this.seq().obj(this.key("version").int(), this.key("modulus").int(), this.key("publicExponent").int(), this.key("privateExponent").int(), this.key("prime1").int(), this.key("prime2").int(), this.key("exponent1").int(), this.key("exponent2").int(), this.key("coefficient").int())
    });
    exports.RSAPrivateKey = i;
    var t = e.define("RSAPublicKey", function() {
      this.seq().obj(this.key("modulus").int(), this.key("publicExponent").int())
    });
    exports.RSAPublicKey = t;
    var s = e.define("SubjectPublicKeyInfo", function() {
      this.seq().obj(this.key("algorithm").use(n), this.key("subjectPublicKey").bitstr())
    });
    exports.PublicKey = s;
    var n = e.define("AlgorithmIdentifier", function() {
        this.seq().obj(this.key("algorithm").objid(), this.key("none").null_().optional(), this.key("curve").objid().optional(), this.key("params").seq().obj(this.key("p").int(), this.key("q").int(), this.key("g").int()).optional())
      }),
      o = e.define("PrivateKeyInfo", function() {
        this.seq().obj(this.key("version").int(), this.key("algorithm").use(n), this.key("subjectPrivateKey").octstr())
      });
    exports.PrivateKey = o;
    var r = e.define("EncryptedPrivateKeyInfo", function() {
      this.seq().obj(this.key("algorithm").seq().obj(this.key("id").objid(), this.key("decrypt").seq().obj(this.key("kde").seq().obj(this.key("id").objid(), this.key("kdeparams").seq().obj(this.key("salt").octstr(), this.key("iters").int())), this.key("cipher").seq().obj(this.key("algo").objid(), this.key("iv").octstr()))), this.key("subjectPrivateKey").octstr())
    });
    exports.EncryptedPrivateKey = r;
    var y = e.define("DSAPrivateKey", function() {
      this.seq().obj(this.key("version").int(), this.key("p").int(), this.key("q").int(), this.key("g").int(), this.key("pub_key").int(), this.key("priv_key").int())
    });
    exports.DSAPrivateKey = y, exports.DSAparam = e.define("DSAparam", function() {
      this.int()
    });
    var h = e.define("ECPrivateKey", function() {
      this.seq().obj(this.key("version").int(), this.key("privateKey").octstr(), this.key("parameters").optional().explicit(0).use(a), this.key("publicKey").optional().explicit(1).bitstr())
    });
    exports.ECPrivateKey = h;
    var a = e.define("ECParameters", function() {
      this.choice({
        namedCurve: this.objid()
      })
    });
    exports.signature = e.define("signature", function() {
      this.seq().obj(this.key("r").int(), this.key("s").int())
    });
  }, {
    "asn1.js": "NNmB",
    "./certificate": "XsN6"
  }],
  "QyaF": [function(require, module, exports) {
    module.exports = {
      "2.16.840.1.101.3.4.1.1": "aes-128-ecb",
      "2.16.840.1.101.3.4.1.2": "aes-128-cbc",
      "2.16.840.1.101.3.4.1.3": "aes-128-ofb",
      "2.16.840.1.101.3.4.1.4": "aes-128-cfb",
      "2.16.840.1.101.3.4.1.21": "aes-192-ecb",
      "2.16.840.1.101.3.4.1.22": "aes-192-cbc",
      "2.16.840.1.101.3.4.1.23": "aes-192-ofb",
      "2.16.840.1.101.3.4.1.24": "aes-192-cfb",
      "2.16.840.1.101.3.4.1.41": "aes-256-ecb",
      "2.16.840.1.101.3.4.1.42": "aes-256-cbc",
      "2.16.840.1.101.3.4.1.43": "aes-256-ofb",
      "2.16.840.1.101.3.4.1.44": "aes-256-cfb"
    };
  }, {}],
  "PyvQ": [function(require, module, exports) {

    var e = /Proc-Type: 4,ENCRYPTED[\n\r]+DEK-Info: AES-((?:128)|(?:192)|(?:256))-CBC,([0-9A-H]+)[\n\r]+([0-9A-z\n\r+/=]+)[\n\r]+/m,
      r = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----/m,
      a = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----([0-9A-z\n\r+/=]+)-----END \1-----$/m,
      t = require("evp_bytestokey"),
      n = require("browserify-aes"),
      f = require("safe-buffer").Buffer;
    module.exports = function(s, E) {
      var c, o = s.toString(),
        i = o.match(e);
      if (i) {
        var u = "aes" + i[1],
          m = f.from(i[2], "hex"),
          p = f.from(i[3].replace(/[\r\n]/g, ""), "base64"),
          I = t(E, m.slice(0, 8), parseInt(i[1], 10)).key,
          h = [],
          C = n.createDecipheriv(u, I, m);
        h.push(C.update(p)), h.push(C.final()), c = f.concat(h)
      } else {
        var l = o.match(a);
        c = f.from(l[2].replace(/[\r\n]/g, ""), "base64")
      }
      return {
        tag: o.match(r)[1],
        data: c
      }
    };
  }, {
    "evp_bytestokey": "exU6",
    "browserify-aes": "hisC",
    "safe-buffer": "Wugr"
  }],
  "g6E9": [function(require, module, exports) {

    var e = require("./asn1"),
      r = require("./aesid.json"),
      a = require("./fixProc"),
      t = require("browserify-aes"),
      i = require("pbkdf2"),
      c = require("safe-buffer").Buffer;

    function d(r) {
      var t;
      "object" != typeof r || c.isBuffer(r) || (t = r.passphrase, r = r.key), "string" == typeof r && (r = c.from(r));
      var i, d, u = a(r, t),
        o = u.tag,
        n = u.data;
      switch (o) {
        case "CERTIFICATE":
          d = e.certificate.decode(n, "der").tbsCertificate.subjectPublicKeyInfo;
        case "PUBLIC KEY":
          switch (d || (d = e.PublicKey.decode(n, "der")), i = d.algorithm.algorithm.join(".")) {
            case "1.2.840.113549.1.1.1":
              return e.RSAPublicKey.decode(d.subjectPublicKey.data, "der");
            case "1.2.840.10045.2.1":
              return d.subjectPrivateKey = d.subjectPublicKey, {
                type: "ec",
                data: d
              };
            case "1.2.840.10040.4.1":
              return d.algorithm.params.pub_key = e.DSAparam.decode(d.subjectPublicKey.data, "der"), {
                type: "dsa",
                data: d.algorithm.params
              };
            default:
              throw new Error("unknown key id " + i)
          }
          case "ENCRYPTED PRIVATE KEY":
            n = s(n = e.EncryptedPrivateKey.decode(n, "der"), t);
          case "PRIVATE KEY":
            switch (i = (d = e.PrivateKey.decode(n, "der")).algorithm.algorithm.join(".")) {
              case "1.2.840.113549.1.1.1":
                return e.RSAPrivateKey.decode(d.subjectPrivateKey, "der");
              case "1.2.840.10045.2.1":
                return {
                  curve: d.algorithm.curve, privateKey: e.ECPrivateKey.decode(d.subjectPrivateKey, "der").privateKey
                };
              case "1.2.840.10040.4.1":
                return d.algorithm.params.priv_key = e.DSAparam.decode(d.subjectPrivateKey, "der"), {
                  type: "dsa",
                  params: d.algorithm.params
                };
              default:
                throw new Error("unknown key id " + i)
            }
            case "RSA PUBLIC KEY":
              return e.RSAPublicKey.decode(n, "der");
            case "RSA PRIVATE KEY":
              return e.RSAPrivateKey.decode(n, "der");
            case "DSA PRIVATE KEY":
              return {
                type: "dsa", params: e.DSAPrivateKey.decode(n, "der")
              };
            case "EC PRIVATE KEY":
              return {
                curve: (n = e.ECPrivateKey.decode(n, "der")).parameters.value, privateKey: n.privateKey
              };
            default:
              throw new Error("unknown key type " + o)
      }
    }

    function s(e, a) {
      var d = e.algorithm.decrypt.kde.kdeparams.salt,
        s = parseInt(e.algorithm.decrypt.kde.kdeparams.iters.toString(), 10),
        u = r[e.algorithm.decrypt.cipher.algo.join(".")],
        o = e.algorithm.decrypt.cipher.iv,
        n = e.subjectPrivateKey,
        p = parseInt(u.split("-")[1], 10) / 8,
        y = i.pbkdf2Sync(a, d, s, p, "sha1"),
        K = t.createDecipheriv(u, y, o),
        l = [];
      return l.push(K.update(n)), l.push(K.final()), c.concat(l)
    }
    module.exports = d, d.signature = e.signature;
  }, {
    "./asn1": "hfk5",
    "./aesid.json": "QyaF",
    "./fixProc": "PyvQ",
    "browserify-aes": "hisC",
    "pbkdf2": "BKdu",
    "safe-buffer": "Wugr"
  }],
  "lPVM": [function(require, module, exports) {
    module.exports = {
      "1.3.132.0.10": "secp256k1",
      "1.3.132.0.33": "p224",
      "1.2.840.10045.3.1.1": "p192",
      "1.2.840.10045.3.1.7": "p256",
      "1.3.132.0.34": "p384",
      "1.3.132.0.35": "p521"
    };
  }, {}],
  "oj83": [function(require, module, exports) {

    var e = require("safe-buffer").Buffer,
      r = require("create-hmac"),
      t = require("browserify-rsa"),
      n = require("elliptic").ec,
      a = require("bn.js"),
      o = require("parse-asn1"),
      u = require("./curves.json");

    function i(r, n, a, u, i) {
      var p = o(n);
      if (p.curve) {
        if ("ecdsa" !== u && "ecdsa/rsa" !== u) throw new Error("wrong private key type");
        return c(r, p)
      }
      if ("dsa" === p.type) {
        if ("dsa" !== u) throw new Error("wrong private key type");
        return d(r, p, a)
      }
      if ("rsa" !== u && "ecdsa/rsa" !== u) throw new Error("wrong private key type");
      r = e.concat([i, r]);
      for (var f = p.modulus.byteLength(), s = [0, 1]; r.length + s.length + 1 < f;) s.push(255);
      s.push(0);
      for (var l = -1; ++l < r.length;) s.push(r[l]);
      return t(s, p)
    }

    function c(r, t) {
      var a = u[t.curve.join(".")];
      if (!a) throw new Error("unknown curve " + t.curve.join("."));
      var o = new n(a).keyFromPrivate(t.privateKey).sign(r);
      return e.from(o.toDER())
    }

    function d(e, r, t) {
      for (var n, o = r.params.priv_key, u = r.params.p, i = r.params.q, c = r.params.g, d = new a(0), l = s(e, i).mod(i), h = !1, m = f(o, i, e, t); !1 === h;) d = v(c, n = g(i, m, t), u, i), 0 === (h = n.invm(i).imul(l.add(o.mul(d))).mod(i)).cmpn(0) && (h = !1, d = new a(0));
      return p(d, h)
    }

    function p(r, t) {
      r = r.toArray(), t = t.toArray(), 128 & r[0] && (r = [0].concat(r)), 128 & t[0] && (t = [0].concat(t));
      var n = [48, r.length + t.length + 4, 2, r.length];
      return n = n.concat(r, [2, t.length], t), e.from(n)
    }

    function f(t, n, a, o) {
      if ((t = e.from(t.toArray())).length < n.byteLength()) {
        var u = e.alloc(n.byteLength() - t.length);
        t = e.concat([u, t])
      }
      var i = a.length,
        c = l(a, n),
        d = e.alloc(i);
      d.fill(1);
      var p = e.alloc(i);
      return p = r(o, p).update(d).update(e.from([0])).update(t).update(c).digest(), d = r(o, p).update(d).digest(), {
        k: p = r(o, p).update(d).update(e.from([1])).update(t).update(c).digest(),
        v: d = r(o, p).update(d).digest()
      }
    }

    function s(e, r) {
      var t = new a(e),
        n = (e.length << 3) - r.bitLength();
      return n > 0 && t.ishrn(n), t
    }

    function l(r, t) {
      r = (r = s(r, t)).mod(t);
      var n = e.from(r.toArray());
      if (n.length < t.byteLength()) {
        var a = e.alloc(t.byteLength() - n.length);
        n = e.concat([a, n])
      }
      return n
    }

    function g(t, n, a) {
      var o, u;
      do {
        for (o = e.alloc(0); 8 * o.length < t.bitLength();) n.v = r(a, n.k).update(n.v).digest(), o = e.concat([o, n.v]);
        u = s(o, t), n.k = r(a, n.k).update(n.v).update(e.from([0])).digest(), n.v = r(a, n.k).update(n.v).digest()
      } while (-1 !== u.cmp(t));
      return u
    }

    function v(e, r, t, n) {
      return e.toRed(a.mont(t)).redPow(r).fromRed().mod(n)
    }
    module.exports = i, module.exports.getKey = f, module.exports.makeKey = g;
  }, {
    "safe-buffer": "wyv4",
    "create-hmac": "Cx6S",
    "browserify-rsa": "Aukv",
    "elliptic": "xha3",
    "bn.js": "BOxy",
    "parse-asn1": "g6E9",
    "./curves.json": "lPVM"
  }],
  "pXUL": [function(require, module, exports) {

    var r = require("safe-buffer").Buffer,
      e = require("bn.js"),
      n = require("elliptic").ec,
      o = require("parse-asn1"),
      t = require("./curves.json");

    function a(n, t, a, d, f) {
      var c = o(a);
      if ("ec" === c.type) {
        if ("ecdsa" !== d && "ecdsa/rsa" !== d) throw new Error("wrong public key type");
        return u(n, t, c)
      }
      if ("dsa" === c.type) {
        if ("dsa" !== d) throw new Error("wrong public key type");
        return i(n, t, c)
      }
      if ("rsa" !== d && "ecdsa/rsa" !== d) throw new Error("wrong public key type");
      t = r.concat([f, t]);
      for (var s = c.modulus.byteLength(), m = [1], l = 0; t.length + m.length + 2 < s;) m.push(255), l++;
      m.push(0);
      for (var w = -1; ++w < t.length;) m.push(t[w]);
      m = r.from(m);
      var p = e.mont(c.modulus);
      n = (n = new e(n).toRed(p)).redPow(new e(c.publicExponent)), n = r.from(n.fromRed().toArray());
      var h = l < 8 ? 1 : 0;
      for (s = Math.min(n.length, m.length), n.length !== m.length && (h = 1), w = -1; ++w < s;) h |= n[w] ^ m[w];
      return 0 === h
    }

    function u(r, e, o) {
      var a = t[o.data.algorithm.curve.join(".")];
      if (!a) throw new Error("unknown curve " + o.data.algorithm.curve.join("."));
      var u = new n(a),
        i = o.data.subjectPrivateKey.data;
      return u.verify(e, r, i)
    }

    function i(r, n, t) {
      var a = t.data.p,
        u = t.data.q,
        i = t.data.g,
        f = t.data.pub_key,
        c = o.signature.decode(r, "der"),
        s = c.s,
        m = c.r;
      d(s, u), d(m, u);
      var l = e.mont(a),
        w = s.invm(u);
      return 0 === i.toRed(l).redPow(new e(n).mul(w).mod(u)).fromRed().mul(f.toRed(l).redPow(m.mul(w).mod(u)).fromRed()).mod(a).mod(u).cmp(m)
    }

    function d(r, e) {
      if (r.cmpn(0) <= 0) throw new Error("invalid sig");
      if (r.cmp(e) >= e) throw new Error("invalid sig")
    }
    module.exports = a;
  }, {
    "safe-buffer": "wyv4",
    "bn.js": "BOxy",
    "elliptic": "xha3",
    "parse-asn1": "g6E9",
    "./curves.json": "lPVM"
  }],
  "BAbM": [function(require, module, exports) {

    var t = require("safe-buffer").Buffer,
      e = require("create-hash"),
      i = require("readable-stream"),
      r = require("inherits"),
      s = require("./sign"),
      h = require("./verify"),
      n = require("./algorithms.json");

    function a(t) {
      i.Writable.call(this);
      var r = n[t];
      if (!r) throw new Error("Unknown message digest");
      this._hashType = r.hash, this._hash = e(r.hash), this._tag = r.id, this._signType = r.sign
    }

    function o(t) {
      i.Writable.call(this);
      var r = n[t];
      if (!r) throw new Error("Unknown message digest");
      this._hash = e(r.hash), this._tag = r.id, this._signType = r.sign
    }

    function u(t) {
      return new a(t)
    }

    function f(t) {
      return new o(t)
    }
    Object.keys(n).forEach(function(e) {
      n[e].id = t.from(n[e].id, "hex"), n[e.toLowerCase()] = n[e]
    }), r(a, i.Writable), a.prototype._write = function(t, e, i) {
      this._hash.update(t), i()
    }, a.prototype.update = function(e, i) {
      return "string" == typeof e && (e = t.from(e, i)), this._hash.update(e), this
    }, a.prototype.sign = function(t, e) {
      this.end();
      var i = this._hash.digest(),
        r = s(i, t, this._hashType, this._signType, this._tag);
      return e ? r.toString(e) : r
    }, r(o, i.Writable), o.prototype._write = function(t, e, i) {
      this._hash.update(t), i()
    }, o.prototype.update = function(e, i) {
      return "string" == typeof e && (e = t.from(e, i)), this._hash.update(e), this
    }, o.prototype.verify = function(e, i, r) {
      "string" == typeof i && (i = t.from(i, r)), this.end();
      var s = this._hash.digest();
      return h(i, s, e, this._signType, this._tag)
    }, module.exports = {
      Sign: u,
      Verify: f,
      createSign: u,
      createVerify: f
    };
  }, {
    "safe-buffer": "wyv4",
    "create-hash": "LF8r",
    "readable-stream": "TgzV",
    "inherits": "Bm0n",
    "./sign": "oj83",
    "./verify": "pXUL",
    "./algorithms.json": "WoCp"
  }],
  "x3tl": [function(require, module, exports) {
    var Buffer = require("buffer").Buffer;
    var e = require("buffer").Buffer,
      t = require("elliptic"),
      r = require("bn.js");
    module.exports = function(e) {
      return new n(e)
    };
    var i = {
      secp256k1: {
        name: "secp256k1",
        byteLength: 32
      },
      secp224r1: {
        name: "p224",
        byteLength: 28
      },
      prime256v1: {
        name: "p256",
        byteLength: 32
      },
      prime192v1: {
        name: "p192",
        byteLength: 24
      },
      ed25519: {
        name: "ed25519",
        byteLength: 32
      },
      secp384r1: {
        name: "p384",
        byteLength: 48
      },
      secp521r1: {
        name: "p521",
        byteLength: 66
      }
    };

    function n(e) {
      this.curveType = i[e], this.curveType || (this.curveType = {
        name: e
      }), this.curve = new t.ec(this.curveType.name), this.keys = void 0
    }

    function s(t, r, i) {
      Array.isArray(t) || (t = t.toArray());
      var n = new e(t);
      if (i && n.length < i) {
        var s = new e(i - n.length);
        s.fill(0), n = e.concat([s, n])
      }
      return r ? n.toString(r) : n
    }
    i.p224 = i.secp224r1, i.p256 = i.secp256r1 = i.prime256v1, i.p192 = i.secp192r1 = i.prime192v1, i.p384 = i.secp384r1, i.p521 = i.secp521r1, n.prototype.generateKeys = function(e, t) {
      return this.keys = this.curve.genKeyPair(), this.getPublicKey(e, t)
    }, n.prototype.computeSecret = function(t, r, i) {
      return r = r || "utf8", e.isBuffer(t) || (t = new e(t, r)), s(this.curve.keyFromPublic(t).getPublic().mul(this.keys.getPrivate()).getX(), i, this.curveType.byteLength)
    }, n.prototype.getPublicKey = function(e, t) {
      var r = this.keys.getPublic("compressed" === t, !0);
      return "hybrid" === t && (r[r.length - 1] % 2 ? r[0] = 7 : r[0] = 6), s(r, e)
    }, n.prototype.getPrivateKey = function(e) {
      return s(this.keys.getPrivate(), e)
    }, n.prototype.setPublicKey = function(t, r) {
      return r = r || "utf8", e.isBuffer(t) || (t = new e(t, r)), this.keys._importPublic(t), this
    }, n.prototype.setPrivateKey = function(t, i) {
      i = i || "utf8", e.isBuffer(t) || (t = new e(t, i));
      var n = new r(t);
      return n = n.toString(16), this.keys = this.curve.genKeyPair(), this.keys._importPrivate(n), this
    };
  }, {
    "elliptic": "xha3",
    "bn.js": "AGD1",
    "buffer": "dskh"
  }],
  "QJXH": [function(require, module, exports) {

    var e = require("create-hash"),
      r = require("safe-buffer").Buffer;

    function a(e) {
      var a = r.allocUnsafe(4);
      return a.writeUInt32BE(e, 0), a
    }
    module.exports = function(t, u) {
      for (var n, f = r.alloc(0), c = 0; f.length < u;) n = a(c++), f = r.concat([f, e("sha1").update(t).update(n).digest()]);
      return f.slice(0, u)
    };
  }, {
    "create-hash": "LF8r",
    "safe-buffer": "Wugr"
  }],
  "CItV": [function(require, module, exports) {
    module.exports = function(r, e) {
      for (var n = r.length, o = -1; ++o < n;) r[o] ^= e[o];
      return r
    };
  }, {}],
  "kM9E": [function(require, module, exports) {

    var e = require("bn.js"),
      r = require("safe-buffer").Buffer;

    function o(o, u) {
      return r.from(o.toRed(e.mont(u.modulus)).redPow(new e(u.publicExponent)).fromRed().toArray())
    }
    module.exports = o;
  }, {
    "bn.js": "AGD1",
    "safe-buffer": "Wugr"
  }],
  "U4Qp": [function(require, module, exports) {

    var r = require("parse-asn1"),
      e = require("randombytes"),
      o = require("create-hash"),
      n = require("./mgf"),
      a = require("./xor"),
      t = require("bn.js"),
      u = require("./withPublic"),
      l = require("browserify-rsa"),
      i = require("safe-buffer").Buffer;

    function s(r, u) {
      var l = r.modulus.byteLength(),
        s = u.length,
        f = o("sha1").update(i.alloc(0)).digest(),
        c = f.length,
        g = 2 * c;
      if (s > l - g - 2) throw new Error("message too long");
      var d = i.alloc(l - s - g - 2),
        h = l - c - 1,
        w = e(c),
        m = a(i.concat([f, d, i.alloc(1, 1), u], h), n(w, h)),
        q = a(w, n(m, c));
      return new t(i.concat([i.alloc(1), q, m], l))
    }

    function f(r, e, o) {
      var n, a = e.length,
        u = r.modulus.byteLength();
      if (a > u - 11) throw new Error("message too long");
      return n = o ? i.alloc(u - a - 3, 255) : c(u - a - 3), new t(i.concat([i.from([0, o ? 1 : 2]), n, i.alloc(1), e], u))
    }

    function c(r) {
      for (var o, n = i.allocUnsafe(r), a = 0, t = e(2 * r), u = 0; a < r;) u === t.length && (t = e(2 * r), u = 0), (o = t[u++]) && (n[a++] = o);
      return n
    }
    module.exports = function(e, o, n) {
      var a;
      a = e.padding ? e.padding : n ? 1 : 4;
      var i, c = r(e);
      if (4 === a) i = s(c, o);
      else if (1 === a) i = f(c, o, n);
      else {
        if (3 !== a) throw new Error("unknown padding");
        if ((i = new t(o)).cmp(c.modulus) >= 0) throw new Error("data too long for modulus")
      }
      return n ? l(i, c) : u(i, c)
    };
  }, {
    "parse-asn1": "g6E9",
    "randombytes": "XJNj",
    "create-hash": "LF8r",
    "./mgf": "QJXH",
    "./xor": "CItV",
    "bn.js": "AGD1",
    "./withPublic": "kM9E",
    "browserify-rsa": "Aukv",
    "safe-buffer": "Wugr"
  }],
  "mWkL": [function(require, module, exports) {

    var r = require("parse-asn1"),
      e = require("./mgf"),
      n = require("./xor"),
      t = require("bn.js"),
      o = require("browserify-rsa"),
      i = require("create-hash"),
      u = require("./withPublic"),
      a = require("safe-buffer").Buffer;

    function l(r, t) {
      var o = r.modulus.byteLength(),
        u = i("sha1").update(a.alloc(0)).digest(),
        l = u.length;
      if (0 !== t[0]) throw new Error("decryption error");
      var f = t.slice(1, l + 1),
        c = t.slice(l + 1),
        s = n(f, e(c, l)),
        g = n(c, e(s, o - l - 1));
      if (h(u, g.slice(0, l))) throw new Error("decryption error");
      for (var d = l; 0 === g[d];) d++;
      if (1 !== g[d++]) throw new Error("decryption error");
      return g.slice(d)
    }

    function f(r, e, n) {
      for (var t = e.slice(0, 2), o = 2, i = 0; 0 !== e[o++];)
        if (o >= e.length) {
          i++;
          break
        } var u = e.slice(2, o - 1);
      if (("0002" !== t.toString("hex") && !n || "0001" !== t.toString("hex") && n) && i++, u.length < 8 && i++, i) throw new Error("decryption error");
      return e.slice(o)
    }

    function h(r, e) {
      r = a.from(r), e = a.from(e);
      var n = 0,
        t = r.length;
      r.length !== e.length && (n++, t = Math.min(r.length, e.length));
      for (var o = -1; ++o < t;) n += r[o] ^ e[o];
      return n
    }
    module.exports = function(e, n, i) {
      var h;
      h = e.padding ? e.padding : i ? 1 : 4;
      var c, s = r(e),
        g = s.modulus.byteLength();
      if (n.length > g || new t(n).cmp(s.modulus) >= 0) throw new Error("decryption error");
      c = i ? u(new t(n), s) : o(n, s);
      var d = a.alloc(g - c.length);
      if (c = a.concat([d, c], g), 4 === h) return l(s, c);
      if (1 === h) return f(s, c, i);
      if (3 === h) return c;
      throw new Error("unknown padding")
    };
  }, {
    "parse-asn1": "g6E9",
    "./mgf": "QJXH",
    "./xor": "CItV",
    "bn.js": "AGD1",
    "browserify-rsa": "Aukv",
    "create-hash": "LF8r",
    "./withPublic": "kM9E",
    "safe-buffer": "Wugr"
  }],
  "WjUF": [function(require, module, exports) {
    exports.publicEncrypt = require("./publicEncrypt"), exports.privateDecrypt = require("./privateDecrypt"), exports.privateEncrypt = function(r, p) {
      return exports.publicEncrypt(r, p, !0)
    }, exports.publicDecrypt = function(r, p) {
      return exports.privateDecrypt(r, p, !0)
    };
  }, {
    "./publicEncrypt": "U4Qp",
    "./privateDecrypt": "mWkL"
  }],
  "ODza": [function(require, module, exports) {

    var global = arguments[3];
    var process = require("process");
    var r = arguments[3],
      e = require("process");

    function n() {
      throw new Error("secure random number generation not supported by this browser\nuse chrome, FireFox or Internet Explorer 11")
    }
    var t = require("safe-buffer"),
      o = require("randombytes"),
      f = t.Buffer,
      u = t.kMaxLength,
      i = r.crypto || r.msCrypto,
      a = Math.pow(2, 32) - 1;

    function s(r, e) {
      if ("number" != typeof r || r != r) throw new TypeError("offset must be a number");
      if (r > a || r < 0) throw new TypeError("offset must be a uint32");
      if (r > u || r > e) throw new RangeError("offset out of range")
    }

    function m(r, e, n) {
      if ("number" != typeof r || r != r) throw new TypeError("size must be a number");
      if (r > a || r < 0) throw new TypeError("size must be a uint32");
      if (r + e > n || r > u) throw new RangeError("buffer too small")
    }

    function l(e, n, t, o) {
      if (!(f.isBuffer(e) || e instanceof r.Uint8Array)) throw new TypeError('"buf" argument must be a Buffer or Uint8Array');
      if ("function" == typeof n) o = n, n = 0, t = e.length;
      else if ("function" == typeof t) o = t, t = e.length - n;
      else if ("function" != typeof o) throw new TypeError('"cb" argument must be a function');
      return s(n, e.length), m(t, n, e.length), p(e, n, t, o)
    }

    function p(r, n, t, o) {
      var f = r.buffer,
        u = new Uint8Array(f, n, t);
      return i.getRandomValues(u), o ? void e.nextTick(function() {
        o(null, r)
      }) : r
    }

    function w(e, n, t) {
      if (void 0 === n && (n = 0), !(f.isBuffer(e) || e instanceof r.Uint8Array)) throw new TypeError('"buf" argument must be a Buffer or Uint8Array');
      return s(n, e.length), void 0 === t && (t = e.length - n), m(t, n, e.length), p(e, n, t)
    }
    i && i.getRandomValues ? (exports.randomFill = l, exports.randomFillSync = w) : (exports.randomFill = n, exports.randomFillSync = n);
  }, {
    "safe-buffer": "Wugr",
    "randombytes": "XJNj",
    "process": "pBGv"
  }],
  "mRF4": [function(require, module, exports) {
    "use strict";
    exports.randomBytes = exports.rng = exports.pseudoRandomBytes = exports.prng = require("randombytes"), exports.createHash = exports.Hash = require("create-hash"), exports.createHmac = exports.Hmac = require("create-hmac");
    var e = require("browserify-sign/algos"),
      r = Object.keys(e),
      t = ["sha1", "sha224", "sha256", "sha384", "sha512", "md5", "rmd160"].concat(r);
    exports.getHashes = function() {
      return t
    };
    var i = require("pbkdf2");
    exports.pbkdf2 = i.pbkdf2, exports.pbkdf2Sync = i.pbkdf2Sync;
    var p = require("browserify-cipher");
    exports.Cipher = p.Cipher, exports.createCipher = p.createCipher, exports.Cipheriv = p.Cipheriv, exports.createCipheriv = p.createCipheriv, exports.Decipher = p.Decipher, exports.createDecipher = p.createDecipher, exports.Decipheriv = p.Decipheriv, exports.createDecipheriv = p.createDecipheriv, exports.getCiphers = p.getCiphers, exports.listCiphers = p.listCiphers;
    var s = require("diffie-hellman");
    exports.DiffieHellmanGroup = s.DiffieHellmanGroup, exports.createDiffieHellmanGroup = s.createDiffieHellmanGroup, exports.getDiffieHellman = s.getDiffieHellman, exports.createDiffieHellman = s.createDiffieHellman, exports.DiffieHellman = s.DiffieHellman;
    var a = require("browserify-sign");
    exports.createSign = a.createSign, exports.Sign = a.Sign, exports.createVerify = a.createVerify, exports.Verify = a.Verify, exports.createECDH = require("create-ecdh");
    var o = require("public-encrypt");
    exports.publicEncrypt = o.publicEncrypt, exports.privateEncrypt = o.privateEncrypt, exports.publicDecrypt = o.publicDecrypt, exports.privateDecrypt = o.privateDecrypt;
    var c = require("randomfill");
    exports.randomFill = c.randomFill, exports.randomFillSync = c.randomFillSync, exports.createCredentials = function() {
      throw new Error(["sorry, createCredentials is not implemented yet", "we accept pull requests", "https://github.com/crypto-browserify/crypto-browserify"].join("\n"))
    }, exports.constants = {
      DH_CHECK_P_NOT_SAFE_PRIME: 2,
      DH_CHECK_P_NOT_PRIME: 1,
      DH_UNABLE_TO_CHECK_GENERATOR: 4,
      DH_NOT_SUITABLE_GENERATOR: 8,
      NPN_ENABLED: 1,
      ALPN_ENABLED: 1,
      RSA_PKCS1_PADDING: 1,
      RSA_SSLV23_PADDING: 2,
      RSA_NO_PADDING: 3,
      RSA_PKCS1_OAEP_PADDING: 4,
      RSA_X931_PADDING: 5,
      RSA_PKCS1_PSS_PADDING: 6,
      POINT_CONVERSION_COMPRESSED: 2,
      POINT_CONVERSION_UNCOMPRESSED: 4,
      POINT_CONVERSION_HYBRID: 6
    };
  }, {
    "randombytes": "XJNj",
    "create-hash": "LF8r",
    "create-hmac": "Cx6S",
    "browserify-sign/algos": "YKr5",
    "pbkdf2": "BKdu",
    "browserify-cipher": "KTbn",
    "diffie-hellman": "WFL2",
    "browserify-sign": "BAbM",
    "create-ecdh": "x3tl",
    "public-encrypt": "WjUF",
    "randomfill": "ODza"
  }],
  "oOWn": [function(require, module, exports) {
    var define;
    var r;
    ! function(t) {
      const n = 2147483647;

      function e(r) {
        const t = new Uint32Array([1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298]);
        let n = 1779033703,
          e = 3144134277,
          o = 1013904242,
          f = 2773480762,
          i = 1359893119,
          u = 2600822924,
          c = 528734635,
          l = 1541459225;
        const s = new Uint32Array(64);

        function a(r) {
          let a = 0,
            p = r.length;
          for (; p >= 64;) {
            let h, y, w, g, m, b = n,
              A = e,
              d = o,
              U = f,
              E = i,
              k = u,
              I = c,
              N = l;
            for (y = 0; y < 16; y++) w = a + 4 * y, s[y] = (255 & r[w]) << 24 | (255 & r[w + 1]) << 16 | (255 & r[w + 2]) << 8 | 255 & r[w + 3];
            for (y = 16; y < 64; y++) g = ((h = s[y - 2]) >>> 17 | h << 15) ^ (h >>> 19 | h << 13) ^ h >>> 10, m = ((h = s[y - 15]) >>> 7 | h << 25) ^ (h >>> 18 | h << 14) ^ h >>> 3, s[y] = (g + s[y - 7] | 0) + (m + s[y - 16] | 0) | 0;
            for (y = 0; y < 64; y++) g = (((E >>> 6 | E << 26) ^ (E >>> 11 | E << 21) ^ (E >>> 25 | E << 7)) + (E & k ^ ~E & I) | 0) + (N + (t[y] + s[y] | 0) | 0) | 0, m = ((b >>> 2 | b << 30) ^ (b >>> 13 | b << 19) ^ (b >>> 22 | b << 10)) + (b & A ^ b & d ^ A & d) | 0, N = I, I = k, k = E, E = U + g | 0, U = d, d = A, A = b, b = g + m | 0;
            n = n + b | 0, e = e + A | 0, o = o + d | 0, f = f + U | 0, i = i + E | 0, u = u + k | 0, c = c + I | 0, l = l + N | 0, a += 64, p -= 64
          }
        }
        a(r);
        let p, h = r.length % 64,
          y = r.length / 536870912 | 0,
          w = r.length << 3,
          g = h < 56 ? 56 : 120,
          m = r.slice(r.length - h, r.length);
        for (m.push(128), p = h + 1; p < g; p++) m.push(0);
        return m.push(y >>> 24 & 255), m.push(y >>> 16 & 255), m.push(y >>> 8 & 255), m.push(y >>> 0 & 255), m.push(w >>> 24 & 255), m.push(w >>> 16 & 255), m.push(w >>> 8 & 255), m.push(w >>> 0 & 255), a(m), [n >>> 24 & 255, n >>> 16 & 255, n >>> 8 & 255, n >>> 0 & 255, e >>> 24 & 255, e >>> 16 & 255, e >>> 8 & 255, e >>> 0 & 255, o >>> 24 & 255, o >>> 16 & 255, o >>> 8 & 255, o >>> 0 & 255, f >>> 24 & 255, f >>> 16 & 255, f >>> 8 & 255, f >>> 0 & 255, i >>> 24 & 255, i >>> 16 & 255, i >>> 8 & 255, i >>> 0 & 255, u >>> 24 & 255, u >>> 16 & 255, u >>> 8 & 255, u >>> 0 & 255, c >>> 24 & 255, c >>> 16 & 255, c >>> 8 & 255, c >>> 0 & 255, l >>> 24 & 255, l >>> 16 & 255, l >>> 8 & 255, l >>> 0 & 255]
      }

      function o(r, t, n) {
        r = r.length <= 64 ? r : e(r);
        const o = 64 + t.length + 4,
          f = new Array(o),
          i = new Array(64);
        let u, c = [];
        for (u = 0; u < 64; u++) f[u] = 54;
        for (u = 0; u < r.length; u++) f[u] ^= r[u];
        for (u = 0; u < t.length; u++) f[64 + u] = t[u];
        for (u = o - 4; u < o; u++) f[u] = 0;
        for (u = 0; u < 64; u++) i[u] = 92;
        for (u = 0; u < r.length; u++) i[u] ^= r[u];

        function l() {
          for (let r = o - 1; r >= o - 4; r--) {
            if (f[r]++, f[r] <= 255) return;
            f[r] = 0
          }
        }
        for (; n >= 32;) l(), c = c.concat(e(i.concat(e(f)))), n -= 32;
        return n > 0 && (l(), c = c.concat(e(i.concat(e(f))).slice(0, n))), c
      }

      function f(r, t, n, e, o) {
        let f;
        for (l(r, 16 * (2 * n - 1), o, 0, 16), f = 0; f < 2 * n; f++) c(r, 16 * f, o, 16), u(o, e), l(o, 0, r, t + 16 * f, 16);
        for (f = 0; f < n; f++) l(r, t + 2 * f * 16, r, 16 * f, 16);
        for (f = 0; f < n; f++) l(r, t + 16 * (2 * f + 1), r, 16 * (f + n), 16)
      }

      function i(r, t) {
        return r << t | r >>> 32 - t
      }

      function u(r, t) {
        l(r, 0, t, 0, 16);
        for (let n = 8; n > 0; n -= 2) t[4] ^= i(t[0] + t[12], 7), t[8] ^= i(t[4] + t[0], 9), t[12] ^= i(t[8] + t[4], 13), t[0] ^= i(t[12] + t[8], 18), t[9] ^= i(t[5] + t[1], 7), t[13] ^= i(t[9] + t[5], 9), t[1] ^= i(t[13] + t[9], 13), t[5] ^= i(t[1] + t[13], 18), t[14] ^= i(t[10] + t[6], 7), t[2] ^= i(t[14] + t[10], 9), t[6] ^= i(t[2] + t[14], 13), t[10] ^= i(t[6] + t[2], 18), t[3] ^= i(t[15] + t[11], 7), t[7] ^= i(t[3] + t[15], 9), t[11] ^= i(t[7] + t[3], 13), t[15] ^= i(t[11] + t[7], 18), t[1] ^= i(t[0] + t[3], 7), t[2] ^= i(t[1] + t[0], 9), t[3] ^= i(t[2] + t[1], 13), t[0] ^= i(t[3] + t[2], 18), t[6] ^= i(t[5] + t[4], 7), t[7] ^= i(t[6] + t[5], 9), t[4] ^= i(t[7] + t[6], 13), t[5] ^= i(t[4] + t[7], 18), t[11] ^= i(t[10] + t[9], 7), t[8] ^= i(t[11] + t[10], 9), t[9] ^= i(t[8] + t[11], 13), t[10] ^= i(t[9] + t[8], 18), t[12] ^= i(t[15] + t[14], 7), t[13] ^= i(t[12] + t[15], 9), t[14] ^= i(t[13] + t[12], 13), t[15] ^= i(t[14] + t[13], 18);
        for (let n = 0; n < 16; ++n) r[n] += t[n]
      }

      function c(r, t, n, e) {
        for (let o = 0; o < e; o++) n[o] ^= r[t + o]
      }

      function l(r, t, n, e, o) {
        for (; o--;) n[e++] = r[t++]
      }

      function s(r) {
        if (!r || "number" != typeof r.length) return !1;
        for (let t = 0; t < r.length; t++) {
          const n = r[t];
          if ("number" != typeof n || n % 1 || n < 0 || n >= 256) return !1
        }
        return !0
      }

      function a(r, t) {
        if ("number" != typeof r || r % 1) throw new Error("invalid " + t);
        return r
      }

      function p(r, t, e, i, u, p, h) {
        if (e = a(e, "N"), i = a(i, "r"), u = a(u, "p"), p = a(p, "dkLen"), 0 === e || 0 != (e & e - 1)) throw new Error("N must be power of 2");
        if (e > n / 128 / i) throw new Error("N too large");
        if (i > n / 128 / u) throw new Error("r too large");
        if (!s(r)) throw new Error("password must be an array or buffer");
        if (r = Array.prototype.slice.call(r), !s(t)) throw new Error("salt must be an array or buffer");
        t = Array.prototype.slice.call(t);
        let y = o(r, t, 128 * u * i);
        const w = new Uint32Array(32 * u * i);
        for (let n = 0; n < w.length; n++) {
          const r = 4 * n;
          w[n] = (255 & y[r + 3]) << 24 | (255 & y[r + 2]) << 16 | (255 & y[r + 1]) << 8 | (255 & y[r + 0]) << 0
        }
        const g = new Uint32Array(64 * i),
          m = new Uint32Array(32 * i * e),
          b = 32 * i,
          A = new Uint32Array(16),
          d = new Uint32Array(16),
          U = u * e * 2;
        let E, k, I = 0,
          N = null,
          v = !1,
          x = 0,
          L = 0;
        const P = h ? parseInt(1e3 / i) : 4294967295,
          S = "undefined" != typeof setImmediate ? setImmediate : setTimeout,
          T = function() {
            if (v) return h(new Error("cancelled"), I / U);
            let t;
            switch (x) {
              case 0:
                l(w, k = 32 * L * i, g, 0, b), x = 1, E = 0;
              case 1:
                (t = e - E) > P && (t = P);
                for (let r = 0; r < t; r++) l(g, 0, m, (E + r) * b, b), f(g, b, i, A, d);
                if (E += t, I += t, h) {
                  const r = parseInt(1e3 * I / U);
                  if (r !== N) {
                    if (v = h(null, I / U)) break;
                    N = r
                  }
                }
                if (E < e) break;
                E = 0, x = 2;
              case 2:
                (t = e - E) > P && (t = P);
                for (let r = 0; r < t; r++) {
                  const r = g[16 * (2 * i - 1)] & e - 1;
                  c(m, r * b, g, b), f(g, b, i, A, d)
                }
                if (E += t, I += t, h) {
                  const r = parseInt(1e3 * I / U);
                  if (r !== N) {
                    if (v = h(null, I / U)) break;
                    N = r
                  }
                }
                if (E < e) break;
                if (l(g, 0, w, k, b), ++L < u) {
                  x = 0;
                  break
                }
                y = [];
                for (let r = 0; r < w.length; r++) y.push(w[r] >> 0 & 255), y.push(w[r] >> 8 & 255), y.push(w[r] >> 16 & 255), y.push(w[r] >> 24 & 255);
                const n = o(r, y, p);
                return h && h(null, 1, n), n
            }
            h && S(T)
          };
        if (!h)
          for (;;) {
            const r = T();
            if (null != r) return r
          }
        T()
      }
      const h = {
        scrypt: function(r, t, n, e, o, f, i) {
          return new Promise(function(u, c) {
            let l = 0;
            i && i(0), p(r, t, n, e, o, f, function(r, t, n) {
              if (r) c(r);
              else if (n) i && 1 !== l && i(1), u(new Uint8Array(n));
              else if (i && t !== l) return l = t, i(t)
            })
          })
        },
        syncScrypt: function(r, t, n, e, o, f) {
          return new Uint8Array(p(r, t, n, e, o, f))
        }
      };
      "undefined" != typeof exports ? module.exports = h : "function" == typeof r && r.amd ? r(h) : t && (t.scrypt && (t._scrypt = t.scrypt), t.scrypt = h)
    }(this);
  }, {}],
  "sqRQ": [function(require, module, exports) {
    var e = "undefined" != typeof crypto && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || "undefined" != typeof msCrypto && "function" == typeof window.msCrypto.getRandomValues && msCrypto.getRandomValues.bind(msCrypto);
    if (e) {
      var o = new Uint8Array(16);
      module.exports = function() {
        return e(o), o
      }
    } else {
      var r = new Array(16);
      module.exports = function() {
        for (var e, o = 0; o < 16; o++) 0 == (3 & o) && (e = 4294967296 * Math.random()), r[o] = e >>> ((3 & o) << 3) & 255;
        return r
      }
    }
  }, {}],
  "h2kI": [function(require, module, exports) {
    for (var r = [], o = 0; o < 256; ++o) r[o] = (o + 256).toString(16).substr(1);

    function t(o, t) {
      var n = t || 0,
        u = r;
      return [u[o[n++]], u[o[n++]], u[o[n++]], u[o[n++]], "-", u[o[n++]], u[o[n++]], "-", u[o[n++]], u[o[n++]], "-", u[o[n++]], u[o[n++]], "-", u[o[n++]], u[o[n++]], u[o[n++]], u[o[n++]], u[o[n++]], u[o[n++]]].join("")
    }
    module.exports = t;
  }, {}],
  "P9SM": [function(require, module, exports) {
    var e, r, o = require("./lib/rng"),
      s = require("./lib/bytesToUuid"),
      i = 0,
      n = 0;

    function c(c, l, u) {
      var v = l && u || 0,
        a = l || [],
        d = (c = c || {}).node || e,
        t = void 0 !== c.clockseq ? c.clockseq : r;
      if (null == d || null == t) {
        var m = o();
        null == d && (d = e = [1 | m[0], m[1], m[2], m[3], m[4], m[5]]), null == t && (t = r = 16383 & (m[6] << 8 | m[7]))
      }
      var q = void 0 !== c.msecs ? c.msecs : (new Date).getTime(),
        f = void 0 !== c.nsecs ? c.nsecs : n + 1,
        b = q - i + (f - n) / 1e4;
      if (b < 0 && void 0 === c.clockseq && (t = t + 1 & 16383), (b < 0 || q > i) && void 0 === c.nsecs && (f = 0), f >= 1e4) throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
      i = q, n = f, r = t;
      var k = (1e4 * (268435455 & (q += 122192928e5)) + f) % 4294967296;
      a[v++] = k >>> 24 & 255, a[v++] = k >>> 16 & 255, a[v++] = k >>> 8 & 255, a[v++] = 255 & k;
      var w = q / 4294967296 * 1e4 & 268435455;
      a[v++] = w >>> 8 & 255, a[v++] = 255 & w, a[v++] = w >>> 24 & 15 | 16, a[v++] = w >>> 16 & 255, a[v++] = t >>> 8 | 128, a[v++] = 255 & t;
      for (var g = 0; g < 6; ++g) a[v + g] = d[g];
      return l || s(a)
    }
    module.exports = c;
  }, {
    "./lib/rng": "sqRQ",
    "./lib/bytesToUuid": "h2kI"
  }],
  "dsMY": [function(require, module, exports) {
    var r = require("./lib/rng"),
      n = require("./lib/bytesToUuid");

    function e(e, i, u) {
      var a = i && u || 0;
      "string" == typeof e && (i = "binary" === e ? new Array(16) : null, e = null);
      var l = (e = e || {}).random || (e.rng || r)();
      if (l[6] = 15 & l[6] | 64, l[8] = 63 & l[8] | 128, i)
        for (var o = 0; o < 16; ++o) i[a + o] = l[o];
      return i || n(l)
    }
    module.exports = e;
  }, {
    "./lib/rng": "sqRQ",
    "./lib/bytesToUuid": "h2kI"
  }],
  "Lvuw": [function(require, module, exports) {
    var e = require("./v1"),
      r = require("./v4"),
      v = r;
    v.v1 = e, v.v4 = r, module.exports = v;
  }, {
    "./v1": "P9SM",
    "./v4": "dsMY"
  }],
  "XrxB": [function(require, module, exports) {
    function e(e, t) {
      var n = "undefined" != typeof Symbol && e[Symbol.iterator] || e["@@iterator"];
      if (!n) {
        if (Array.isArray(e) || (n = r(e)) || t && e && "number" == typeof e.length) {
          n && (e = n);
          var o = 0,
            a = function() {};
          return {
            s: a,
            n: function() {
              return o >= e.length ? {
                done: !0
              } : {
                done: !1,
                value: e[o++]
              }
            },
            e: function(e) {
              throw e
            },
            f: a
          }
        }
        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
      }
      var i, c = !0,
        u = !1;
      return {
        s: function() {
          n = n.call(e)
        },
        n: function() {
          var e = n.next();
          return c = e.done, e
        },
        e: function(e) {
          u = !0, i = e
        },
        f: function() {
          try {
            c || null == n.return || n.return()
          } finally {
            if (u) throw i
          }
        }
      }
    }

    function r(e, r) {
      if (e) {
        if ("string" == typeof e) return t(e, r);
        var n = Object.prototype.toString.call(e).slice(8, -1);
        return "Object" === n && e.constructor && (n = e.constructor.name), "Map" === n || "Set" === n ? Array.from(e) : "Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? t(e, r) : void 0
      }
    }

    function t(e, r) {
      (null == r || r > e.length) && (r = e.length);
      for (var t = 0, n = new Array(r); t < r; t++) n[t] = e[t];
      return n
    }
    var n = {
      IMPOSSIBLE_CASE: "Impossible case. Please create issue.",
      TWEAK_ADD: "The tweak was out of range or the resulted private key is invalid",
      TWEAK_MUL: "The tweak was out of range or equal to zero",
      CONTEXT_RANDOMIZE_UNKNOW: "Unknow error on context randomization",
      SECKEY_INVALID: "Private Key is invalid",
      PUBKEY_PARSE: "Public Key could not be parsed",
      PUBKEY_SERIALIZE: "Public Key serialization error",
      PUBKEY_COMBINE: "The sum of the public keys is not valid",
      SIG_PARSE: "Signature could not be parsed",
      SIGN: "The nonce generation function failed, or the private key was invalid",
      RECOVER: "Public key could not be recover",
      ECDH: "Scalar was invalid (zero or overflow)"
    };

    function o(e, r) {
      if (!e) throw new Error(r)
    }

    function a(e, r, t) {
      if (o(r instanceof Uint8Array, "Expected ".concat(e, " to be an Uint8Array")), void 0 !== t)
        if (Array.isArray(t)) {
          var n = t.join(", "),
            a = "Expected ".concat(e, " to be an Uint8Array with length [").concat(n, "]");
          o(t.includes(r.length), a)
        } else {
          var i = "Expected ".concat(e, " to be an Uint8Array with length ").concat(t);
          o(r.length === t, i)
        }
    }

    function i(e) {
      o("Boolean" === u(e), "Expected compressed to be a Boolean")
    }

    function c() {
      var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : function(e) {
          return new Uint8Array(e)
        },
        r = arguments.length > 1 ? arguments[1] : void 0;
      return "function" == typeof e && (e = e(r)), a("output", e, r), e
    }

    function u(e) {
      return Object.prototype.toString.call(e).slice(8, -1)
    }
    module.exports = function(r) {
      return {
        contextRandomize: function(e) {
          switch (o(null === e || e instanceof Uint8Array, "Expected seed to be an Uint8Array or null"), null !== e && a("seed", e, 32), r.contextRandomize(e)) {
            case 1:
              throw new Error(n.CONTEXT_RANDOMIZE_UNKNOW)
          }
        },
        privateKeyVerify: function(e) {
          return a("private key", e, 32), 0 === r.privateKeyVerify(e)
        },
        privateKeyNegate: function(e) {
          switch (a("private key", e, 32), r.privateKeyNegate(e)) {
            case 0:
              return e;
            case 1:
              throw new Error(n.IMPOSSIBLE_CASE)
          }
        },
        privateKeyTweakAdd: function(e, t) {
          switch (a("private key", e, 32), a("tweak", t, 32), r.privateKeyTweakAdd(e, t)) {
            case 0:
              return e;
            case 1:
              throw new Error(n.TWEAK_ADD)
          }
        },
        privateKeyTweakMul: function(e, t) {
          switch (a("private key", e, 32), a("tweak", t, 32), r.privateKeyTweakMul(e, t)) {
            case 0:
              return e;
            case 1:
              throw new Error(n.TWEAK_MUL)
          }
        },
        publicKeyVerify: function(e) {
          return a("public key", e, [33, 65]), 0 === r.publicKeyVerify(e)
        },
        publicKeyCreate: function(e) {
          var t = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1],
            o = arguments.length > 2 ? arguments[2] : void 0;
          switch (a("private key", e, 32), i(t), o = c(o, t ? 33 : 65), r.publicKeyCreate(o, e)) {
            case 0:
              return o;
            case 1:
              throw new Error(n.SECKEY_INVALID);
            case 2:
              throw new Error(n.PUBKEY_SERIALIZE)
          }
        },
        publicKeyConvert: function(e) {
          var t = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1],
            o = arguments.length > 2 ? arguments[2] : void 0;
          switch (a("public key", e, [33, 65]), i(t), o = c(o, t ? 33 : 65), r.publicKeyConvert(o, e)) {
            case 0:
              return o;
            case 1:
              throw new Error(n.PUBKEY_PARSE);
            case 2:
              throw new Error(n.PUBKEY_SERIALIZE)
          }
        },
        publicKeyNegate: function(e) {
          var t = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1],
            o = arguments.length > 2 ? arguments[2] : void 0;
          switch (a("public key", e, [33, 65]), i(t), o = c(o, t ? 33 : 65), r.publicKeyNegate(o, e)) {
            case 0:
              return o;
            case 1:
              throw new Error(n.PUBKEY_PARSE);
            case 2:
              throw new Error(n.IMPOSSIBLE_CASE);
            case 3:
              throw new Error(n.PUBKEY_SERIALIZE)
          }
        },
        publicKeyCombine: function(t) {
          var u = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1],
            s = arguments.length > 2 ? arguments[2] : void 0;
          o(Array.isArray(t), "Expected public keys to be an Array"), o(t.length > 0, "Expected public keys array will have more than zero items");
          var l, E = e(t);
          try {
            for (E.s(); !(l = E.n()).done;) {
              a("public key", l.value, [33, 65])
            }
          } catch (w) {
            E.e(w)
          } finally {
            E.f()
          }
          switch (i(u), s = c(s, u ? 33 : 65), r.publicKeyCombine(s, t)) {
            case 0:
              return s;
            case 1:
              throw new Error(n.PUBKEY_PARSE);
            case 2:
              throw new Error(n.PUBKEY_COMBINE);
            case 3:
              throw new Error(n.PUBKEY_SERIALIZE)
          }
        },
        publicKeyTweakAdd: function(e, t) {
          var o = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2],
            u = arguments.length > 3 ? arguments[3] : void 0;
          switch (a("public key", e, [33, 65]), a("tweak", t, 32), i(o), u = c(u, o ? 33 : 65), r.publicKeyTweakAdd(u, e, t)) {
            case 0:
              return u;
            case 1:
              throw new Error(n.PUBKEY_PARSE);
            case 2:
              throw new Error(n.TWEAK_ADD)
          }
        },
        publicKeyTweakMul: function(e, t) {
          var o = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2],
            u = arguments.length > 3 ? arguments[3] : void 0;
          switch (a("public key", e, [33, 65]), a("tweak", t, 32), i(o), u = c(u, o ? 33 : 65), r.publicKeyTweakMul(u, e, t)) {
            case 0:
              return u;
            case 1:
              throw new Error(n.PUBKEY_PARSE);
            case 2:
              throw new Error(n.TWEAK_MUL)
          }
        },
        signatureNormalize: function(e) {
          switch (a("signature", e, 64), r.signatureNormalize(e)) {
            case 0:
              return e;
            case 1:
              throw new Error(n.SIG_PARSE)
          }
        },
        signatureExport: function(e, t) {
          a("signature", e, 64);
          var o = {
            output: t = c(t, 72),
            outputlen: 72
          };
          switch (r.signatureExport(o, e)) {
            case 0:
              return t.slice(0, o.outputlen);
            case 1:
              throw new Error(n.SIG_PARSE);
            case 2:
              throw new Error(n.IMPOSSIBLE_CASE)
          }
        },
        signatureImport: function(e, t) {
          switch (a("signature", e), t = c(t, 64), r.signatureImport(t, e)) {
            case 0:
              return t;
            case 1:
              throw new Error(n.SIG_PARSE);
            case 2:
              throw new Error(n.IMPOSSIBLE_CASE)
          }
        },
        ecdsaSign: function(e, t) {
          var i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {},
            s = arguments.length > 3 ? arguments[3] : void 0;
          a("message", e, 32), a("private key", t, 32), o("Object" === u(i), "Expected options to be an Object"), void 0 !== i.data && a("options.data", i.data), void 0 !== i.noncefn && o("Function" === u(i.noncefn), "Expected options.noncefn to be a Function");
          var l = {
            signature: s = c(s, 64),
            recid: null
          };
          switch (r.ecdsaSign(l, e, t, i.data, i.noncefn)) {
            case 0:
              return l;
            case 1:
              throw new Error(n.SIGN);
            case 2:
              throw new Error(n.IMPOSSIBLE_CASE)
          }
        },
        ecdsaVerify: function(e, t, o) {
          switch (a("signature", e, 64), a("message", t, 32), a("public key", o, [33, 65]), r.ecdsaVerify(e, t, o)) {
            case 0:
              return !0;
            case 3:
              return !1;
            case 1:
              throw new Error(n.SIG_PARSE);
            case 2:
              throw new Error(n.PUBKEY_PARSE)
          }
        },
        ecdsaRecover: function(e, t, s) {
          var l = !(arguments.length > 3 && void 0 !== arguments[3]) || arguments[3],
            E = arguments.length > 4 ? arguments[4] : void 0;
          switch (a("signature", e, 64), o("Number" === u(t) && t >= 0 && t <= 3, "Expected recovery id to be a Number within interval [0, 3]"), a("message", s, 32), i(l), E = c(E, l ? 33 : 65), r.ecdsaRecover(E, e, t, s)) {
            case 0:
              return E;
            case 1:
              throw new Error(n.SIG_PARSE);
            case 2:
              throw new Error(n.RECOVER);
            case 3:
              throw new Error(n.IMPOSSIBLE_CASE)
          }
        },
        ecdh: function(e, t) {
          var i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {},
            s = arguments.length > 3 ? arguments[3] : void 0;
          switch (a("public key", e, [33, 65]), a("private key", t, 32), o("Object" === u(i), "Expected options to be an Object"), void 0 !== i.data && a("options.data", i.data), void 0 !== i.hashfn ? (o("Function" === u(i.hashfn), "Expected options.hashfn to be a Function"), void 0 !== i.xbuf && a("options.xbuf", i.xbuf, 32), void 0 !== i.ybuf && a("options.ybuf", i.ybuf, 32), a("output", s)) : s = c(s, 32), r.ecdh(s, e, t, i.data, i.hashfn, i.xbuf, i.ybuf)) {
            case 0:
              return s;
            case 1:
              throw new Error(n.PUBKEY_PARSE);
            case 2:
              throw new Error(n.ECDH)
          }
        }
      }
    };
  }, {}],
  "mh8d": [function(require, module, exports) {
    var r = require("elliptic").ec,
      e = new r("secp256k1"),
      n = e.curve,
      t = n.n.constructor;

    function u(r, u) {
      var i = new t(u);
      if (i.cmp(n.p) >= 0) return null;
      var a = (i = i.toRed(n.red)).redSqr().redIMul(i).redIAdd(n.b).redSqrt();
      return 3 === r !== a.isOdd() && (a = a.redNeg()), e.keyPair({
        pub: {
          x: i,
          y: a
        }
      })
    }

    function i(r, u, i) {
      var a = new t(u),
        c = new t(i);
      if (a.cmp(n.p) >= 0 || c.cmp(n.p) >= 0) return null;
      if (a = a.toRed(n.red), c = c.toRed(n.red), (6 === r || 7 === r) && c.isOdd() !== (7 === r)) return null;
      var l = a.redSqr().redIMul(a);
      return c.redSqr().redISub(l.redIAdd(n.b)).isZero() ? e.keyPair({
        pub: {
          x: a,
          y: c
        }
      }) : null
    }

    function a(r) {
      var e = r[0];
      switch (e) {
        case 2:
        case 3:
          return 33 !== r.length ? null : u(e, r.subarray(1, 33));
        case 4:
        case 6:
        case 7:
          return 65 !== r.length ? null : i(e, r.subarray(1, 33), r.subarray(33, 65));
        default:
          return null
      }
    }

    function c(r, e) {
      for (var n = e.encode(null, 33 === r.length), t = 0; t < r.length; ++t) r[t] = n[t]
    }
    module.exports = {
      contextRandomize: function() {
        return 0
      },
      privateKeyVerify: function(r) {
        var e = new t(r);
        return e.cmp(n.n) < 0 && !e.isZero() ? 0 : 1
      },
      privateKeyNegate: function(r) {
        var e = new t(r),
          u = n.n.sub(e).umod(n.n).toArrayLike(Uint8Array, "be", 32);
        return r.set(u), 0
      },
      privateKeyTweakAdd: function(r, e) {
        var u = new t(e);
        if (u.cmp(n.n) >= 0) return 1;
        if (u.iadd(new t(r)), u.cmp(n.n) >= 0 && u.isub(n.n), u.isZero()) return 1;
        var i = u.toArrayLike(Uint8Array, "be", 32);
        return r.set(i), 0
      },
      privateKeyTweakMul: function(r, e) {
        var u = new t(e);
        if (u.cmp(n.n) >= 0 || u.isZero()) return 1;
        u.imul(new t(r)), u.cmp(n.n) >= 0 && (u = u.umod(n.n));
        var i = u.toArrayLike(Uint8Array, "be", 32);
        return r.set(i), 0
      },
      publicKeyVerify: function(r) {
        return null === a(r) ? 1 : 0
      },
      publicKeyCreate: function(r, u) {
        var i = new t(u);
        return i.cmp(n.n) >= 0 || i.isZero() ? 1 : (c(r, e.keyFromPrivate(u).getPublic()), 0)
      },
      publicKeyConvert: function(r, e) {
        var n = a(e);
        return null === n ? 1 : (c(r, n.getPublic()), 0)
      },
      publicKeyNegate: function(r, e) {
        var n = a(e);
        if (null === n) return 1;
        var t = n.getPublic();
        return t.y = t.y.redNeg(), c(r, t), 0
      },
      publicKeyCombine: function(r, e) {
        for (var n = new Array(e.length), t = 0; t < e.length; ++t)
          if (n[t] = a(e[t]), null === n[t]) return 1;
        for (var u = n[0].getPublic(), i = 1; i < n.length; ++i) u = u.add(n[i].pub);
        return u.isInfinity() ? 2 : (c(r, u), 0)
      },
      publicKeyTweakAdd: function(r, e, u) {
        var i = a(e);
        if (null === i) return 1;
        if ((u = new t(u)).cmp(n.n) >= 0) return 2;
        var l = i.getPublic().add(n.g.mul(u));
        return l.isInfinity() ? 2 : (c(r, l), 0)
      },
      publicKeyTweakMul: function(r, e, u) {
        var i = a(e);
        return null === i ? 1 : (u = new t(u)).cmp(n.n) >= 0 || u.isZero() ? 2 : (c(r, i.getPublic().mul(u)), 0)
      },
      signatureNormalize: function(r) {
        var u = new t(r.subarray(0, 32)),
          i = new t(r.subarray(32, 64));
        return u.cmp(n.n) >= 0 || i.cmp(n.n) >= 0 ? 1 : (1 === i.cmp(e.nh) && r.set(n.n.sub(i).toArrayLike(Uint8Array, "be", 32), 32), 0)
      },
      signatureExport: function(r, e) {
        var u = e.subarray(0, 32),
          i = e.subarray(32, 64);
        if (new t(u).cmp(n.n) >= 0) return 1;
        if (new t(i).cmp(n.n) >= 0) return 1;
        var a = r.output,
          c = a.subarray(4, 37);
        c[0] = 0, c.set(u, 1);
        for (var l = 33, o = 0; l > 1 && 0 === c[o] && !(128 & c[o + 1]); --l, ++o);
        if (128 & (c = c.subarray(o))[0]) return 1;
        if (l > 1 && 0 === c[0] && !(128 & c[1])) return 1;
        var s = a.subarray(39, 72);
        s[0] = 0, s.set(i, 1);
        for (var f = 33, y = 0; f > 1 && 0 === s[y] && !(128 & s[y + 1]); --f, ++y);
        return 128 & (s = s.subarray(y))[0] ? 1 : f > 1 && 0 === s[0] && !(128 & s[1]) ? 1 : (r.outputlen = 6 + l + f, a[0] = 48, a[1] = r.outputlen - 2, a[2] = 2, a[3] = c.length, a.set(c, 4), a[4 + l] = 2, a[5 + l] = s.length, a.set(s, 6 + l), 0)
      },
      signatureImport: function(r, e) {
        if (e.length < 8) return 1;
        if (e.length > 72) return 1;
        if (48 !== e[0]) return 1;
        if (e[1] !== e.length - 2) return 1;
        if (2 !== e[2]) return 1;
        var u = e[3];
        if (0 === u) return 1;
        if (5 + u >= e.length) return 1;
        if (2 !== e[4 + u]) return 1;
        var i = e[5 + u];
        if (0 === i) return 1;
        if (6 + u + i !== e.length) return 1;
        if (128 & e[4]) return 1;
        if (u > 1 && 0 === e[4] && !(128 & e[5])) return 1;
        if (128 & e[u + 6]) return 1;
        if (i > 1 && 0 === e[u + 6] && !(128 & e[u + 7])) return 1;
        var a = e.subarray(4, 4 + u);
        if (33 === a.length && 0 === a[0] && (a = a.subarray(1)), a.length > 32) return 1;
        var c = e.subarray(6 + u);
        if (33 === c.length && 0 === c[0] && (c = c.slice(1)), c.length > 32) throw new Error("S length is too long");
        var l = new t(a);
        l.cmp(n.n) >= 0 && (l = new t(0));
        var o = new t(e.subarray(6 + u));
        return o.cmp(n.n) >= 0 && (o = new t(0)), r.set(l.toArrayLike(Uint8Array, "be", 32), 0), r.set(o.toArrayLike(Uint8Array, "be", 32), 32), 0
      },
      ecdsaSign: function(r, u, i, a, c) {
        if (c) {
          var l = c;
          c = function(r) {
            var e = l(u, i, null, a, r);
            if (!(e instanceof Uint8Array && 32 === e.length)) throw new Error("This is the way");
            return new t(e)
          }
        }
        var o, s = new t(i);
        if (s.cmp(n.n) >= 0 || s.isZero()) return 1;
        try {
          o = e.sign(u, i, {
            canonical: !0,
            k: c,
            pers: a
          })
        } catch (f) {
          return 1
        }
        return r.signature.set(o.r.toArrayLike(Uint8Array, "be", 32), 0), r.signature.set(o.s.toArrayLike(Uint8Array, "be", 32), 32), r.recid = o.recoveryParam, 0
      },
      ecdsaVerify: function(r, u, i) {
        var c = {
            r: r.subarray(0, 32),
            s: r.subarray(32, 64)
          },
          l = new t(c.r),
          o = new t(c.s);
        if (l.cmp(n.n) >= 0 || o.cmp(n.n) >= 0) return 1;
        if (1 === o.cmp(e.nh) || l.isZero() || o.isZero()) return 3;
        var s = a(i);
        if (null === s) return 2;
        var f = s.getPublic();
        return e.verify(u, c, f) ? 0 : 3
      },
      ecdsaRecover: function(r, u, i, a) {
        var l, o = {
            r: u.slice(0, 32),
            s: u.slice(32, 64)
          },
          s = new t(o.r),
          f = new t(o.s);
        if (s.cmp(n.n) >= 0 || f.cmp(n.n) >= 0) return 1;
        if (s.isZero() || f.isZero()) return 2;
        try {
          l = e.recoverPubKey(a, o, i)
        } catch (y) {
          return 2
        }
        return c(r, l), 0
      },
      ecdh: function(r, u, i, c, l, o, s) {
        var f = a(u);
        if (null === f) return 1;
        var y = new t(i);
        if (y.cmp(n.n) >= 0 || y.isZero()) return 2;
        var v = f.getPublic().mul(y);
        if (void 0 === l)
          for (var b = v.encode(null, !0), p = e.hash().update(b).digest(), d = 0; d < 32; ++d) r[d] = p[d];
        else {
          o || (o = new Uint8Array(32));
          for (var g = v.getX().toArray("be", 32), w = 0; w < 32; ++w) o[w] = g[w];
          s || (s = new Uint8Array(32));
          for (var m = v.getY().toArray("be", 32), h = 0; h < 32; ++h) s[h] = m[h];
          var A = l(o, s, c);
          if (!(A instanceof Uint8Array && A.length === r.length)) return 2;
          r.set(A)
        }
        return 0
      }
    };
  }, {
    "elliptic": "xha3"
  }],
  "jO6T": [function(require, module, exports) {
    module.exports = require("./lib")(require("./lib/elliptic"));
  }, {
    "./lib": "XrxB",
    "./lib/elliptic": "mh8d"
  }],
  "yera": [function(require, module, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    var e = require("randombytes");

    function t(t) {
      return new Promise(function(n, r) {
        e(t, function(e, t) {
          e ? r(e) : n(t)
        })
      })
    }

    function n(t) {
      return e(t)
    }
    exports.getRandomBytes = t, exports.getRandomBytesSync = n;
  }, {
    "randombytes": "XJNj"
  }],
  "Q6JH": [function(require, module, exports) {
    "use strict";
    var e = this && this.__awaiter || function(e, t, r, n) {
        return new(r || (r = Promise))(function(o, i) {
          function a(e) {
            try {
              c(n.next(e))
            } catch (t) {
              i(t)
            }
          }

          function u(e) {
            try {
              c(n.throw(e))
            } catch (t) {
              i(t)
            }
          }

          function c(e) {
            var t;
            e.done ? o(e.value) : (t = e.value, t instanceof r ? t : new r(function(e) {
              e(t)
            })).then(a, u)
          }
          c((n = n.apply(e, t || [])).next())
        })
      },
      t = this && this.__generator || function(e, t) {
        var r, n, o, i, a = {
          label: 0,
          sent: function() {
            if (1 & o[0]) throw o[1];
            return o[1]
          },
          trys: [],
          ops: []
        };
        return i = {
          next: u(0),
          throw: u(1),
          return: u(2)
        }, "function" == typeof Symbol && (i[Symbol.iterator] = function() {
          return this
        }), i;

        function u(i) {
          return function(u) {
            return function(i) {
              if (r) throw new TypeError("Generator is already executing.");
              for (; a;) try {
                if (r = 1, n && (o = 2 & i[0] ? n.return : i[0] ? n.throw || ((o = n.return) && o.call(n), 0) : n.next) && !(o = o.call(n, i[1])).done) return o;
                switch (n = 0, o && (i = [2 & i[0], o.value]), i[0]) {
                  case 0:
                  case 1:
                    o = i;
                    break;
                  case 4:
                    return a.label++, {
                      value: i[1],
                      done: !1
                    };
                  case 5:
                    a.label++, n = i[1], i = [0];
                    continue;
                  case 7:
                    i = a.ops.pop(), a.trys.pop();
                    continue;
                  default:
                    if (!(o = (o = a.trys).length > 0 && o[o.length - 1]) && (6 === i[0] || 2 === i[0])) {
                      a = 0;
                      continue
                    }
                    if (3 === i[0] && (!o || i[1] > o[0] && i[1] < o[3])) {
                      a.label = i[1];
                      break
                    }
                    if (6 === i[0] && a.label < o[1]) {
                      a.label = o[1], o = i;
                      break
                    }
                    if (o && a.label < o[2]) {
                      a.label = o[2], a.ops.push(i);
                      break
                    }
                    o[2] && a.ops.pop(), a.trys.pop();
                    continue
                }
                i = t.call(e, a)
              } catch (u) {
                i = [6, u], n = 0
              } finally {
                r = o = 0
              }
              if (5 & i[0]) throw i[1];
              return {
                value: i[0] ? i[1] : void 0,
                done: !0
              }
            }([i, u])
          }
        }
      };

    function r(e) {
      for (var t in e) exports.hasOwnProperty(t) || (exports[t] = e[t])
    }
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    var n = require("secp256k1"),
      o = require("./random"),
      i = 32;

    function a() {
      return e(this, void 0, void 0, function() {
        var e;
        return t(this, function(t) {
          switch (t.label) {
            case 0:
              return [4, o.getRandomBytes(i)];
            case 1:
              return e = t.sent(), n.privateKeyVerify(e) ? [2, e] : [3, 0];
            case 2:
              return [2]
          }
        })
      })
    }

    function u() {
      for (;;) {
        var e = o.getRandomBytesSync(i);
        if (n.privateKeyVerify(e)) return e
      }
    }
    exports.createPrivateKey = a, exports.createPrivateKeySync = u, r(require("secp256k1"));
  }, {
    "secp256k1": "jO6T",
    "./random": "yera"
  }],
  "QgkO": [function(require, module, exports) {
    var Buffer = require("buffer").Buffer;
    var r = require("buffer").Buffer;
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    var e = require("bn.js"),
      o = require("elliptic").ec,
      n = new o("secp256k1"),
      t = n.curve;
    exports.privateKeyExport = function(r, o) {
      void 0 === o && (o = !0);
      var a = new e(r);
      if (a.ucmp(t.n) >= 0) throw new Error("couldn't export to DER format");
      var u = n.g.mul(a);
      return i(u.getX(), u.getY(), o)
    }, exports.privateKeyModInverse = function(o) {
      var n = new e(o);
      if (n.ucmp(t.n) >= 0 || n.isZero()) throw new Error("private key range is invalid");
      return n.invm(t.n).toArrayLike(r, "be", 32)
    }, exports.signatureImport = function(o) {
      var n = new e(o.r);
      n.ucmp(t.n) >= 0 && (n = new e(0));
      var i = new e(o.s);
      return i.ucmp(t.n) >= 0 && (i = new e(0)), r.concat([n.toArrayLike(r, "be", 32), i.toArrayLike(r, "be", 32)])
    }, exports.ecdhUnsafe = function(r, o, a) {
      void 0 === a && (a = !0);
      var u = n.keyFromPublic(r),
        c = new e(o);
      if (c.ucmp(t.n) >= 0 || c.isZero()) throw new Error("scalar was invalid (zero or overflow)");
      var p = u.pub.mul(c);
      return i(p.getX(), p.getY(), a)
    };
    var i = function(e, o, n) {
      var t;
      return n ? ((t = r.alloc(33))[0] = o.isOdd() ? 3 : 2, e.toArrayLike(r, "be", 32).copy(t, 1)) : ((t = r.alloc(65))[0] = 4, e.toArrayLike(r, "be", 32).copy(t, 1), o.toArrayLike(r, "be", 32).copy(t, 33)), t
    };
  }, {
    "bn.js": "AGD1",
    "elliptic": "xha3",
    "buffer": "dskh"
  }],
  "Vypw": [function(require, module, exports) {
    var Buffer = require("buffer").Buffer;
    var r = require("buffer").Buffer;
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    var l = r.from([48, 129, 211, 2, 1, 1, 4, 32, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 160, 129, 133, 48, 129, 130, 2, 1, 1, 48, 44, 6, 7, 42, 134, 72, 206, 61, 1, 1, 2, 33, 0, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 254, 255, 255, 252, 47, 48, 6, 4, 1, 0, 4, 1, 7, 4, 33, 2, 121, 190, 102, 126, 249, 220, 187, 172, 85, 160, 98, 149, 206, 135, 11, 7, 2, 155, 252, 219, 45, 206, 40, 217, 89, 242, 129, 91, 22, 248, 23, 152, 2, 33, 0, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 254, 186, 174, 220, 230, 175, 72, 160, 59, 191, 210, 94, 140, 208, 54, 65, 65, 2, 1, 1, 161, 36, 3, 34, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]),
      n = r.from([48, 130, 1, 19, 2, 1, 1, 4, 32, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 160, 129, 165, 48, 129, 162, 2, 1, 1, 48, 44, 6, 7, 42, 134, 72, 206, 61, 1, 1, 2, 33, 0, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 254, 255, 255, 252, 47, 48, 6, 4, 1, 0, 4, 1, 7, 4, 65, 4, 121, 190, 102, 126, 249, 220, 187, 172, 85, 160, 98, 149, 206, 135, 11, 7, 2, 155, 252, 219, 45, 206, 40, 217, 89, 242, 129, 91, 22, 248, 23, 152, 72, 58, 218, 119, 38, 163, 196, 101, 93, 164, 251, 252, 14, 17, 8, 168, 253, 23, 180, 72, 166, 133, 84, 25, 156, 71, 208, 143, 251, 16, 212, 184, 2, 33, 0, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 254, 186, 174, 220, 230, 175, 72, 160, 59, 191, 210, 94, 140, 208, 54, 65, 65, 2, 1, 1, 161, 68, 3, 66, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);
    exports.privateKeyExport = function(e, u, t) {
      void 0 === t && (t = !0);
      var f = r.from(t ? l : n);
      return e.copy(f, t ? 8 : 9), u.copy(f, t ? 181 : 214), f
    }, exports.privateKeyImport = function(r) {
      var l = r.length,
        n = 0;
      if (l < n + 1 || 48 !== r[n]) return null;
      if (l < (n += 1) + 1 || !(128 & r[n])) return null;
      var e = 127 & r[n];
      if (e < 1 || e > 2) return null;
      if (l < (n += 1) + e) return null;
      var u = r[n + e - 1] | (e > 1 ? r[n + e - 2] << 8 : 0);
      return l < (n += e) + u ? null : l < n + 3 || 2 !== r[n] || 1 !== r[n + 1] || 1 !== r[n + 2] ? null : l < (n += 3) + 2 || 4 !== r[n] || r[n + 1] > 32 || l < n + 2 + r[n + 1] ? null : r.slice(n + 2, n + 2 + r[n + 1])
    }, exports.signatureImportLax = function(l) {
      var n = r.alloc(32, 0),
        e = r.alloc(32, 0),
        u = l.length,
        t = 0;
      if (48 !== l[t++]) return null;
      var f = l[t++];
      if (128 & f && (t += f - 128) > u) return null;
      if (2 !== l[t++]) return null;
      var i = l[t++];
      if (128 & i) {
        if (t + (f = i - 128) > u) return null;
        for (; f > 0 && 0 === l[t]; t += 1, f -= 1);
        for (i = 0; f > 0; t += 1, f -= 1) i = (i << 8) + l[t]
      }
      if (i > u - t) return null;
      var o = t;
      if (t += i, 2 !== l[t++]) return null;
      var a = l[t++];
      if (128 & a) {
        if (t + (f = a - 128) > u) return null;
        for (; f > 0 && 0 === l[t]; t += 1, f -= 1);
        for (a = 0; f > 0; t += 1, f -= 1) a = (a << 8) + l[t]
      }
      if (a > u - t) return null;
      var v = t;
      for (t += a; i > 0 && 0 === l[o]; i -= 1, o += 1);
      if (i > 32) return null;
      var p = l.slice(o, o + i);
      for (p.copy(n, 32 - p.length); a > 0 && 0 === l[v]; a -= 1, v += 1);
      if (a > 32) return null;
      var c = l.slice(v, v + a);
      return c.copy(e, 32 - c.length), {
        r: n,
        s: e
      }
    };
  }, {
    "buffer": "dskh"
  }],
  "EP9j": [function(require, module, exports) {
    var Buffer = require("buffer").Buffer;
    var r = require("buffer").Buffer;
    Object.defineProperty(exports, "__esModule", {
      value: !0
    }), exports.ecdhUnsafe = exports.ecdh = exports.recover = exports.verify = exports.sign = exports.signatureImportLax = exports.signatureImport = exports.signatureExport = exports.signatureNormalize = exports.publicKeyCombine = exports.publicKeyTweakMul = exports.publicKeyTweakAdd = exports.publicKeyVerify = exports.publicKeyConvert = exports.publicKeyCreate = exports.privateKeyTweakMul = exports.privateKeyTweakAdd = exports.privateKeyModInverse = exports.privateKeyNegate = exports.privateKeyImport = exports.privateKeyExport = exports.privateKeyVerify = void 0;
    var e = require("ethereum-cryptography/secp256k1"),
      t = require("./secp256k1v3-lib/index"),
      n = require("./secp256k1v3-lib/der");
    exports.privateKeyVerify = function(r) {
      return 32 === r.length && e.privateKeyVerify(Uint8Array.from(r))
    }, exports.privateKeyExport = function(r, e) {
      if (32 !== r.length) throw new RangeError("private key length is invalid");
      var o = t.privateKeyExport(r, e);
      return n.privateKeyExport(r, o, e)
    }, exports.privateKeyImport = function(r) {
      if (null !== (r = n.privateKeyImport(r)) && 32 === r.length && exports.privateKeyVerify(r)) return r;
      throw new Error("couldn't import from DER format")
    }, exports.privateKeyNegate = function(t) {
      return r.from(e.privateKeyNegate(Uint8Array.from(t)))
    }, exports.privateKeyModInverse = function(e) {
      if (32 !== e.length) throw new Error("private key length is invalid");
      return r.from(t.privateKeyModInverse(Uint8Array.from(e)))
    }, exports.privateKeyTweakAdd = function(t, n) {
      return r.from(e.privateKeyTweakAdd(Uint8Array.from(t), n))
    }, exports.privateKeyTweakMul = function(t, n) {
      return r.from(e.privateKeyTweakMul(Uint8Array.from(t), Uint8Array.from(n)))
    }, exports.publicKeyCreate = function(t, n) {
      return r.from(e.publicKeyCreate(Uint8Array.from(t), n))
    }, exports.publicKeyConvert = function(t, n) {
      return r.from(e.publicKeyConvert(Uint8Array.from(t), n))
    }, exports.publicKeyVerify = function(r) {
      return (33 === r.length || 65 === r.length) && e.publicKeyVerify(Uint8Array.from(r))
    }, exports.publicKeyTweakAdd = function(t, n, o) {
      return r.from(e.publicKeyTweakAdd(Uint8Array.from(t), Uint8Array.from(n), o))
    }, exports.publicKeyTweakMul = function(t, n, o) {
      return r.from(e.publicKeyTweakMul(Uint8Array.from(t), Uint8Array.from(n), o))
    }, exports.publicKeyCombine = function(t, n) {
      var o = [];
      return t.forEach(function(r) {
        o.push(Uint8Array.from(r))
      }), r.from(e.publicKeyCombine(o, n))
    }, exports.signatureNormalize = function(t) {
      return r.from(e.signatureNormalize(Uint8Array.from(t)))
    }, exports.signatureExport = function(t) {
      return r.from(e.signatureExport(Uint8Array.from(t)))
    }, exports.signatureImport = function(t) {
      return r.from(e.signatureImport(Uint8Array.from(t)))
    }, exports.signatureImportLax = function(r) {
      if (0 === r.length) throw new RangeError("signature length is invalid");
      var e = n.signatureImportLax(r);
      if (null === e) throw new Error("couldn't parse DER signature");
      return t.signatureImport(e)
    }, exports.sign = function(t, n, o) {
      if (null === o) throw new TypeError("options should be an Object");
      var i = void 0;
      if (o) {
        if (i = {}, null === o.data) throw new TypeError("options.data should be a Buffer");
        if (o.data) {
          if (32 != o.data.length) throw new RangeError("options.data length is invalid");
          i.data = new Uint8Array(o.data)
        }
        if (null === o.noncefn) throw new TypeError("options.noncefn should be a Function");
        o.noncefn && (i.noncefn = function(e, t, n, i, a) {
          var p = null != n ? r.from(n) : null,
            u = null != i ? r.from(i) : null,
            f = r.from("");
          return o.noncefn && (f = o.noncefn(r.from(e), r.from(t), p, u, a)), new Uint8Array(f)
        })
      }
      var a = e.ecdsaSign(Uint8Array.from(t), Uint8Array.from(n), i);
      return {
        signature: r.from(a.signature),
        recovery: a.recid
      }
    }, exports.verify = function(r, t, n) {
      return e.ecdsaVerify(Uint8Array.from(t), Uint8Array.from(r), n)
    }, exports.recover = function(t, n, o, i) {
      return r.from(e.ecdsaRecover(Uint8Array.from(n), o, Uint8Array.from(t), i))
    }, exports.ecdh = function(t, n) {
      return r.from(e.ecdh(Uint8Array.from(t), Uint8Array.from(n), {}))
    }, exports.ecdhUnsafe = function(e, n, o) {
      if (33 !== e.length && 65 !== e.length) throw new RangeError("public key length is invalid");
      if (32 !== n.length) throw new RangeError("private key length is invalid");
      return r.from(t.ecdhUnsafe(Uint8Array.from(e), Uint8Array.from(n), o))
    };
  }, {
    "ethereum-cryptography/secp256k1": "Q6JH",
    "./secp256k1v3-lib/index": "QgkO",
    "./secp256k1v3-lib/der": "Vypw",
    "buffer": "dskh"
  }],
  "uDCt": [function(require, module, exports) {
    var Buffer = require("buffer").Buffer;
    var r = require("buffer").Buffer;

    function t(r) {
      return (t = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(r) {
        return typeof r
      } : function(r) {
        return r && "function" == typeof Symbol && r.constructor === Symbol && r !== Symbol.prototype ? "symbol" : typeof r
      })(r)
    }
    var e = require("is-hex-prefixed"),
      n = require("strip-hex-prefix");

    function i(r) {
      var e = r;
      if ("string" != typeof e) throw new Error("[ethjs-util] while padding to even, value must be string, is currently " + t(e) + ", while padToEven.");
      return e.length % 2 && (e = "0" + e), e
    }

    function o(r) {
      return "0x" + r.toString(16)
    }

    function u(t) {
      var e = o(t);
      return new r(i(e.slice(2)), "hex")
    }

    function f(e) {
      if ("string" != typeof e) throw new Error("[ethjs-util] while getting binary size, method getBinarySize requires input 'str' to be type String, got '" + t(e) + "'.");
      return r.byteLength(e, "utf8")
    }

    function a(r, e, n) {
      if (!0 !== Array.isArray(r)) throw new Error("[ethjs-util] method arrayContainsArray requires input 'superset' to be an array got type '" + t(r) + "'");
      if (!0 !== Array.isArray(e)) throw new Error("[ethjs-util] method arrayContainsArray requires input 'subset' to be an array got type '" + t(e) + "'");
      return e[Boolean(n) ? "some" : "every"](function(t) {
        return r.indexOf(t) >= 0
      })
    }

    function s(t) {
      return new r(i(n(t).replace(/^0+|0+$/g, "")), "hex").toString("utf8")
    }

    function y(r) {
      var t = "",
        e = 0,
        n = r.length;
      for ("0x" === r.substring(0, 2) && (e = 2); e < n; e += 2) {
        var i = parseInt(r.substr(e, 2), 16);
        t += String.fromCharCode(i)
      }
      return t
    }

    function g(t) {
      return "0x" + i(new r(t, "utf8").toString("hex")).replace(/^0+|0+$/g, "")
    }

    function p(r) {
      for (var t = "", e = 0; e < r.length; e++) {
        var n = r.charCodeAt(e).toString(16);
        t += n.length < 2 ? "0" + n : n
      }
      return "0x" + t
    }

    function h(r, e, n) {
      if (!Array.isArray(r)) throw new Error("[ethjs-util] method getKeys expecting type Array as 'params' input, got '" + t(r) + "'");
      if ("string" != typeof e) throw new Error("[ethjs-util] method getKeys expecting type String for input 'key' got '" + t(e) + "'.");
      for (var i = [], o = 0; o < r.length; o++) {
        var u = r[o][e];
        if (n && !u) u = "";
        else if ("string" != typeof u) throw new Error("invalid abi");
        i.push(u)
      }
      return i
    }

    function l(r, t) {
      return !("string" != typeof r || !r.match(/^0x[0-9A-Fa-f]*$/)) && (!t || r.length === 2 + 2 * t)
    }
    module.exports = {
      arrayContainsArray: a,
      intToBuffer: u,
      getBinarySize: f,
      isHexPrefixed: e,
      stripHexPrefix: n,
      padToEven: i,
      intToHex: o,
      fromAscii: p,
      fromUtf8: g,
      toAscii: y,
      toUtf8: s,
      getKeys: h,
      isHexString: l
    };
  }, {
    "is-hex-prefixed": "xMCX",
    "strip-hex-prefix": "kqPR",
    "buffer": "dskh"
  }],
  "bL3J": [function(require, module, exports) {
    var Buffer = require("buffer").Buffer;
    var r = require("buffer").Buffer;
    Object.defineProperty(exports, "__esModule", {
      value: !0
    }), exports.getLength = exports.decode = exports.encode = void 0;
    var e = require("bn.js");

    function n(e) {
      if (Array.isArray(e)) {
        for (var t = [], o = 0; o < e.length; o++) t.push(n(e[o]));
        var a = r.concat(t);
        return r.concat([i(a.length, 192), a])
      }
      var f = c(e);
      return 1 === f.length && f[0] < 128 ? f : r.concat([i(f.length, 128), f])
    }

    function t(r, e) {
      if ("00" === r.slice(0, 2)) throw new Error("invalid RLP: extra zeros");
      return parseInt(r, e)
    }

    function i(e, n) {
      if (e < 56) return r.from([e + n]);
      var t = s(e),
        i = s(n + 55 + t.length / 2);
      return r.from(i + t, "hex")
    }

    function o(e, n) {
      if (void 0 === n && (n = !1), !e || 0 === e.length) return r.from([]);
      var t = f(c(e));
      if (n) return t;
      if (0 !== t.remainder.length) throw new Error("invalid remainder");
      return t.data
    }

    function a(e) {
      if (!e || 0 === e.length) return r.from([]);
      var n = c(e),
        i = n[0];
      if (i <= 127) return n.length;
      if (i <= 183) return i - 127;
      if (i <= 191) return i - 182;
      if (i <= 247) return i - 191;
      var o = i - 246;
      return o + t(n.slice(1, o).toString("hex"), 16)
    }

    function f(e) {
      var n, i, o, a, u, l = [],
        s = e[0];
      if (s <= 127) return {
        data: e.slice(0, 1),
        remainder: e.slice(1)
      };
      if (s <= 183) {
        if (n = s - 127, o = 128 === s ? r.from([]) : e.slice(1, n), 2 === n && o[0] < 128) throw new Error("invalid rlp encoding: byte must be less 0x80");
        return {
          data: o,
          remainder: e.slice(n)
        }
      }
      if (s <= 191) {
        if (i = s - 182, e.length - 1 < i) throw new Error("invalid RLP: not enough bytes for string length");
        if ((n = t(e.slice(1, i).toString("hex"), 16)) <= 55) throw new Error("invalid RLP: expected string length to be greater than 55");
        if ((o = e.slice(i, n + i)).length < n) throw new Error("invalid RLP: not enough bytes for string");
        return {
          data: o,
          remainder: e.slice(n + i)
        }
      }
      if (s <= 247) {
        for (n = s - 191, a = e.slice(1, n); a.length;) u = f(a), l.push(u.data), a = u.remainder;
        return {
          data: l,
          remainder: e.slice(n)
        }
      }
      var h = (i = s - 246) + (n = t(e.slice(1, i).toString("hex"), 16));
      if (h > e.length) throw new Error("invalid rlp: total length is larger than the data");
      if (0 === (a = e.slice(i, h)).length) throw new Error("invalid rlp, List has a invalid length");
      for (; a.length;) u = f(a), l.push(u.data), a = u.remainder;
      return {
        data: l,
        remainder: e.slice(h)
      }
    }

    function u(r) {
      return "0x" === r.slice(0, 2)
    }

    function l(r) {
      return "string" != typeof r ? r : u(r) ? r.slice(2) : r
    }

    function s(r) {
      if (r < 0) throw new Error("Invalid integer as argument, must be unsigned!");
      var e = r.toString(16);
      return e.length % 2 ? "0" + e : e
    }

    function h(r) {
      return r.length % 2 ? "0" + r : r
    }

    function g(e) {
      var n = s(e);
      return r.from(n, "hex")
    }

    function c(n) {
      if (!r.isBuffer(n)) {
        if ("string" == typeof n) return u(n) ? r.from(h(l(n)), "hex") : r.from(n);
        if ("number" == typeof n || "bigint" == typeof n) return n ? g(n) : r.from([]);
        if (null == n) return r.from([]);
        if (n instanceof Uint8Array) return r.from(n);
        if (e.isBN(n)) return r.from(n.toArray());
        throw new Error("invalid type")
      }
      return n
    }
    exports.encode = n, exports.decode = o, exports.getLength = a;
  }, {
    "bn.js": "AGD1",
    "buffer": "dskh"
  }],
  "le7r": [function(require, module, exports) {
    var Buffer = require("buffer").Buffer;
    var f = require("buffer").Buffer;
    Object.defineProperty(exports, "__esModule", {
      value: !0
    }), exports.KECCAK256_RLP = exports.KECCAK256_RLP_S = exports.KECCAK256_RLP_ARRAY = exports.KECCAK256_RLP_ARRAY_S = exports.KECCAK256_NULL = exports.KECCAK256_NULL_S = exports.TWO_POW256 = exports.MAX_INTEGER = void 0;
    var e = require("bn.js");
    exports.MAX_INTEGER = new e("ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff", 16), exports.TWO_POW256 = new e("10000000000000000000000000000000000000000000000000000000000000000", 16), exports.KECCAK256_NULL_S = "c5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470", exports.KECCAK256_NULL = f.from(exports.KECCAK256_NULL_S, "hex"), exports.KECCAK256_RLP_ARRAY_S = "1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347", exports.KECCAK256_RLP_ARRAY = f.from(exports.KECCAK256_RLP_ARRAY_S, "hex"), exports.KECCAK256_RLP_S = "56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421", exports.KECCAK256_RLP = f.from(exports.KECCAK256_RLP_S, "hex");
  }, {
    "bn.js": "AGD1",
    "buffer": "dskh"
  }],
  "J4Nk": [function(require, module, exports) {
    "use strict";
    var r = Object.getOwnPropertySymbols,
      t = Object.prototype.hasOwnProperty,
      e = Object.prototype.propertyIsEnumerable;

    function n(r) {
      if (null == r) throw new TypeError("Object.assign cannot be called with null or undefined");
      return Object(r)
    }

    function o() {
      try {
        if (!Object.assign) return !1;
        var r = new String("abc");
        if (r[5] = "de", "5" === Object.getOwnPropertyNames(r)[0]) return !1;
        for (var t = {}, e = 0; e < 10; e++) t["_" + String.fromCharCode(e)] = e;
        if ("0123456789" !== Object.getOwnPropertyNames(t).map(function(r) {
            return t[r]
          }).join("")) return !1;
        var n = {};
        return "abcdefghijklmnopqrst".split("").forEach(function(r) {
          n[r] = r
        }), "abcdefghijklmnopqrst" === Object.keys(Object.assign({}, n)).join("")
      } catch (o) {
        return !1
      }
    }
    module.exports = o() ? Object.assign : function(o, c) {
      for (var a, i, s = n(o), f = 1; f < arguments.length; f++) {
        for (var u in a = Object(arguments[f])) t.call(a, u) && (s[u] = a[u]);
        if (r) {
          i = r(a);
          for (var b = 0; b < i.length; b++) e.call(a, i[b]) && (s[i[b]] = a[i[b]])
        }
      }
      return s
    };
  }, {}],
  "XOAc": [function(require, module, exports) {
    var global = arguments[3];
    var process = require("process");
    var e = arguments[3],
      t = require("process"),
      r = /%[sdj%]/g;
    exports.format = function(e) {
      if (!v(e)) {
        for (var t = [], n = 0; n < arguments.length; n++) t.push(i(arguments[n]));
        return t.join(" ")
      }
      n = 1;
      for (var o = arguments, s = o.length, u = String(e).replace(r, function(e) {
          if ("%%" === e) return "%";
          if (n >= s) return e;
          switch (e) {
            case "%s":
              return String(o[n++]);
            case "%d":
              return Number(o[n++]);
            case "%j":
              try {
                return JSON.stringify(o[n++])
              } catch (t) {
                return "[Circular]"
              }
              default:
                return e
          }
        }), c = o[n]; n < s; c = o[++n]) h(c) || !z(c) ? u += " " + c : u += " " + i(c);
      return u
    }, exports.deprecate = function(r, n) {
      if (j(e.process)) return function() {
        return exports.deprecate(r, n).apply(this, arguments)
      };
      if (!0 === t.noDeprecation) return r;
      var o = !1;
      return function() {
        if (!o) {
          if (t.throwDeprecation) throw new Error(n);
          t.traceDeprecation ? console.trace(n) : console.error(n), o = !0
        }
        return r.apply(this, arguments)
      }
    };
    var n, o = {};

    function i(e, t) {
      var r = {
        seen: [],
        stylize: u
      };
      return arguments.length >= 3 && (r.depth = arguments[2]), arguments.length >= 4 && (r.colors = arguments[3]), x(t) ? r.showHidden = t : t && exports._extend(r, t), j(r.showHidden) && (r.showHidden = !1), j(r.depth) && (r.depth = 2), j(r.colors) && (r.colors = !1), j(r.customInspect) && (r.customInspect = !0), r.colors && (r.stylize = s), p(r, e, r.depth)
    }

    function s(e, t) {
      var r = i.styles[t];
      return r ? "[" + i.colors[r][0] + "m" + e + "[" + i.colors[r][1] + "m" : e
    }

    function u(e, t) {
      return e
    }

    function c(e) {
      var t = {};
      return e.forEach(function(e, r) {
        t[e] = !0
      }), t
    }

    function p(e, t, r) {
      if (e.customInspect && t && D(t.inspect) && t.inspect !== exports.inspect && (!t.constructor || t.constructor.prototype !== t)) {
        var n = t.inspect(r, e);
        return v(n) || (n = p(e, n, r)), n
      }
      var o = l(e, t);
      if (o) return o;
      var i = Object.keys(t),
        s = c(i);
      if (e.showHidden && (i = Object.getOwnPropertyNames(t)), E(t) && (i.indexOf("message") >= 0 || i.indexOf("description") >= 0)) return a(t);
      if (0 === i.length) {
        if (D(t)) {
          var u = t.name ? ": " + t.name : "";
          return e.stylize("[Function" + u + "]", "special")
        }
        if (O(t)) return e.stylize(RegExp.prototype.toString.call(t), "regexp");
        if (w(t)) return e.stylize(Date.prototype.toString.call(t), "date");
        if (E(t)) return a(t)
      }
      var x, h = "",
        b = !1,
        m = ["{", "}"];
      (d(t) && (b = !0, m = ["[", "]"]), D(t)) && (h = " [Function" + (t.name ? ": " + t.name : "") + "]");
      return O(t) && (h = " " + RegExp.prototype.toString.call(t)), w(t) && (h = " " + Date.prototype.toUTCString.call(t)), E(t) && (h = " " + a(t)), 0 !== i.length || b && 0 != t.length ? r < 0 ? O(t) ? e.stylize(RegExp.prototype.toString.call(t), "regexp") : e.stylize("[Object]", "special") : (e.seen.push(t), x = b ? f(e, t, r, s, i) : i.map(function(n) {
        return g(e, t, r, s, n, b)
      }), e.seen.pop(), y(x, h, m)) : m[0] + h + m[1]
    }

    function l(e, t) {
      if (j(t)) return e.stylize("undefined", "undefined");
      if (v(t)) {
        var r = "'" + JSON.stringify(t).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
        return e.stylize(r, "string")
      }
      return m(t) ? e.stylize("" + t, "number") : x(t) ? e.stylize("" + t, "boolean") : h(t) ? e.stylize("null", "null") : void 0
    }

    function a(e) {
      return "[" + Error.prototype.toString.call(e) + "]"
    }

    function f(e, t, r, n, o) {
      for (var i = [], s = 0, u = t.length; s < u; ++s) $(t, String(s)) ? i.push(g(e, t, r, n, String(s), !0)) : i.push("");
      return o.forEach(function(o) {
        o.match(/^\d+$/) || i.push(g(e, t, r, n, o, !0))
      }), i
    }

    function g(e, t, r, n, o, i) {
      var s, u, c;
      if ((c = Object.getOwnPropertyDescriptor(t, o) || {
          value: t[o]
        }).get ? u = c.set ? e.stylize("[Getter/Setter]", "special") : e.stylize("[Getter]", "special") : c.set && (u = e.stylize("[Setter]", "special")), $(n, o) || (s = "[" + o + "]"), u || (e.seen.indexOf(c.value) < 0 ? (u = h(r) ? p(e, c.value, null) : p(e, c.value, r - 1)).indexOf("\n") > -1 && (u = i ? u.split("\n").map(function(e) {
          return "  " + e
        }).join("\n").substr(2) : "\n" + u.split("\n").map(function(e) {
          return "   " + e
        }).join("\n")) : u = e.stylize("[Circular]", "special")), j(s)) {
        if (i && o.match(/^\d+$/)) return u;
        (s = JSON.stringify("" + o)).match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/) ? (s = s.substr(1, s.length - 2), s = e.stylize(s, "name")) : (s = s.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'"), s = e.stylize(s, "string"))
      }
      return s + ": " + u
    }

    function y(e, t, r) {
      return e.reduce(function(e, t) {
        return 0, t.indexOf("\n") >= 0 && 0, e + t.replace(/\u001b\[\d\d?m/g, "").length + 1
      }, 0) > 60 ? r[0] + ("" === t ? "" : t + "\n ") + " " + e.join(",\n  ") + " " + r[1] : r[0] + t + " " + e.join(", ") + " " + r[1]
    }

    function d(e) {
      return Array.isArray(e)
    }

    function x(e) {
      return "boolean" == typeof e
    }

    function h(e) {
      return null === e
    }

    function b(e) {
      return null == e
    }

    function m(e) {
      return "number" == typeof e
    }

    function v(e) {
      return "string" == typeof e
    }

    function S(e) {
      return "symbol" == typeof e
    }

    function j(e) {
      return void 0 === e
    }

    function O(e) {
      return z(e) && "[object RegExp]" === A(e)
    }

    function z(e) {
      return "object" == typeof e && null !== e
    }

    function w(e) {
      return z(e) && "[object Date]" === A(e)
    }

    function E(e) {
      return z(e) && ("[object Error]" === A(e) || e instanceof Error)
    }

    function D(e) {
      return "function" == typeof e
    }

    function N(e) {
      return null === e || "boolean" == typeof e || "number" == typeof e || "string" == typeof e || "symbol" == typeof e || void 0 === e
    }

    function A(e) {
      return Object.prototype.toString.call(e)
    }

    function J(e) {
      return e < 10 ? "0" + e.toString(10) : e.toString(10)
    }
    exports.debuglog = function(e) {
      if (j(n) && (n = ""), e = e.toUpperCase(), !o[e])
        if (new RegExp("\\b" + e + "\\b", "i").test(n)) {
          var r = t.pid;
          o[e] = function() {
            var t = exports.format.apply(exports, arguments);
            console.error("%s %d: %s", e, r, t)
          }
        } else o[e] = function() {};
      return o[e]
    }, exports.inspect = i, i.colors = {
      bold: [1, 22],
      italic: [3, 23],
      underline: [4, 24],
      inverse: [7, 27],
      white: [37, 39],
      grey: [90, 39],
      black: [30, 39],
      blue: [34, 39],
      cyan: [36, 39],
      green: [32, 39],
      magenta: [35, 39],
      red: [31, 39],
      yellow: [33, 39]
    }, i.styles = {
      special: "cyan",
      number: "yellow",
      boolean: "yellow",
      undefined: "grey",
      null: "bold",
      string: "green",
      date: "magenta",
      regexp: "red"
    }, exports.isArray = d, exports.isBoolean = x, exports.isNull = h, exports.isNullOrUndefined = b, exports.isNumber = m, exports.isString = v, exports.isSymbol = S, exports.isUndefined = j, exports.isRegExp = O, exports.isObject = z, exports.isDate = w, exports.isError = E, exports.isFunction = D, exports.isPrimitive = N, exports.isBuffer = require("./support/isBuffer");
    var R = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];

    function H() {
      var e = new Date,
        t = [J(e.getHours()), J(e.getMinutes()), J(e.getSeconds())].join(":");
      return [e.getDate(), R[e.getMonth()], t].join(" ")
    }

    function $(e, t) {
      return Object.prototype.hasOwnProperty.call(e, t)
    }
    exports.log = function() {
      console.log("%s - %s", H(), exports.format.apply(exports, arguments))
    }, exports.inherits = require("inherits"), exports._extend = function(e, t) {
      if (!t || !z(t)) return e;
      for (var r = Object.keys(t), n = r.length; n--;) e[r[n]] = t[r[n]];
      return e
    };
  }, {
    "./support/isBuffer": "vexR",
    "inherits": "tcrG",
    "process": "pBGv"
  }],
  "DlZn": [function(require, module, exports) {
    var global = arguments[3];
    var t = arguments[3],
      e = require("object-assign");

    function r(t, e) {
      if (t === e) return 0;
      for (var r = t.length, n = e.length, i = 0, o = Math.min(r, n); i < o; ++i)
        if (t[i] !== e[i]) {
          r = t[i], n = e[i];
          break
        } return r < n ? -1 : n < r ? 1 : 0
    }

    function n(e) {
      return t.Buffer && "function" == typeof t.Buffer.isBuffer ? t.Buffer.isBuffer(e) : !(null == e || !e._isBuffer)
    }
    var i = require("util/"),
      o = Object.prototype.hasOwnProperty,
      u = Array.prototype.slice,
      a = "foo" === function() {}.name;

    function c(t) {
      return Object.prototype.toString.call(t)
    }

    function f(e) {
      return !n(e) && ("function" == typeof t.ArrayBuffer && ("function" == typeof ArrayBuffer.isView ? ArrayBuffer.isView(e) : !!e && (e instanceof DataView || !!(e.buffer && e.buffer instanceof ArrayBuffer))))
    }
    var s = module.exports = q,
      l = /\s*function\s+([^\(\s]*)\s*/;

    function p(t) {
      if (i.isFunction(t)) {
        if (a) return t.name;
        var e = t.toString().match(l);
        return e && e[1]
      }
    }

    function g(t, e) {
      return "string" == typeof t ? t.length < e ? t : t.slice(0, e) : t
    }

    function E(t) {
      if (a || !i.isFunction(t)) return i.inspect(t);
      var e = p(t);
      return "[Function" + (e ? ": " + e : "") + "]"
    }

    function h(t) {
      return g(E(t.actual), 128) + " " + t.operator + " " + g(E(t.expected), 128)
    }

    function y(t, e, r, n, i) {
      throw new s.AssertionError({
        message: r,
        actual: t,
        expected: e,
        operator: n,
        stackStartFunction: i
      })
    }

    function q(t, e) {
      t || y(t, !0, e, "==", s.ok)
    }

    function d(t, e, o, u) {
      if (t === e) return !0;
      if (n(t) && n(e)) return 0 === r(t, e);
      if (i.isDate(t) && i.isDate(e)) return t.getTime() === e.getTime();
      if (i.isRegExp(t) && i.isRegExp(e)) return t.source === e.source && t.global === e.global && t.multiline === e.multiline && t.lastIndex === e.lastIndex && t.ignoreCase === e.ignoreCase;
      if (null !== t && "object" == typeof t || null !== e && "object" == typeof e) {
        if (f(t) && f(e) && c(t) === c(e) && !(t instanceof Float32Array || t instanceof Float64Array)) return 0 === r(new Uint8Array(t.buffer), new Uint8Array(e.buffer));
        if (n(t) !== n(e)) return !1;
        var a = (u = u || {
          actual: [],
          expected: []
        }).actual.indexOf(t);
        return -1 !== a && a === u.expected.indexOf(e) || (u.actual.push(t), u.expected.push(e), b(t, e, o, u))
      }
      return o ? t === e : t == e
    }

    function m(t) {
      return "[object Arguments]" == Object.prototype.toString.call(t)
    }

    function b(t, e, r, n) {
      if (null == t || null == e) return !1;
      if (i.isPrimitive(t) || i.isPrimitive(e)) return t === e;
      if (r && Object.getPrototypeOf(t) !== Object.getPrototypeOf(e)) return !1;
      var o = m(t),
        a = m(e);
      if (o && !a || !o && a) return !1;
      if (o) return d(t = u.call(t), e = u.call(e), r);
      var c, f, s = A(t),
        l = A(e);
      if (s.length !== l.length) return !1;
      for (s.sort(), l.sort(), f = s.length - 1; f >= 0; f--)
        if (s[f] !== l[f]) return !1;
      for (f = s.length - 1; f >= 0; f--)
        if (!d(t[c = s[f]], e[c], r, n)) return !1;
      return !0
    }

    function v(t, e, r) {
      d(t, e, !0) && y(t, e, r, "notDeepStrictEqual", v)
    }

    function x(t, e) {
      if (!t || !e) return !1;
      if ("[object RegExp]" == Object.prototype.toString.call(e)) return e.test(t);
      try {
        if (t instanceof e) return !0
      } catch (r) {}
      return !Error.isPrototypeOf(e) && !0 === e.call({}, t)
    }

    function S(t) {
      var e;
      try {
        t()
      } catch (r) {
        e = r
      }
      return e
    }

    function w(t, e, r, n) {
      var o;
      if ("function" != typeof e) throw new TypeError('"block" argument must be a function');
      "string" == typeof r && (n = r, r = null), o = S(e), n = (r && r.name ? " (" + r.name + ")." : ".") + (n ? " " + n : "."), t && !o && y(o, r, "Missing expected exception" + n);
      var u = "string" == typeof n,
        a = !t && o && !r;
      if ((!t && i.isError(o) && u && x(o, r) || a) && y(o, r, "Got unwanted exception" + n), t && o && r && !x(o, r) || !t && o) throw o
    }

    function O(t, e) {
      t || y(t, !0, e, "==", O)
    }
    s.AssertionError = function(t) {
      this.name = "AssertionError", this.actual = t.actual, this.expected = t.expected, this.operator = t.operator, t.message ? (this.message = t.message, this.generatedMessage = !1) : (this.message = h(this), this.generatedMessage = !0);
      var e = t.stackStartFunction || y;
      if (Error.captureStackTrace) Error.captureStackTrace(this, e);
      else {
        var r = new Error;
        if (r.stack) {
          var n = r.stack,
            i = p(e),
            o = n.indexOf("\n" + i);
          if (o >= 0) {
            var u = n.indexOf("\n", o + 1);
            n = n.substring(u + 1)
          }
          this.stack = n
        }
      }
    }, i.inherits(s.AssertionError, Error), s.fail = y, s.ok = q, s.equal = function(t, e, r) {
      t != e && y(t, e, r, "==", s.equal)
    }, s.notEqual = function(t, e, r) {
      t == e && y(t, e, r, "!=", s.notEqual)
    }, s.deepEqual = function(t, e, r) {
      d(t, e, !1) || y(t, e, r, "deepEqual", s.deepEqual)
    }, s.deepStrictEqual = function(t, e, r) {
      d(t, e, !0) || y(t, e, r, "deepStrictEqual", s.deepStrictEqual)
    }, s.notDeepEqual = function(t, e, r) {
      d(t, e, !1) && y(t, e, r, "notDeepEqual", s.notDeepEqual)
    }, s.notDeepStrictEqual = v, s.strictEqual = function(t, e, r) {
      t !== e && y(t, e, r, "===", s.strictEqual)
    }, s.notStrictEqual = function(t, e, r) {
      t === e && y(t, e, r, "!==", s.notStrictEqual)
    }, s.throws = function(t, e, r) {
      w(!0, t, e, r)
    }, s.doesNotThrow = function(t, e, r) {
      w(!1, t, e, r)
    }, s.ifError = function(t) {
      if (t) throw t
    }, s.strict = e(O, s, {
      equal: s.strictEqual,
      deepEqual: s.deepStrictEqual,
      notEqual: s.notStrictEqual,
      notDeepEqual: s.notDeepStrictEqual
    }), s.strict.strict = s.strict;
    var A = Object.keys || function(t) {
      var e = [];
      for (var r in t) o.call(t, r) && e.push(r);
      return e
    };
  }, {
    "object-assign": "J4Nk",
    "util/": "XOAc"
  }],
  "mLWy": [function(require, module, exports) {
    var Buffer = require("buffer").Buffer;
    var e = require("buffer").Buffer;
    Object.defineProperty(exports, "__esModule", {
      value: !0
    }), exports.baToJSON = exports.addHexPrefix = exports.toUnsigned = exports.fromSigned = exports.bufferToHex = exports.bufferToInt = exports.toBuffer = exports.stripZeros = exports.unpad = exports.setLengthRight = exports.setLength = exports.setLengthLeft = exports.zeros = void 0;
    var r = require("ethjs-util"),
      t = require("bn.js");
    exports.zeros = function(r) {
      return e.allocUnsafe(r).fill(0)
    }, exports.setLengthLeft = function(e, r, t) {
      void 0 === t && (t = !1);
      var o = exports.zeros(r);
      return e = exports.toBuffer(e), t ? e.length < r ? (e.copy(o), o) : e.slice(0, r) : e.length < r ? (e.copy(o, r - e.length), o) : e.slice(-r)
    }, exports.setLength = exports.setLengthLeft, exports.setLengthRight = function(e, r) {
      return exports.setLength(e, r, !0)
    }, exports.unpad = function(e) {
      for (var t = (e = r.stripHexPrefix(e))[0]; e.length > 0 && "0" === t.toString();) t = (e = e.slice(1))[0];
      return e
    }, exports.stripZeros = exports.unpad, exports.toBuffer = function(o) {
      if (!e.isBuffer(o))
        if (Array.isArray(o)) o = e.from(o);
        else if ("string" == typeof o) {
        if (!r.isHexString(o)) throw new Error("Cannot convert string to buffer. toBuffer only supports 0x-prefixed hex strings and this string was given: " + o);
        o = e.from(r.padToEven(r.stripHexPrefix(o)), "hex")
      } else if ("number" == typeof o) o = r.intToBuffer(o);
      else if (null == o) o = e.allocUnsafe(0);
      else if (t.isBN(o)) o = o.toArrayLike(e);
      else {
        if (!o.toArray) throw new Error("invalid type");
        o = e.from(o.toArray())
      }
      return o
    }, exports.bufferToInt = function(e) {
      return new t(exports.toBuffer(e)).toNumber()
    }, exports.bufferToHex = function(e) {
      return "0x" + (e = exports.toBuffer(e)).toString("hex")
    }, exports.fromSigned = function(e) {
      return new t(e).fromTwos(256)
    }, exports.toUnsigned = function(r) {
      return e.from(r.toTwos(256).toArray())
    }, exports.addHexPrefix = function(e) {
      return "string" != typeof e ? e : r.isHexPrefixed(e) ? e : "0x" + e
    }, exports.baToJSON = function(r) {
      if (e.isBuffer(r)) return "0x" + r.toString("hex");
      if (r instanceof Array) {
        for (var t = [], o = 0; o < r.length; o++) t.push(exports.baToJSON(r[o]));
        return t
      }
    };
  }, {
    "ethjs-util": "uDCt",
    "bn.js": "AGD1",
    "buffer": "dskh"
  }],
  "kDZy": [function(require, module, exports) {
    var Buffer = require("buffer").Buffer;
    var e = require("buffer").Buffer;

    function r(r) {
      return function(t) {
        var u = r();
        return u.update(t), e.from(u.digest())
      }
    }
    Object.defineProperty(exports, "__esModule", {
      value: !0
    }), exports.createHashFunction = r;
  }, {
    "buffer": "dskh"
  }],
  "KA5z": [function(require, module, exports) {
    var Buffer = require("buffer").Buffer;
    var t = require("buffer").Buffer;

    function e(t) {
      return (e = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t) {
        return typeof t
      } : function(t) {
        return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
      })(t)
    }

    function r(t, e) {
      if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
    }

    function n(t, e) {
      for (var r = 0; r < e.length; r++) {
        var n = e[r];
        n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(t, n.key, n)
      }
    }

    function i(t, e, r) {
      return e && n(t.prototype, e), r && n(t, r), t
    }

    function o(t, e) {
      if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
      t.prototype = Object.create(e && e.prototype, {
        constructor: {
          value: t,
          writable: !0,
          configurable: !0
        }
      }), e && u(t, e)
    }

    function u(t, e) {
      return (u = Object.setPrototypeOf || function(t, e) {
        return t.__proto__ = e, t
      })(t, e)
    }

    function a(t) {
      var e = c();
      return function() {
        var r, n = l(t);
        if (e) {
          var i = l(this).constructor;
          r = Reflect.construct(n, arguments, i)
        } else r = n.apply(this, arguments);
        return f(this, r)
      }
    }

    function f(t, r) {
      return !r || "object" !== e(r) && "function" != typeof r ? s(t) : r
    }

    function s(t) {
      if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return t
    }

    function c() {
      if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
      if (Reflect.construct.sham) return !1;
      if ("function" == typeof Proxy) return !0;
      try {
        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {})), !0
      } catch (t) {
        return !1
      }
    }

    function l(t) {
      return (l = Object.setPrototypeOf ? Object.getPrototypeOf : function(t) {
        return t.__proto__ || Object.getPrototypeOf(t)
      })(t)
    }
    var h = require("stream"),
      y = h.Transform;
    module.exports = function(e) {
      return function(n) {
        o(f, y);
        var u = a(f);

        function f(t, n, i, o, a) {
          var s;
          return r(this, f), (s = u.call(this, a))._rate = t, s._capacity = n, s._delimitedSuffix = i, s._hashBitLength = o, s._options = a, s._state = new e, s._state.initialize(t, n), s._finalized = !1, s
        }
        return i(f, [{
          key: "_transform",
          value: function(t, e, r) {
            var n = null;
            try {
              this.update(t, e)
            } catch (i) {
              n = i
            }
            r(n)
          }
        }, {
          key: "_flush",
          value: function(t) {
            var e = null;
            try {
              this.push(this.digest())
            } catch (r) {
              e = r
            }
            t(e)
          }
        }, {
          key: "update",
          value: function(e, r) {
            if (!t.isBuffer(e) && "string" != typeof e) throw new TypeError("Data must be a string or a buffer");
            if (this._finalized) throw new Error("Digest already called");
            return t.isBuffer(e) || (e = t.from(e, r)), this._state.absorb(e), this
          }
        }, {
          key: "digest",
          value: function(t) {
            if (this._finalized) throw new Error("Digest already called");
            this._finalized = !0, this._delimitedSuffix && this._state.absorbLastFewBits(this._delimitedSuffix);
            var e = this._state.squeeze(this._hashBitLength / 8);
            return void 0 !== t && (e = e.toString(t)), this._resetState(), e
          }
        }, {
          key: "_resetState",
          value: function() {
            return this._state.initialize(this._rate, this._capacity), this
          }
        }, {
          key: "_clone",
          value: function() {
            var t = new f(this._rate, this._capacity, this._delimitedSuffix, this._hashBitLength, this._options);
            return this._state.copy(t._state), t._finalized = this._finalized, t
          }
        }]), f
      }()
    };
  }, {
    "stream": "fnRj",
    "buffer": "dskh"
  }],
  "VwQj": [function(require, module, exports) {
    var Buffer = require("buffer").Buffer;
    var t = require("buffer").Buffer;

    function e(t) {
      return (e = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t) {
        return typeof t
      } : function(t) {
        return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
      })(t)
    }

    function r(t, e) {
      if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
    }

    function n(t, e) {
      for (var r = 0; r < e.length; r++) {
        var n = e[r];
        n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(t, n.key, n)
      }
    }

    function i(t, e, r) {
      return e && n(t.prototype, e), r && n(t, r), t
    }

    function o(t, e) {
      if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
      t.prototype = Object.create(e && e.prototype, {
        constructor: {
          value: t,
          writable: !0,
          configurable: !0
        }
      }), e && u(t, e)
    }

    function u(t, e) {
      return (u = Object.setPrototypeOf || function(t, e) {
        return t.__proto__ = e, t
      })(t, e)
    }

    function f(t) {
      var e = s();
      return function() {
        var r, n = l(t);
        if (e) {
          var i = l(this).constructor;
          r = Reflect.construct(n, arguments, i)
        } else r = n.apply(this, arguments);
        return a(this, r)
      }
    }

    function a(t, r) {
      return !r || "object" !== e(r) && "function" != typeof r ? c(t) : r
    }

    function c(t) {
      if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return t
    }

    function s() {
      if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
      if (Reflect.construct.sham) return !1;
      if ("function" == typeof Proxy) return !0;
      try {
        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {})), !0
      } catch (t) {
        return !1
      }
    }

    function l(t) {
      return (l = Object.setPrototypeOf ? Object.getPrototypeOf : function(t) {
        return t.__proto__ || Object.getPrototypeOf(t)
      })(t)
    }
    var y = require("stream"),
      p = y.Transform;
    module.exports = function(e) {
      return function(n) {
        o(a, p);
        var u = f(a);

        function a(t, n, i, o) {
          var f;
          return r(this, a), (f = u.call(this, o))._rate = t, f._capacity = n, f._delimitedSuffix = i, f._options = o, f._state = new e, f._state.initialize(t, n), f._finalized = !1, f
        }
        return i(a, [{
          key: "_transform",
          value: function(t, e, r) {
            var n = null;
            try {
              this.update(t, e)
            } catch (i) {
              n = i
            }
            r(n)
          }
        }, {
          key: "_flush",
          value: function() {}
        }, {
          key: "_read",
          value: function(t) {
            this.push(this.squeeze(t))
          }
        }, {
          key: "update",
          value: function(e, r) {
            if (!t.isBuffer(e) && "string" != typeof e) throw new TypeError("Data must be a string or a buffer");
            if (this._finalized) throw new Error("Squeeze already called");
            return t.isBuffer(e) || (e = t.from(e, r)), this._state.absorb(e), this
          }
        }, {
          key: "squeeze",
          value: function(t, e) {
            this._finalized || (this._finalized = !0, this._state.absorbLastFewBits(this._delimitedSuffix));
            var r = this._state.squeeze(t);
            return void 0 !== e && (r = r.toString(e)), r
          }
        }, {
          key: "_resetState",
          value: function() {
            return this._state.initialize(this._rate, this._capacity), this
          }
        }, {
          key: "_clone",
          value: function() {
            var t = new a(this._rate, this._capacity, this._delimitedSuffix, this._options);
            return this._state.copy(t._state), t._finalized = this._finalized, t
          }
        }]), a
      }()
    };
  }, {
    "stream": "fnRj",
    "buffer": "dskh"
  }],
  "nIJC": [function(require, module, exports) {
    var e = require("./keccak"),
      r = require("./shake");
    module.exports = function(n) {
      var a = e(n),
        c = r(n);
      return function(e, r) {
        switch ("string" == typeof e ? e.toLowerCase() : e) {
          case "keccak224":
            return new a(1152, 448, null, 224, r);
          case "keccak256":
            return new a(1088, 512, null, 256, r);
          case "keccak384":
            return new a(832, 768, null, 384, r);
          case "keccak512":
            return new a(576, 1024, null, 512, r);
          case "sha3-224":
            return new a(1152, 448, 6, 224, r);
          case "sha3-256":
            return new a(1088, 512, 6, 256, r);
          case "sha3-384":
            return new a(832, 768, 6, 384, r);
          case "sha3-512":
            return new a(576, 1024, 6, 512, r);
          case "shake128":
            return new c(1344, 256, 31, r);
          case "shake256":
            return new c(1088, 512, 31, r);
          default:
            throw new Error("Invald algorithm: " + e)
        }
      }
    };
  }, {
    "./keccak": "KA5z",
    "./shake": "VwQj"
  }],
  "Z7Uk": [function(require, module, exports) {
    var r = [1, 0, 32898, 0, 32906, 2147483648, 2147516416, 2147483648, 32907, 0, 2147483649, 0, 2147516545, 2147483648, 32777, 2147483648, 138, 0, 136, 0, 2147516425, 0, 2147483658, 0, 2147516555, 0, 139, 2147483648, 32905, 2147483648, 32771, 2147483648, 32770, 2147483648, 128, 2147483648, 32778, 0, 2147483658, 2147483648, 2147516545, 2147483648, 32896, 2147483648, 2147483649, 0, 2147516424, 2147483648];
    exports.p1600 = function(a) {
      for (var v = 0; v < 24; ++v) {
        var o = a[0] ^ a[10] ^ a[20] ^ a[30] ^ a[40],
          f = a[1] ^ a[11] ^ a[21] ^ a[31] ^ a[41],
          n = a[2] ^ a[12] ^ a[22] ^ a[32] ^ a[42],
          p = a[3] ^ a[13] ^ a[23] ^ a[33] ^ a[43],
          t = a[4] ^ a[14] ^ a[24] ^ a[34] ^ a[44],
          c = a[5] ^ a[15] ^ a[25] ^ a[35] ^ a[45],
          e = a[6] ^ a[16] ^ a[26] ^ a[36] ^ a[46],
          i = a[7] ^ a[17] ^ a[27] ^ a[37] ^ a[47],
          s = a[8] ^ a[18] ^ a[28] ^ a[38] ^ a[48],
          u = a[9] ^ a[19] ^ a[29] ^ a[39] ^ a[49],
          x = s ^ (n << 1 | p >>> 31),
          b = u ^ (p << 1 | n >>> 31),
          d = a[0] ^ x,
          g = a[1] ^ b,
          h = a[10] ^ x,
          j = a[11] ^ b,
          k = a[20] ^ x,
          l = a[21] ^ b,
          m = a[30] ^ x,
          q = a[31] ^ b,
          w = a[40] ^ x,
          y = a[41] ^ b;
        x = o ^ (t << 1 | c >>> 31), b = f ^ (c << 1 | t >>> 31);
        var z = a[2] ^ x,
          A = a[3] ^ b,
          B = a[12] ^ x,
          C = a[13] ^ b,
          D = a[22] ^ x,
          E = a[23] ^ b,
          F = a[32] ^ x,
          G = a[33] ^ b,
          H = a[42] ^ x,
          I = a[43] ^ b;
        x = n ^ (e << 1 | i >>> 31), b = p ^ (i << 1 | e >>> 31);
        var J = a[4] ^ x,
          K = a[5] ^ b,
          L = a[14] ^ x,
          M = a[15] ^ b,
          N = a[24] ^ x,
          O = a[25] ^ b,
          P = a[34] ^ x,
          Q = a[35] ^ b,
          R = a[44] ^ x,
          S = a[45] ^ b;
        x = t ^ (s << 1 | u >>> 31), b = c ^ (u << 1 | s >>> 31);
        var T = a[6] ^ x,
          U = a[7] ^ b,
          V = a[16] ^ x,
          W = a[17] ^ b,
          X = a[26] ^ x,
          Y = a[27] ^ b,
          Z = a[36] ^ x,
          $ = a[37] ^ b,
          _ = a[46] ^ x,
          rr = a[47] ^ b;
        x = e ^ (o << 1 | f >>> 31), b = i ^ (f << 1 | o >>> 31);
        var ar = a[8] ^ x,
          vr = a[9] ^ b,
          or = a[18] ^ x,
          fr = a[19] ^ b,
          nr = a[28] ^ x,
          pr = a[29] ^ b,
          tr = a[38] ^ x,
          cr = a[39] ^ b,
          er = a[48] ^ x,
          ir = a[49] ^ b,
          sr = d,
          ur = g,
          xr = j << 4 | h >>> 28,
          br = h << 4 | j >>> 28,
          dr = k << 3 | l >>> 29,
          gr = l << 3 | k >>> 29,
          hr = q << 9 | m >>> 23,
          jr = m << 9 | q >>> 23,
          kr = w << 18 | y >>> 14,
          lr = y << 18 | w >>> 14,
          mr = z << 1 | A >>> 31,
          qr = A << 1 | z >>> 31,
          wr = C << 12 | B >>> 20,
          yr = B << 12 | C >>> 20,
          zr = D << 10 | E >>> 22,
          Ar = E << 10 | D >>> 22,
          Br = G << 13 | F >>> 19,
          Cr = F << 13 | G >>> 19,
          Dr = H << 2 | I >>> 30,
          Er = I << 2 | H >>> 30,
          Fr = K << 30 | J >>> 2,
          Gr = J << 30 | K >>> 2,
          Hr = L << 6 | M >>> 26,
          Ir = M << 6 | L >>> 26,
          Jr = O << 11 | N >>> 21,
          Kr = N << 11 | O >>> 21,
          Lr = P << 15 | Q >>> 17,
          Mr = Q << 15 | P >>> 17,
          Nr = S << 29 | R >>> 3,
          Or = R << 29 | S >>> 3,
          Pr = T << 28 | U >>> 4,
          Qr = U << 28 | T >>> 4,
          Rr = W << 23 | V >>> 9,
          Sr = V << 23 | W >>> 9,
          Tr = X << 25 | Y >>> 7,
          Ur = Y << 25 | X >>> 7,
          Vr = Z << 21 | $ >>> 11,
          Wr = $ << 21 | Z >>> 11,
          Xr = rr << 24 | _ >>> 8,
          Yr = _ << 24 | rr >>> 8,
          Zr = ar << 27 | vr >>> 5,
          $r = vr << 27 | ar >>> 5,
          _r = or << 20 | fr >>> 12,
          ra = fr << 20 | or >>> 12,
          aa = pr << 7 | nr >>> 25,
          va = nr << 7 | pr >>> 25,
          oa = tr << 8 | cr >>> 24,
          fa = cr << 8 | tr >>> 24,
          na = er << 14 | ir >>> 18,
          pa = ir << 14 | er >>> 18;
        a[0] = sr ^ ~wr & Jr, a[1] = ur ^ ~yr & Kr, a[10] = Pr ^ ~_r & dr, a[11] = Qr ^ ~ra & gr, a[20] = mr ^ ~Hr & Tr, a[21] = qr ^ ~Ir & Ur, a[30] = Zr ^ ~xr & zr, a[31] = $r ^ ~br & Ar, a[40] = Fr ^ ~Rr & aa, a[41] = Gr ^ ~Sr & va, a[2] = wr ^ ~Jr & Vr, a[3] = yr ^ ~Kr & Wr, a[12] = _r ^ ~dr & Br, a[13] = ra ^ ~gr & Cr, a[22] = Hr ^ ~Tr & oa, a[23] = Ir ^ ~Ur & fa, a[32] = xr ^ ~zr & Lr, a[33] = br ^ ~Ar & Mr, a[42] = Rr ^ ~aa & hr, a[43] = Sr ^ ~va & jr, a[4] = Jr ^ ~Vr & na, a[5] = Kr ^ ~Wr & pa, a[14] = dr ^ ~Br & Nr, a[15] = gr ^ ~Cr & Or, a[24] = Tr ^ ~oa & kr, a[25] = Ur ^ ~fa & lr, a[34] = zr ^ ~Lr & Xr, a[35] = Ar ^ ~Mr & Yr, a[44] = aa ^ ~hr & Dr, a[45] = va ^ ~jr & Er, a[6] = Vr ^ ~na & sr, a[7] = Wr ^ ~pa & ur, a[16] = Br ^ ~Nr & Pr, a[17] = Cr ^ ~Or & Qr, a[26] = oa ^ ~kr & mr, a[27] = fa ^ ~lr & qr, a[36] = Lr ^ ~Xr & Zr, a[37] = Mr ^ ~Yr & $r, a[46] = hr ^ ~Dr & Fr, a[47] = jr ^ ~Er & Gr, a[8] = na ^ ~sr & wr, a[9] = pa ^ ~ur & yr, a[18] = Nr ^ ~Pr & _r, a[19] = Or ^ ~Qr & ra, a[28] = kr ^ ~mr & Hr, a[29] = lr ^ ~qr & Ir, a[38] = Xr ^ ~Zr & xr, a[39] = Yr ^ ~$r & br, a[48] = Dr ^ ~Fr & Rr, a[49] = Er ^ ~Gr & Sr, a[0] ^= r[2 * v], a[1] ^= r[2 * v + 1]
      }
    };
  }, {}],
  "KSrb": [function(require, module, exports) {
    var Buffer = require("buffer").Buffer;
    var t = require("buffer").Buffer,
      i = require("./keccak-state-unroll");

    function s() {
      this.state = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], this.blockSize = null, this.count = 0, this.squeezing = !1
    }
    s.prototype.initialize = function(t, i) {
      for (var s = 0; s < 50; ++s) this.state[s] = 0;
      this.blockSize = t / 8, this.count = 0, this.squeezing = !1
    }, s.prototype.absorb = function(t) {
      for (var s = 0; s < t.length; ++s) this.state[~~(this.count / 4)] ^= t[s] << this.count % 4 * 8, this.count += 1, this.count === this.blockSize && (i.p1600(this.state), this.count = 0)
    }, s.prototype.absorbLastFewBits = function(t) {
      this.state[~~(this.count / 4)] ^= t << this.count % 4 * 8, 0 != (128 & t) && this.count === this.blockSize - 1 && i.p1600(this.state), this.state[~~((this.blockSize - 1) / 4)] ^= 128 << (this.blockSize - 1) % 4 * 8, i.p1600(this.state), this.count = 0, this.squeezing = !0
    }, s.prototype.squeeze = function(s) {
      this.squeezing || this.absorbLastFewBits(1);
      for (var e = t.alloc(s), o = 0; o < s; ++o) e[o] = this.state[~~(this.count / 4)] >>> this.count % 4 * 8 & 255, this.count += 1, this.count === this.blockSize && (i.p1600(this.state), this.count = 0);
      return e
    }, s.prototype.copy = function(t) {
      for (var i = 0; i < 50; ++i) t.state[i] = this.state[i];
      t.blockSize = this.blockSize, t.count = this.count, t.squeezing = this.squeezing
    }, module.exports = s;
  }, {
    "./keccak-state-unroll": "Z7Uk",
    "buffer": "dskh"
  }],
  "l2NE": [function(require, module, exports) {
    module.exports = require("./lib/api")(require("./lib/keccak"));
  }, {
    "./lib/api": "nIJC",
    "./lib/keccak": "KSrb"
  }],
  "Ln97": [function(require, module, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    var e = require("./hash-utils"),
      c = require("keccak");
    exports.keccak224 = e.createHashFunction(function() {
      return c("keccak224")
    }), exports.keccak256 = e.createHashFunction(function() {
      return c("keccak256")
    }), exports.keccak384 = e.createHashFunction(function() {
      return c("keccak384")
    }), exports.keccak512 = e.createHashFunction(function() {
      return c("keccak512")
    });
  }, {
    "./hash-utils": "kDZy",
    "keccak": "l2NE"
  }],
  "WQ2h": [function(require, module, exports) {
    var Buffer = require("buffer").Buffer;
    var e = require("buffer").Buffer;
    Object.defineProperty(exports, "__esModule", {
      value: !0
    }), exports.rlphash = exports.ripemd160 = exports.sha256 = exports.keccak256 = exports.keccak = void 0;
    var r = require("ethereum-cryptography/keccak"),
      t = r.keccak224,
      c = r.keccak384,
      a = r.keccak256,
      o = r.keccak512,
      s = require("create-hash"),
      u = require("ethjs-util"),
      n = require("rlp"),
      i = require("./bytes");
    exports.keccak = function(r, s) {
      switch (void 0 === s && (s = 256), r = "string" != typeof r || u.isHexString(r) ? i.toBuffer(r) : e.from(r, "utf8"), s || (s = 256), s) {
        case 224:
          return t(r);
        case 256:
          return a(r);
        case 384:
          return c(r);
        case 512:
          return o(r);
        default:
          throw new Error("Invald algorithm: keccak" + s)
      }
    }, exports.keccak256 = function(e) {
      return exports.keccak(e)
    }, exports.sha256 = function(e) {
      return e = i.toBuffer(e), s("sha256").update(e).digest()
    }, exports.ripemd160 = function(e, r) {
      e = i.toBuffer(e);
      var t = s("rmd160").update(e).digest();
      return !0 === r ? i.setLength(t, 32) : t
    }, exports.rlphash = function(e) {
      return exports.keccak(n.encode(e))
    };
  }, {
    "ethereum-cryptography/keccak": "Ln97",
    "create-hash": "LF8r",
    "ethjs-util": "uDCt",
    "rlp": "bL3J",
    "./bytes": "mLWy",
    "buffer": "dskh"
  }],
  "IYC9": [function(require, module, exports) {
    var Buffer = require("buffer").Buffer;
    var e = require("buffer").Buffer;
    Object.defineProperty(exports, "__esModule", {
      value: !0
    }), exports.importPublic = exports.privateToPublic = exports.privateToAddress = exports.publicToAddress = exports.pubToAddress = exports.isValidPublic = exports.isValidPrivate = exports.isPrecompiled = exports.generateAddress2 = exports.generateAddress = exports.isValidChecksumAddress = exports.toChecksumAddress = exports.isZeroAddress = exports.isValidAddress = exports.zeroAddress = void 0;
    var r = require("assert"),
      s = require("ethjs-util"),
      t = require("./secp256k1v3-adapter"),
      o = require("bn.js"),
      i = require("./bytes"),
      u = require("./hash");
    exports.zeroAddress = function() {
      var e = i.zeros(20);
      return i.bufferToHex(e)
    }, exports.isValidAddress = function(e) {
      return /^0x[0-9a-fA-F]{40}$/.test(e)
    }, exports.isZeroAddress = function(e) {
      return exports.zeroAddress() === i.addHexPrefix(e)
    }, exports.toChecksumAddress = function(e, r) {
      e = s.stripHexPrefix(e).toLowerCase();
      for (var t = void 0 !== r ? r.toString() + "0x" : "", o = u.keccak(t + e).toString("hex"), i = "0x", d = 0; d < e.length; d++) parseInt(o[d], 16) >= 8 ? i += e[d].toUpperCase() : i += e[d];
      return i
    }, exports.isValidChecksumAddress = function(e, r) {
      return exports.isValidAddress(e) && exports.toChecksumAddress(e, r) === e
    }, exports.generateAddress = function(r, s) {
      r = i.toBuffer(r);
      var t = new o(s);
      return t.isZero() ? u.rlphash([r, null]).slice(-20) : u.rlphash([r, e.from(t.toArray())]).slice(-20)
    }, exports.generateAddress2 = function(s, t, o) {
      var d = i.toBuffer(s),
        p = i.toBuffer(t),
        n = i.toBuffer(o);
      return r(20 === d.length), r(32 === p.length), u.keccak256(e.concat([e.from("ff", "hex"), d, p, u.keccak256(n)])).slice(-20)
    }, exports.isPrecompiled = function(e) {
      var r = i.unpad(e);
      return 1 === r.length && r[0] >= 1 && r[0] <= 8
    }, exports.isValidPrivate = function(e) {
      return t.privateKeyVerify(e)
    }, exports.isValidPublic = function(r, s) {
      return void 0 === s && (s = !1), 64 === r.length ? t.publicKeyVerify(e.concat([e.from([4]), r])) : !!s && t.publicKeyVerify(r)
    }, exports.pubToAddress = function(e, s) {
      return void 0 === s && (s = !1), e = i.toBuffer(e), s && 64 !== e.length && (e = t.publicKeyConvert(e, !1).slice(1)), r(64 === e.length), u.keccak(e).slice(-20)
    }, exports.publicToAddress = exports.pubToAddress, exports.privateToAddress = function(e) {
      return exports.publicToAddress(exports.privateToPublic(e))
    }, exports.privateToPublic = function(e) {
      return e = i.toBuffer(e), t.publicKeyCreate(e, !1).slice(1)
    }, exports.importPublic = function(e) {
      return 64 !== (e = i.toBuffer(e)).length && (e = t.publicKeyConvert(e, !1).slice(1)), e
    };
  }, {
    "assert": "DlZn",
    "ethjs-util": "uDCt",
    "./secp256k1v3-adapter": "EP9j",
    "bn.js": "AGD1",
    "./bytes": "mLWy",
    "./hash": "WQ2h",
    "buffer": "dskh"
  }],
  "Xy2C": [function(require, module, exports) {
    var Buffer = require("buffer").Buffer;
    var e = require("buffer").Buffer;
    Object.defineProperty(exports, "__esModule", {
      value: !0
    }), exports.hashPersonalMessage = exports.isValidSignature = exports.fromRpcSig = exports.toRpcSig = exports.ecrecover = exports.ecsign = void 0;
    var r = require("./secp256k1v3-adapter"),
      f = require("bn.js"),
      t = require("./bytes"),
      n = require("./hash");

    function i(e, r) {
      return r ? e - (2 * r + 35) : e - 27
    }

    function o(e) {
      return 0 === e || 1 === e
    }
    exports.ecsign = function(e, f, t) {
      var n = r.sign(e, f),
        i = n.recovery;
      return {
        r: n.signature.slice(0, 32),
        s: n.signature.slice(32, 64),
        v: t ? i + (2 * t + 35) : i + 27
      }
    }, exports.ecrecover = function(f, n, s, a, u) {
      var c = e.concat([t.setLength(s, 32), t.setLength(a, 32)], 64),
        g = i(n, u);
      if (!o(g)) throw new Error("Invalid signature v value");
      var v = r.recover(f, c, g);
      return r.publicKeyConvert(v, !1).slice(1)
    }, exports.toRpcSig = function(r, f, n, s) {
      if (!o(i(r, s))) throw new Error("Invalid signature v value");
      return t.bufferToHex(e.concat([t.setLengthLeft(f, 32), t.setLengthLeft(n, 32), t.toBuffer(r)]))
    }, exports.fromRpcSig = function(e) {
      var r = t.toBuffer(e);
      if (65 !== r.length) throw new Error("Invalid signature length");
      var f = r[64];
      return f < 27 && (f += 27), {
        v: f,
        r: r.slice(0, 32),
        s: r.slice(32, 64)
      }
    }, exports.isValidSignature = function(e, r, t, n, s) {
      void 0 === n && (n = !0);
      var a = new f("7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a0", 16),
        u = new f("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141", 16);
      if (32 !== r.length || 32 !== t.length) return !1;
      if (!o(i(e, s))) return !1;
      var c = new f(r),
        g = new f(t);
      return !(c.isZero() || c.gt(u) || g.isZero() || g.gt(u)) && (!n || 1 !== g.cmp(a))
    }, exports.hashPersonalMessage = function(r) {
      var f = e.from("Ethereum Signed Message:\n" + r.length.toString(), "utf-8");
      return n.keccak(e.concat([f, r]))
    };
  }, {
    "./secp256k1v3-adapter": "EP9j",
    "bn.js": "AGD1",
    "./bytes": "mLWy",
    "./hash": "WQ2h",
    "buffer": "dskh"
  }],
  "iOBX": [function(require, module, exports) {
    var Buffer = require("buffer").Buffer;
    var e = require("buffer").Buffer;
    Object.defineProperty(exports, "__esModule", {
      value: !0
    }), exports.defineProperties = void 0;
    var r = require("assert"),
      t = require("ethjs-util"),
      n = require("rlp"),
      i = require("./bytes");
    exports.defineProperties = function(a, f, o) {
      if (a.raw = [], a._fields = [], a.toJSON = function(e) {
          if (void 0 === e && (e = !1), e) {
            var r = {};
            return a._fields.forEach(function(e) {
              r[e] = "0x" + a[e].toString("hex")
            }), r
          }
          return i.baToJSON(a.raw)
        }, a.serialize = function() {
          return n.encode(a.raw)
        }, f.forEach(function(t, n) {
          function f() {
            return a.raw[n]
          }

          function o(f) {
            "00" !== (f = i.toBuffer(f)).toString("hex") || t.allowZero || (f = e.allocUnsafe(0)), t.allowLess && t.length ? (f = i.stripZeros(f), r(t.length >= f.length, "The field " + t.name + " must not have more " + t.length + " bytes")) : t.allowZero && 0 === f.length || !t.length || r(t.length === f.length, "The field " + t.name + " must have byte length of " + t.length), a.raw[n] = f
          }
          a._fields.push(t.name), Object.defineProperty(a, t.name, {
            enumerable: !0,
            configurable: !0,
            get: f,
            set: o
          }), t.default && (a[t.name] = t.default), t.alias && Object.defineProperty(a, t.alias, {
            enumerable: !1,
            configurable: !0,
            set: o,
            get: f
          })
        }), o)
        if ("string" == typeof o && (o = e.from(t.stripHexPrefix(o), "hex")), e.isBuffer(o) && (o = n.decode(o)), Array.isArray(o)) {
          if (o.length > a._fields.length) throw new Error("wrong number of fields in data");
          o.forEach(function(e, r) {
            a[a._fields[r]] = i.toBuffer(e)
          })
        } else {
          if ("object" != typeof o) throw new Error("invalid data");
          var l = Object.keys(o);
          f.forEach(function(e) {
            -1 !== l.indexOf(e.name) && (a[e.name] = o[e.name]), -1 !== l.indexOf(e.alias) && (a[e.alias] = o[e.alias])
          })
        }
    };
  }, {
    "assert": "DlZn",
    "ethjs-util": "uDCt",
    "rlp": "bL3J",
    "./bytes": "mLWy",
    "buffer": "dskh"
  }],
  "BQcR": [function(require, module, exports) {
    "use strict";
    var e = this && this.__createBinding || (Object.create ? function(e, r, t, s) {
        void 0 === s && (s = t), Object.defineProperty(e, s, {
          enumerable: !0,
          get: function() {
            return r[t]
          }
        })
      } : function(e, r, t, s) {
        void 0 === s && (s = t), e[s] = r[t]
      }),
      r = this && this.__exportStar || function(r, t) {
        for (var s in r) "default" === s || t.hasOwnProperty(s) || e(t, r, s)
      };
    Object.defineProperty(exports, "__esModule", {
      value: !0
    }), exports.secp256k1 = exports.rlp = exports.BN = void 0;
    var t = require("./secp256k1v3-adapter");
    exports.secp256k1 = t;
    var s = require("ethjs-util"),
      i = require("bn.js");
    exports.BN = i;
    var o = require("rlp");
    exports.rlp = o, Object.assign(exports, s), r(require("./constants"), exports), r(require("./account"), exports), r(require("./hash"), exports), r(require("./signature"), exports), r(require("./bytes"), exports), r(require("./object"), exports);
  }, {
    "./secp256k1v3-adapter": "EP9j",
    "ethjs-util": "uDCt",
    "bn.js": "AGD1",
    "rlp": "bL3J",
    "./constants": "le7r",
    "./account": "IYC9",
    "./hash": "WQ2h",
    "./signature": "Xy2C",
    "./bytes": "mLWy",
    "./object": "iOBX"
  }],
  "y7qC": [function(require, module, exports) {
    module.exports = {
      name: "mainnet",
      chainId: 1,
      networkId: 1,
      comment: "The Ethereum main chain",
      url: "https://ethstats.net/",
      genesis: {
        hash: "0xd4e56740f876aef8c010b86a40d5f56745a118d0906a34e69aec8c0db1cb8fa3",
        timestamp: null,
        gasLimit: 5e3,
        difficulty: 17179869184,
        nonce: "0x0000000000000042",
        extraData: "0x11bbe8db4e347b4e8c937c1c8370e4b5ed33adb3db69cbdb7a38e1e50b1b82fa",
        stateRoot: "0xd7f8974fb5ac78d9ac099b9ad5018bedc2ce0a72dad1827a1709da30580f0544"
      },
      hardforks: [{
        name: "chainstart",
        block: 0,
        consensus: "pow",
        finality: null
      }, {
        name: "homestead",
        block: 115e4,
        consensus: "pow",
        finality: null
      }, {
        name: "dao",
        block: 192e4,
        consensus: "pow",
        finality: null
      }, {
        name: "tangerineWhistle",
        block: 2463e3,
        consensus: "pow",
        finality: null
      }, {
        name: "spuriousDragon",
        block: 2675e3,
        consensus: "pow",
        finality: null
      }, {
        name: "byzantium",
        block: 437e4,
        consensus: "pow",
        finality: null
      }, {
        name: "constantinople",
        block: 728e4,
        consensus: "pow",
        finality: null
      }, {
        name: "petersburg",
        block: 728e4,
        consensus: "pow",
        finality: null
      }, {
        name: "istanbul",
        block: 9069e3,
        consensus: "pow",
        finality: null
      }, {
        name: "muirGlacier",
        block: 92e5,
        consensus: "pow",
        finality: null
      }],
      bootstrapNodes: [{
        ip: "18.138.108.67",
        port: 30303,
        id: "d860a01f9722d78051619d1e2351aba3f43f943f6f00718d1b9baa4101932a1f5011f16bb2b1bb35db20d6fe28fa0bf09636d26a87d31de9ec6203eeedb1f666",
        location: "ap-southeast-1-001",
        comment: "bootnode-aws-ap-southeast-1-001"
      }, {
        ip: "3.209.45.79",
        port: 30303,
        id: "22a8232c3abc76a16ae9d6c3b164f98775fe226f0917b0ca871128a74a8e9630b458460865bab457221f1d448dd9791d24c4e5d88786180ac185df813a68d4de",
        location: "us-east-1-001",
        comment: "bootnode-aws-us-east-1-001"
      }, {
        ip: "34.255.23.113",
        port: 30303,
        id: "ca6de62fce278f96aea6ec5a2daadb877e51651247cb96ee310a318def462913b653963c155a0ef6c7d50048bba6e6cea881130857413d9f50a621546b590758",
        location: "eu-west-1-001",
        comment: "bootnode-aws-eu-west-1-001"
      }, {
        ip: "35.158.244.151",
        port: 30303,
        id: "279944d8dcd428dffaa7436f25ca0ca43ae19e7bcf94a8fb7d1641651f92d121e972ac2e8f381414b80cc8e5555811c2ec6e1a99bb009b3f53c4c69923e11bd8",
        location: "eu-central-1-001",
        comment: "bootnode-aws-eu-central-1-001"
      }, {
        ip: "52.187.207.27",
        port: 30303,
        id: "8499da03c47d637b20eee24eec3c356c9a2e6148d6fe25ca195c7949ab8ec2c03e3556126b0d7ed644675e78c4318b08691b7b57de10e5f0d40d05b09238fa0a",
        location: "australiaeast-001",
        comment: "bootnode-azure-australiaeast-001"
      }, {
        ip: "191.234.162.198",
        port: 30303,
        id: "103858bdb88756c71f15e9b5e09b56dc1be52f0a5021d46301dbbfb7e130029cc9d0d6f73f693bc29b665770fff7da4d34f3c6379fe12721b5d7a0bcb5ca1fc1",
        location: "brazilsouth-001",
        comment: "bootnode-azure-brazilsouth-001"
      }, {
        ip: "52.231.165.108",
        port: 30303,
        id: "715171f50508aba88aecd1250af392a45a330af91d7b90701c436b618c86aaa1589c9184561907bebbb56439b8f8787bc01f49a7c77276c58c1b09822d75e8e8",
        location: "koreasouth-001",
        comment: "bootnode-azure-koreasouth-001"
      }, {
        ip: "104.42.217.25",
        port: 30303,
        id: "5d6d7cd20d6da4bb83a1d28cadb5d409b64edf314c0335df658c1a54e32c7c4a7ab7823d57c39b6a757556e68ff1df17c748b698544a55cb488b52479a92b60f",
        location: "westus-001",
        comment: "bootnode-azure-westus-001"
      }]
    };
  }, {}],
  "Qwxf": [function(require, module, exports) {
    module.exports = {
      name: "ropsten",
      chainId: 3,
      networkId: 3,
      comment: "PoW test network",
      url: "https://github.com/ethereum/ropsten",
      genesis: {
        hash: "0x41941023680923e0fe4d74a34bdac8141f2540e3ae90623718e47d66d1ca4a2d",
        timestamp: null,
        gasLimit: 16777216,
        difficulty: 1048576,
        nonce: "0x0000000000000042",
        extraData: "0x3535353535353535353535353535353535353535353535353535353535353535",
        stateRoot: "0x217b0bbcfb72e2d57e28f33cb361b9983513177755dc3f33ce3e7022ed62b77b"
      },
      hardforks: [{
        name: "chainstart",
        block: 0,
        consensus: "pow",
        finality: null
      }, {
        name: "homestead",
        block: 0,
        consensus: "pow",
        finality: null
      }, {
        name: "dao",
        block: null,
        consensus: "pow",
        finality: null
      }, {
        name: "tangerineWhistle",
        block: 0,
        consensus: "pow",
        finality: null
      }, {
        name: "spuriousDragon",
        block: 10,
        consensus: "pow",
        finality: null
      }, {
        name: "byzantium",
        block: 17e5,
        consensus: "pow",
        finality: null
      }, {
        name: "constantinople",
        block: 423e4,
        consensus: "pow",
        finality: null
      }, {
        name: "petersburg",
        block: 4939394,
        consensus: "pow",
        finality: null
      }, {
        name: "istanbul",
        block: 6485846,
        consensus: "pow",
        finality: null
      }, {
        name: "muirGlacier",
        block: 7117117,
        consensus: "pow",
        finality: null
      }],
      bootstrapNodes: [{
        ip: "52.176.7.10",
        port: 30303,
        id: "30b7ab30a01c124a6cceca36863ece12c4f5fa68e3ba9b0b51407ccc002eeed3b3102d20a88f1c1d3c3154e2449317b8ef95090e77b312d5cc39354f86d5d606",
        location: "",
        comment: "US-Azure geth"
      }, {
        ip: "52.176.100.77",
        port: 30303,
        id: "865a63255b3bb68023b6bffd5095118fcc13e79dcf014fe4e47e065c350c7cc72af2e53eff895f11ba1bbb6a2b33271c1116ee870f266618eadfc2e78aa7349c",
        location: "",
        comment: "US-Azure parity"
      }, {
        ip: "52.232.243.152",
        port: 30303,
        id: "6332792c4a00e3e4ee0926ed89e0d27ef985424d97b6a45bf0f23e51f0dcb5e66b875777506458aea7af6f9e4ffb69f43f3778ee73c81ed9d34c51c4b16b0b0f",
        location: "",
        comment: "Parity"
      }, {
        ip: "192.81.208.223",
        port: 30303,
        id: "94c15d1b9e2fe7ce56e458b9a3b672ef11894ddedd0c6f247e0f1d3487f52b66208fb4aeb8179fce6e3a749ea93ed147c37976d67af557508d199d9594c35f09",
        location: "",
        comment: "@gpip"
      }]
    };
  }, {}],
  "ZVmh": [function(require, module, exports) {
    module.exports = {
      name: "rinkeby",
      chainId: 4,
      networkId: 4,
      comment: "PoA test network",
      url: "https://www.rinkeby.io",
      genesis: {
        hash: "0x6341fd3daf94b748c72ced5a5b26028f2474f5f00d824504e4fa37a75767e177",
        timestamp: "0x58ee40ba",
        gasLimit: 47e5,
        difficulty: 1,
        nonce: "0x0000000000000000",
        extraData: "0x52657370656374206d7920617574686f7269746168207e452e436172746d616e42eb768f2244c8811c63729a21a3569731535f067ffc57839b00206d1ad20c69a1981b489f772031b279182d99e65703f0076e4812653aab85fca0f00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
        stateRoot: "0x53580584816f617295ea26c0e17641e0120cab2f0a8ffb53a866fd53aa8e8c2d"
      },
      hardforks: [{
        name: "chainstart",
        block: 0,
        consensus: "poa",
        finality: null
      }, {
        name: "homestead",
        block: 1,
        consensus: "poa",
        finality: null
      }, {
        name: "dao",
        block: null,
        consensus: "poa",
        finality: null
      }, {
        name: "tangerineWhistle",
        block: 2,
        consensus: "poa",
        finality: null
      }, {
        name: "spuriousDragon",
        block: 3,
        consensus: "poa",
        finality: null
      }, {
        name: "byzantium",
        block: 1035301,
        consensus: "poa",
        finality: null
      }, {
        name: "constantinople",
        block: 3660663,
        consensus: "poa",
        finality: null
      }, {
        name: "petersburg",
        block: 4321234,
        consensus: "poa",
        finality: null
      }, {
        name: "istanbul",
        block: 5435345,
        consensus: "poa",
        finality: null
      }],
      bootstrapNodes: [{
        ip: "52.169.42.101",
        port: 30303,
        id: "a24ac7c5484ef4ed0c5eb2d36620ba4e4aa13b8c84684e1b4aab0cebea2ae45cb4d375b77eab56516d34bfbd3c1a833fc51296ff084b770b94fb9028c4d25ccf",
        location: "",
        comment: "IE"
      }, {
        ip: "52.3.158.184",
        port: 30303,
        id: "343149e4feefa15d882d9fe4ac7d88f885bd05ebb735e547f12e12080a9fa07c8014ca6fd7f373123488102fe5e34111f8509cf0b7de3f5b44339c9f25e87cb8",
        location: "",
        comment: "INFURA"
      }, {
        ip: "159.89.28.211",
        port: 30303,
        id: "b6b28890b006743680c52e64e0d16db57f28124885595fa03a562be1d2bf0f3a1da297d56b13da25fb992888fd556d4c1a27b1f39d531bde7de1921c90061cc6",
        location: "",
        comment: "AKASHA"
      }]
    };
  }, {}],
  "SL9u": [function(require, module, exports) {
    module.exports = {
      name: "kovan",
      chainId: 42,
      networkId: 42,
      comment: "Parity PoA test network",
      url: "https://kovan-testnet.github.io/website/",
      genesis: {
        hash: "0xa3c565fc15c7478862d50ccd6561e3c06b24cc509bf388941c25ea985ce32cb9",
        timestamp: null,
        gasLimit: 6e6,
        difficulty: 131072,
        nonce: "0x0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
        extraData: "0x",
        stateRoot: "0x2480155b48a1cea17d67dbfdfaafe821c1d19cdd478c5358e8ec56dec24502b2"
      },
      hardforks: [{
        name: "chainstart",
        block: 0,
        consensus: "poa",
        finality: null
      }, {
        name: "homestead",
        block: 0,
        consensus: "poa",
        finality: null
      }, {
        name: "dao",
        block: 0,
        consensus: "poa",
        finality: null
      }, {
        name: "tangerineWhistle",
        block: 0,
        consensus: "poa",
        finality: null
      }, {
        name: "spuriousDragon",
        block: 0,
        consensus: "poa",
        finality: null
      }, {
        name: "byzantium",
        block: 5067e3,
        consensus: "poa",
        finality: null
      }, {
        name: "constantinople",
        block: 92e5,
        consensus: "poa",
        finality: null
      }, {
        name: "petersburg",
        block: 10255201,
        consensus: "poa",
        finality: null
      }, {
        name: "istanbul",
        block: 14111141,
        consensus: "poa",
        finality: null
      }],
      bootstrapNodes: [{
        ip: "116.203.116.241",
        port: 30303,
        id: "16898006ba2cd4fa8bf9a3dfe32684c178fa861df144bfc21fe800dc4838a03e342056951fa9fd533dcb0be1219e306106442ff2cf1f7e9f8faa5f2fc1a3aa45",
        location: "",
        comment: "1"
      }, {
        ip: "3.217.96.11",
        port: 30303,
        id: "2909846f78c37510cc0e306f185323b83bb2209e5ff4fdd279d93c60e3f365e3c6e62ad1d2133ff11f9fd6d23ad9c3dad73bb974d53a22f7d1ac5b7dea79d0b0",
        location: "",
        comment: "2"
      }, {
        ip: "108.61.170.124",
        port: 30303,
        id: "740e1c8ea64e71762c71a463a04e2046070a0c9394fcab5891d41301dc473c0cff00ebab5a9bc87fbcb610ab98ac18225ff897bc8b7b38def5975d5ceb0a7d7c",
        location: "",
        comment: "3"
      }, {
        ip: "157.230.31.163",
        port: 30303,
        id: "2909846f78c37510cc0e306f185323b83bb2209e5ff4fdd279d93c60e3f365e3c6e62ad1d2133ff11f9fd6d23ad9c3dad73bb974d53a22f7d1ac5b7dea79d0b0",
        location: "",
        comment: "4"
      }]
    };
  }, {}],
  "z5Le": [function(require, module, exports) {
    module.exports = {
      name: "goerli",
      chainId: 5,
      networkId: 5,
      comment: "Cross-client PoA test network",
      url: "https://github.com/goerli/testnet",
      genesis: {
        hash: "0xbf7e331f7f7c1dd2e05159666b3bf8bc7a8a3a9eb1d518969eab529dd9b88c1a",
        timestamp: "0x5c51a607",
        gasLimit: 10485760,
        difficulty: 1,
        nonce: "0x0000000000000000",
        extraData: "0x22466c6578692069732061207468696e6722202d204166726900000000000000e0a2bd4258d2768837baa26a28fe71dc079f84c70000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
        stateRoot: "0x5d6cded585e73c4e322c30c2f782a336316f17dd85a4863b9d838d2d4b8b3008"
      },
      hardforks: [{
        name: "chainstart",
        block: 0,
        consensus: "poa",
        finality: null
      }, {
        name: "homestead",
        block: 0,
        consensus: "poa",
        finality: null
      }, {
        name: "dao",
        block: 0,
        consensus: "poa",
        finality: null
      }, {
        name: "tangerineWhistle",
        block: 0,
        consensus: "poa",
        finality: null
      }, {
        name: "spuriousDragon",
        block: 0,
        consensus: "poa",
        finality: null
      }, {
        name: "byzantium",
        block: 0,
        consensus: "poa",
        finality: null
      }, {
        name: "constantinople",
        block: 0,
        consensus: "poa",
        finality: null
      }, {
        name: "petersburg",
        block: 0,
        consensus: "poa",
        finality: null
      }, {
        name: "istanbul",
        block: 1561651,
        consensus: "poa",
        finality: null
      }],
      bootstrapNodes: [{
        ip: "51.141.78.53",
        port: 30303,
        id: "011f758e6552d105183b1761c5e2dea0111bc20fd5f6422bc7f91e0fabbec9a6595caf6239b37feb773dddd3f87240d99d859431891e4a642cf2a0a9e6cbb98a",
        location: "",
        comment: "Upstream bootnode 1"
      }, {
        ip: "13.93.54.137",
        port: 30303,
        id: "176b9417f511d05b6b2cf3e34b756cf0a7096b3094572a8f6ef4cdcb9d1f9d00683bf0f83347eebdf3b81c3521c2332086d9592802230bf528eaf606a1d9677b",
        location: "",
        comment: "Upstream bootnode 2"
      }, {
        ip: "94.237.54.114",
        port: 30313,
        id: "46add44b9f13965f7b9875ac6b85f016f341012d84f975377573800a863526f4da19ae2c620ec73d11591fa9510e992ecc03ad0751f53cc02f7c7ed6d55c7291",
        location: "",
        comment: "Upstream bootnode 3"
      }, {
        ip: "52.64.155.147",
        port: 30303,
        id: "c1f8b7c2ac4453271fa07d8e9ecf9a2e8285aa0bd0c07df0131f47153306b0736fd3db8924e7a9bf0bed6b1d8d4f87362a71b033dc7c64547728d953e43e59b2",
        location: "",
        comment: "Upstream bootnode 4"
      }, {
        ip: "213.186.16.82",
        port: 30303,
        id: "f4a9c6ee28586009fb5a96c8af13a58ed6d8315a9eee4772212c1d4d9cebe5a8b8a78ea4434f318726317d04a3f531a1ef0420cf9752605a562cfe858c46e263",
        location: "",
        comment: "Upstream bootnode 5"
      }, {
        ip: "3.11.147.67",
        port: 30303,
        id: "a61215641fb8714a373c80edbfa0ea8878243193f57c96eeb44d0bc019ef295abd4e044fd619bfc4c59731a73fb79afe84e9ab6da0c743ceb479cbb6d263fa91",
        location: "",
        comment: "Ethereum Foundation bootnode"
      }]
    };
  }, {}],
  "XL6A": [function(require, module, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    }), exports.chains = void 0, exports.chains = {
      names: {
        1: "mainnet",
        3: "ropsten",
        4: "rinkeby",
        42: "kovan",
        5: "goerli"
      },
      mainnet: require("./mainnet.json"),
      ropsten: require("./ropsten.json"),
      rinkeby: require("./rinkeby.json"),
      kovan: require("./kovan.json"),
      goerli: require("./goerli.json")
    };
  }, {
    "./mainnet.json": "y7qC",
    "./ropsten.json": "Qwxf",
    "./rinkeby.json": "ZVmh",
    "./kovan.json": "SL9u",
    "./goerli.json": "z5Le"
  }],
  "vExz": [function(require, module, exports) {
    module.exports = {
      name: "chainstart",
      comment: "Start of the Ethereum main chain",
      eip: {
        url: "",
        status: ""
      },
      status: "",
      gasConfig: {
        minGasLimit: {
          v: 5e3,
          d: "Minimum the gas limit may ever be"
        },
        gasLimitBoundDivisor: {
          v: 1024,
          d: "The bound divisor of the gas limit, used in update calculations"
        }
      },
      gasPrices: {
        base: {
          v: 2,
          d: "Gas base cost, used e.g. for ChainID opcode (Istanbul)"
        },
        tierStep: {
          v: [0, 2, 3, 5, 8, 10, 20],
          d: "Once per operation, for a selection of them"
        },
        exp: {
          v: 10,
          d: "Once per EXP instuction"
        },
        expByte: {
          v: 10,
          d: "Times ceil(log256(exponent)) for the EXP instruction"
        },
        sha3: {
          v: 30,
          d: "Once per SHA3 operation"
        },
        sha3Word: {
          v: 6,
          d: "Once per word of the SHA3 operation's data"
        },
        sload: {
          v: 50,
          d: "Once per SLOAD operation"
        },
        sstoreSet: {
          v: 2e4,
          d: "Once per SSTORE operation if the zeroness changes from zero"
        },
        sstoreReset: {
          v: 5e3,
          d: "Once per SSTORE operation if the zeroness does not change from zero"
        },
        sstoreRefund: {
          v: 15e3,
          d: "Once per SSTORE operation if the zeroness changes to zero"
        },
        jumpdest: {
          v: 1,
          d: "Refunded gas, once per SSTORE operation if the zeroness changes to zero"
        },
        log: {
          v: 375,
          d: "Per LOG* operation"
        },
        logData: {
          v: 8,
          d: "Per byte in a LOG* operation's data"
        },
        logTopic: {
          v: 375,
          d: "Multiplied by the * of the LOG*, per LOG transaction. e.g. LOG0 incurs 0 * c_txLogTopicGas, LOG4 incurs 4 * c_txLogTopicGas"
        },
        create: {
          v: 32e3,
          d: "Once per CREATE operation & contract-creation transaction"
        },
        call: {
          v: 40,
          d: "Once per CALL operation & message call transaction"
        },
        callStipend: {
          v: 2300,
          d: "Free gas given at beginning of call"
        },
        callValueTransfer: {
          v: 9e3,
          d: "Paid for CALL when the value transfor is non-zero"
        },
        callNewAccount: {
          v: 25e3,
          d: "Paid for CALL when the destination address didn't exist prior"
        },
        selfdestructRefund: {
          v: 24e3,
          d: "Refunded following a selfdestruct operation"
        },
        memory: {
          v: 3,
          d: "Times the address of the (highest referenced byte in memory + 1). NOTE: referencing happens on read, write and in instructions such as RETURN and CALL"
        },
        quadCoeffDiv: {
          v: 512,
          d: "Divisor for the quadratic particle of the memory cost equation"
        },
        createData: {
          v: 200,
          d: ""
        },
        tx: {
          v: 21e3,
          d: "Per transaction. NOTE: Not payable on data of calls between transactions"
        },
        txCreation: {
          v: 32e3,
          d: "The cost of creating a contract via tx"
        },
        txDataZero: {
          v: 4,
          d: "Per byte of data attached to a transaction that equals zero. NOTE: Not payable on data of calls between transactions"
        },
        txDataNonZero: {
          v: 68,
          d: "Per byte of data attached to a transaction that is not equal to zero. NOTE: Not payable on data of calls between transactions"
        },
        copy: {
          v: 3,
          d: "Multiplied by the number of 32-byte words that are copied (round up) for any *COPY operation and added"
        },
        ecRecover: {
          v: 3e3,
          d: ""
        },
        sha256: {
          v: 60,
          d: ""
        },
        sha256Word: {
          v: 12,
          d: ""
        },
        ripemd160: {
          v: 600,
          d: ""
        },
        ripemd160Word: {
          v: 120,
          d: ""
        },
        identity: {
          v: 15,
          d: ""
        },
        identityWord: {
          v: 3,
          d: ""
        }
      },
      vm: {
        stackLimit: {
          v: 1024,
          d: "Maximum size of VM stack allowed"
        },
        callCreateDepth: {
          v: 1024,
          d: "Maximum depth of call/create stack"
        },
        maxExtraDataSize: {
          v: 32,
          d: "Maximum size extra data may be after Genesis"
        }
      },
      pow: {
        minimumDifficulty: {
          v: 131072,
          d: "The minimum that the difficulty may ever be"
        },
        difficultyBoundDivisor: {
          v: 2048,
          d: "The bound divisor of the difficulty, used in the update calculations"
        },
        durationLimit: {
          v: 13,
          d: "The decision boundary on the blocktime duration used to determine whether difficulty should go up or not"
        },
        epochDuration: {
          v: 3e4,
          d: "Duration between proof-of-work epochs"
        },
        timebombPeriod: {
          v: 1e5,
          d: "Exponential difficulty timebomb period"
        },
        minerReward: {
          v: "5000000000000000000",
          d: "the amount a miner get rewarded for mining a block"
        }
      },
      casper: {},
      sharding: {}
    };
  }, {}],
  "oMyY": [function(require, module, exports) {
    module.exports = {
      name: "homestead",
      comment: "Homestead hardfork with protocol and network changes",
      eip: {
        url: "https://eips.ethereum.org/EIPS/eip-606",
        status: "Final"
      },
      gasConfig: {},
      gasPrices: {},
      vm: {},
      pow: {},
      casper: {},
      sharding: {}
    };
  }, {}],
  "DHrv": [function(require, module, exports) {
    module.exports = {
      name: "dao",
      comment: "DAO rescue hardfork",
      eip: {
        url: "https://eips.ethereum.org/EIPS/eip-779",
        status: "Final"
      },
      gasConfig: {},
      gasPrices: {},
      vm: {},
      pow: {},
      casper: {},
      sharding: {}
    };
  }, {}],
  "LVwS": [function(require, module, exports) {
    module.exports = {
      name: "tangerineWhistle",
      comment: "Hardfork with gas cost changes for IO-heavy operations",
      eip: {
        url: "https://eips.ethereum.org/EIPS/eip-608",
        status: "Final"
      },
      gasConfig: {},
      gasPrices: {
        sload: {
          v: 200,
          d: "Once per SLOAD operation"
        },
        call: {
          v: 700,
          d: "Once per CALL operation & message call transaction"
        }
      },
      vm: {},
      pow: {},
      casper: {},
      sharding: {}
    };
  }, {}],
  "GtWw": [function(require, module, exports) {
    module.exports = {
      name: "spuriousDragon",
      comment: "HF with EIPs for simple replay attack protection, EXP cost increase, state trie clearing, contract code size limit",
      eip: {
        url: "https://eips.ethereum.org/EIPS/eip-607",
        status: "Final"
      },
      gasConfig: {},
      gasPrices: {
        expByte: {
          v: 50,
          d: "Times ceil(log256(exponent)) for the EXP instruction"
        }
      },
      vm: {
        maxCodeSize: {
          v: 24576,
          d: "Maximum length of contract code"
        }
      },
      pow: {},
      casper: {},
      sharding: {}
    };
  }, {}],
  "T11O": [function(require, module, exports) {
    module.exports = {
      name: "byzantium",
      comment: "Hardfork with new precompiles, instructions and other protocol changes",
      eip: {
        url: "https://eips.ethereum.org/EIPS/eip-609",
        status: "Final"
      },
      gasConfig: {},
      gasPrices: {
        modexpGquaddivisor: {
          v: 20,
          d: "Gquaddivisor from modexp precompile for gas calculation"
        },
        ecAdd: {
          v: 500,
          d: "Gas costs for curve addition precompile"
        },
        ecMul: {
          v: 4e4,
          d: "Gas costs for curve multiplication precompile"
        },
        ecPairing: {
          v: 1e5,
          d: "Base gas costs for curve pairing precompile"
        },
        ecPairingWord: {
          v: 8e4,
          d: "Gas costs regarding curve pairing precompile input length"
        }
      },
      vm: {},
      pow: {
        minerReward: {
          v: "3000000000000000000",
          d: "the amount a miner get rewarded for mining a block"
        }
      },
      casper: {},
      sharding: {}
    };
  }, {}],
  "qYIU": [function(require, module, exports) {
    module.exports = {
      name: "constantinople",
      comment: "Postponed hardfork including EIP-1283 (SSTORE gas metering changes)",
      eip: {
        url: "https://eips.ethereum.org/EIPS/eip-1013",
        status: "Final"
      },
      gasConfig: {},
      gasPrices: {
        netSstoreNoopGas: {
          v: 200,
          d: "Once per SSTORE operation if the value doesn't change"
        },
        netSstoreInitGas: {
          v: 2e4,
          d: "Once per SSTORE operation from clean zero"
        },
        netSstoreCleanGas: {
          v: 5e3,
          d: "Once per SSTORE operation from clean non-zero"
        },
        netSstoreDirtyGas: {
          v: 200,
          d: "Once per SSTORE operation from dirty"
        },
        netSstoreClearRefund: {
          v: 15e3,
          d: "Once per SSTORE operation for clearing an originally existing storage slot"
        },
        netSstoreResetRefund: {
          v: 4800,
          d: "Once per SSTORE operation for resetting to the original non-zero value"
        },
        netSstoreResetClearRefund: {
          v: 19800,
          d: "Once per SSTORE operation for resetting to the original zero value"
        }
      },
      vm: {},
      pow: {
        minerReward: {
          v: "2000000000000000000",
          d: "The amount a miner gets rewarded for mining a block"
        }
      },
      casper: {},
      sharding: {}
    };
  }, {}],
  "Oy1j": [function(require, module, exports) {
    module.exports = {
      name: "petersburg",
      comment: "Aka constantinopleFix, removes EIP-1283, activate together with or after constantinople",
      eip: {
        url: "https://eips.ethereum.org/EIPS/eip-1716",
        status: "Draft"
      },
      gasConfig: {},
      gasPrices: {
        netSstoreNoopGas: {
          v: null,
          d: "Removed along EIP-1283"
        },
        netSstoreInitGas: {
          v: null,
          d: "Removed along EIP-1283"
        },
        netSstoreCleanGas: {
          v: null,
          d: "Removed along EIP-1283"
        },
        netSstoreDirtyGas: {
          v: null,
          d: "Removed along EIP-1283"
        },
        netSstoreClearRefund: {
          v: null,
          d: "Removed along EIP-1283"
        },
        netSstoreResetRefund: {
          v: null,
          d: "Removed along EIP-1283"
        },
        netSstoreResetClearRefund: {
          v: null,
          d: "Removed along EIP-1283"
        }
      },
      vm: {},
      pow: {},
      casper: {},
      sharding: {}
    };
  }, {}],
  "v2Bu": [function(require, module, exports) {
    module.exports = {
      name: "istanbul",
      comment: "HF targeted for December 2019 following the Constantinople/Petersburg HF",
      eip: {
        url: "https://eips.ethereum.org/EIPS/eip-1679",
        status: "Draft"
      },
      gasConfig: {},
      gasPrices: {
        blake2Round: {
          v: 1,
          d: "Gas cost per round for the Blake2 F precompile"
        },
        ecAdd: {
          v: 150,
          d: "Gas costs for curve addition precompile"
        },
        ecMul: {
          v: 6e3,
          d: "Gas costs for curve multiplication precompile"
        },
        ecPairing: {
          v: 45e3,
          d: "Base gas costs for curve pairing precompile"
        },
        ecPairingWord: {
          v: 34e3,
          d: "Gas costs regarding curve pairing precompile input length"
        },
        txDataNonZero: {
          v: 16,
          d: "Per byte of data attached to a transaction that is not equal to zero. NOTE: Not payable on data of calls between transactions"
        },
        sstoreSentryGasEIP2200: {
          v: 2300,
          d: "Minimum gas required to be present for an SSTORE call, not consumed"
        },
        sstoreNoopGasEIP2200: {
          v: 800,
          d: "Once per SSTORE operation if the value doesn't change"
        },
        sstoreDirtyGasEIP2200: {
          v: 800,
          d: "Once per SSTORE operation if a dirty value is changed"
        },
        sstoreInitGasEIP2200: {
          v: 2e4,
          d: "Once per SSTORE operation from clean zero to non-zero"
        },
        sstoreInitRefundEIP2200: {
          v: 19200,
          d: "Once per SSTORE operation for resetting to the original zero value"
        },
        sstoreCleanGasEIP2200: {
          v: 5e3,
          d: "Once per SSTORE operation from clean non-zero to something else"
        },
        sstoreCleanRefundEIP2200: {
          v: 4200,
          d: "Once per SSTORE operation for resetting to the original non-zero value"
        },
        sstoreClearRefundEIP2200: {
          v: 15e3,
          d: "Once per SSTORE operation for clearing an originally existing storage slot"
        }
      },
      vm: {},
      pow: {},
      casper: {},
      sharding: {}
    };
  }, {}],
  "eJ1u": [function(require, module, exports) {
    module.exports = {
      name: "muirGlacier",
      comment: "HF to delay the difficulty bomb",
      eip: {
        url: "https://eips.ethereum.org/EIPS/eip-2384",
        status: "Last Call"
      },
      gasConfig: {},
      gasPrices: {},
      vm: {},
      pow: {},
      casper: {},
      sharding: {}
    };
  }, {}],
  "fVFy": [function(require, module, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    }), exports.hardforks = void 0, exports.hardforks = [
      ["chainstart", require("./chainstart.json")],
      ["homestead", require("./homestead.json")],
      ["dao", require("./dao.json")],
      ["tangerineWhistle", require("./tangerineWhistle.json")],
      ["spuriousDragon", require("./spuriousDragon.json")],
      ["byzantium", require("./byzantium.json")],
      ["constantinople", require("./constantinople.json")],
      ["petersburg", require("./petersburg.json")],
      ["istanbul", require("./istanbul.json")],
      ["muirGlacier", require("./muirGlacier.json")]
    ];
  }, {
    "./chainstart.json": "vExz",
    "./homestead.json": "oMyY",
    "./dao.json": "DHrv",
    "./tangerineWhistle.json": "LVwS",
    "./spuriousDragon.json": "GtWw",
    "./byzantium.json": "T11O",
    "./constantinople.json": "qYIU",
    "./petersburg.json": "Oy1j",
    "./istanbul.json": "v2Bu",
    "./muirGlacier.json": "eJ1u"
  }],
  "jfAm": [function(require, module, exports) {
    "use strict";
    var r = this && this.__assign || function() {
      return (r = Object.assign || function(r) {
        for (var o, t = 1, n = arguments.length; t < n; t++)
          for (var e in o = arguments[t]) Object.prototype.hasOwnProperty.call(o, e) && (r[e] = o[e]);
        return r
      }).apply(this, arguments)
    };
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    var o = require("./chains"),
      t = require("./hardforks"),
      n = function() {
        function n(r, o, t) {
          this._chainParams = this.setChain(r), this._hardfork = null, this._supportedHardforks = void 0 === t ? [] : t, o && this.setHardfork(o)
        }
        return n.forCustomChain = function(o, t, e, a) {
          var i = n._getChainParams(o);
          return new n(r(r({}, i), t), e, a)
        }, n._getChainParams = function(r) {
          if ("number" == typeof r) {
            if (o.chains.names[r]) return o.chains[o.chains.names[r]];
            throw new Error("Chain with ID " + r + " not supported")
          }
          if (o.chains[r]) return o.chains[r];
          throw new Error("Chain with name " + r + " not supported")
        }, n.prototype.setChain = function(r) {
          if ("number" == typeof r || "string" == typeof r) this._chainParams = n._getChainParams(r);
          else {
            if ("object" != typeof r) throw new Error("Wrong input format");
            for (var o = 0, t = ["networkId", "genesis", "hardforks", "bootstrapNodes"]; o < t.length; o++) {
              var e = t[o];
              if (void 0 === r[e]) throw new Error("Missing required chain parameter: " + e)
            }
            this._chainParams = r
          }
          return this._chainParams
        }, n.prototype.setHardfork = function(r) {
          if (!this._isSupportedHardfork(r)) throw new Error("Hardfork " + r + " not set as supported in supportedHardforks");
          for (var o = !1, n = 0, e = t.hardforks; n < e.length; n++) {
            e[n][0] === r && (this._hardfork = r, o = !0)
          }
          if (!o) throw new Error("Hardfork with name " + r + " not supported")
        }, n.prototype._chooseHardfork = function(r, o) {
          if (o = void 0 === o || o, r) {
            if (o && !this._isSupportedHardfork(r)) throw new Error("Hardfork " + r + " not set as supported in supportedHardforks")
          } else {
            if (!this._hardfork) throw new Error("Method called with neither a hardfork set nor provided by param");
            r = this._hardfork
          }
          return r
        }, n.prototype._getHardfork = function(r) {
          for (var o = 0, t = this.hardforks(); o < t.length; o++) {
            var n = t[o];
            if (n.name === r) return n
          }
          throw new Error("Hardfork " + r + " not defined for chain " + this.chainName())
        }, n.prototype._isSupportedHardfork = function(r) {
          if (!(this._supportedHardforks.length > 0)) return !0;
          for (var o = 0, t = this._supportedHardforks; o < t.length; o++) {
            if (r === t[o]) return !0
          }
          return !1
        }, n.prototype.param = function(r, o, n) {
          var e;
          n = this._chooseHardfork(n);
          for (var a = 0, i = t.hardforks; a < i.length; a++) {
            var s = i[a];
            if (!s[1][r]) throw new Error("Topic " + r + " not defined");
            if (void 0 !== s[1][r][o] && (e = s[1][r][o].v), s[0] === n) break
          }
          if (void 0 === e) throw new Error(r + " value for " + o + " not found");
          return e
        }, n.prototype.paramByBlock = function(r, o, t) {
          var n = this.activeHardforks(t),
            e = n[n.length - 1].name;
          return this.param(r, o, e)
        }, n.prototype.hardforkIsActiveOnBlock = function(r, o, t) {
          var n = void 0 !== (t = void 0 !== t ? t : {}).onlySupported && t.onlySupported;
          r = this._chooseHardfork(r, n);
          var e = this.hardforkBlock(r);
          return null !== e && o >= e
        }, n.prototype.activeOnBlock = function(r, o) {
          return this.hardforkIsActiveOnBlock(null, r, o)
        }, n.prototype.hardforkGteHardfork = function(r, o, t) {
          var n = void 0 !== (t = void 0 !== t ? t : {}).onlyActive && t.onlyActive;
          r = this._chooseHardfork(r, t.onlySupported);
          for (var e = -1, a = -1, i = 0, s = 0, h = n ? this.activeHardforks(null, t) : this.hardforks(); s < h.length; s++) {
            var f = h[s];
            f.name === r && (e = i), f.name === o && (a = i), i += 1
          }
          return e >= a
        }, n.prototype.gteHardfork = function(r, o) {
          return this.hardforkGteHardfork(null, r, o)
        }, n.prototype.hardforkIsActiveOnChain = function(r, o) {
          var t = void 0 !== (o = void 0 !== o ? o : {}).onlySupported && o.onlySupported;
          r = this._chooseHardfork(r, t);
          for (var n = 0, e = this.hardforks(); n < e.length; n++) {
            var a = e[n];
            if (a.name === r && null !== a.block) return !0
          }
          return !1
        }, n.prototype.activeHardforks = function(r, o) {
          o = void 0 !== o ? o : {};
          for (var t = [], n = 0, e = this.hardforks(); n < e.length; n++) {
            var a = e[n];
            if (null !== a.block) {
              if (null != r && r < a.block) break;
              o.onlySupported && !this._isSupportedHardfork(a.name) || t.push(a)
            }
          }
          return t
        }, n.prototype.activeHardfork = function(r, o) {
          o = void 0 !== o ? o : {};
          var t = this.activeHardforks(r, o);
          if (t.length > 0) return t[t.length - 1].name;
          throw new Error("No (supported) active hardfork found")
        }, n.prototype.hardforkBlock = function(r) {
          return r = this._chooseHardfork(r, !1), this._getHardfork(r).block
        }, n.prototype.isHardforkBlock = function(r, o) {
          return o = this._chooseHardfork(o, !1), this.hardforkBlock(o) === r
        }, n.prototype.consensus = function(r) {
          return r = this._chooseHardfork(r), this._getHardfork(r).consensus
        }, n.prototype.finality = function(r) {
          return r = this._chooseHardfork(r), this._getHardfork(r).finality
        }, n.prototype.genesis = function() {
          return this._chainParams.genesis
        }, n.prototype.hardforks = function() {
          return this._chainParams.hardforks
        }, n.prototype.bootstrapNodes = function() {
          return this._chainParams.bootstrapNodes
        }, n.prototype.hardfork = function() {
          return this._hardfork
        }, n.prototype.chainId = function() {
          return this._chainParams.chainId
        }, n.prototype.chainName = function() {
          return o.chains.names[this.chainId()] || this._chainParams.name
        }, n.prototype.networkId = function() {
          return this._chainParams.networkId
        }, n
      }();
    exports.default = n;
  }, {
    "./chains": "XL6A",
    "./hardforks": "fVFy"
  }],
  "tJXK": [function(require, module, exports) {
    "use strict";
    var e = this && this.__assign || function() {
      return (e = Object.assign || function(e) {
        for (var t, r = 1, i = arguments.length; r < i; r++)
          for (var n in t = arguments[r]) Object.prototype.hasOwnProperty.call(t, n) && (e[n] = t[n]);
        return e
      }).apply(this, arguments)
    };
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    var t = require("ethereumjs-util"),
      r = require("ethereumjs-common"),
      i = require("buffer"),
      n = new t.BN("7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a0", 16),
      o = function() {
        function o(e, n) {
          if (void 0 === e && (e = {}), void 0 === n && (n = {}), n.common) {
            if (n.chain || n.hardfork) throw new Error("Instantiation with both opts.common, and opts.chain and opts.hardfork parameter not allowed!");
            this._common = n.common
          } else {
            var o = n.chain ? n.chain : "mainnet",
              a = n.hardfork ? n.hardfork : "petersburg";
            this._common = new r.default(o, a)
          }
          var s = [{
            name: "nonce",
            length: 32,
            allowLess: !0,
            default: new i.Buffer([])
          }, {
            name: "gasPrice",
            length: 32,
            allowLess: !0,
            default: new i.Buffer([])
          }, {
            name: "gasLimit",
            alias: "gas",
            length: 32,
            allowLess: !0,
            default: new i.Buffer([])
          }, {
            name: "to",
            allowZero: !0,
            length: 20,
            default: new i.Buffer([])
          }, {
            name: "value",
            length: 32,
            allowLess: !0,
            default: new i.Buffer([])
          }, {
            name: "data",
            alias: "input",
            allowZero: !0,
            default: new i.Buffer([])
          }, {
            name: "v",
            allowZero: !0,
            default: new i.Buffer([])
          }, {
            name: "r",
            length: 32,
            allowZero: !0,
            allowLess: !0,
            default: new i.Buffer([])
          }, {
            name: "s",
            length: 32,
            allowZero: !0,
            allowLess: !0,
            default: new i.Buffer([])
          }];
          t.defineProperties(this, s, e), Object.defineProperty(this, "from", {
            enumerable: !0,
            configurable: !0,
            get: this.getSenderAddress.bind(this)
          }), this._validateV(this.v), this._overrideVSetterWithValidation()
        }
        return o.prototype.toCreationAddress = function() {
          return "" === this.to.toString("hex")
        }, o.prototype.hash = function(e) {
          var r;
          return void 0 === e && (e = !0), r = e ? this.raw : this._implementsEIP155() ? this.raw.slice(0, 6).concat([t.toBuffer(this.getChainId()), t.stripZeros(t.toBuffer(0)), t.stripZeros(t.toBuffer(0))]) : this.raw.slice(0, 6), t.rlphash(r)
        }, o.prototype.getChainId = function() {
          return this._common.chainId()
        }, o.prototype.getSenderAddress = function() {
          if (this._from) return this._from;
          var e = this.getSenderPublicKey();
          return this._from = t.publicToAddress(e), this._from
        }, o.prototype.getSenderPublicKey = function() {
          if (!this.verifySignature()) throw new Error("Invalid Signature");
          return this._senderPubKey
        }, o.prototype.verifySignature = function() {
          var e = this.hash(!1);
          if (this._common.gteHardfork("homestead") && 1 === new t.BN(this.s).cmp(n)) return !1;
          try {
            var r = t.bufferToInt(this.v),
              i = r >= 2 * this.getChainId() + 35 && this._common.gteHardfork("spuriousDragon");
            this._senderPubKey = t.ecrecover(e, r, this.r, this.s, i ? this.getChainId() : void 0)
          } catch (o) {
            return !1
          }
          return !!this._senderPubKey
        }, o.prototype.sign = function(e) {
          this.v = new i.Buffer([]), this.s = new i.Buffer([]), this.r = new i.Buffer([]);
          var r = this.hash(!1),
            n = t.ecsign(r, e);
          this._implementsEIP155() && (n.v += 2 * this.getChainId() + 8), Object.assign(this, n)
        }, o.prototype.getDataFee = function() {
          for (var e = this.raw[5], r = new t.BN(0), i = 0; i < e.length; i++) 0 === e[i] ? r.iaddn(this._common.param("gasPrices", "txDataZero")) : r.iaddn(this._common.param("gasPrices", "txDataNonZero"));
          return r
        }, o.prototype.getBaseFee = function() {
          var e = this.getDataFee().iaddn(this._common.param("gasPrices", "tx"));
          return this._common.gteHardfork("homestead") && this.toCreationAddress() && e.iaddn(this._common.param("gasPrices", "txCreation")), e
        }, o.prototype.getUpfrontCost = function() {
          return new t.BN(this.gasLimit).imul(new t.BN(this.gasPrice)).iadd(new t.BN(this.value))
        }, o.prototype.validate = function(e) {
          void 0 === e && (e = !1);
          var r = [];
          return this.verifySignature() || r.push("Invalid Signature"), this.getBaseFee().cmp(new t.BN(this.gasLimit)) > 0 && r.push(["gas limit is too low. Need at least " + this.getBaseFee()]), !1 === e ? 0 === r.length : r.join(" ")
        }, o.prototype.serialize = function() {
          return t.rlp.encode(this.raw)
        }, o.prototype.toJSON = function(e) {
          return void 0 === e && (e = !1), {}
        }, o.prototype._validateV = function(e) {
          if (void 0 !== e && 0 !== e.length && this._common.gteHardfork("spuriousDragon")) {
            var r = t.bufferToInt(e);
            if (27 !== r && 28 !== r)
              if (!(r === 2 * this.getChainId() + 35 || r === 2 * this.getChainId() + 36)) throw new Error("Incompatible EIP155-based V " + r + " and chain id " + this.getChainId() + ". See the second parameter of the Transaction constructor to set the chain id.")
          }
        }, o.prototype._isSigned = function() {
          return this.v.length > 0 && this.r.length > 0 && this.s.length > 0
        }, o.prototype._overrideVSetterWithValidation = function() {
          var r = this,
            i = Object.getOwnPropertyDescriptor(this, "v");
          Object.defineProperty(this, "v", e({}, i, {
            set: function(e) {
              void 0 !== e && r._validateV(t.toBuffer(e)), i.set(e)
            }
          }))
        }, o.prototype._implementsEIP155 = function() {
          var e = this._common.gteHardfork("spuriousDragon");
          if (!this._isSigned()) return e;
          var r = t.bufferToInt(this.v);
          return (r === 2 * this.getChainId() + 35 || r === 2 * this.getChainId() + 36) && e
        }, o
      }();
    exports.default = o;
  }, {
    "ethereumjs-util": "BQcR",
    "ethereumjs-common": "jfAm",
    "buffer": "dskh"
  }],
  "tNmi": [function(require, module, exports) {
    "use strict";
    var t = this && this.__extends || function() {
      var t = function(r, e) {
        return (t = Object.setPrototypeOf || {
            __proto__: []
          }
          instanceof Array && function(t, r) {
            t.__proto__ = r
          } || function(t, r) {
            for (var e in r) r.hasOwnProperty(e) && (t[e] = r[e])
          })(r, e)
      };
      return function(r, e) {
        function o() {
          this.constructor = r
        }
        t(r, e), r.prototype = null === e ? Object.create(e) : (o.prototype = e.prototype, new o)
      }
    }();
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    var r = require("ethereumjs-util"),
      e = require("buffer"),
      o = require("./transaction"),
      n = function(o) {
        function n(t, e) {
          void 0 === t && (t = {}), void 0 === e && (e = {});
          var n = o.call(this, t, e) || this;
          Object.defineProperty(n, "from", {
            enumerable: !0,
            configurable: !0,
            get: function() {
              return n.getSenderAddress()
            },
            set: function(t) {
              t && (n._from = r.toBuffer(t))
            }
          });
          var i = t;
          return i.from && (n.from = r.toBuffer(i.from)), n
        }
        return t(n, o), n.prototype.hash = function(t) {
          if (void 0 === t && (t = !0), t && this._from && "" !== this._from.toString("hex")) {
            var r = e.Buffer.concat([this._from, this._from.slice(0, 12)]);
            this.sign(r)
          }
          return o.prototype.hash.call(this, t)
        }, n
      }(o.default);
    exports.default = n;
  }, {
    "ethereumjs-util": "BQcR",
    "buffer": "dskh",
    "./transaction": "tJXK"
  }],
  "iCX0": [function(require, module, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: !0
    });
    var e = require("./transaction");
    exports.Transaction = e.default;
    var r = require("./fake");
    exports.FakeTransaction = r.default;
  }, {
    "./transaction": "tJXK",
    "./fake": "tNmi"
  }],
  "ZwQN": [function(require, module, exports) {
    var global = arguments[3];
    var Buffer = require("buffer").Buffer;
    var e = arguments[3],
      r = require("buffer").Buffer;

    function t(e) {
      return i(e) || a(e) || o(e) || n()
    }

    function n() {
      throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
    }

    function o(e, r) {
      if (e) {
        if ("string" == typeof e) return s(e, r);
        var t = Object.prototype.toString.call(e).slice(8, -1);
        return "Object" === t && e.constructor && (t = e.constructor.name), "Map" === t || "Set" === t ? Array.from(e) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? s(e, r) : void 0
      }
    }

    function a(e) {
      if ("undefined" != typeof Symbol && null != e[Symbol.iterator] || null != e["@@iterator"]) return Array.from(e)
    }

    function i(e) {
      if (Array.isArray(e)) return s(e)
    }

    function s(e, r) {
      (null == r || r > e.length) && (r = e.length);
      for (var t = 0, n = new Array(r); t < r; t++) n[t] = e[t];
      return n
    }
    var c = require("underscore"),
      h = require("web3-core"),
      u = require("web3-core-method"),
      d = require("eth-lib/lib/account"),
      p = require("eth-lib/lib/hash"),
      f = require("eth-lib/lib/rlp"),
      l = require("eth-lib/lib/bytes"),
      m = void 0 === e ? require("crypto-browserify") : require("crypto"),
      y = require("scrypt-js"),
      v = require("uuid"),
      g = require("web3-utils"),
      w = require("web3-core-helpers"),
      x = require("ethereumjs-tx").Transaction,
      k = require("ethereumjs-common").default,
      b = function(e) {
        return c.isUndefined(e) || c.isNull(e)
      },
      I = function() {
        var e = this;
        h.packageInit(this, arguments), delete this.BatchRequest, delete this.extend;
        var r = [new u({
          name: "getNetworkId",
          call: "net_version",
          params: 0,
          outputFormatter: parseInt
        }), new u({
          name: "getChainId",
          call: "eth_chainId",
          params: 0,
          outputFormatter: g.hexToNumber
        }), new u({
          name: "getGasPrice",
          call: "eth_gasPrice",
          params: 0
        }), new u({
          name: "getTransactionCount",
          call: "eth_getTransactionCount",
          params: 2,
          inputFormatter: [function(e) {
            if (g.isAddress(e)) return e;
            throw new Error("Address " + e + ' is not a valid address to get the "transactionCount".')
          }, function() {
            return "latest"
          }]
        })];
        this._ethereumCall = {}, c.each(r, function(r) {
          r.attachToObject(e._ethereumCall), r.setRequestManager(e._requestManager)
        }), this.wallet = new _(this)
      };

    function S(e) {
      return e.common && e.chain && e.hardfork ? new Error("Please provide the ethereumjs-common object or the chain and hardfork property but not all together.") : e.chain && !e.hardfork || e.hardfork && !e.chain ? new Error('When specifying chain and hardfork, both values must be defined. Received "chain": ' + e.chain + ', "hardfork": ' + e.hardfork) : e.gas || e.gasLimit ? e.nonce < 0 || e.gas < 0 || e.gasPrice < 0 || e.chainId < 0 ? new Error("Gas, gasPrice, nonce or chainId is lower than 0") : void 0 : new Error('"gas" is missing')
    }

    function _(e) {
      this._accounts = e, this.length = 0, this.defaultKeyName = "web3js_wallet"
    }

    function C(e) {
      var r;
      try {
        r = window[e];
        var t = "__storage_test__";
        return r.setItem(t, t), r.removeItem(t), !0
      } catch (n) {
        return n && (22 === n.code || 1014 === n.code || "QuotaExceededError" === n.name || "NS_ERROR_DOM_QUOTA_REACHED" === n.name) && r && 0 !== r.length
      }
    }
    I.prototype._addAccountFunctions = function(e) {
      var r = this;
      return e.signTransaction = function(t, n) {
        return r.signTransaction(t, e.privateKey, n)
      }, e.sign = function(t) {
        return r.sign(t, e.privateKey)
      }, e.encrypt = function(t, n) {
        return r.encrypt(e.privateKey, t, n)
      }, e
    }, I.prototype.create = function(e) {
      return this._addAccountFunctions(d.create(e || g.randomHex(32)))
    }, I.prototype.privateKeyToAccount = function(e, r) {
      if (e.startsWith("0x") || (e = "0x" + e), !r && 66 !== e.length) throw new Error("Private key must be 32 bytes long");
      return this._addAccountFunctions(d.fromPrivate(e))
    }, I.prototype.signTransaction = function(e, t, n) {
      var o = !1,
        a = {},
        i = !(!e || !(e.chain && e.hardfork || e.common));
      if (n = n || function() {}, !e) return o = new Error("No transaction object given!"), n(o), Promise.reject(o);

      function s(e) {
        var o = S(e);
        if (o) return n(o), Promise.reject(o);
        try {
          var s = w.formatters.inputCallFormatter(c.clone(e));
          s.to = s.to || "0x", s.data = s.data || "0x", s.value = s.value || "0x", s.chainId = g.numberToHex(s.chainId), i ? (s.common && (a.common = k.forCustomChain(s.common.baseChain || "mainnet", {
            name: s.common.customChain.name || "custom-network",
            networkId: s.common.customChain.networkId,
            chainId: s.common.customChain.chainId
          }, s.common.hardfork || "petersburg"), delete s.common), s.chain && (a.chain = s.chain, delete s.chain), s.hardfork && (a.hardfork = s.hardfork, delete s.hardfork)) : (a.common = k.forCustomChain("mainnet", {
            name: "custom-network",
            networkId: s.networkId,
            chainId: s.chainId
          }, "petersburg"), delete s.networkId), t.startsWith("0x") && (t = t.substring(2));
          var h = new x(s, a);
          h.sign(r.from(t, "hex"));
          var u = h.validate(!0);
          if ("" !== u) throw new Error("Signer Error: " + u);
          var d = "0x" + h.serialize().toString("hex"),
            p = g.keccak256(d),
            f = {
              messageHash: "0x" + r.from(h.hash(!1)).toString("hex"),
              v: "0x" + r.from(h.v).toString("hex"),
              r: "0x" + r.from(h.r).toString("hex"),
              s: "0x" + r.from(h.s).toString("hex"),
              rawTransaction: d,
              transactionHash: p
            };
          return n(null, f), f
        } catch (l) {
          return n(l), Promise.reject(l)
        }
      }
      return void 0 !== e.nonce && void 0 !== e.chainId && void 0 !== e.gasPrice && i ? Promise.resolve(s(e)) : Promise.all([b(e.chainId) ? this._ethereumCall.getChainId() : e.chainId, b(e.gasPrice) ? this._ethereumCall.getGasPrice() : e.gasPrice, b(e.nonce) ? this._ethereumCall.getTransactionCount(this.privateKeyToAccount(t).address) : e.nonce, b(i) ? this._ethereumCall.getNetworkId() : 1]).then(function(r) {
        if (b(r[0]) || b(r[1]) || b(r[2]) || b(r[3])) throw new Error('One of the values "chainId", "networkId", "gasPrice", or "nonce" couldn\'t be fetched: ' + JSON.stringify(r));
        return s(c.extend(e, {
          chainId: r[0],
          gasPrice: r[1],
          nonce: r[2],
          networkId: r[3]
        }))
      })
    }, I.prototype.recoverTransaction = function(e) {
      var r = f.decode(e),
        t = d.encodeSignature(r.slice(6, 9)),
        n = l.toNumber(r[6]),
        o = n < 35 ? [] : [l.fromNumber(n - 35 >> 1), "0x", "0x"],
        a = r.slice(0, 6).concat(o),
        i = f.encode(a);
      return d.recover(p.keccak256(i), t)
    }, I.prototype.hashMessage = function(e) {
      var t = g.isHexStrict(e) ? e : g.utf8ToHex(e),
        n = g.hexToBytes(t),
        o = r.from(n),
        a = "Ethereum Signed Message:\n" + n.length,
        i = r.from(a),
        s = r.concat([i, o]);
      return p.keccak256s(s)
    }, I.prototype.sign = function(e, r) {
      if (r.startsWith("0x") || (r = "0x" + r), 66 !== r.length) throw new Error("Private key must be 32 bytes long");
      var t = this.hashMessage(e),
        n = d.sign(t, r),
        o = d.decodeSignature(n);
      return {
        message: e,
        messageHash: t,
        v: o[0],
        r: o[1],
        s: o[2],
        signature: n
      }
    }, I.prototype.recover = function(e, r, t) {
      var n = [].slice.apply(arguments);
      return c.isObject(e) ? this.recover(e.messageHash, d.encodeSignature([e.v, e.r, e.s]), !0) : (t || (e = this.hashMessage(e)), n.length >= 4 ? (t = n.slice(-1)[0], t = !!c.isBoolean(t) && !!t, this.recover(e, d.encodeSignature(n.slice(1, 4)), t)) : d.recover(e, r))
    }, I.prototype.decrypt = function(e, n, o) {
      if (!c.isString(n)) throw new Error("No password given.");
      var a, i, s = c.isObject(e) ? e : JSON.parse(o ? e.toLowerCase() : e);
      if (3 !== s.version) throw new Error("Not a valid V3 wallet");
      if ("scrypt" === s.crypto.kdf) i = s.crypto.kdfparams, a = y.syncScrypt(r.from(n), r.from(i.salt, "hex"), i.n, i.r, i.p, i.dklen);
      else {
        if ("pbkdf2" !== s.crypto.kdf) throw new Error("Unsupported key derivation scheme");
        if ("hmac-sha256" !== (i = s.crypto.kdfparams).prf) throw new Error("Unsupported parameters to PBKDF2");
        a = m.pbkdf2Sync(r.from(n), r.from(i.salt, "hex"), i.c, i.dklen, "sha256")
      }
      var h = r.from(s.crypto.ciphertext, "hex");
      if (g.sha3(r.from([].concat(t(a.slice(16, 32)), t(h)))).replace("0x", "") !== s.crypto.mac) throw new Error("Key derivation failed - possibly wrong password");
      var u = m.createDecipheriv(s.crypto.cipher, a.slice(0, 16), r.from(s.crypto.cipherparams.iv, "hex")),
        d = "0x" + r.from([].concat(t(u.update(h)), t(u.final()))).toString("hex");
      return this.privateKeyToAccount(d, !0)
    }, I.prototype.encrypt = function(e, n, o) {
      var a, i = this.privateKeyToAccount(e, !0),
        s = (o = o || {}).salt || m.randomBytes(32),
        c = o.iv || m.randomBytes(16),
        h = o.kdf || "scrypt",
        u = {
          dklen: o.dklen || 32,
          salt: s.toString("hex")
        };
      if ("pbkdf2" === h) u.c = o.c || 262144, u.prf = "hmac-sha256", a = m.pbkdf2Sync(r.from(n), r.from(u.salt, "hex"), u.c, u.dklen, "sha256");
      else {
        if ("scrypt" !== h) throw new Error("Unsupported kdf");
        u.n = o.n || 8192, u.r = o.r || 8, u.p = o.p || 1, a = y.syncScrypt(r.from(n), r.from(u.salt, "hex"), u.n, u.r, u.p, u.dklen)
      }
      var d = m.createCipheriv(o.cipher || "aes-128-ctr", a.slice(0, 16), c);
      if (!d) throw new Error("Unsupported cipher");
      var p = r.from([].concat(t(d.update(r.from(i.privateKey.replace("0x", ""), "hex"))), t(d.final()))),
        f = g.sha3(r.from([].concat(t(a.slice(16, 32)), t(p)))).replace("0x", "");
      return {
        version: 3,
        id: v.v4({
          random: o.uuid || m.randomBytes(16)
        }),
        address: i.address.toLowerCase().replace("0x", ""),
        crypto: {
          ciphertext: p.toString("hex"),
          cipherparams: {
            iv: c.toString("hex")
          },
          cipher: o.cipher || "aes-128-ctr",
          kdf: h,
          kdfparams: u,
          mac: f.toString("hex")
        }
      }
    }, _.prototype._findSafeIndex = function(e) {
      return e = e || 0, c.has(this, e) ? this._findSafeIndex(e + 1) : e
    }, _.prototype._currentIndexes = function() {
      return Object.keys(this).map(function(e) {
        return parseInt(e)
      }).filter(function(e) {
        return e < 9e20
      })
    }, _.prototype.create = function(e, r) {
      for (var t = 0; t < e; ++t) this.add(this._accounts.create(r).privateKey);
      return this
    }, _.prototype.add = function(e) {
      return c.isString(e) && (e = this._accounts.privateKeyToAccount(e)), this[e.address] ? this[e.address] : ((e = this._accounts.privateKeyToAccount(e.privateKey)).index = this._findSafeIndex(), this[e.index] = e, this[e.address] = e, this[e.address.toLowerCase()] = e, this.length++, e)
    }, _.prototype.remove = function(e) {
      var r = this[e];
      return !(!r || !r.address) && (this[r.address].privateKey = null, delete this[r.address], this[r.address.toLowerCase()].privateKey = null, delete this[r.address.toLowerCase()], this[r.index].privateKey = null, delete this[r.index], this.length--, !0)
    }, _.prototype.clear = function() {
      var e = this;
      return this._currentIndexes().forEach(function(r) {
        e.remove(r)
      }), this
    }, _.prototype.encrypt = function(e, r) {
      var t = this;
      return this._currentIndexes().map(function(n) {
        return t[n].encrypt(e, r)
      })
    }, _.prototype.decrypt = function(e, r) {
      var t = this;
      return e.forEach(function(e) {
        var n = t._accounts.decrypt(e, r);
        if (!n) throw new Error("Couldn't decrypt accounts. Password wrong?");
        t.add(n)
      }), this
    }, _.prototype.save = function(e, r) {
      return localStorage.setItem(r || this.defaultKeyName, JSON.stringify(this.encrypt(e))), !0
    }, _.prototype.load = function(e, r) {
      var t = localStorage.getItem(r || this.defaultKeyName);
      if (t) try {
        t = JSON.parse(t)
      } catch (n) {}
      return this.decrypt(t || [], e)
    }, C("localStorage") || (delete _.prototype.save, delete _.prototype.load), module.exports = I;
  }, {
    "underscore": "h15N",
    "web3-core": "KUai",
    "web3-core-method": "pw7F",
    "eth-lib/lib/account": "Yt2k",
    "eth-lib/lib/hash": "Swo0",
    "eth-lib/lib/rlp": "P2po",
    "eth-lib/lib/bytes": "k4zK",
    "crypto-browserify": "mRF4",
    "crypto": "mRF4",
    "scrypt-js": "oOWn",
    "uuid": "Lvuw",
    "web3-utils": "uckD",
    "web3-core-helpers": "EoeS",
    "ethereumjs-tx": "iCX0",
    "ethereumjs-common": "jfAm",
    "buffer": "dskh"
  }],
  "YDp9": [function(require, module, exports) {
    "use strict";
    var e = require("underscore"),
      c = function(c) {
        var a, d = this;
        return this.net.getId().then(function(e) {
          return a = e, d.getBlock(0)
        }).then(function(d) {
          var n = "private";
          return "0xd4e56740f876aef8c010b86a40d5f56745a118d0906a34e69aec8c0db1cb8fa3" === d.hash && 1 === a && (n = "main"), "0cd786a2425d16f152c658316c423e6ce1181e15c3295826d7c9904cba9ce303" === d.hash && 2 === a && (n = "morden"), "0x41941023680923e0fe4d74a34bdac8141f2540e3ae90623718e47d66d1ca4a2d" === d.hash && 3 === a && (n = "ropsten"), "0x6341fd3daf94b748c72ced5a5b26028f2474f5f00d824504e4fa37a75767e177" === d.hash && 4 === a && (n = "rinkeby"), "0xbf7e331f7f7c1dd2e05159666b3bf8bc7a8a3a9eb1d518969eab529dd9b88c1a" === d.hash && 5 === a && (n = "goerli"), "0xa3c565fc15c7478862d50ccd6561e3c06b24cc509bf388941c25ea985ce32cb9" === d.hash && 42 === a && (n = "kovan"), e.isFunction(c) && c(null, n), n
        }).catch(function(a) {
          if (!e.isFunction(c)) throw a;
          c(a)
        })
      };
    module.exports = c;
  }, {
    "underscore": "h15N"
  }],
  "qrxu": [function(require, module, exports) {
    "use strict";
    var t = require("underscore"),
      e = require("web3-core"),
      n = require("web3-core-helpers"),
      r = require("web3-core-subscriptions").subscriptions,
      a = require("web3-core-method"),
      o = require("web3-utils"),
      i = require("web3-net"),
      u = require("web3-eth-ens"),
      c = require("web3-eth-personal"),
      s = require("web3-eth-contract"),
      l = require("web3-eth-iban"),
      m = require("web3-eth-accounts"),
      p = require("web3-eth-abi"),
      h = require("./getNetworkType.js"),
      d = n.formatters,
      g = function(e) {
        return t.isString(e[0]) && 0 === e[0].indexOf("0x") ? "eth_getBlockByHash" : "eth_getBlockByNumber"
      },
      f = function(e) {
        return t.isString(e[0]) && 0 === e[0].indexOf("0x") ? "eth_getTransactionByBlockHashAndIndex" : "eth_getTransactionByBlockNumberAndIndex"
      },
      b = function(e) {
        return t.isString(e[0]) && 0 === e[0].indexOf("0x") ? "eth_getUncleByBlockHashAndIndex" : "eth_getUncleByBlockNumberAndIndex"
      },
      F = function(e) {
        return t.isString(e[0]) && 0 === e[0].indexOf("0x") ? "eth_getBlockTransactionCountByHash" : "eth_getBlockTransactionCountByNumber"
      },
      k = function(e) {
        return t.isString(e[0]) && 0 === e[0].indexOf("0x") ? "eth_getUncleCountByBlockHash" : "eth_getUncleCountByBlockNumber"
      },
      B = function() {
        var n = this;
        e.packageInit(this, arguments);
        var B = this.setRequestManager;
        this.setRequestManager = function(t) {
          return B(t), n.net.setRequestManager(t), n.personal.setRequestManager(t), n.accounts.setRequestManager(t), n.Contract._requestManager = n._requestManager, n.Contract.currentProvider = n._provider, !0
        };
        var T = this.setProvider;
        this.setProvider = function() {
          T.apply(n, arguments), n.setRequestManager(n._requestManager), n.ens._detectedAddress = null, n.ens._lastSyncCheck = null
        };
        var _, w, C, y = !1,
          P = null,
          q = "latest",
          v = 50,
          N = 24,
          A = 750,
          x = 100;
        Object.defineProperty(this, "handleRevert", {
          get: function() {
            return y
          },
          set: function(t) {
            y = t, n.Contract.handleRevert = y, R.forEach(function(t) {
              t.handleRevert = y
            })
          },
          enumerable: !0
        }), Object.defineProperty(this, "defaultCommon", {
          get: function() {
            return C
          },
          set: function(t) {
            C = t, n.Contract.defaultCommon = C, R.forEach(function(t) {
              t.defaultCommon = C
            })
          },
          enumerable: !0
        }), Object.defineProperty(this, "defaultHardfork", {
          get: function() {
            return w
          },
          set: function(t) {
            w = t, n.Contract.defaultHardfork = w, R.forEach(function(t) {
              t.defaultHardfork = w
            })
          },
          enumerable: !0
        }), Object.defineProperty(this, "defaultChain", {
          get: function() {
            return _
          },
          set: function(t) {
            _ = t, n.Contract.defaultChain = _, R.forEach(function(t) {
              t.defaultChain = _
            })
          },
          enumerable: !0
        }), Object.defineProperty(this, "transactionPollingTimeout", {
          get: function() {
            return A
          },
          set: function(t) {
            A = t, n.Contract.transactionPollingTimeout = A, R.forEach(function(t) {
              t.transactionPollingTimeout = A
            })
          },
          enumerable: !0
        }), Object.defineProperty(this, "transactionConfirmationBlocks", {
          get: function() {
            return N
          },
          set: function(t) {
            N = t, n.Contract.transactionConfirmationBlocks = N, R.forEach(function(t) {
              t.transactionConfirmationBlocks = N
            })
          },
          enumerable: !0
        }), Object.defineProperty(this, "transactionBlockTimeout", {
          get: function() {
            return v
          },
          set: function(t) {
            v = t, n.Contract.transactionBlockTimeout = v, R.forEach(function(t) {
              t.transactionBlockTimeout = v
            })
          },
          enumerable: !0
        }), Object.defineProperty(this, "defaultAccount", {
          get: function() {
            return P
          },
          set: function(t) {
            return t && (P = o.toChecksumAddress(d.inputAddressFormatter(t))), n.Contract.defaultAccount = P, n.personal.defaultAccount = P, R.forEach(function(t) {
              t.defaultAccount = P
            }), t
          },
          enumerable: !0
        }), Object.defineProperty(this, "defaultBlock", {
          get: function() {
            return q
          },
          set: function(t) {
            return q = t, n.Contract.defaultBlock = q, n.personal.defaultBlock = q, R.forEach(function(t) {
              t.defaultBlock = q
            }), t
          },
          enumerable: !0
        }), Object.defineProperty(this, "maxListenersWarningThreshold", {
          get: function() {
            return x
          },
          set: function(t) {
            n.currentProvider && n.currentProvider.setMaxListeners && (x = t, n.currentProvider.setMaxListeners(t))
          },
          enumerable: !0
        }), this.clearSubscriptions = n._requestManager.clearSubscriptions.bind(n._requestManager), this.net = new i(this), this.net.getNetworkType = h.bind(this), this.accounts = new m(this), this.personal = new c(this), this.personal.defaultAccount = this.defaultAccount, this.maxListenersWarningThreshold = x;
        var S = this,
          M = function() {
            s.apply(this, arguments);
            var t = this,
              n = S.setProvider;
            S.setProvider = function() {
              n.apply(S, arguments), e.packageInit(t, [S])
            }
          };
        M.setProvider = function() {
          s.setProvider.apply(this, arguments)
        }, (M.prototype = Object.create(s.prototype)).constructor = M, this.Contract = M, this.Contract.defaultAccount = this.defaultAccount, this.Contract.defaultBlock = this.defaultBlock, this.Contract.transactionBlockTimeout = this.transactionBlockTimeout, this.Contract.transactionConfirmationBlocks = this.transactionConfirmationBlocks, this.Contract.transactionPollingTimeout = this.transactionPollingTimeout, this.Contract.handleRevert = this.handleRevert, this.Contract._requestManager = this._requestManager, this.Contract._ethAccounts = this.accounts, this.Contract.currentProvider = this._requestManager.provider, this.Iban = l, this.abi = p, this.ens = new u(this);
        var R = [new a({
          name: "getNodeInfo",
          call: "web3_clientVersion"
        }), new a({
          name: "getProtocolVersion",
          call: "eth_protocolVersion",
          params: 0
        }), new a({
          name: "getCoinbase",
          call: "eth_coinbase",
          params: 0
        }), new a({
          name: "isMining",
          call: "eth_mining",
          params: 0
        }), new a({
          name: "getHashrate",
          call: "eth_hashrate",
          params: 0,
          outputFormatter: o.hexToNumber
        }), new a({
          name: "isSyncing",
          call: "eth_syncing",
          params: 0,
          outputFormatter: d.outputSyncingFormatter
        }), new a({
          name: "getGasPrice",
          call: "eth_gasPrice",
          params: 0,
          outputFormatter: d.outputBigNumberFormatter
        }), new a({
          name: "getAccounts",
          call: "eth_accounts",
          params: 0,
          outputFormatter: o.toChecksumAddress
        }), new a({
          name: "getBlockNumber",
          call: "eth_blockNumber",
          params: 0,
          outputFormatter: o.hexToNumber
        }), new a({
          name: "getBalance",
          call: "eth_getBalance",
          params: 2,
          inputFormatter: [d.inputAddressFormatter, d.inputDefaultBlockNumberFormatter],
          outputFormatter: d.outputBigNumberFormatter
        }), new a({
          name: "getStorageAt",
          call: "eth_getStorageAt",
          params: 3,
          inputFormatter: [d.inputAddressFormatter, o.numberToHex, d.inputDefaultBlockNumberFormatter]
        }), new a({
          name: "getCode",
          call: "eth_getCode",
          params: 2,
          inputFormatter: [d.inputAddressFormatter, d.inputDefaultBlockNumberFormatter]
        }), new a({
          name: "getBlock",
          call: g,
          params: 2,
          inputFormatter: [d.inputBlockNumberFormatter, function(t) {
            return !!t
          }],
          outputFormatter: d.outputBlockFormatter
        }), new a({
          name: "getUncle",
          call: b,
          params: 2,
          inputFormatter: [d.inputBlockNumberFormatter, o.numberToHex],
          outputFormatter: d.outputBlockFormatter
        }), new a({
          name: "getBlockTransactionCount",
          call: F,
          params: 1,
          inputFormatter: [d.inputBlockNumberFormatter],
          outputFormatter: o.hexToNumber
        }), new a({
          name: "getBlockUncleCount",
          call: k,
          params: 1,
          inputFormatter: [d.inputBlockNumberFormatter],
          outputFormatter: o.hexToNumber
        }), new a({
          name: "getTransaction",
          call: "eth_getTransactionByHash",
          params: 1,
          inputFormatter: [null],
          outputFormatter: d.outputTransactionFormatter
        }), new a({
          name: "getTransactionFromBlock",
          call: f,
          params: 2,
          inputFormatter: [d.inputBlockNumberFormatter, o.numberToHex],
          outputFormatter: d.outputTransactionFormatter
        }), new a({
          name: "getTransactionReceipt",
          call: "eth_getTransactionReceipt",
          params: 1,
          inputFormatter: [null],
          outputFormatter: d.outputTransactionReceiptFormatter
        }), new a({
          name: "getTransactionCount",
          call: "eth_getTransactionCount",
          params: 2,
          inputFormatter: [d.inputAddressFormatter, d.inputDefaultBlockNumberFormatter],
          outputFormatter: o.hexToNumber
        }), new a({
          name: "sendSignedTransaction",
          call: "eth_sendRawTransaction",
          params: 1,
          inputFormatter: [null],
          abiCoder: p
        }), new a({
          name: "signTransaction",
          call: "eth_signTransaction",
          params: 1,
          inputFormatter: [d.inputTransactionFormatter]
        }), new a({
          name: "sendTransaction",
          call: "eth_sendTransaction",
          params: 1,
          inputFormatter: [d.inputTransactionFormatter],
          abiCoder: p
        }), new a({
          name: "sign",
          call: "eth_sign",
          params: 2,
          inputFormatter: [d.inputSignFormatter, d.inputAddressFormatter],
          transformPayload: function(t) {
            return t.params.reverse(), t
          }
        }), new a({
          name: "call",
          call: "eth_call",
          params: 2,
          inputFormatter: [d.inputCallFormatter, d.inputDefaultBlockNumberFormatter],
          abiCoder: p
        }), new a({
          name: "estimateGas",
          call: "eth_estimateGas",
          params: 1,
          inputFormatter: [d.inputCallFormatter],
          outputFormatter: o.hexToNumber
        }), new a({
          name: "submitWork",
          call: "eth_submitWork",
          params: 3
        }), new a({
          name: "getWork",
          call: "eth_getWork",
          params: 0
        }), new a({
          name: "getPastLogs",
          call: "eth_getLogs",
          params: 1,
          inputFormatter: [d.inputLogFormatter],
          outputFormatter: d.outputLogFormatter
        }), new a({
          name: "getChainId",
          call: "eth_chainId",
          params: 0,
          outputFormatter: o.hexToNumber
        }), new a({
          name: "requestAccounts",
          call: "eth_requestAccounts",
          params: 0,
          outputFormatter: o.toChecksumAddress
        }), new a({
          name: "getProof",
          call: "eth_getProof",
          params: 3,
          inputFormatter: [d.inputAddressFormatter, d.inputStorageKeysFormatter, d.inputDefaultBlockNumberFormatter],
          outputFormatter: d.outputProofFormatter
        }), new a({
          name: "getPendingTransactions",
          call: "eth_pendingTransactions",
          params: 0,
          outputFormatter: d.outputTransactionFormatter
        }), new r({
          name: "subscribe",
          type: "eth",
          subscriptions: {
            newBlockHeaders: {
              subscriptionName: "newHeads",
              params: 0,
              outputFormatter: d.outputBlockFormatter
            },
            pendingTransactions: {
              subscriptionName: "newPendingTransactions",
              params: 0
            },
            logs: {
              params: 1,
              inputFormatter: [d.inputLogFormatter],
              outputFormatter: d.outputLogFormatter,
              subscriptionHandler: function(e) {
                e.removed ? this.emit("changed", e) : this.emit("data", e), t.isFunction(this.callback) && this.callback(null, e, this)
              }
            },
            syncing: {
              params: 0,
              outputFormatter: d.outputSyncingFormatter,
              subscriptionHandler: function(e) {
                var n = this;
                !0 !== this._isSyncing ? (this._isSyncing = !0, this.emit("changed", n._isSyncing), t.isFunction(this.callback) && this.callback(null, n._isSyncing, this), setTimeout(function() {
                  n.emit("data", e), t.isFunction(n.callback) && n.callback(null, e, n)
                }, 0)) : (this.emit("data", e), t.isFunction(n.callback) && this.callback(null, e, this), clearTimeout(this._isSyncingTimeout), this._isSyncingTimeout = setTimeout(function() {
                  e.currentBlock > e.highestBlock - 200 && (n._isSyncing = !1, n.emit("changed", n._isSyncing), t.isFunction(n.callback) && n.callback(null, n._isSyncing, n))
                }, 500))
              }
            }
          }
        })];
        R.forEach(function(t) {
          t.attachToObject(n), t.setRequestManager(n._requestManager, n.accounts), t.defaultBlock = n.defaultBlock, t.defaultAccount = n.defaultAccount, t.transactionBlockTimeout = n.transactionBlockTimeout, t.transactionConfirmationBlocks = n.transactionConfirmationBlocks, t.transactionPollingTimeout = n.transactionPollingTimeout, t.handleRevert = n.handleRevert
        })
      };
    e.addProviders(B), module.exports = B;
  }, {
    "underscore": "h15N",
    "web3-core": "KUai",
    "web3-core-helpers": "EoeS",
    "web3-core-subscriptions": "Sn3u",
    "web3-core-method": "pw7F",
    "web3-utils": "uckD",
    "web3-net": "SwGM",
    "web3-eth-ens": "dtHq",
    "web3-eth-personal": "TVxr",
    "web3-eth-contract": "vrPZ",
    "web3-eth-iban": "qamH",
    "web3-eth-accounts": "ZwQN",
    "web3-eth-abi": "TqCA",
    "./getNetworkType.js": "YDp9"
  }],
  "SnCl": [function(require, module, exports) {
    "use strict";
    var e = require("web3-core"),
      a = require("web3-core-subscriptions").subscriptions,
      s = require("web3-core-method"),
      r = require("web3-net"),
      n = function() {
        var n = this;
        e.packageInit(this, arguments);
        var t = this.setRequestManager;
        this.setRequestManager = function(e) {
          return t(e), n.net.setRequestManager(e), !0
        };
        var m = this.setProvider;
        this.setProvider = function() {
          m.apply(n, arguments), n.setRequestManager(n._requestManager)
        }, this.net = new r(this), [new a({
          name: "subscribe",
          type: "shh",
          subscriptions: {
            messages: {
              params: 1
            }
          }
        }), new s({
          name: "getVersion",
          call: "shh_version",
          params: 0
        }), new s({
          name: "getInfo",
          call: "shh_info",
          params: 0
        }), new s({
          name: "setMaxMessageSize",
          call: "shh_setMaxMessageSize",
          params: 1
        }), new s({
          name: "setMinPoW",
          call: "shh_setMinPoW",
          params: 1
        }), new s({
          name: "markTrustedPeer",
          call: "shh_markTrustedPeer",
          params: 1
        }), new s({
          name: "newKeyPair",
          call: "shh_newKeyPair",
          params: 0
        }), new s({
          name: "addPrivateKey",
          call: "shh_addPrivateKey",
          params: 1
        }), new s({
          name: "deleteKeyPair",
          call: "shh_deleteKeyPair",
          params: 1
        }), new s({
          name: "hasKeyPair",
          call: "shh_hasKeyPair",
          params: 1
        }), new s({
          name: "getPublicKey",
          call: "shh_getPublicKey",
          params: 1
        }), new s({
          name: "getPrivateKey",
          call: "shh_getPrivateKey",
          params: 1
        }), new s({
          name: "newSymKey",
          call: "shh_newSymKey",
          params: 0
        }), new s({
          name: "addSymKey",
          call: "shh_addSymKey",
          params: 1
        }), new s({
          name: "generateSymKeyFromPassword",
          call: "shh_generateSymKeyFromPassword",
          params: 1
        }), new s({
          name: "hasSymKey",
          call: "shh_hasSymKey",
          params: 1
        }), new s({
          name: "getSymKey",
          call: "shh_getSymKey",
          params: 1
        }), new s({
          name: "deleteSymKey",
          call: "shh_deleteSymKey",
          params: 1
        }), new s({
          name: "newMessageFilter",
          call: "shh_newMessageFilter",
          params: 1
        }), new s({
          name: "getFilterMessages",
          call: "shh_getFilterMessages",
          params: 1
        }), new s({
          name: "deleteMessageFilter",
          call: "shh_deleteMessageFilter",
          params: 1
        }), new s({
          name: "post",
          call: "shh_post",
          params: 1,
          inputFormatter: [null]
        }), new s({
          name: "unsubscribe",
          call: "shh_unsubscribe",
          params: 1
        })].forEach(function(e) {
          e.attachToObject(n), e.setRequestManager(n._requestManager)
        })
      };
    n.prototype.clearSubscriptions = function() {
      this._requestManager.clearSubscriptions()
    }, e.addProviders(n), module.exports = n;
  }, {
    "web3-core": "KUai",
    "web3-core-subscriptions": "Sn3u",
    "web3-core-method": "pw7F",
    "web3-net": "SwGM"
  }],
  "A2is": [function(require, module, exports) {
    "use strict";
    module.exports = function(e) {
      return encodeURIComponent(e).replace(/[!'()*]/g, function(e) {
        return "%" + e.charCodeAt(0).toString(16).toUpperCase()
      })
    };
  }, {}],
  "pWxZ": [function(require, module, exports) {
    "use strict";
    var e = "%[a-f0-9]{2}",
      t = new RegExp(e, "gi"),
      r = new RegExp("(" + e + ")+", "gi");

    function n(e, t) {
      try {
        return decodeURIComponent(e.join(""))
      } catch (c) {}
      if (1 === e.length) return e;
      t = t || 1;
      var r = e.slice(0, t),
        o = e.slice(t);
      return Array.prototype.concat.call([], n(r), n(o))
    }

    function o(e) {
      try {
        return decodeURIComponent(e)
      } catch (c) {
        for (var r = e.match(t), o = 1; o < r.length; o++) r = (e = n(r, o).join("")).match(t);
        return e
      }
    }

    function c(e) {
      for (var t = {
          "%FE%FF": "",
          "%FF%FE": ""
        }, n = r.exec(e); n;) {
        try {
          t[n[0]] = decodeURIComponent(n[0])
        } catch (u) {
          var c = o(n[0]);
          c !== n[0] && (t[n[0]] = c)
        }
        n = r.exec(e)
      }
      t["%C2"] = "";
      for (var a = Object.keys(t), p = 0; p < a.length; p++) {
        var i = a[p];
        e = e.replace(new RegExp(i, "g"), t[i])
      }
      return e
    }
    module.exports = function(e) {
      if ("string" != typeof e) throw new TypeError("Expected `encodedURI` to be of type `string`, got `" + typeof e + "`");
      try {
        return e = e.replace(/\+/g, " "), decodeURIComponent(e)
      } catch (t) {
        return c(e)
      }
    };
  }, {}],
  "FvpG": [function(require, module, exports) {
    "use strict";
    var r = require("strict-uri-encode"),
      n = require("object-assign"),
      e = require("decode-uri-component");

    function t(r) {
      switch (r.arrayFormat) {
        case "index":
          return function(n, e, t) {
            return null === e ? [i(n, r), "[", t, "]"].join("") : [i(n, r), "[", i(t, r), "]=", i(e, r)].join("")
          };
        case "bracket":
          return function(n, e) {
            return null === e ? i(n, r) : [i(n, r), "[]=", i(e, r)].join("")
          };
        default:
          return function(n, e) {
            return null === e ? i(n, r) : [i(n, r), "=", i(e, r)].join("")
          }
      }
    }

    function o(r) {
      var n;
      switch (r.arrayFormat) {
        case "index":
          return function(r, e, t) {
            n = /\[(\d*)\]$/.exec(r), r = r.replace(/\[\d*\]$/, ""), n ? (void 0 === t[r] && (t[r] = {}), t[r][n[1]] = e) : t[r] = e
          };
        case "bracket":
          return function(r, e, t) {
            n = /(\[\])$/.exec(r), r = r.replace(/\[\]$/, ""), n ? void 0 !== t[r] ? t[r] = [].concat(t[r], e) : t[r] = [e] : t[r] = e
          };
        default:
          return function(r, n, e) {
            void 0 !== e[r] ? e[r] = [].concat(e[r], n) : e[r] = n
          }
      }
    }

    function i(n, e) {
      return e.encode ? e.strict ? r(n) : encodeURIComponent(n) : n
    }

    function c(r) {
      return Array.isArray(r) ? r.sort() : "object" == typeof r ? c(Object.keys(r)).sort(function(r, n) {
        return Number(r) - Number(n)
      }).map(function(n) {
        return r[n]
      }) : r
    }

    function u(r) {
      var n = r.indexOf("?");
      return -1 === n ? "" : r.slice(n + 1)
    }

    function a(r, t) {
      var i = o(t = n({
          arrayFormat: "none"
        }, t)),
        u = Object.create(null);
      return "string" != typeof r ? u : (r = r.trim().replace(/^[?#&]/, "")) ? (r.split("&").forEach(function(r) {
        var n = r.replace(/\+/g, " ").split("="),
          t = n.shift(),
          o = n.length > 0 ? n.join("=") : void 0;
        o = void 0 === o ? null : e(o), i(e(t), o, u)
      }), Object.keys(u).sort().reduce(function(r, n) {
        var e = u[n];
        return Boolean(e) && "object" == typeof e && !Array.isArray(e) ? r[n] = c(e) : r[n] = e, r
      }, Object.create(null))) : u
    }
    exports.extract = u, exports.parse = a, exports.stringify = function(r, e) {
      !1 === (e = n({
        encode: !0,
        strict: !0,
        arrayFormat: "none"
      }, e)).sort && (e.sort = function() {});
      var o = t(e);
      return r ? Object.keys(r).sort(e.sort).map(function(n) {
        var t = r[n];
        if (void 0 === t) return "";
        if (null === t) return i(n, e);
        if (Array.isArray(t)) {
          var c = [];
          return t.slice().forEach(function(r) {
            void 0 !== r && c.push(o(n, r, c.length))
          }), c.join("&")
        }
        return i(n, e) + "=" + i(t, e)
      }).filter(function(r) {
        return r.length > 0
      }).join("&") : ""
    }, exports.parseUrl = function(r, n) {
      return {
        url: r.split("?")[0] || "",
        query: a(u(r), n)
      }
    };
  }, {
    "strict-uri-encode": "A2is",
    "object-assign": "J4Nk",
    "decode-uri-component": "pWxZ"
  }],
  "NN6L": [function(require, module, exports) {
    function t(t, r) {
      if (r) {
        r = (r = r.trim().replace(/^(\?|#|&)/, "")) ? "?" + r : r;
        var e = t.split(/[\?\#]/)[0];
        r && /\:\/\/[^\/]*$/.test(e) && (e += "/");
        var a = t.match(/(\#.*)$/);
        t = e + r, a && (t += a[0])
      }
      return t
    }
    module.exports = t;
  }, {}],
  "iRPi": [function(require, module, exports) {
    function o(o, e, r) {
      var t = e.toLowerCase();
      o[e] || o[t] || (o[e] = r)
    }
    module.exports = o;
  }, {}],
  "tALL": [function(require, module, exports) {
    var global = arguments[3];
    var e, d = arguments[3];
    e = "undefined" != typeof window ? window : void 0 !== d ? d : "undefined" != typeof self ? self : {}, module.exports = e;
  }, {}],
  "xIVz": [function(require, module, exports) {
    module.exports = t;
    var o = Object.prototype.toString;

    function t(t) {
      if (!t) return !1;
      var n = o.call(t);
      return "[object Function]" === n || "function" == typeof t && "[object RegExp]" !== n || "undefined" != typeof window && (t === window.setTimeout || t === window.alert || t === window.confirm || t === window.prompt)
    }
  }, {}],
  "q9uR": [function(require, module, exports) {
    var r = function(r) {
        return r.replace(/^\s+|\s+$/g, "")
      },
      e = function(r) {
        return "[object Array]" === Object.prototype.toString.call(r)
      };
    module.exports = function(t) {
      if (!t) return {};
      for (var n = {}, o = r(t).split("\n"), i = 0; i < o.length; i++) {
        var c = o[i],
          u = c.indexOf(":"),
          l = r(c.slice(0, u)).toLowerCase(),
          s = r(c.slice(u + 1));
        void 0 === n[l] ? n[l] = s : e(n[l]) ? n[l].push(s) : n[l] = [n[l], s]
      }
      return n
    };
  }, {}],
  "iMim": [function(require, module, exports) {
    "use strict";
    var e = require("global/window"),
      t = require("is-function"),
      r = require("parse-headers"),
      n = require("xtend");

    function o(e, t) {
      for (var r = 0; r < e.length; r++) t(e[r])
    }

    function s(e) {
      for (var t in e)
        if (e.hasOwnProperty(t)) return !1;
      return !0
    }

    function u(e, r, o) {
      var s = e;
      return t(r) ? (o = r, "string" == typeof e && (s = {
        uri: e
      })) : s = n(r, {
        uri: e
      }), s.callback = o, s
    }

    function a(e, t, r) {
      return i(t = u(e, t, r))
    }

    function i(e) {
      if (void 0 === e.callback) throw new Error("callback argument missing");
      var t = !1,
        n = function(r, n, o) {
          t || (t = !0, e.callback(r, n, o))
        };

      function o() {
        var e = void 0;
        if (e = l.response ? l.response : l.responseText || d(l), R) try {
          e = JSON.parse(e)
        } catch (t) {}
        return e
      }

      function u(e) {
        return clearTimeout(f), e instanceof Error || (e = new Error("" + (e || "Unknown XMLHttpRequest Error"))), e.statusCode = 0, n(e, X)
      }

      function i() {
        if (!c) {
          var t;
          clearTimeout(f), t = e.useXDR && void 0 === l.status ? 200 : 1223 === l.status ? 204 : l.status;
          var s = X,
            u = null;
          return 0 !== t ? (s = {
            body: o(),
            statusCode: t,
            method: m,
            headers: {},
            url: h,
            rawRequest: l
          }, l.getAllResponseHeaders && (s.headers = r(l.getAllResponseHeaders()))) : u = new Error("Internal XMLHttpRequest Error"), n(u, s, s.body)
        }
      }
      var p, c, l = e.xhr || null;
      l || (l = e.cors || e.useXDR ? new a.XDomainRequest : new a.XMLHttpRequest);
      var f, h = l.url = e.uri || e.url,
        m = l.method = e.method || "GET",
        y = e.body || e.data,
        w = l.headers = e.headers || {},
        q = !!e.sync,
        R = !1,
        X = {
          body: void 0,
          headers: {},
          statusCode: 0,
          method: m,
          url: h,
          rawRequest: l
        };
      if ("json" in e && !1 !== e.json && (R = !0, w.accept || w.Accept || (w.Accept = "application/json"), "GET" !== m && "HEAD" !== m && (w["content-type"] || w["Content-Type"] || (w["Content-Type"] = "application/json"), y = JSON.stringify(!0 === e.json ? y : e.json))), l.onreadystatechange = function() {
          4 === l.readyState && setTimeout(i, 0)
        }, l.onload = i, l.onerror = u, l.onprogress = function() {}, l.onabort = function() {
          c = !0
        }, l.ontimeout = u, l.open(m, h, !q, e.username, e.password), q || (l.withCredentials = !!e.withCredentials), !q && e.timeout > 0 && (f = setTimeout(function() {
          if (!c) {
            c = !0, l.abort("timeout");
            var e = new Error("XMLHttpRequest timeout");
            e.code = "ETIMEDOUT", u(e)
          }
        }, e.timeout)), l.setRequestHeader)
        for (p in w) w.hasOwnProperty(p) && l.setRequestHeader(p, w[p]);
      else if (e.headers && !s(e.headers)) throw new Error("Headers cannot be set on an XDomainRequest object");
      return "responseType" in e && (l.responseType = e.responseType), "beforeSend" in e && "function" == typeof e.beforeSend && e.beforeSend(l), l.send(y || null), l
    }

    function d(e) {
      try {
        if ("document" === e.responseType) return e.responseXML;
        var t = e.responseXML && "parsererror" === e.responseXML.documentElement.nodeName;
        if ("" === e.responseType && !t) return e.responseXML
      } catch (r) {}
      return null
    }

    function p() {}
    module.exports = a, module.exports.default = a, a.XMLHttpRequest = e.XMLHttpRequest || p, a.XDomainRequest = "withCredentials" in new a.XMLHttpRequest ? a.XMLHttpRequest : e.XDomainRequest, o(["get", "put", "post", "patch", "head", "delete"], function(e) {
      a["delete" === e ? "del" : e] = function(t, r, n) {
        return (r = u(t, r, n)).method = e.toUpperCase(), i(r)
      }
    });
  }, {
    "global/window": "tALL",
    "is-function": "xIVz",
    "parse-headers": "q9uR",
    "xtend": "K5Tb"
  }],
  "zc5H": [function(require, module, exports) {
    function e(e, t) {
      return t ? {
        statusCode: t.statusCode,
        headers: t.headers,
        method: e.method,
        url: e.url,
        rawRequest: t.rawRequest ? t.rawRequest : t
      } : null
    }
    module.exports = e;
  }, {}],
  "ayiN": [function(require, module, exports) {
    var r = require("xhr"),
      e = require("./normalize-response"),
      n = function() {};

    function o(o, t) {
      delete o.uri;
      var a = !1;
      "json" === o.responseType && (o.responseType = "text", a = !0);
      var s = r(o, function(r, s, p) {
          if (a && !r) try {
            var u = s.rawRequest.responseText;
            p = JSON.parse(u)
          } catch (i) {
            r = i
          }
          s = e(o, s), t(r, r ? null : p, s), t = n
        }),
        p = s.onabort;
      return s.onabort = function() {
        var r = p.apply(s, Array.prototype.slice.call(arguments));
        return t(new Error("XHR Aborted")), t = n, r
      }, s
    }
    module.exports = o;
  }, {
    "xhr": "iMim",
    "./normalize-response": "zc5H"
  }],
  "MCXC": [function(require, module, exports) {
    var e = require("query-string"),
      r = require("url-set-query"),
      t = require("object-assign"),
      n = require("./lib/ensure-header.js"),
      o = require("./lib/request.js"),
      s = "application/json",
      i = function() {};

    function u(u, p, y) {
      if (!u || "string" != typeof u) throw new TypeError("must specify a URL");
      if ("function" == typeof p && (y = p, p = {}), y && "function" != typeof y) throw new TypeError("expected cb to be undefined or a function");
      y = y || i;
      var f = (p = p || {}).json ? "json" : "text",
        d = (p = t({
          responseType: f
        }, p)).headers || {},
        c = (p.method || "GET").toUpperCase(),
        a = p.query;
      return a && ("string" != typeof a && (a = e.stringify(a)), u = r(u, a)), "json" === p.responseType && n(d, "Accept", s), p.json && "GET" !== c && "HEAD" !== c && (n(d, "Content-Type", s), p.body = JSON.stringify(p.body)), p.method = c, p.url = u, p.headers = d, delete p.query, delete p.json, o(p, y)
    }
    module.exports = u;
  }, {
    "query-string": "FvpG",
    "url-set-query": "NN6L",
    "object-assign": "J4Nk",
    "./lib/ensure-header.js": "iRPi",
    "./lib/request.js": "ayiN"
  }],
  "Oysz": [function(require, module, exports) {
    var n = function(n, r) {
        for (var t = [], e = 0; e < n; ++e) t.push(r(e));
        return t
      },
      r = function(r, t) {
        return n(r, function() {
          return t
        })
      },
      t = function(n, r) {
        return n.concat(r)
      },
      e = function(n) {
        for (var r = [], t = 0, e = n.length; t < e; ++t)
          for (var u = 0, o = n[t].length; u < o; ++u) r.push(n[t][u]);
        return r
      },
      u = function(n, r) {
        for (var t = [], e = 0, u = r.length; e < u; e += n) t.push(r.slice(e, e + n));
        return t
      };
    module.exports = {
      generate: n,
      replicate: r,
      concat: t,
      flatten: e,
      chunksOf: u
    };
  }, {}],
  "SS6D": [function(require, module, exports) {
    var r = require("./array.js"),
      n = function(r, n) {
        return parseInt(r.slice(2 * n + 2, 2 * n + 4), 16)
      },
      t = function(r) {
        var n = void 0;
        if ("undefined" != typeof window && window.crypto && window.crypto.getRandomValues) n = window.crypto.getRandomValues(new Uint8Array(r));
        else {
          if ("undefined" == typeof require) throw "Safe random numbers not available.";
          n = require("crypto").randomBytes(r)
        }
        for (var t = "0x", e = 0; e < r; ++e) t += ("00" + n[e].toString(16)).slice(-2);
        return t
      },
      e = function(r) {
        return (r.length - 2) / 2
      },
      i = function(r) {
        return "0x" + r.reduce(function(r, n) {
          return r + n.slice(2)
        }, "")
      },
      o = function(r, n, t) {
        return "0x" + t.slice(2 * r + 2, 2 * n + 2)
      },
      u = function(r) {
        for (var n = "0x", t = 0, i = e(r); t < i; ++t) n += r.slice(2 * (i - t), 2 * (i - t + 1));
        return n
      },
      f = function r(n, t) {
        return t.length === 2 * n + 2 ? t : r(n, "0x0" + t.slice(2))
      },
      l = function r(n, t) {
        return t.length === 2 * n + 2 ? t : r(n, t + "0")
      },
      a = function(r) {
        for (var n = [], t = 2, e = r.length; t < e; t += 2) n.push(parseInt(r.slice(t, t + 2), 16));
        return n
      },
      c = function(r) {
        for (var n = "0x", t = 0, e = r.length; t < e; ++t) {
          var i = r[t];
          n += (i < 16 ? "0" : "") + i.toString(16)
        }
        return n
      },
      s = function(r) {
        return new Uint8Array(a(r))
      },
      g = function(r) {
        return c([].slice.call(r, 0))
      },
      d = function(r) {
        var n = r.toString(16);
        return n.length % 2 == 0 ? "0x" + n : "0x0" + n
      },
      h = function(r) {
        return parseInt(r.slice(2), 16)
      },
      m = function(r, n) {
        return r.concat(n.slice(2))
      },
      v = function(r) {
        return "0x0" === r ? "0x" : r.length % 2 == 0 ? r : "0x0" + r.slice(2)
      },
      x = function(r) {
        return "0" === r[2] ? "0x" + r.slice(3) : r
      },
      p = function(r) {
        for (var n = "0x", t = 0; t < r.length; ++t) n += ("00" + r.charCodeAt(t).toString(16)).slice(-2);
        return n
      },
      y = function(r) {
        for (var n = "", t = 2; t < r.length; t += 2) n += String.fromCharCode(parseInt(r.slice(t, t + 2), 16));
        return n
      },
      S = function(r) {
        for (var n = function(r) {
            var n = r.toString(16);
            return n.length < 2 ? "0" + n : n
          }, t = "0x", e = 0; e != r.length; e++) {
          var i = r.charCodeAt(e);
          if (i < 128) t += n(i);
          else {
            if (i < 2048) t += n(i >> 6 | 192);
            else {
              if (i > 55295 && i < 56320) {
                if (++e == r.length) return null;
                var o = r.charCodeAt(e);
                if (o < 56320 || o > 57343) return null;
                t += n((i = 65536 + ((1023 & i) << 10) + (1023 & o)) >> 18 | 240), t += n(i >> 12 & 63 | 128)
              } else t += n(i >> 12 | 224);
              t += n(i >> 6 & 63 | 128)
            }
            t += n(63 & i | 128)
          }
        }
        return t
      },
      w = function(r) {
        for (var t = "", i = 0, o = e(r); i < o;) {
          var u = n(r, i++);
          if (u > 127) {
            if (u > 191 && u < 224) {
              if (i >= o) return null;
              u = (31 & u) << 6 | 63 & n(r, i)
            } else if (u > 223 && u < 240) {
              if (i + 1 >= o) return null;
              u = (15 & u) << 12 | (63 & n(r, i)) << 6 | 63 & n(r, ++i)
            } else {
              if (!(u > 239 && u < 248)) return null;
              if (i + 2 >= o) return null;
              u = (7 & u) << 18 | (63 & n(r, i)) << 12 | (63 & n(r, ++i)) << 6 | 63 & n(r, ++i)
            }++i
          }
          if (u <= 65535) t += String.fromCharCode(u);
          else {
            if (!(u <= 1114111)) return null;
            u -= 65536, t += String.fromCharCode(u >> 10 | 55296), t += String.fromCharCode(1023 & u | 56320)
          }
        }
        return t
      };
    module.exports = {
      random: t,
      length: e,
      concat: m,
      flatten: i,
      slice: o,
      reverse: u,
      pad: f,
      padRight: l,
      fromAscii: p,
      toAscii: y,
      fromString: S,
      toString: w,
      fromNumber: d,
      toNumber: h,
      fromNat: v,
      toNat: x,
      fromArray: c,
      toArray: a,
      fromUint8Array: g,
      toUint8Array: s
    };
  }, {
    "./array.js": "Oysz"
  }],
  "Dig0": [function(require, module, exports) {
    var t = "0123456789abcdef".split(""),
      r = [1, 256, 65536, 16777216],
      e = [0, 8, 16, 24],
      o = [1, 0, 32898, 0, 32906, 2147483648, 2147516416, 2147483648, 32907, 0, 2147483649, 0, 2147516545, 2147483648, 32777, 2147483648, 138, 0, 136, 0, 2147516425, 0, 2147483658, 0, 2147516555, 0, 139, 2147483648, 32905, 2147483648, 32771, 2147483648, 32770, 2147483648, 128, 2147483648, 32778, 0, 2147483658, 2147483648, 2147516545, 2147483648, 32896, 2147483648, 2147483649, 0, 2147516424, 2147483648],
      c = function(t) {
        return {
          blocks: [],
          reset: !0,
          block: 0,
          start: 0,
          blockCount: 1600 - (t << 1) >> 5,
          outputBlocks: t >> 5,
          s: (r = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [].concat(r, r, r, r, r))
        };
        var r
      },
      s = function(o, c) {
        for (var s, a = c.length, f = o.blocks, l = o.blockCount << 2, k = o.blockCount, u = o.outputBlocks, i = o.s, b = 0; b < a;) {
          if (o.reset)
            for (o.reset = !1, f[0] = o.block, v = 1; v < k + 1; ++v) f[v] = 0;
          if ("string" != typeof c)
            for (v = o.start; b < a && v < l; ++b) f[v >> 2] |= c[b] << e[3 & v++];
          else
            for (v = o.start; b < a && v < l; ++b)(s = c.charCodeAt(b)) < 128 ? f[v >> 2] |= s << e[3 & v++] : s < 2048 ? (f[v >> 2] |= (192 | s >> 6) << e[3 & v++], f[v >> 2] |= (128 | 63 & s) << e[3 & v++]) : s < 55296 || s >= 57344 ? (f[v >> 2] |= (224 | s >> 12) << e[3 & v++], f[v >> 2] |= (128 | s >> 6 & 63) << e[3 & v++], f[v >> 2] |= (128 | 63 & s) << e[3 & v++]) : (s = 65536 + ((1023 & s) << 10 | 1023 & c.charCodeAt(++b)), f[v >> 2] |= (240 | s >> 18) << e[3 & v++], f[v >> 2] |= (128 | s >> 12 & 63) << e[3 & v++], f[v >> 2] |= (128 | s >> 6 & 63) << e[3 & v++], f[v >> 2] |= (128 | 63 & s) << e[3 & v++]);
          if (o.lastByteIndex = v, v >= l) {
            for (o.start = v - l, o.block = f[k], v = 0; v < k; ++v) i[v] ^= f[v];
            n(i), o.reset = !0
          } else o.start = v
        }
        if (f[(v = o.lastByteIndex) >> 2] |= r[3 & v], o.lastByteIndex === l)
          for (f[0] = f[k], v = 1; v < k + 1; ++v) f[v] = 0;
        for (f[k - 1] |= 2147483648, v = 0; v < k; ++v) i[v] ^= f[v];
        n(i);
        for (var d, p = "", v = 0, x = 0; x < u;) {
          for (v = 0; v < k && x < u; ++v, ++x) d = i[v], p += t[d >> 4 & 15] + t[15 & d] + t[d >> 12 & 15] + t[d >> 8 & 15] + t[d >> 20 & 15] + t[d >> 16 & 15] + t[d >> 28 & 15] + t[d >> 24 & 15];
          x % k == 0 && (n(i), v = 0)
        }
        return "0x" + p
      },
      n = function(t) {
        var r, e, c, s, n, a, f, l, k, u, i, b, d, p, v, x, h, B, C, y, I, g, A, m, j, q, w, z, D, E, F, G, H, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y, Z, $, _, tt, rt, et, ot, ct, st, nt, at, ft, lt, kt;
        for (c = 0; c < 48; c += 2) s = t[0] ^ t[10] ^ t[20] ^ t[30] ^ t[40], n = t[1] ^ t[11] ^ t[21] ^ t[31] ^ t[41], a = t[2] ^ t[12] ^ t[22] ^ t[32] ^ t[42], f = t[3] ^ t[13] ^ t[23] ^ t[33] ^ t[43], l = t[4] ^ t[14] ^ t[24] ^ t[34] ^ t[44], k = t[5] ^ t[15] ^ t[25] ^ t[35] ^ t[45], u = t[6] ^ t[16] ^ t[26] ^ t[36] ^ t[46], i = t[7] ^ t[17] ^ t[27] ^ t[37] ^ t[47], r = (b = t[8] ^ t[18] ^ t[28] ^ t[38] ^ t[48]) ^ (a << 1 | f >>> 31), e = (d = t[9] ^ t[19] ^ t[29] ^ t[39] ^ t[49]) ^ (f << 1 | a >>> 31), t[0] ^= r, t[1] ^= e, t[10] ^= r, t[11] ^= e, t[20] ^= r, t[21] ^= e, t[30] ^= r, t[31] ^= e, t[40] ^= r, t[41] ^= e, r = s ^ (l << 1 | k >>> 31), e = n ^ (k << 1 | l >>> 31), t[2] ^= r, t[3] ^= e, t[12] ^= r, t[13] ^= e, t[22] ^= r, t[23] ^= e, t[32] ^= r, t[33] ^= e, t[42] ^= r, t[43] ^= e, r = a ^ (u << 1 | i >>> 31), e = f ^ (i << 1 | u >>> 31), t[4] ^= r, t[5] ^= e, t[14] ^= r, t[15] ^= e, t[24] ^= r, t[25] ^= e, t[34] ^= r, t[35] ^= e, t[44] ^= r, t[45] ^= e, r = l ^ (b << 1 | d >>> 31), e = k ^ (d << 1 | b >>> 31), t[6] ^= r, t[7] ^= e, t[16] ^= r, t[17] ^= e, t[26] ^= r, t[27] ^= e, t[36] ^= r, t[37] ^= e, t[46] ^= r, t[47] ^= e, r = u ^ (s << 1 | n >>> 31), e = i ^ (n << 1 | s >>> 31), t[8] ^= r, t[9] ^= e, t[18] ^= r, t[19] ^= e, t[28] ^= r, t[29] ^= e, t[38] ^= r, t[39] ^= e, t[48] ^= r, t[49] ^= e, p = t[0], v = t[1], V = t[11] << 4 | t[10] >>> 28, W = t[10] << 4 | t[11] >>> 28, z = t[20] << 3 | t[21] >>> 29, D = t[21] << 3 | t[20] >>> 29, at = t[31] << 9 | t[30] >>> 23, ft = t[30] << 9 | t[31] >>> 23, R = t[40] << 18 | t[41] >>> 14, S = t[41] << 18 | t[40] >>> 14, J = t[2] << 1 | t[3] >>> 31, K = t[3] << 1 | t[2] >>> 31, x = t[13] << 12 | t[12] >>> 20, h = t[12] << 12 | t[13] >>> 20, X = t[22] << 10 | t[23] >>> 22, Y = t[23] << 10 | t[22] >>> 22, E = t[33] << 13 | t[32] >>> 19, F = t[32] << 13 | t[33] >>> 19, lt = t[42] << 2 | t[43] >>> 30, kt = t[43] << 2 | t[42] >>> 30, rt = t[5] << 30 | t[4] >>> 2, et = t[4] << 30 | t[5] >>> 2, L = t[14] << 6 | t[15] >>> 26, M = t[15] << 6 | t[14] >>> 26, B = t[25] << 11 | t[24] >>> 21, C = t[24] << 11 | t[25] >>> 21, Z = t[34] << 15 | t[35] >>> 17, $ = t[35] << 15 | t[34] >>> 17, G = t[45] << 29 | t[44] >>> 3, H = t[44] << 29 | t[45] >>> 3, m = t[6] << 28 | t[7] >>> 4, j = t[7] << 28 | t[6] >>> 4, ot = t[17] << 23 | t[16] >>> 9, ct = t[16] << 23 | t[17] >>> 9, N = t[26] << 25 | t[27] >>> 7, O = t[27] << 25 | t[26] >>> 7, y = t[36] << 21 | t[37] >>> 11, I = t[37] << 21 | t[36] >>> 11, _ = t[47] << 24 | t[46] >>> 8, tt = t[46] << 24 | t[47] >>> 8, T = t[8] << 27 | t[9] >>> 5, U = t[9] << 27 | t[8] >>> 5, q = t[18] << 20 | t[19] >>> 12, w = t[19] << 20 | t[18] >>> 12, st = t[29] << 7 | t[28] >>> 25, nt = t[28] << 7 | t[29] >>> 25, P = t[38] << 8 | t[39] >>> 24, Q = t[39] << 8 | t[38] >>> 24, g = t[48] << 14 | t[49] >>> 18, A = t[49] << 14 | t[48] >>> 18, t[0] = p ^ ~x & B, t[1] = v ^ ~h & C, t[10] = m ^ ~q & z, t[11] = j ^ ~w & D, t[20] = J ^ ~L & N, t[21] = K ^ ~M & O, t[30] = T ^ ~V & X, t[31] = U ^ ~W & Y, t[40] = rt ^ ~ot & st, t[41] = et ^ ~ct & nt, t[2] = x ^ ~B & y, t[3] = h ^ ~C & I, t[12] = q ^ ~z & E, t[13] = w ^ ~D & F, t[22] = L ^ ~N & P, t[23] = M ^ ~O & Q, t[32] = V ^ ~X & Z, t[33] = W ^ ~Y & $, t[42] = ot ^ ~st & at, t[43] = ct ^ ~nt & ft, t[4] = B ^ ~y & g, t[5] = C ^ ~I & A, t[14] = z ^ ~E & G, t[15] = D ^ ~F & H, t[24] = N ^ ~P & R, t[25] = O ^ ~Q & S, t[34] = X ^ ~Z & _, t[35] = Y ^ ~$ & tt, t[44] = st ^ ~at & lt, t[45] = nt ^ ~ft & kt, t[6] = y ^ ~g & p, t[7] = I ^ ~A & v, t[16] = E ^ ~G & m, t[17] = F ^ ~H & j, t[26] = P ^ ~R & J, t[27] = Q ^ ~S & K, t[36] = Z ^ ~_ & T, t[37] = $ ^ ~tt & U, t[46] = at ^ ~lt & rt, t[47] = ft ^ ~kt & et, t[8] = g ^ ~p & x, t[9] = A ^ ~v & h, t[18] = G ^ ~m & q, t[19] = H ^ ~j & w, t[28] = R ^ ~J & L, t[29] = S ^ ~K & M, t[38] = _ ^ ~T & V, t[39] = tt ^ ~U & W, t[48] = lt ^ ~rt & ot, t[49] = kt ^ ~et & ct, t[0] ^= o[c], t[1] ^= o[c + 1]
      },
      a = function(t) {
        return function(r) {
          var e;
          if ("0x" === r.slice(0, 2)) {
            e = [];
            for (var o = 2, n = r.length; o < n; o += 2) e.push(parseInt(r.slice(o, o + 2), 16))
          } else e = r;
          return s(c(t, t), e)
        }
      };
    module.exports = {
      keccak256: a(256),
      keccak512: a(512),
      keccak256s: a(256),
      keccak512s: a(512)
    };
  }, {}],
  "bzlj": [function(require, module, exports) {
    var r = require("eth-lib/lib/hash").keccak256,
      e = require("eth-lib/lib/bytes"),
      t = function(t, i) {
        var n = e.reverse(e.pad(6, e.fromNumber(t))),
          a = e.flatten([n, "0x0000", i]);
        return r(a).slice(2)
      },
      i = function r(i) {
        "string" == typeof i && "0x" !== i.slice(0, 2) ? i = e.fromString(i) : "string" != typeof i && void 0 !== i.length && (i = e.fromUint8Array(i));
        var n = e.length(i);
        if (n <= 4096) return t(n, i);
        for (var a = 4096; 128 * a < n;) a *= 128;
        for (var f = [], l = 0; l < n; l += a) {
          var o = a < n - l ? a : n - l;
          f.push(r(e.slice(i, l, l + o)))
        }
        return t(n, e.flatten(f))
      };
    module.exports = i;
  }, {
    "eth-lib/lib/hash": "Dig0",
    "eth-lib/lib/bytes": "SS6D"
  }],
  "w3fP": [function(require, module, exports) {
    var e = function(e) {
      return function() {
        return new Promise(function(t, r) {
          var i, n = function(r) {
            var i = {},
              n = r.target.files.length,
              a = 0;
            [].map.call(r.target.files, function(r) {
              var c = new FileReader;
              c.onload = function(c) {
                var o = new Uint8Array(c.target.result);
                if ("directory" === e) {
                  var d = r.webkitRelativePath;
                  i[d.slice(d.indexOf("/") + 1)] = {
                    type: "text/plain",
                    data: o
                  }, ++a === n && t(i)
                } else if ("file" === e) {
                  var l = r.webkitRelativePath;
                  t({
                    type: mimetype.lookup(l),
                    data: o
                  })
                } else t(o)
              }, c.readAsArrayBuffer(r)
            })
          };
          "directory" === e ? ((i = document.createElement("input")).addEventListener("change", n), i.type = "file", i.webkitdirectory = !0, i.mozdirectory = !0, i.msdirectory = !0, i.odirectory = !0, i.directory = !0) : ((i = document.createElement("input")).addEventListener("change", n), i.type = "file");
          var a = document.createEvent("MouseEvents");
          a.initEvent("click", !0, !1), i.dispatchEvent(a)
        })
      }
    };
    module.exports = {
      data: e("data"),
      file: e("file"),
      directory: e("directory")
    };
  }, {}],
  "GVWY": [function(require, module, exports) {
    var process = require("process");
    var n = require("process");
    module.exports = function(n) {
      var t = n.fs,
        r = n.files,
        e = n.os,
        o = n.path,
        u = n.child_process,
        i = n.mimetype,
        a = n.defaultArchives,
        c = n.request,
        f = n.downloadUrl,
        s = n.bytes,
        d = n.hash,
        l = n.pick,
        h = function(n) {
          return function(t) {
            for (var r = {}, e = 0, o = n.length; e < o; ++e) r[n[e]] = t[e];
            return r
          }
        },
        p = function(n) {
          return function(t) {
            return "".concat(n, "/bzz-raw:/").concat(t)
          }
        },
        m = function(n) {
          return function(t) {
            return new Promise(function(r, e) {
              c(p(n)(t), {
                responseType: "arraybuffer"
              }, function(n, t, o) {
                return n ? e(n) : o.statusCode >= 400 ? e(new Error("Error ".concat(o.statusCode, "."))) : r(new Uint8Array(t))
              })
            })
          }
        },
        v = function(n) {
          return function(t) {
            return function t(r) {
              return function(e) {
                return function(o) {
                  var u = function(n) {
                    return void 0 === n.path ? Promise.resolve() : "application/bzz-manifest+json" === n.contentType ? t(n.hash)(e + n.path)(o) : Promise.resolve((r = e + n.path, function(n) {
                      return function(t) {
                        return t[r] = n, t
                      }
                    })(function(n) {
                      return {
                        type: n.contentType,
                        hash: n.hash
                      }
                    }(n))(o));
                    var r
                  };
                  return m(n)(r).then(function(n) {
                    return JSON.parse(I(n)).entries
                  }).then(function(n) {
                    return Promise.all(n.map(u))
                  }).then(function() {
                    return o
                  })
                }
              }
            }(t)("")({})
          }
        },
        y = function(n) {
          return function(t) {
            return v(n)(t).then(function(n) {
              return h(Object.keys(n))(Object.keys(n).map(function(t) {
                return n[t].hash
              }))
            })
          }
        },
        w = function(n) {
          return function(t) {
            return v(n)(t).then(function(t) {
              var r = Object.keys(t),
                e = r.map(function(n) {
                  return t[n].hash
                }),
                o = r.map(function(n) {
                  return t[n].type
                }),
                u = e.map(m(n));
              return Promise.all(u).then(function(n) {
                return h(r)(function(n) {
                  return n.map(function(n, t) {
                    return {
                      type: o[t],
                      data: n
                    }
                  })
                }(n))
              })
            })
          }
        },
        D = function(n) {
          return function(t) {
            return function(e) {
              return r.download(p(n)(t))(e)
            }
          }
        },
        k = function(n) {
          return function(t) {
            return function(r) {
              return y(n)(t).then(function(t) {
                var e = [];
                for (var u in t)
                  if (u.length > 0) {
                    var i = o.join(r, u);
                    e.push(D(n)(t[u])(i))
                  } return Promise.all(e).then(function() {
                  return r
                })
              })
            }
          }
        },
        P = function(n) {
          return function(t) {
            return new Promise(function(r, e) {
              var o = {
                body: "string" == typeof t ? M(t) : t,
                method: "POST"
              };
              c("".concat(n, "/bzz-raw:/"), o, function(n, t) {
                return n ? e(n) : r(t)
              })
            })
          }
        },
        b = function(n) {
          return function(t) {
            return function(r) {
              return function(e) {
                return function o(u) {
                  var i = "/" === r[0] ? r : "/" + r,
                    a = "".concat(n, "/bzz:/").concat(t).concat(i),
                    f = {
                      method: "PUT",
                      headers: {
                        "Content-Type": e.type
                      },
                      body: e.data
                    };
                  return new Promise(function(n, t) {
                    c(a, f, function(r, e) {
                      return r ? t(r) : -1 !== e.indexOf("error") ? t(e) : n(e)
                    })
                  }).catch(function(n) {
                    return u > 0 && o(u - 1)
                  })
                }(3)
              }
            }
          }
        },
        T = function(n) {
          return function(t) {
            return F(n)({
              "": t
            })
          }
        },
        g = function(n) {
          return function(r) {
            return t.readFile(r).then(function(t) {
              return T(n)({
                type: i.lookup(r),
                data: t
              })
            })
          }
        },
        F = function(n) {
          return function(t) {
            return P(n)("{}").then(function(r) {
              return Object.keys(t).reduce(function(r, e) {
                return r.then(function(r) {
                  return function(e) {
                    return b(n)(e)(r)(t[r])
                  }
                }(e))
              }, Promise.resolve(r))
            })
          }
        },
        A = function(n) {
          return function(r) {
            return t.readFile(r).then(P(n))
          }
        },
        S = function(n) {
          return function(e) {
            return function(o) {
              return r.directoryTree(o).then(function(n) {
                return Promise.all(n.map(function(n) {
                  return t.readFile(n)
                })).then(function(t) {
                  var r = n.map(function(n) {
                      return n.slice(o.length)
                    }),
                    e = n.map(function(n) {
                      return i.lookup(n) || "text/plain"
                    });
                  return h(r)(t.map(function(n, t) {
                    return {
                      type: e[t],
                      data: n
                    }
                  }))
                })
              }).then(function(n) {
                return (t = e ? {
                  "": n[e]
                } : {}, function(n) {
                  var r = {};
                  for (var e in t) r[e] = t[e];
                  for (var o in n) r[o] = n[o];
                  return r
                })(n);
                var t
              }).then(F(n))
            }
          }
        },
        z = function(n) {
          return function(t) {
            if ("data" === t.pick) return l.data().then(P(n));
            if ("file" === t.pick) return l.file().then(T(n));
            if ("directory" === t.pick) return l.directory().then(F(n));
            if (t.path) switch (t.kind) {
              case "data":
                return A(n)(t.path);
              case "file":
                return g(n)(t.path);
              case "directory":
                return S(n)(t.defaultFile)(t.path)
            } else {
              if (t.length || "string" == typeof t) return P(n)(t);
              if (t instanceof Object) return F(n)(t)
            }
            return Promise.reject(new Error("Bad arguments"))
          }
        },
        O = function(n) {
          return function(t) {
            return function(r) {
              return U(n)(t).then(function(e) {
                return e ? r ? k(n)(t)(r) : w(n)(t) : r ? D(n)(t)(r) : m(n)(t)
              })
            }
          }
        },
        j = function(n, t) {
          var o = e.platform().replace("win32", "windows") + "-" + ("x64" === e.arch() ? "amd64" : "386"),
            u = (t || a)[o],
            i = f + u.archive + ".tar.gz",
            c = u.archiveMD5,
            s = u.binaryMD5;
          return r.safeDownloadArchived(i)(c)(s)(n)
        },
        x = function(n) {
          return new Promise(function(t, r) {
            var e = u.spawn,
              o = function(n) {
                return function(t) {
                  return -1 !== ("" + t).indexOf(n)
                }
              },
              i = n.account,
              a = n.password,
              c = n.dataDir,
              f = n.ensApi,
              s = n.privateKey,
              d = 0,
              l = e(n.binPath, ["--bzzaccount", i || s, "--datadir", c, "--ens-api", f]),
              h = function(n) {
                0 === d && o("Passphrase")(n) ? setTimeout(function() {
                  d = 1, l.stdin.write(a + "\n")
                }, 500) : o("Swarm http proxy started")(n) && (d = 2, clearTimeout(p), t(l))
              };
            l.stdout.on("data", h), l.stderr.on("data", h);
            var p = setTimeout(function() {
              return r(new Error("Couldn't start swarm process."))
            }, 2e4)
          })
        },
        L = function(n) {
          return new Promise(function(t, r) {
            n.stderr.removeAllListeners("data"), n.stdout.removeAllListeners("data"), n.stdin.removeAllListeners("error"), n.removeAllListeners("error"), n.removeAllListeners("exit"), n.kill("SIGINT");
            var e = setTimeout(function() {
              return n.kill("SIGKILL")
            }, 8e3);
            n.once("close", function() {
              clearTimeout(e), t()
            })
          })
        },
        E = function(n) {
          return P(n)("test").then(function(n) {
            return "c9a99c7d326dcc6316f32fe2625b311f6dc49a175e6877681ded93137d3569e7" === n
          }).catch(function() {
            return !1
          })
        },
        U = function(n) {
          return function(t) {
            return m(n)(t).then(function(n) {
              try {
                return !!JSON.parse(I(n)).entries
              } catch (t) {
                return !1
              }
            })
          }
        },
        C = function(n) {
          return function(t, r, e, o, u) {
            var i;
            return void 0 !== t && (i = n(t)), void 0 !== r && (i = n(r)), void 0 !== e && (i = n(e)), void 0 !== o && (i = n(o)), void 0 !== u && (i = n(u)), i
          }
        },
        I = function(n) {
          return s.toString(s.fromUint8Array(n))
        },
        M = function(n) {
          return s.toUint8Array(s.fromString(n))
        },
        N = function(n) {
          return {
            download: function(t, r) {
              return O(n)(t)(r)
            },
            downloadData: C(m(n)),
            downloadDataToDisk: C(D(n)),
            downloadDirectory: C(w(n)),
            downloadDirectoryToDisk: C(k(n)),
            downloadEntries: C(v(n)),
            downloadRoutes: C(y(n)),
            isAvailable: function() {
              return E(n)
            },
            upload: function(t) {
              return z(n)(t)
            },
            uploadData: C(P(n)),
            uploadFile: C(T(n)),
            uploadFileFromDisk: C(T(n)),
            uploadDataFromDisk: C(A(n)),
            uploadDirectory: C(F(n)),
            uploadDirectoryFromDisk: C(S(n)),
            uploadToManifest: C(b(n)),
            pick: l,
            hash: d,
            fromString: M,
            toString: I
          }
        };
      return {
        at: N,
        local: function(n) {
          return function(t) {
            return E("http://localhost:8500").then(function(r) {
              return r ? t(N("http://localhost:8500")).then(function() {}) : j(n.binPath, n.archives).onData(function(t) {
                return (n.onProgress || function() {})(t.length)
              }).then(function() {
                return x(n)
              }).then(function(n) {
                return t(N("http://localhost:8500")).then(function() {
                  return n
                })
              }).then(L)
            })
          }
        },
        download: O,
        downloadBinary: j,
        downloadData: m,
        downloadDataToDisk: D,
        downloadDirectory: w,
        downloadDirectoryToDisk: k,
        downloadEntries: v,
        downloadRoutes: y,
        isAvailable: E,
        startProcess: x,
        stopProcess: L,
        upload: z,
        uploadData: P,
        uploadDataFromDisk: A,
        uploadFile: T,
        uploadFileFromDisk: g,
        uploadDirectory: F,
        uploadDirectoryFromDisk: S,
        uploadToManifest: b,
        pick: l,
        hash: d,
        fromString: M,
        toString: I
      }
    };
  }, {
    "process": "pBGv"
  }],
  "Zk8a": [function(require, module, exports) {
    var e = function() {
        throw "This swarm.js function isn't available on the browser."
      },
      r = {
        readFile: e
      },
      s = {
        download: e,
        safeDownloadArchived: e,
        directoryTree: e
      },
      i = {
        platform: e,
        arch: e
      },
      o = {
        join: e,
        slice: e
      },
      a = {
        spawn: e
      },
      l = {
        lookup: e
      },
      t = {},
      h = null,
      u = require("xhr-request"),
      n = require("eth-lib/lib/bytes"),
      c = require("./swarm-hash.js"),
      d = require("./pick.js"),
      p = require("./swarm");
    module.exports = p({
      fs: r,
      files: s,
      os: i,
      path: o,
      child_process: a,
      defaultArchives: t,
      mimetype: l,
      request: u,
      downloadUrl: h,
      bytes: n,
      hash: c,
      pick: d
    });
  }, {
    "xhr-request": "MCXC",
    "eth-lib/lib/bytes": "SS6D",
    "./swarm-hash.js": "bzlj",
    "./pick.js": "w3fP",
    "./swarm": "GVWY"
  }],
  "rk5u": [function(require, module, exports) {
    "use strict";
    var e = require("underscore"),
      r = require("swarm-js"),
      i = function e(i) {
        this.givenProvider = e.givenProvider, i && i._requestManager && (i = i.currentProvider), "undefined" != typeof document && (this.pick = r.pick), this.setProvider(i)
      };
    i.givenProvider = null, "undefined" != typeof ethereum && ethereum.bzz && (i.givenProvider = ethereum.bzz), i.prototype.setProvider = function(i) {
      if (e.isObject(i) && e.isString(i.bzz) && (i = i.bzz), !e.isString(i)) {
        this.currentProvider = null;
        var t = new Error("No provider set, please set one using bzz.setProvider().");
        return this.download = this.upload = this.isAvailable = function() {
          throw t
        }, !1
      }
      return this.currentProvider = i, this.download = r.at(i).download, this.upload = r.at(i).upload, this.isAvailable = r.at(i).isAvailable, !0
    }, module.exports = i;
  }, {
    "underscore": "h15N",
    "swarm-js": "Zk8a"
  }],
  "ikFg": [function(require, module, exports) {
    "use strict";
    var e = require("../package.json").version,
      r = require("web3-core"),
      s = require("web3-eth"),
      t = require("web3-net"),
      i = require("web3-eth-personal"),
      h = require("web3-shh"),
      u = require("web3-bzz"),
      n = require("web3-utils"),
      a = function() {
        var t = this;
        r.packageInit(this, arguments), this.version = e, this.utils = n, this.eth = new s(this), this.shh = new h(this), this.bzz = new u(this);
        var i = this.setProvider;
        this.setProvider = function(e, r) {
          return i.apply(t, arguments), t.eth.setRequestManager(t._requestManager), t.shh.setRequestManager(t._requestManager), t.bzz.setProvider(e), !0
        }
      };
    a.version = e, a.utils = n, a.modules = {
      Eth: s,
      Net: t,
      Personal: i,
      Shh: h,
      Bzz: u
    }, r.addProviders(a), module.exports = a;
  }, {
    "../package.json": "hh6X",
    "web3-core": "KUai",
    "web3-eth": "qrxu",
    "web3-net": "SwGM",
    "web3-eth-personal": "TVxr",
    "web3-shh": "SnCl",
    "web3-bzz": "rk5u",
    "web3-utils": "uckD"
  }],
  "g7hl": [function(require, module, exports) {
    "use strict";
    var e = this && this.__awaiter || function(e, t, r, n) {
        return new(r || (r = Promise))(function(i, o) {
          function u(e) {
            try {
              s(n.next(e))
            } catch (t) {
              o(t)
            }
          }

          function a(e) {
            try {
              s(n.throw(e))
            } catch (t) {
              o(t)
            }
          }

          function s(e) {
            var t;
            e.done ? i(e.value) : (t = e.value, t instanceof r ? t : new r(function(e) {
              e(t)
            })).then(u, a)
          }
          s((n = n.apply(e, t || [])).next())
        })
      },
      t = this && this.__generator || function(e, t) {
        var r, n, i, o, u = {
          label: 0,
          sent: function() {
            if (1 & i[0]) throw i[1];
            return i[1]
          },
          trys: [],
          ops: []
        };
        return o = {
          next: a(0),
          throw: a(1),
          return: a(2)
        }, "function" == typeof Symbol && (o[Symbol.iterator] = function() {
          return this
        }), o;

        function a(o) {
          return function(a) {
            return function(o) {
              if (r) throw new TypeError("Generator is already executing.");
              for (; u;) try {
                if (r = 1, n && (i = 2 & o[0] ? n.return : o[0] ? n.throw || ((i = n.return) && i.call(n), 0) : n.next) && !(i = i.call(n, o[1])).done) return i;
                switch (n = 0, i && (o = [2 & o[0], i.value]), o[0]) {
                  case 0:
                  case 1:
                    i = o;
                    break;
                  case 4:
                    return u.label++, {
                      value: o[1],
                      done: !1
                    };
                  case 5:
                    u.label++, n = o[1], o = [0];
                    continue;
                  case 7:
                    o = u.ops.pop(), u.trys.pop();
                    continue;
                  default:
                    if (!(i = (i = u.trys).length > 0 && i[i.length - 1]) && (6 === o[0] || 2 === o[0])) {
                      u = 0;
                      continue
                    }
                    if (3 === o[0] && (!i || o[1] > i[0] && o[1] < i[3])) {
                      u.label = o[1];
                      break
                    }
                    if (6 === o[0] && u.label < i[1]) {
                      u.label = i[1], i = o;
                      break
                    }
                    if (i && u.label < i[2]) {
                      u.label = i[2], u.ops.push(o);
                      break
                    }
                    i[2] && u.ops.pop(), u.trys.pop();
                    continue
                }
                o = t.call(e, u)
              } catch (a) {
                o = [6, a], n = 0
              } finally {
                r = i = 0
              }
              if (5 & o[0]) throw o[1];
              return {
                value: o[0] ? o[1] : void 0,
                done: !0
              }
            }([o, a])
          }
        }
      };
    Object.defineProperty(exports, "__esModule", {
      value: !0
    }), require("regenerator-runtime/runtime");
    var r = require("./hero/hero"),
      n = require("./stats/stats"),
      i = require("./milestones"),
      o = require("./buy"),
      u = require("./news"),
      a = require("./utils"),
      s = require("web3");
    e(void 0, void 0, void 0, function() {
      var e, c, l;
      return t(this, function(t) {
        switch (t.label) {
          case 0:
            return AOS.init({
              once: !0,
              disable: "phone"
            }), e = new s("https://bsc-dataseed1.binance.org:443"), new r.Hero, [4, a.GetBNBPrice(e)];
          case 1:
            return c = t.sent(), [4, new n.Stats(e, c).getO1TPrice()];
          case 2:
            return l = t.sent(), new i.Milestones(l, e, c), new o.Buy, new u.News, [2]
        }
      })
    });
  }, {
    "regenerator-runtime/runtime": "QVnC",
    "./hero/hero": "BESp",
    "./stats/stats": "FE3g",
    "./milestones": "GTgq",
    "./buy": "CZUP",
    "./news": "f6lU",
    "./utils": "u7YK",
    "web3": "ikFg"
  }]
}, {}, ["g7hl"], null)
//# sourceMappingURL=main.b4394823.js.map
